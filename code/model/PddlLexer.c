/** \file
 *  This C source file was generated by $ANTLR version 3.1.3 Mar 17, 2009 19:23:44
 *
 *     -  From the grammar source file : ../../model/subgoal_learning/Pddl.g
 *     -                            On : 2011-12-04 10:25:06
 *     -                 for the lexer : PddlLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */

#pragma GCC diagnostic ignored "-Wunused-variable"

#include    "PddlLexer.h"
/* ----------------------------------------- */


/** String literals used by PddlLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x64, 0x6F, 0x6D, 0x61, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x3A, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x3A, 0x74, 0x79, 0x70, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x65, 0x69, 0x74, 0x68, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x3A, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x3A, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x3A, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x3A, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x3A, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x3A, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x3A, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x3A, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x61, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x6E, 0x6F, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x69, 0x6D, 0x70, 0x6C, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x65, 0x78, 0x69, 0x73, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x66, 0x6F, 0x72, 0x61, 0x6C, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x3A, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x3A, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x3A, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x6F, 0x76, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x73, 0x74, 0x61, 0x72, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x65, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x61, 0x6C, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x3A, 0x64, 0x65, 0x72, 0x69, 0x76, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x77, 0x68, 0x65, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x61, 0x73, 0x73, 0x69, 0x67, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x73, 0x63, 0x61, 0x6C, 0x65, 0x2D, 0x75, 0x70,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x73, 0x63, 0x61, 0x6C, 0x65, 0x2D, 0x64, 0x6F, 0x77, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x69, 0x6E, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x64, 0x65, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x3F, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x70, 0x72, 0x6F, 0x62, 0x6C, 0x65, 0x6D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x3A, 0x64, 0x6F, 0x6D, 0x61, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x3A, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x3A, 0x69, 0x6E, 0x69, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x3A, 0x67, 0x6F, 0x61, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x3A, 0x6D, 0x65, 0x74, 0x72, 0x69, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x6D, 0x69, 0x6E, 0x69, 0x6D, 0x69, 0x7A, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x69, 0x7A, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x74, 0x6F, 0x74, 0x61, 0x6C, 0x2D, 0x74, 0x69, 0x6D, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x69, 0x73, 0x2D, 0x76, 0x69, 0x6F, 0x6C, 0x61, 0x74, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x61, 0x6C, 0x77, 0x61, 0x79, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x73, 0x6F, 0x6D, 0x65, 0x74, 0x69, 0x6D, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x61, 0x74, 0x2D, 0x6D, 0x6F, 0x73, 0x74, 0x2D, 0x6F, 0x6E, 0x63, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x73, 0x6F, 0x6D, 0x65, 0x74, 0x69, 0x6D, 0x65, 0x2D, 0x61, 0x66, 0x74, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x73, 0x6F, 0x6D, 0x65, 0x74, 0x69, 0x6D, 0x65, 0x2D, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x61, 0x6C, 0x77, 0x61, 0x79, 0x73, 0x2D, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x68, 0x6F, 0x6C, 0x64, 0x2D, 0x64, 0x75, 0x72, 0x69, 0x6E, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x68, 0x6F, 0x6C, 0x64, 0x2D, 0x61, 0x66, 0x74, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x3A, 0x73, 0x74, 0x72, 0x69, 0x70, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x3A, 0x74, 0x79, 0x70, 0x69, 0x6E, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x3A, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x3A, 0x64, 0x69, 0x73, 0x6A, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_63[]  = { 0x3A, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x69, 0x74, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_64[]  = { 0x3A, 0x65, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x69, 0x61, 0x6C, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_65[]  = { 0x3A, 0x75, 0x6E, 0x69, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_66[]  = { 0x3A, 0x71, 0x75, 0x61, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_67[]  = { 0x3A, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x2D, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_68[]  = { 0x3A, 0x66, 0x6C, 0x75, 0x65, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_69[]  = { 0x3A, 0x61, 0x64, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_70[]  = { 0x3A, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_71[]  = { 0x3A, 0x64, 0x65, 0x72, 0x69, 0x76, 0x65, 0x64, 0x2D, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_72[]  = { 0x3A, 0x74, 0x69, 0x6D, 0x65, 0x64, 0x2D, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x2D, 0x6C, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6C, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_73[]  = { 0x3A, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pPddlLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pPddlLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pPddlLexer_##scope##Top
#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))						\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;											\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);		\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void	mT__54    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__55    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__56    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__57    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__58    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__59    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__60    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__61    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__62    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__63    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__64    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__65    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__66    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__67    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__68    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__69    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__70    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__71    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__72    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__73    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__74    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__75    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__76    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__77    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__78    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__79    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__80    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__81    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__82    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__83    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__84    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__85    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__86    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__87    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__88    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__89    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__90    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__91    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__92    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__93    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__94    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__95    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__96    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__97    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__98    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__99    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__100    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__101    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__102    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__103    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__104    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__105    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__106    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__107    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__108    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__109    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__110    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__111    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__112    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__113    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__114    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__115    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__116    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__117    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__118    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__119    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mT__120    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mREQUIRE_KEY    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mNAME    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mLETTER    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mANY_CHAR    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mVARIABLE    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mNUMBER    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mDIGIT    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mLINE_COMMENT    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mWHITESPACE    (pPddlLexer ctx);
static ANTLR3_INLINE  void	mTokens    (pPddlLexer ctx);
static void	PddlLexerFree(pPddlLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
PddlLexerFree  (pPddlLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Pddl.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called PddlLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return 
 *     - Success pPddlLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pPddlLexer PddlLexerNew         
(pANTLR3_INPUT_STREAM instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return PddlLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called PddlLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return 
 *     - Success pPddlLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pPddlLexer PddlLexerNewSSD         
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pPddlLexer ctx; // Context structure we will build and return

    ctx = (pPddlLexer) ANTLR3_CALLOC(1, sizeof(PddlLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in PddlLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);
    
    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our PddlLexer interface
     */
    ctx->mT__54	= mT__54;
    ctx->mT__55	= mT__55;
    ctx->mT__56	= mT__56;
    ctx->mT__57	= mT__57;
    ctx->mT__58	= mT__58;
    ctx->mT__59	= mT__59;
    ctx->mT__60	= mT__60;
    ctx->mT__61	= mT__61;
    ctx->mT__62	= mT__62;
    ctx->mT__63	= mT__63;
    ctx->mT__64	= mT__64;
    ctx->mT__65	= mT__65;
    ctx->mT__66	= mT__66;
    ctx->mT__67	= mT__67;
    ctx->mT__68	= mT__68;
    ctx->mT__69	= mT__69;
    ctx->mT__70	= mT__70;
    ctx->mT__71	= mT__71;
    ctx->mT__72	= mT__72;
    ctx->mT__73	= mT__73;
    ctx->mT__74	= mT__74;
    ctx->mT__75	= mT__75;
    ctx->mT__76	= mT__76;
    ctx->mT__77	= mT__77;
    ctx->mT__78	= mT__78;
    ctx->mT__79	= mT__79;
    ctx->mT__80	= mT__80;
    ctx->mT__81	= mT__81;
    ctx->mT__82	= mT__82;
    ctx->mT__83	= mT__83;
    ctx->mT__84	= mT__84;
    ctx->mT__85	= mT__85;
    ctx->mT__86	= mT__86;
    ctx->mT__87	= mT__87;
    ctx->mT__88	= mT__88;
    ctx->mT__89	= mT__89;
    ctx->mT__90	= mT__90;
    ctx->mT__91	= mT__91;
    ctx->mT__92	= mT__92;
    ctx->mT__93	= mT__93;
    ctx->mT__94	= mT__94;
    ctx->mT__95	= mT__95;
    ctx->mT__96	= mT__96;
    ctx->mT__97	= mT__97;
    ctx->mT__98	= mT__98;
    ctx->mT__99	= mT__99;
    ctx->mT__100	= mT__100;
    ctx->mT__101	= mT__101;
    ctx->mT__102	= mT__102;
    ctx->mT__103	= mT__103;
    ctx->mT__104	= mT__104;
    ctx->mT__105	= mT__105;
    ctx->mT__106	= mT__106;
    ctx->mT__107	= mT__107;
    ctx->mT__108	= mT__108;
    ctx->mT__109	= mT__109;
    ctx->mT__110	= mT__110;
    ctx->mT__111	= mT__111;
    ctx->mT__112	= mT__112;
    ctx->mT__113	= mT__113;
    ctx->mT__114	= mT__114;
    ctx->mT__115	= mT__115;
    ctx->mT__116	= mT__116;
    ctx->mT__117	= mT__117;
    ctx->mT__118	= mT__118;
    ctx->mT__119	= mT__119;
    ctx->mT__120	= mT__120;
    ctx->mREQUIRE_KEY	= mREQUIRE_KEY;
    ctx->mNAME	= mNAME;
    ctx->mLETTER	= mLETTER;
    ctx->mANY_CHAR	= mANY_CHAR;
    ctx->mVARIABLE	= mVARIABLE;
    ctx->mNUMBER	= mNUMBER;
    ctx->mDIGIT	= mDIGIT;
    ctx->mLINE_COMMENT	= mLINE_COMMENT;
    ctx->mWHITESPACE	= mWHITESPACE;
    ctx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;
    
    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= PddlLexerFree;

    
    


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    506:1: REQUIRE_KEY : ( ':strips' | ':typing' | ':negative-preconditions' | ':disjunctive-preconditions' | ':equality' | ':existential-preconditions' | ':universal-preconditions' | ':quantified-preconditions' | ':conditional-effects' | ':fluents' | ':adl' | ':durative-actions' | ':derived-predicates' | ':timed-initial-literals' | ':preferences' | ':constraints' );
 */
static const ANTLR3_INT32 dfa1_eot[24] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa1_eof[24] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa1_min[24] =
    {
	58, 97, -1, 105, -1, 101, 113, -1, -1, 111, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 110, 100, -1, -1
    };
static const ANTLR3_INT32 dfa1_max[24] =
    {
	58, 117, -1, 121, -1, 117, 120, -1, -1, 111, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 110, 115, -1, -1
    };
static const ANTLR3_INT32 dfa1_accept[24] =
    {
	-1, -1, 1, -1, 3, -1, -1, 7, 8, -1, 10, 11, 15, 2, 14, 4, 12, 13, 5, 6, 
	-1, -1, 9, 16
    };
static const ANTLR3_INT32 dfa1_special[24] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa1_T_empty	    NULL

static const ANTLR3_INT32 dfa1_T0[] =
    {
	1
    };static const ANTLR3_INT32 dfa1_T1[] =
    {
	22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23
    };static const ANTLR3_INT32 dfa1_T2[] =
    {
	21
    };static const ANTLR3_INT32 dfa1_T3[] =
    {
	18, -1, -1, -1, -1, -1, -1, 19
    };static const ANTLR3_INT32 dfa1_T4[] =
    {
	20
    };static const ANTLR3_INT32 dfa1_T5[] =
    {
	17, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16
    };static const ANTLR3_INT32 dfa1_T6[] =
    {
	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13
    };static const ANTLR3_INT32 dfa1_T7[] =
    {
	11, -1, 9, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, 4, -1, 12, 8, -1, 2, 3, 
	7
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa1_transitions[] =
{
    dfa1_T0, dfa1_T7, dfa1_T_empty, dfa1_T6, dfa1_T_empty, dfa1_T5, dfa1_T3, 
    dfa1_T_empty, dfa1_T_empty, dfa1_T4, dfa1_T_empty, dfa1_T_empty, dfa1_T_empty, 
    dfa1_T_empty, dfa1_T_empty, dfa1_T_empty, dfa1_T_empty, dfa1_T_empty, 
    dfa1_T_empty, dfa1_T_empty, dfa1_T2, dfa1_T1, dfa1_T_empty, dfa1_T_empty	
};


/* Declare tracking structure for Cyclic DFA 1
 */
static
ANTLR3_CYCLIC_DFA cdfa1
    =	{
	    1,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"506:1: REQUIRE_KEY : ( ':strips' | ':typing' | ':negative-preconditions' | ':disjunctive-preconditions' | ':equality' | ':existential-preconditions' | ':universal-preconditions' | ':quantified-preconditions' | ':conditional-effects' | ':fluents' | ':adl' | ':durative-actions' | ':derived-predicates' | ':timed-initial-literals' | ':preferences' | ':constraints' );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa1_eot,	    /* EOT table			    */
	    dfa1_eof,	    /* EOF table			    */
	    dfa1_min,	    /* Minimum tokens for each state    */
	    dfa1_max,	    /* Maximum tokens for each state    */
	    dfa1_accept,	/* Accept table			    */
	    dfa1_special,	/* Special transition states	    */
	    dfa1_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 1
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | T__94 | T__95 | T__96 | T__97 | T__98 | T__99 | T__100 | T__101 | T__102 | T__103 | T__104 | T__105 | T__106 | T__107 | T__108 | T__109 | T__110 | T__111 | T__112 | T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | REQUIRE_KEY | NAME | VARIABLE | NUMBER | LINE_COMMENT | WHITESPACE );
 */
static const ANTLR3_INT32 dfa10_eot[336] =
    {
	-1, -1, 25, -1, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, 
	66, 68, -1, -1, 25, 25, 25, -1, -1, -1, -1, 25, 25, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 25, 25, 25, 25, 25, 25, 95, 25, 25, 99, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 70, -1, 25, 
	25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, 25, 
	127, 25, 129, 130, 25, -1, 132, 25, 25, -1, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 70, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, 
	25, 25, -1, 25, -1, -1, 25, -1, 25, 25, 168, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 178, 25, 70, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, -1, 
	-1, 25, 25, 25, 25, 25, 25, -1, 198, 25, 25, 25, 25, 25, 204, 25, 25, -1, 
	25, 70, 25, 25, 25, 25, 214, 25, 216, -1, -1, -1, -1, 222, 223, 224, 25, 
	227, 228, -1, 25, 25, 231, 25, 25, -1, 25, 25, 237, 70, 25, 25, 25, 25, 
	25, -1, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, 25, -1, -1, 25, 25, 
	-1, 25, 255, 25, 25, 25, -1, 70, 25, 25, 25, 25, 25, 265, -1, -1, -1, -1, 
	269, 25, 25, 272, 25, 25, -1, 275, 25, 278, 70, 280, 281, 25, 25, 25, -1, 
	-1, -1, -1, -1, 25, 25, -1, 25, 25, -1, 25, 25, -1, 295, -1, -1, 25, 25, 
	25, -1, 300, -1, 25, 25, 25, 305, 306, 25, 25, -1, 309, 25, 311, -1, -1, 
	-1, 25, 25, 316, -1, -1, 25, 25, -1, 319, -1, -1, -1, 322, 25, -1, 25, 
	25, -1, -1, -1, -1, 327, 25, 25, -1, -1, 331, 25, -1, -1, 334, 335, -1, 
	-1
    };
static const ANTLR3_INT32 dfa10_eof[336] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa10_min[336] =
    {
	9, -1, 101, -1, 97, -1, 105, 111, 108, 114, 109, 111, 114, 99, 104, -1, 
	-1, -1, 61, 61, -1, 65, 97, 111, 111, -1, -1, -1, -1, 99, 109, -1, 105, 
	108, 111, 97, 99, 102, 101, -1, -1, -1, -1, -1, 116, 105, 100, 109, 116, 
	100, 45, 108, 115, 45, 101, 112, 99, 45, 114, 101, 97, 97, 109, 101, 116, 
	-1, -1, -1, -1, 117, -1, 110, 120, 116, 108, 105, 114, 97, 112, -1, 110, 
	101, -1, -1, -1, 114, 114, -1, 104, 115, 45, 98, 45, 45, 109, -1, 45, 97, 
	105, -1, 114, 108, 114, 118, 97, 102, 98, 114, 108, 101, 110, 104, 114, 
	105, 105, 97, 100, 110, 101, 105, 101, 100, 99, 97, 105, 101, 116, -1, 
	101, -1, -1, 111, -1, 121, 103, 45, 121, 101, 105, 108, 101, 108, 116, 
	101, 116, 45, 105, 97, 109, 109, 108, 45, 101, 97, 110, -1, 116, 105, -1, 
	-1, 116, 118, 114, 115, 114, 115, 115, 110, -1, 45, 97, 111, 108, 114, 
	101, 45, 45, 105, -1, 110, 116, 105, 105, 45, 97, 45, 115, 45, 97, 116, 
	105, 101, 45, 45, 45, 116, 45, 45, -1, 115, 108, 45, 101, 109, -1, 100, 
	109, 45, 105, 122, 122, 116, 117, 102, -1, 101, -1, -1, 97, 105, 111, 100, 
	-1, -1, -1, 45, 119, -1, -1, 101, 97, -1, 110, 45, 112, 111, 101, -1, 111, 
	101, 101, 105, 114, 116, 45, 105, 111, 101, -1, 45, 111, 105, 45, 116, 
	99, -1, 45, 119, 45, 110, 45, 45, 109, 105, 101, -1, 110, 110, 45, -1, 
	110, 116, -1, 101, 101, -1, 110, 97, -1, 45, -1, -1, 101, 110, 114, 116, 
	97, 97, 99, 104, 100, 45, 45, 102, 101, -1, 45, 103, 45, 115, -1, 99, 101, 
	105, 45, -1, -1, 116, 102, -1, 45, -1, -1, 116, 45, 110, -1, 101, 111, 
	-1, -1, 105, -1, 45, 114, 114, 111, -1, 45, 101, 110, -1, 45, 115, -1, 
	-1
    };
static const ANTLR3_INT32 dfa10_max[336] =
    {
	122, -1, 111, -1, 117, -1, 120, 117, 116, 118, 115, 111, 114, 116, 105, 
	-1, -1, -1, 61, 61, -1, 122, 105, 111, 111, -1, -1, -1, -1, 102, 109, -1, 
	121, 117, 111, 114, 100, 120, 117, -1, -1, -1, -1, -1, 116, 105, 100, 109, 
	116, 100, 122, 119, 115, 122, 101, 112, 99, 45, 114, 111, 97, 97, 109, 
	101, 116, -1, -1, -1, -1, 117, -1, 110, 120, 116, 108, 105, 114, 97, 112, 
	-1, 110, 101, -1, -1, -1, 114, 114, -1, 104, 115, 122, 98, 122, 122, 109, 
	-1, 122, 97, 105, -1, 114, 108, 114, 118, 97, 102, 98, 114, 108, 101, 110, 
	104, 114, 105, 105, 97, 100, 110, 101, 105, 105, 115, 102, 97, 105, 101, 
	116, -1, 101, -1, -1, 111, -1, 121, 103, 122, 121, 101, 105, 108, 101, 
	108, 116, 101, 116, 122, 105, 97, 109, 109, 108, 45, 101, 97, 110, -1, 
	116, 105, -1, -1, 116, 118, 114, 115, 114, 115, 115, 110, -1, 122, 97, 
	111, 108, 114, 101, 122, 45, 105, -1, 110, 116, 105, 105, 45, 100, 122, 
	115, 122, 114, 116, 105, 101, 122, 122, 122, 116, 122, 122, -1, 115, 108, 
	122, 101, 109, -1, 117, 109, 122, 105, 122, 122, 116, 117, 102, -1, 101, 
	-1, -1, 97, 105, 118, 100, -1, -1, -1, 45, 119, -1, -1, 101, 97, -1, 110, 
	122, 112, 111, 101, -1, 111, 101, 101, 105, 114, 116, 122, 105, 111, 101, 
	-1, 45, 111, 105, 122, 116, 99, -1, 122, 119, 122, 110, 122, 122, 109, 
	105, 101, -1, 110, 110, 45, -1, 110, 116, -1, 101, 101, -1, 110, 98, -1, 
	122, -1, -1, 101, 110, 114, 116, 97, 97, 99, 104, 100, 122, 122, 102, 101, 
	-1, 122, 103, 122, 115, -1, 99, 101, 105, 122, -1, -1, 116, 102, -1, 122, 
	-1, -1, 116, 122, 110, -1, 101, 111, -1, -1, 105, -1, 122, 114, 114, 111, 
	-1, 122, 101, 110, -1, 122, 115, -1, -1
    };
static const ANTLR3_INT32 dfa10_accept[336] =
    {
	-1, 1, -1, 3, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 35, 36, 37, -1, 
	-1, 40, -1, -1, -1, -1, 69, 71, 72, 73, -1, -1, 5, -1, -1, -1, -1, -1, 
	-1, -1, 51, 52, 53, 54, 68, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 38, 42, 39, -1, 70, -1, -1, 
	-1, -1, -1, -1, -1, -1, 9, -1, -1, 15, 14, 17, -1, -1, 50, -1, -1, -1, 
	-1, -1, -1, -1, 28, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	31, -1, 20, 18, -1, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, 12, 16, -1, -1, -1, 
	-1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, 34, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21, 
	-1, -1, -1, -1, -1, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 4, 11, 
	-1, -1, -1, -1, 8, 22, 10, -1, -1, 59, 43, -1, -1, 23, -1, -1, -1, -1, 
	-1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, -1, -1, -1, -1, -1, 
	-1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, 33, -1, -1, 
	46, -1, -1, 44, -1, -1, 60, -1, 55, 56, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 48, -1, -1, -1, -1, 26, -1, -1, -1, -1, 27, 45, -1, 
	-1, 57, -1, 67, 13, -1, -1, -1, 58, -1, -1, 66, 13, -1, 62, -1, -1, -1, 
	-1, 65, -1, -1, -1, 63, -1, -1, 64, 24
    };
static const ANTLR3_INT32 dfa10_special[336] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa10_T_empty	    NULL

static const ANTLR3_INT32 dfa10_T0[] =
    {
	114
    };static const ANTLR3_INT32 dfa10_T1[] =
    {
	149
    };static const ANTLR3_INT32 dfa10_T2[] =
    {
	182
    };static const ANTLR3_INT32 dfa10_T3[] =
    {
	25, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, 
	-1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 25, -1, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa10_T4[] =
    {
	65
    };static const ANTLR3_INT32 dfa10_T5[] =
    {
	122
    };static const ANTLR3_INT32 dfa10_T6[] =
    {
	48, -1, -1, -1, -1, -1, 47
    };static const ANTLR3_INT32 dfa10_T7[] =
    {
	28, 28, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, 1, 3, 15, 16, -1, 5, 
	-1, 17, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 4, 27, 19, 20, 18, 21, 
	-1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, -1, 8, 25, 25, 
	2, 6, 11, 25, 24, 10, 25, 25, 25, 22, 7, 9, 12, 25, 25, 13, 23, 25, 25, 
	14, 25, 25, 25
    };static const ANTLR3_INT32 dfa10_T8[] =
    {
	147
    };static const ANTLR3_INT32 dfa10_T9[] =
    {
	72, -1, -1, -1, -1, -1, -1, -1, 71
    };static const ANTLR3_INT32 dfa10_T10[] =
    {
	210
    };static const ANTLR3_INT32 dfa10_T11[] =
    {
	277, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, 
	-1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 25, -1, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa10_T12[] =
    {
	240
    };static const ANTLR3_INT32 dfa10_T13[] =
    {
	261
    };static const ANTLR3_INT32 dfa10_T14[] =
    {
	159, 158, -1, 43
    };static const ANTLR3_INT32 dfa10_T15[] =
    {
	209
    };static const ANTLR3_INT32 dfa10_T16[] =
    {
	181
    };static const ANTLR3_INT32 dfa10_T17[] =
    {
	260
    };static const ANTLR3_INT32 dfa10_T18[] =
    {
	239
    };static const ANTLR3_INT32 dfa10_T19[] =
    {
	148
    };static const ANTLR3_INT32 dfa10_T20[] =
    {
	113
    };static const ANTLR3_INT32 dfa10_T21[] =
    {
	188
    };static const ANTLR3_INT32 dfa10_T22[] =
    {
	217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 218
    };static const ANTLR3_INT32 dfa10_T23[] =
    {
	226, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, 
	-1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 25, -1, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa10_T24[] =
    {
	119
    };static const ANTLR3_INT32 dfa10_T25[] =
    {
	146
    };static const ANTLR3_INT32 dfa10_T26[] =
    {
	154
    };static const ANTLR3_INT32 dfa10_T27[] =
    {
	179
    };static const ANTLR3_INT32 dfa10_T28[] =
    {
	207
    };static const ANTLR3_INT32 dfa10_T29[] =
    {
	77
    };static const ANTLR3_INT32 dfa10_T30[] =
    {
	131
    };static const ANTLR3_INT32 dfa10_T31[] =
    {
	155, -1, -1, -1, 43
    };static const ANTLR3_INT32 dfa10_T32[] =
    {
	165
    };static const ANTLR3_INT32 dfa10_T33[] =
    {
	76, -1, -1, 75
    };static const ANTLR3_INT32 dfa10_T34[] =
    {
	195
    };static const ANTLR3_INT32 dfa10_T35[] =
    {
	225
    };static const ANTLR3_INT32 dfa10_T36[] =
    {
	250
    };static const ANTLR3_INT32 dfa10_T37[] =
    {
	270
    };static const ANTLR3_INT32 dfa10_T38[] =
    {
	187
    };static const ANTLR3_INT32 dfa10_T39[] =
    {
	288
    };static const ANTLR3_INT32 dfa10_T40[] =
    {
	36, -1, 34, 38, 37, 33, 41, -1, 40, -1, -1, -1, 42, 43, 39, 35, 43, 31, 
	43, 32, 43
    };static const ANTLR3_INT32 dfa10_T41[] =
    {
	185
    };static const ANTLR3_INT32 dfa10_T42[] =
    {
	152
    };static const ANTLR3_INT32 dfa10_T43[] =
    {
	117
    };static const ANTLR3_INT32 dfa10_T44[] =
    {
	111
    };static const ANTLR3_INT32 dfa10_T45[] =
    {
	253
    };static const ANTLR3_INT32 dfa10_T46[] =
    {
	273
    };static const ANTLR3_INT32 dfa10_T47[] =
    {
	200
    };static const ANTLR3_INT32 dfa10_T48[] =
    {
	230
    };static const ANTLR3_INT32 dfa10_T49[] =
    {
	290
    };static const ANTLR3_INT32 dfa10_T50[] =
    {
	304
    };static const ANTLR3_INT32 dfa10_T51[] =
    {
	125
    };static const ANTLR3_INT32 dfa10_T52[] =
    {
	162
    };static const ANTLR3_INT32 dfa10_T53[] =
    {
	192
    };static const ANTLR3_INT32 dfa10_T54[] =
    {
	88
    };static const ANTLR3_INT32 dfa10_T55[] =
    {
	259
    };static const ANTLR3_INT32 dfa10_T56[] =
    {
	73
    };static const ANTLR3_INT32 dfa10_T57[] =
    {
	211
    };static const ANTLR3_INT32 dfa10_T58[] =
    {
	238
    };static const ANTLR3_INT32 dfa10_T59[] =
    {
	183
    };static const ANTLR3_INT32 dfa10_T60[] =
    {
	150
    };static const ANTLR3_INT32 dfa10_T61[] =
    {
	208
    };static const ANTLR3_INT32 dfa10_T62[] =
    {
	115
    };static const ANTLR3_INT32 dfa10_T63[] =
    {
	180
    };static const ANTLR3_INT32 dfa10_T64[] =
    {
	296
    };static const ANTLR3_INT32 dfa10_T65[] =
    {
	282
    };static const ANTLR3_INT32 dfa10_T66[] =
    {
	262
    };static const ANTLR3_INT32 dfa10_T67[] =
    {
	279
    };static const ANTLR3_INT32 dfa10_T68[] =
    {
	241
    };static const ANTLR3_INT32 dfa10_T69[] =
    {
	171
    };static const ANTLR3_INT32 dfa10_T70[] =
    {
	138
    };static const ANTLR3_INT32 dfa10_T71[] =
    {
	103
    };static const ANTLR3_INT32 dfa10_T72[] =
    {
	256
    };static const ANTLR3_INT32 dfa10_T73[] =
    {
	197
    };static const ANTLR3_INT32 dfa10_T74[] =
    {
	167
    };static const ANTLR3_INT32 dfa10_T75[] =
    {
	63, 64
    };static const ANTLR3_INT32 dfa10_T76[] =
    {
	98
    };static const ANTLR3_INT32 dfa10_T77[] =
    {
	134
    };static const ANTLR3_INT32 dfa10_T78[] =
    {
	123
    };static const ANTLR3_INT32 dfa10_T79[] =
    {
	112
    };static const ANTLR3_INT32 dfa10_T80[] =
    {
	196
    };static const ANTLR3_INT32 dfa10_T81[] =
    {
	160
    };static const ANTLR3_INT32 dfa10_T82[] =
    {
	166
    };static const ANTLR3_INT32 dfa10_T83[] =
    {
	220
    };static const ANTLR3_INT32 dfa10_T84[] =
    {
	133
    };static const ANTLR3_INT32 dfa10_T85[] =
    {
	190
    };static const ANTLR3_INT32 dfa10_T86[] =
    {
	43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 78
    };static const ANTLR3_INT32 dfa10_T87[] =
    {
	84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, -1, -1, -1, -1, -1, 
	43
    };static const ANTLR3_INT32 dfa10_T88[] =
    {
	94, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, 
	-1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 25, -1, 25, 25, 
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 
	25, 25, 25, 25, 25, 25
    };static const ANTLR3_INT32 dfa10_T89[] =
    {
	145
    };static const ANTLR3_INT32 dfa10_T90[] =
    {
	110
    };static const ANTLR3_INT32 dfa10_T91[] =
    {
	74
    };static const ANTLR3_INT32 dfa10_T92[] =
    {
	174
    };static const ANTLR3_INT32 dfa10_T93[] =
    {
	141
    };static const ANTLR3_INT32 dfa10_T94[] =
    {
	233
    };static const ANTLR3_INT32 dfa10_T95[] =
    {
	203
    };static const ANTLR3_INT32 dfa10_T96[] =
    {
	53, -1, -1, -1, 54
    };static const ANTLR3_INT32 dfa10_T97[] =
    {
	118
    };static const ANTLR3_INT32 dfa10_T98[] =
    {
	244
    };static const ANTLR3_INT32 dfa10_T99[] =
    {
	51, -1, 49, -1, -1, -1, -1, 52, 50
    };static const ANTLR3_INT32 dfa10_T100[] =
    {
	215
    };static const ANTLR3_INT32 dfa10_T101[] =
    {
	186
    };static const ANTLR3_INT32 dfa10_T102[] =
    {
	153
    };static const ANTLR3_INT32 dfa10_T103[] =
    {
	229
    };static const ANTLR3_INT32 dfa10_T104[] =
    {
	199
    };static const ANTLR3_INT32 dfa10_T105[] =
    {
	170
    };static const ANTLR3_INT32 dfa10_T106[] =
    {
	137
    };static const ANTLR3_INT32 dfa10_T107[] =
    {
	252
    };static const ANTLR3_INT32 dfa10_T108[] =
    {
	276
    };static const ANTLR3_INT32 dfa10_T109[] =
    {
	292
    };static const ANTLR3_INT32 dfa10_T110[] =
    {
	102
    };static const ANTLR3_INT32 dfa10_T111[] =
    {
	96, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97
    };static const ANTLR3_INT32 dfa10_T112[] =
    {
	43, -1, -1, -1, -1, -1, -1, -1, -1, 79
    };static const ANTLR3_INT32 dfa10_T113[] =
    {
	257
    };static const ANTLR3_INT32 dfa10_T114[] =
    {
	92
    };static const ANTLR3_INT32 dfa10_T115[] =
    {
	101
    };static const ANTLR3_INT32 dfa10_T116[] =
    {
	312
    };static const ANTLR3_INT32 dfa10_T117[] =
    {
	169
    };static const ANTLR3_INT32 dfa10_T118[] =
    {
	136
    };static const ANTLR3_INT32 dfa10_T119[] =
    {
	157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 156
    };static const ANTLR3_INT32 dfa10_T120[] =
    {
	299
    };static const ANTLR3_INT32 dfa10_T121[] =
    {
	285
    };static const ANTLR3_INT32 dfa10_T122[] =
    {
	266
    };static const ANTLR3_INT32 dfa10_T123[] =
    {
	89
    };static const ANTLR3_INT32 dfa10_T124[] =
    {
	126
    };static const ANTLR3_INT32 dfa10_T125[] =
    {
	245
    };static const ANTLR3_INT32 dfa10_T126[] =
    {
	163
    };static const ANTLR3_INT32 dfa10_T127[] =
    {
	70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 
	70, 70, 70, 70, 70, 70, 70, 70, -1, -1, -1, -1, -1, -1, 70, 70, 70, 69, 
	70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 
	70, 70, 70, 70
    };static const ANTLR3_INT32 dfa10_T128[] =
    {
	193
    };static const ANTLR3_INT32 dfa10_T129[] =
    {
	104
    };static const ANTLR3_INT32 dfa10_T130[] =
    {
	116
    };static const ANTLR3_INT32 dfa10_T131[] =
    {
	139
    };static const ANTLR3_INT32 dfa10_T132[] =
    {
	172
    };static const ANTLR3_INT32 dfa10_T133[] =
    {
	201
    };static const ANTLR3_INT32 dfa10_T134[] =
    {
	184
    };static const ANTLR3_INT32 dfa10_T135[] =
    {
	151
    };static const ANTLR3_INT32 dfa10_T136[] =
    {
	213, -1, -1, 212
    };static const ANTLR3_INT32 dfa10_T137[] =
    {
	326
    };static const ANTLR3_INT32 dfa10_T138[] =
    {
	330
    };static const ANTLR3_INT32 dfa10_T139[] =
    {
	313
    };static const ANTLR3_INT32 dfa10_T140[] =
    {
	321
    };static const ANTLR3_INT32 dfa10_T141[] =
    {
	55, 56, -1, -1, -1, -1, 57
    };static const ANTLR3_INT32 dfa10_T142[] =
    {
	287
    };static const ANTLR3_INT32 dfa10_T143[] =
    {
	301
    };static const ANTLR3_INT32 dfa10_T144[] =
    {
	44, -1, -1, -1, -1, 46, -1, -1, -1, -1, -1, -1, -1, -1, -1, 45
    };static const ANTLR3_INT32 dfa10_T145[] =
    {
	286
    };static const ANTLR3_INT32 dfa10_T146[] =
    {
	268
    };static const ANTLR3_INT32 dfa10_T147[] =
    {
	246
    };static const ANTLR3_INT32 dfa10_T148[] =
    {
	176
    };static const ANTLR3_INT32 dfa10_T149[] =
    {
	121
    };static const ANTLR3_INT32 dfa10_T150[] =
    {
	267
    };static const ANTLR3_INT32 dfa10_T151[] =
    {
	143
    };static const ANTLR3_INT32 dfa10_T152[] =
    {
	108
    };static const ANTLR3_INT32 dfa10_T153[] =
    {
	80
    };static const ANTLR3_INT32 dfa10_T154[] =
    {
	189
    };static const ANTLR3_INT32 dfa10_T155[] =
    {
	219
    };static const ANTLR3_INT32 dfa10_T156[] =
    {
	43
    };static const ANTLR3_INT32 dfa10_T157[] =
    {
	235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234
    };static const ANTLR3_INT32 dfa10_T158[] =
    {
	205
    };static const ANTLR3_INT32 dfa10_T159[] =
    {
	59
    };static const ANTLR3_INT32 dfa10_T160[] =
    {
	293, 294
    };static const ANTLR3_INT32 dfa10_T161[] =
    {
	58
    };static const ANTLR3_INT32 dfa10_T162[] =
    {
	173
    };static const ANTLR3_INT32 dfa10_T163[] =
    {
	140
    };static const ANTLR3_INT32 dfa10_T164[] =
    {
	291
    };static const ANTLR3_INT32 dfa10_T165[] =
    {
	202
    };static const ANTLR3_INT32 dfa10_T166[] =
    {
	232
    };static const ANTLR3_INT32 dfa10_T167[] =
    {
	254
    };static const ANTLR3_INT32 dfa10_T168[] =
    {
	274
    };static const ANTLR3_INT32 dfa10_T169[] =
    {
	100
    };static const ANTLR3_INT32 dfa10_T170[] =
    {
	83, 43
    };static const ANTLR3_INT32 dfa10_T171[] =
    {
	142
    };static const ANTLR3_INT32 dfa10_T172[] =
    {
	107
    };static const ANTLR3_INT32 dfa10_T173[] =
    {
	135
    };static const ANTLR3_INT32 dfa10_T174[] =
    {
	90
    };static const ANTLR3_INT32 dfa10_T175[] =
    {
	86, -1, -1, -1, 43, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, 85
    };static const ANTLR3_INT32 dfa10_T176[] =
    {
	175
    };static const ANTLR3_INT32 dfa10_T177[] =
    {
	105, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106
    };static const ANTLR3_INT32 dfa10_T178[] =
    {
	248, -1, -1, -1, -1, -1, -1, 247
    };static const ANTLR3_INT32 dfa10_T179[] =
    {
	251
    };static const ANTLR3_INT32 dfa10_T180[] =
    {
	191
    };static const ANTLR3_INT32 dfa10_T181[] =
    {
	161
    };static const ANTLR3_INT32 dfa10_T182[] =
    {
	124
    };static const ANTLR3_INT32 dfa10_T183[] =
    {
	332
    };static const ANTLR3_INT32 dfa10_T184[] =
    {
	325
    };static const ANTLR3_INT32 dfa10_T185[] =
    {
	329
    };static const ANTLR3_INT32 dfa10_T186[] =
    {
	249
    };static const ANTLR3_INT32 dfa10_T187[] =
    {
	308
    };static const ANTLR3_INT32 dfa10_T188[] =
    {
	318
    };static const ANTLR3_INT32 dfa10_T189[] =
    {
	221
    };static const ANTLR3_INT32 dfa10_T190[] =
    {
	263
    };static const ANTLR3_INT32 dfa10_T191[] =
    {
	242
    };static const ANTLR3_INT32 dfa10_T192[] =
    {
	109
    };static const ANTLR3_INT32 dfa10_T193[] =
    {
	91
    };static const ANTLR3_INT32 dfa10_T194[] =
    {
	144
    };static const ANTLR3_INT32 dfa10_T195[] =
    {
	164
    };static const ANTLR3_INT32 dfa10_T196[] =
    {
	177
    };static const ANTLR3_INT32 dfa10_T197[] =
    {
	323
    };static const ANTLR3_INT32 dfa10_T198[] =
    {
	128
    };static const ANTLR3_INT32 dfa10_T199[] =
    {
	315
    };static const ANTLR3_INT32 dfa10_T200[] =
    {
	303
    };static const ANTLR3_INT32 dfa10_T201[] =
    {
	194
    };static const ANTLR3_INT32 dfa10_T202[] =
    {
	289
    };static const ANTLR3_INT32 dfa10_T203[] =
    {
	271
    };static const ANTLR3_INT32 dfa10_T204[] =
    {
	206
    };static const ANTLR3_INT32 dfa10_T205[] =
    {
	307
    };static const ANTLR3_INT32 dfa10_T206[] =
    {
	29, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30
    };static const ANTLR3_INT32 dfa10_T207[] =
    {
	302
    };static const ANTLR3_INT32 dfa10_T208[] =
    {
	314
    };static const ANTLR3_INT32 dfa10_T209[] =
    {
	324
    };static const ANTLR3_INT32 dfa10_T210[] =
    {
	317
    };static const ANTLR3_INT32 dfa10_T211[] =
    {
	328
    };static const ANTLR3_INT32 dfa10_T212[] =
    {
	120
    };static const ANTLR3_INT32 dfa10_T213[] =
    {
	70, -1, -1, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, -1, -1, -1, -1, -1, 
	-1, -1, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 
	70, 70, 70, 70, 70, 70, 70, 70, 70, 70, -1, -1, -1, -1, 70, -1, 70, 70, 
	70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 
	70, 70, 70, 70, 70, 70
    };static const ANTLR3_INT32 dfa10_T214[] =
    {
	333
    };static const ANTLR3_INT32 dfa10_T215[] =
    {
	258
    };static const ANTLR3_INT32 dfa10_T216[] =
    {
	243
    };static const ANTLR3_INT32 dfa10_T217[] =
    {
	264
    };static const ANTLR3_INT32 dfa10_T218[] =
    {
	284
    };static const ANTLR3_INT32 dfa10_T219[] =
    {
	298
    };static const ANTLR3_INT32 dfa10_T220[] =
    {
	236
    };static const ANTLR3_INT32 dfa10_T221[] =
    {
	283
    };static const ANTLR3_INT32 dfa10_T222[] =
    {
	67
    };static const ANTLR3_INT32 dfa10_T223[] =
    {
	297
    };static const ANTLR3_INT32 dfa10_T224[] =
    {
	310
    };static const ANTLR3_INT32 dfa10_T225[] =
    {
	82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81
    };static const ANTLR3_INT32 dfa10_T226[] =
    {
	61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, 60
    };static const ANTLR3_INT32 dfa10_T227[] =
    {
	93
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa10_transitions[] =
{
    dfa10_T7, dfa10_T_empty, dfa10_T206, dfa10_T_empty, dfa10_T40, dfa10_T_empty, 
    dfa10_T144, dfa10_T6, dfa10_T99, dfa10_T96, dfa10_T141, dfa10_T161, 
    dfa10_T159, dfa10_T226, dfa10_T75, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, 
    dfa10_T4, dfa10_T222, dfa10_T_empty, dfa10_T127, dfa10_T9, dfa10_T56, 
    dfa10_T91, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, 
    dfa10_T33, dfa10_T29, dfa10_T_empty, dfa10_T86, dfa10_T112, dfa10_T153, 
    dfa10_T225, dfa10_T170, dfa10_T87, dfa10_T175, dfa10_T_empty, dfa10_T_empty, 
    dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T54, dfa10_T123, 
    dfa10_T174, dfa10_T193, dfa10_T114, dfa10_T227, dfa10_T88, dfa10_T111, 
    dfa10_T76, dfa10_T3, dfa10_T169, dfa10_T115, dfa10_T110, dfa10_T71, 
    dfa10_T129, dfa10_T177, dfa10_T172, dfa10_T152, dfa10_T192, dfa10_T90, 
    dfa10_T44, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, 
    dfa10_T79, dfa10_T_empty, dfa10_T20, dfa10_T0, dfa10_T62, dfa10_T130, 
    dfa10_T43, dfa10_T97, dfa10_T24, dfa10_T212, dfa10_T_empty, dfa10_T149, 
    dfa10_T5, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T78, dfa10_T182, 
    dfa10_T_empty, dfa10_T51, dfa10_T124, dfa10_T3, dfa10_T198, dfa10_T3, 
    dfa10_T3, dfa10_T30, dfa10_T_empty, dfa10_T3, dfa10_T84, dfa10_T77, 
    dfa10_T_empty, dfa10_T173, dfa10_T118, dfa10_T106, dfa10_T70, dfa10_T131, 
    dfa10_T163, dfa10_T93, dfa10_T171, dfa10_T151, dfa10_T194, dfa10_T89, 
    dfa10_T25, dfa10_T8, dfa10_T19, dfa10_T1, dfa10_T60, dfa10_T135, dfa10_T42, 
    dfa10_T102, dfa10_T26, dfa10_T31, dfa10_T119, dfa10_T14, dfa10_T81, 
    dfa10_T181, dfa10_T52, dfa10_T126, dfa10_T_empty, dfa10_T195, dfa10_T_empty, 
    dfa10_T_empty, dfa10_T32, dfa10_T_empty, dfa10_T82, dfa10_T74, dfa10_T3, 
    dfa10_T117, dfa10_T105, dfa10_T69, dfa10_T132, dfa10_T162, dfa10_T92, 
    dfa10_T176, dfa10_T148, dfa10_T196, dfa10_T3, dfa10_T27, dfa10_T63, 
    dfa10_T16, dfa10_T2, dfa10_T59, dfa10_T134, dfa10_T41, dfa10_T101, dfa10_T38, 
    dfa10_T_empty, dfa10_T21, dfa10_T154, dfa10_T_empty, dfa10_T_empty, 
    dfa10_T85, dfa10_T180, dfa10_T53, dfa10_T128, dfa10_T201, dfa10_T34, 
    dfa10_T80, dfa10_T73, dfa10_T_empty, dfa10_T3, dfa10_T104, dfa10_T47, 
    dfa10_T133, dfa10_T165, dfa10_T95, dfa10_T3, dfa10_T158, dfa10_T204, 
    dfa10_T_empty, dfa10_T28, dfa10_T61, dfa10_T15, dfa10_T10, dfa10_T57, 
    dfa10_T136, dfa10_T3, dfa10_T100, dfa10_T3, dfa10_T22, dfa10_T155, dfa10_T83, 
    dfa10_T189, dfa10_T3, dfa10_T3, dfa10_T3, dfa10_T35, dfa10_T23, dfa10_T3, 
    dfa10_T_empty, dfa10_T103, dfa10_T48, dfa10_T3, dfa10_T166, dfa10_T94, 
    dfa10_T_empty, dfa10_T157, dfa10_T220, dfa10_T3, dfa10_T58, dfa10_T18, 
    dfa10_T12, dfa10_T68, dfa10_T191, dfa10_T216, dfa10_T_empty, dfa10_T98, 
    dfa10_T_empty, dfa10_T_empty, dfa10_T125, dfa10_T147, dfa10_T178, dfa10_T186, 
    dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T36, dfa10_T179, 
    dfa10_T_empty, dfa10_T_empty, dfa10_T107, dfa10_T45, dfa10_T_empty, 
    dfa10_T167, dfa10_T3, dfa10_T72, dfa10_T113, dfa10_T215, dfa10_T_empty, 
    dfa10_T55, dfa10_T17, dfa10_T13, dfa10_T66, dfa10_T190, dfa10_T217, 
    dfa10_T3, dfa10_T122, dfa10_T150, dfa10_T146, dfa10_T_empty, dfa10_T156, 
    dfa10_T37, dfa10_T203, dfa10_T3, dfa10_T46, dfa10_T168, dfa10_T_empty, 
    dfa10_T3, dfa10_T108, dfa10_T11, dfa10_T67, dfa10_T3, dfa10_T3, dfa10_T65, 
    dfa10_T221, dfa10_T218, dfa10_T_empty, dfa10_T121, dfa10_T145, dfa10_T142, 
    dfa10_T_empty, dfa10_T39, dfa10_T202, dfa10_T_empty, dfa10_T49, dfa10_T164, 
    dfa10_T_empty, dfa10_T109, dfa10_T160, dfa10_T_empty, dfa10_T213, dfa10_T_empty, 
    dfa10_T_empty, dfa10_T64, dfa10_T223, dfa10_T219, dfa10_T120, dfa10_T156, 
    dfa10_T143, dfa10_T207, dfa10_T200, dfa10_T50, dfa10_T3, dfa10_T3, dfa10_T205, 
    dfa10_T187, dfa10_T_empty, dfa10_T3, dfa10_T224, dfa10_T3, dfa10_T116, 
    dfa10_T_empty, dfa10_T139, dfa10_T208, dfa10_T199, dfa10_T3, dfa10_T_empty, 
    dfa10_T_empty, dfa10_T210, dfa10_T188, dfa10_T_empty, dfa10_T3, dfa10_T_empty, 
    dfa10_T_empty, dfa10_T140, dfa10_T3, dfa10_T197, dfa10_T_empty, dfa10_T209, 
    dfa10_T184, dfa10_T_empty, dfa10_T_empty, dfa10_T137, dfa10_T_empty, 
    dfa10_T3, dfa10_T211, dfa10_T185, dfa10_T138, dfa10_T_empty, dfa10_T3, 
    dfa10_T183, dfa10_T214, dfa10_T_empty, dfa10_T3, dfa10_T156, dfa10_T_empty, 
    dfa10_T_empty	
};


/* Declare tracking structure for Cyclic DFA 10
 */
static
ANTLR3_CYCLIC_DFA cdfa10
    =	{
	    10,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | T__94 | T__95 | T__96 | T__97 | T__98 | T__99 | T__100 | T__101 | T__102 | T__103 | T__104 | T__105 | T__106 | T__107 | T__108 | T__109 | T__110 | T__111 | T__112 | T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | REQUIRE_KEY | NAME | VARIABLE | NUMBER | LINE_COMMENT | WHITESPACE );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa10_eot,	    /* EOT table			    */
	    dfa10_eof,	    /* EOF table			    */
	    dfa10_min,	    /* Minimum tokens for each state    */
	    dfa10_max,	    /* Maximum tokens for each state    */
	    dfa10_accept,	/* Accept table			    */
	    dfa10_special,	/* Special transition states	    */
	    dfa10_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 10
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 7:7: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__54
 *
 * Looks to match the characters the constitute the token T__54
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__54(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__54;
       
    
    // ../../model/subgoal_learning/Pddl.g:7:7: ( '(' )
    // ../../model/subgoal_learning/Pddl.g:7:9: '('
    {
        MATCHC('('); 
        if  (HASEXCEPTION())
        {
            goto ruleT__54Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__54Ex; /* Prevent compiler warnings */
    ruleT__54Ex: ;

}
// $ANTLR end T__54

//   Comes from: 8:7: ( 'define' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__55
 *
 * Looks to match the characters the constitute the token T__55
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__55(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__55;
       
    
    // ../../model/subgoal_learning/Pddl.g:8:7: ( 'define' )
    // ../../model/subgoal_learning/Pddl.g:8:9: 'define'
    {
        MATCHS(lit_1); 
        if  (HASEXCEPTION())
        {
            goto ruleT__55Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__55Ex; /* Prevent compiler warnings */
    ruleT__55Ex: ;

}
// $ANTLR end T__55

//   Comes from: 9:7: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__56
 *
 * Looks to match the characters the constitute the token T__56
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__56(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__56;
       
    
    // ../../model/subgoal_learning/Pddl.g:9:7: ( ')' )
    // ../../model/subgoal_learning/Pddl.g:9:9: ')'
    {
        MATCHC(')'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__56Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__56Ex; /* Prevent compiler warnings */
    ruleT__56Ex: ;

}
// $ANTLR end T__56

//   Comes from: 10:7: ( 'domain' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__57
 *
 * Looks to match the characters the constitute the token T__57
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__57(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__57;
       
    
    // ../../model/subgoal_learning/Pddl.g:10:7: ( 'domain' )
    // ../../model/subgoal_learning/Pddl.g:10:9: 'domain'
    {
        MATCHS(lit_2); 
        if  (HASEXCEPTION())
        {
            goto ruleT__57Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__57Ex; /* Prevent compiler warnings */
    ruleT__57Ex: ;

}
// $ANTLR end T__57

//   Comes from: 11:7: ( ':requirements' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__58
 *
 * Looks to match the characters the constitute the token T__58
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__58(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__58;
       
    
    // ../../model/subgoal_learning/Pddl.g:11:7: ( ':requirements' )
    // ../../model/subgoal_learning/Pddl.g:11:9: ':requirements'
    {
        MATCHS(lit_3); 
        if  (HASEXCEPTION())
        {
            goto ruleT__58Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__58Ex; /* Prevent compiler warnings */
    ruleT__58Ex: ;

}
// $ANTLR end T__58

//   Comes from: 12:7: ( ':types' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__59
 *
 * Looks to match the characters the constitute the token T__59
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__59(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__59;
       
    
    // ../../model/subgoal_learning/Pddl.g:12:7: ( ':types' )
    // ../../model/subgoal_learning/Pddl.g:12:9: ':types'
    {
        MATCHS(lit_4); 
        if  (HASEXCEPTION())
        {
            goto ruleT__59Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__59Ex; /* Prevent compiler warnings */
    ruleT__59Ex: ;

}
// $ANTLR end T__59

//   Comes from: 13:7: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__60
 *
 * Looks to match the characters the constitute the token T__60
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__60(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__60;
       
    
    // ../../model/subgoal_learning/Pddl.g:13:7: ( '-' )
    // ../../model/subgoal_learning/Pddl.g:13:9: '-'
    {
        MATCHC('-'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__60Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__60Ex; /* Prevent compiler warnings */
    ruleT__60Ex: ;

}
// $ANTLR end T__60

//   Comes from: 14:7: ( 'either' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__61
 *
 * Looks to match the characters the constitute the token T__61
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__61(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__61;
       
    
    // ../../model/subgoal_learning/Pddl.g:14:7: ( 'either' )
    // ../../model/subgoal_learning/Pddl.g:14:9: 'either'
    {
        MATCHS(lit_5); 
        if  (HASEXCEPTION())
        {
            goto ruleT__61Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__61Ex; /* Prevent compiler warnings */
    ruleT__61Ex: ;

}
// $ANTLR end T__61

//   Comes from: 15:7: ( ':functions' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__62
 *
 * Looks to match the characters the constitute the token T__62
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__62(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__62;
       
    
    // ../../model/subgoal_learning/Pddl.g:15:7: ( ':functions' )
    // ../../model/subgoal_learning/Pddl.g:15:9: ':functions'
    {
        MATCHS(lit_6); 
        if  (HASEXCEPTION())
        {
            goto ruleT__62Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__62Ex; /* Prevent compiler warnings */
    ruleT__62Ex: ;

}
// $ANTLR end T__62

//   Comes from: 16:7: ( 'number' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__63
 *
 * Looks to match the characters the constitute the token T__63
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__63(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__63;
       
    
    // ../../model/subgoal_learning/Pddl.g:16:7: ( 'number' )
    // ../../model/subgoal_learning/Pddl.g:16:9: 'number'
    {
        MATCHS(lit_7); 
        if  (HASEXCEPTION())
        {
            goto ruleT__63Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__63Ex; /* Prevent compiler warnings */
    ruleT__63Ex: ;

}
// $ANTLR end T__63

//   Comes from: 17:7: ( ':constants' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__64
 *
 * Looks to match the characters the constitute the token T__64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__64(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__64;
       
    
    // ../../model/subgoal_learning/Pddl.g:17:7: ( ':constants' )
    // ../../model/subgoal_learning/Pddl.g:17:9: ':constants'
    {
        MATCHS(lit_8); 
        if  (HASEXCEPTION())
        {
            goto ruleT__64Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__64Ex; /* Prevent compiler warnings */
    ruleT__64Ex: ;

}
// $ANTLR end T__64

//   Comes from: 18:7: ( ':predicates' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__65
 *
 * Looks to match the characters the constitute the token T__65
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__65(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__65;
       
    
    // ../../model/subgoal_learning/Pddl.g:18:7: ( ':predicates' )
    // ../../model/subgoal_learning/Pddl.g:18:9: ':predicates'
    {
        MATCHS(lit_9); 
        if  (HASEXCEPTION())
        {
            goto ruleT__65Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__65Ex; /* Prevent compiler warnings */
    ruleT__65Ex: ;

}
// $ANTLR end T__65

//   Comes from: 19:7: ( ':constraints' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__66
 *
 * Looks to match the characters the constitute the token T__66
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__66(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__66;
       
    
    // ../../model/subgoal_learning/Pddl.g:19:7: ( ':constraints' )
    // ../../model/subgoal_learning/Pddl.g:19:9: ':constraints'
    {
        MATCHS(lit_10); 
        if  (HASEXCEPTION())
        {
            goto ruleT__66Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__66Ex; /* Prevent compiler warnings */
    ruleT__66Ex: ;

}
// $ANTLR end T__66

//   Comes from: 20:7: ( ':action' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__67
 *
 * Looks to match the characters the constitute the token T__67
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__67(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__67;
       
    
    // ../../model/subgoal_learning/Pddl.g:20:7: ( ':action' )
    // ../../model/subgoal_learning/Pddl.g:20:9: ':action'
    {
        MATCHS(lit_11); 
        if  (HASEXCEPTION())
        {
            goto ruleT__67Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__67Ex; /* Prevent compiler warnings */
    ruleT__67Ex: ;

}
// $ANTLR end T__67

//   Comes from: 21:7: ( ':parameters' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__68
 *
 * Looks to match the characters the constitute the token T__68
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__68(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__68;
       
    
    // ../../model/subgoal_learning/Pddl.g:21:7: ( ':parameters' )
    // ../../model/subgoal_learning/Pddl.g:21:9: ':parameters'
    {
        MATCHS(lit_12); 
        if  (HASEXCEPTION())
        {
            goto ruleT__68Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__68Ex; /* Prevent compiler warnings */
    ruleT__68Ex: ;

}
// $ANTLR end T__68

//   Comes from: 22:7: ( ':precondition' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__69
 *
 * Looks to match the characters the constitute the token T__69
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__69(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__69;
       
    
    // ../../model/subgoal_learning/Pddl.g:22:7: ( ':precondition' )
    // ../../model/subgoal_learning/Pddl.g:22:9: ':precondition'
    {
        MATCHS(lit_13); 
        if  (HASEXCEPTION())
        {
            goto ruleT__69Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__69Ex; /* Prevent compiler warnings */
    ruleT__69Ex: ;

}
// $ANTLR end T__69

//   Comes from: 23:7: ( ':effect' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__70
 *
 * Looks to match the characters the constitute the token T__70
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__70(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__70;
       
    
    // ../../model/subgoal_learning/Pddl.g:23:7: ( ':effect' )
    // ../../model/subgoal_learning/Pddl.g:23:9: ':effect'
    {
        MATCHS(lit_14); 
        if  (HASEXCEPTION())
        {
            goto ruleT__70Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__70Ex; /* Prevent compiler warnings */
    ruleT__70Ex: ;

}
// $ANTLR end T__70

//   Comes from: 24:7: ( 'and' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__71
 *
 * Looks to match the characters the constitute the token T__71
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__71(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__71;
       
    
    // ../../model/subgoal_learning/Pddl.g:24:7: ( 'and' )
    // ../../model/subgoal_learning/Pddl.g:24:9: 'and'
    {
        MATCHS(lit_15); 
        if  (HASEXCEPTION())
        {
            goto ruleT__71Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__71Ex; /* Prevent compiler warnings */
    ruleT__71Ex: ;

}
// $ANTLR end T__71

//   Comes from: 25:7: ( 'or' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__72
 *
 * Looks to match the characters the constitute the token T__72
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__72(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__72;
       
    
    // ../../model/subgoal_learning/Pddl.g:25:7: ( 'or' )
    // ../../model/subgoal_learning/Pddl.g:25:9: 'or'
    {
        MATCHS(lit_16); 
        if  (HASEXCEPTION())
        {
            goto ruleT__72Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__72Ex; /* Prevent compiler warnings */
    ruleT__72Ex: ;

}
// $ANTLR end T__72

//   Comes from: 26:7: ( 'not' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__73
 *
 * Looks to match the characters the constitute the token T__73
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__73(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__73;
       
    
    // ../../model/subgoal_learning/Pddl.g:26:7: ( 'not' )
    // ../../model/subgoal_learning/Pddl.g:26:9: 'not'
    {
        MATCHS(lit_17); 
        if  (HASEXCEPTION())
        {
            goto ruleT__73Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__73Ex; /* Prevent compiler warnings */
    ruleT__73Ex: ;

}
// $ANTLR end T__73

//   Comes from: 27:7: ( 'imply' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__74
 *
 * Looks to match the characters the constitute the token T__74
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__74(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__74;
       
    
    // ../../model/subgoal_learning/Pddl.g:27:7: ( 'imply' )
    // ../../model/subgoal_learning/Pddl.g:27:9: 'imply'
    {
        MATCHS(lit_18); 
        if  (HASEXCEPTION())
        {
            goto ruleT__74Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__74Ex; /* Prevent compiler warnings */
    ruleT__74Ex: ;

}
// $ANTLR end T__74

//   Comes from: 28:7: ( 'exists' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__75
 *
 * Looks to match the characters the constitute the token T__75
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__75(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__75;
       
    
    // ../../model/subgoal_learning/Pddl.g:28:7: ( 'exists' )
    // ../../model/subgoal_learning/Pddl.g:28:9: 'exists'
    {
        MATCHS(lit_19); 
        if  (HASEXCEPTION())
        {
            goto ruleT__75Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__75Ex; /* Prevent compiler warnings */
    ruleT__75Ex: ;

}
// $ANTLR end T__75

//   Comes from: 29:7: ( 'forall' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__76
 *
 * Looks to match the characters the constitute the token T__76
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__76(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__76;
       
    
    // ../../model/subgoal_learning/Pddl.g:29:7: ( 'forall' )
    // ../../model/subgoal_learning/Pddl.g:29:9: 'forall'
    {
        MATCHS(lit_20); 
        if  (HASEXCEPTION())
        {
            goto ruleT__76Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__76Ex; /* Prevent compiler warnings */
    ruleT__76Ex: ;

}
// $ANTLR end T__76

//   Comes from: 30:7: ( ':durative-action' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__77
 *
 * Looks to match the characters the constitute the token T__77
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__77(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__77;
       
    
    // ../../model/subgoal_learning/Pddl.g:30:7: ( ':durative-action' )
    // ../../model/subgoal_learning/Pddl.g:30:9: ':durative-action'
    {
        MATCHS(lit_21); 
        if  (HASEXCEPTION())
        {
            goto ruleT__77Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__77Ex; /* Prevent compiler warnings */
    ruleT__77Ex: ;

}
// $ANTLR end T__77

//   Comes from: 31:7: ( ':duration' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__78
 *
 * Looks to match the characters the constitute the token T__78
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__78(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__78;
       
    
    // ../../model/subgoal_learning/Pddl.g:31:7: ( ':duration' )
    // ../../model/subgoal_learning/Pddl.g:31:9: ':duration'
    {
        MATCHS(lit_22); 
        if  (HASEXCEPTION())
        {
            goto ruleT__78Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__78Ex; /* Prevent compiler warnings */
    ruleT__78Ex: ;

}
// $ANTLR end T__78

//   Comes from: 32:7: ( ':condition' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__79
 *
 * Looks to match the characters the constitute the token T__79
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__79(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__79;
       
    
    // ../../model/subgoal_learning/Pddl.g:32:7: ( ':condition' )
    // ../../model/subgoal_learning/Pddl.g:32:9: ':condition'
    {
        MATCHS(lit_23); 
        if  (HASEXCEPTION())
        {
            goto ruleT__79Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__79Ex; /* Prevent compiler warnings */
    ruleT__79Ex: ;

}
// $ANTLR end T__79

//   Comes from: 33:7: ( 'preference' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__80
 *
 * Looks to match the characters the constitute the token T__80
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__80(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__80;
       
    
    // ../../model/subgoal_learning/Pddl.g:33:7: ( 'preference' )
    // ../../model/subgoal_learning/Pddl.g:33:9: 'preference'
    {
        MATCHS(lit_24); 
        if  (HASEXCEPTION())
        {
            goto ruleT__80Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__80Ex; /* Prevent compiler warnings */
    ruleT__80Ex: ;

}
// $ANTLR end T__80

//   Comes from: 34:7: ( 'at' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__81
 *
 * Looks to match the characters the constitute the token T__81
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__81(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__81;
       
    
    // ../../model/subgoal_learning/Pddl.g:34:7: ( 'at' )
    // ../../model/subgoal_learning/Pddl.g:34:9: 'at'
    {
        MATCHS(lit_25); 
        if  (HASEXCEPTION())
        {
            goto ruleT__81Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__81Ex; /* Prevent compiler warnings */
    ruleT__81Ex: ;

}
// $ANTLR end T__81

//   Comes from: 35:7: ( 'over' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__82
 *
 * Looks to match the characters the constitute the token T__82
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__82(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__82;
       
    
    // ../../model/subgoal_learning/Pddl.g:35:7: ( 'over' )
    // ../../model/subgoal_learning/Pddl.g:35:9: 'over'
    {
        MATCHS(lit_26); 
        if  (HASEXCEPTION())
        {
            goto ruleT__82Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__82Ex; /* Prevent compiler warnings */
    ruleT__82Ex: ;

}
// $ANTLR end T__82

//   Comes from: 36:7: ( 'start' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__83
 *
 * Looks to match the characters the constitute the token T__83
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__83(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__83;
       
    
    // ../../model/subgoal_learning/Pddl.g:36:7: ( 'start' )
    // ../../model/subgoal_learning/Pddl.g:36:9: 'start'
    {
        MATCHS(lit_27); 
        if  (HASEXCEPTION())
        {
            goto ruleT__83Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__83Ex; /* Prevent compiler warnings */
    ruleT__83Ex: ;

}
// $ANTLR end T__83

//   Comes from: 37:7: ( 'end' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__84
 *
 * Looks to match the characters the constitute the token T__84
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__84(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__84;
       
    
    // ../../model/subgoal_learning/Pddl.g:37:7: ( 'end' )
    // ../../model/subgoal_learning/Pddl.g:37:9: 'end'
    {
        MATCHS(lit_28); 
        if  (HASEXCEPTION())
        {
            goto ruleT__84Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__84Ex; /* Prevent compiler warnings */
    ruleT__84Ex: ;

}
// $ANTLR end T__84

//   Comes from: 38:7: ( 'all' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__85
 *
 * Looks to match the characters the constitute the token T__85
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__85(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__85;
       
    
    // ../../model/subgoal_learning/Pddl.g:38:7: ( 'all' )
    // ../../model/subgoal_learning/Pddl.g:38:9: 'all'
    {
        MATCHS(lit_29); 
        if  (HASEXCEPTION())
        {
            goto ruleT__85Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__85Ex; /* Prevent compiler warnings */
    ruleT__85Ex: ;

}
// $ANTLR end T__85

//   Comes from: 39:7: ( ':derived' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__86
 *
 * Looks to match the characters the constitute the token T__86
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__86(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__86;
       
    
    // ../../model/subgoal_learning/Pddl.g:39:7: ( ':derived' )
    // ../../model/subgoal_learning/Pddl.g:39:9: ':derived'
    {
        MATCHS(lit_30); 
        if  (HASEXCEPTION())
        {
            goto ruleT__86Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__86Ex; /* Prevent compiler warnings */
    ruleT__86Ex: ;

}
// $ANTLR end T__86

//   Comes from: 40:7: ( 'when' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__87
 *
 * Looks to match the characters the constitute the token T__87
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__87(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__87;
       
    
    // ../../model/subgoal_learning/Pddl.g:40:7: ( 'when' )
    // ../../model/subgoal_learning/Pddl.g:40:9: 'when'
    {
        MATCHS(lit_31); 
        if  (HASEXCEPTION())
        {
            goto ruleT__87Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__87Ex; /* Prevent compiler warnings */
    ruleT__87Ex: ;

}
// $ANTLR end T__87

//   Comes from: 41:7: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__88
 *
 * Looks to match the characters the constitute the token T__88
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__88(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__88;
       
    
    // ../../model/subgoal_learning/Pddl.g:41:7: ( '*' )
    // ../../model/subgoal_learning/Pddl.g:41:9: '*'
    {
        MATCHC('*'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__88Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__88Ex; /* Prevent compiler warnings */
    ruleT__88Ex: ;

}
// $ANTLR end T__88

//   Comes from: 42:7: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__89
 *
 * Looks to match the characters the constitute the token T__89
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__89(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__89;
       
    
    // ../../model/subgoal_learning/Pddl.g:42:7: ( '+' )
    // ../../model/subgoal_learning/Pddl.g:42:9: '+'
    {
        MATCHC('+'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__89Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__89Ex; /* Prevent compiler warnings */
    ruleT__89Ex: ;

}
// $ANTLR end T__89

//   Comes from: 43:7: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__90
 *
 * Looks to match the characters the constitute the token T__90
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__90(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__90;
       
    
    // ../../model/subgoal_learning/Pddl.g:43:7: ( '/' )
    // ../../model/subgoal_learning/Pddl.g:43:9: '/'
    {
        MATCHC('/'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__90Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__90Ex; /* Prevent compiler warnings */
    ruleT__90Ex: ;

}
// $ANTLR end T__90

//   Comes from: 44:7: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__91
 *
 * Looks to match the characters the constitute the token T__91
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__91(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__91;
       
    
    // ../../model/subgoal_learning/Pddl.g:44:7: ( '>' )
    // ../../model/subgoal_learning/Pddl.g:44:9: '>'
    {
        MATCHC('>'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__91Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__91Ex; /* Prevent compiler warnings */
    ruleT__91Ex: ;

}
// $ANTLR end T__91

//   Comes from: 45:7: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__92
 *
 * Looks to match the characters the constitute the token T__92
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__92(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__92;
       
    
    // ../../model/subgoal_learning/Pddl.g:45:7: ( '<' )
    // ../../model/subgoal_learning/Pddl.g:45:9: '<'
    {
        MATCHC('<'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__92Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__92Ex; /* Prevent compiler warnings */
    ruleT__92Ex: ;

}
// $ANTLR end T__92

//   Comes from: 46:7: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__93
 *
 * Looks to match the characters the constitute the token T__93
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__93(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__93;
       
    
    // ../../model/subgoal_learning/Pddl.g:46:7: ( '=' )
    // ../../model/subgoal_learning/Pddl.g:46:9: '='
    {
        MATCHC('='); 
        if  (HASEXCEPTION())
        {
            goto ruleT__93Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__93Ex; /* Prevent compiler warnings */
    ruleT__93Ex: ;

}
// $ANTLR end T__93

//   Comes from: 47:7: ( '>=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__94
 *
 * Looks to match the characters the constitute the token T__94
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__94(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__94;
       
    
    // ../../model/subgoal_learning/Pddl.g:47:7: ( '>=' )
    // ../../model/subgoal_learning/Pddl.g:47:9: '>='
    {
        MATCHS(lit_32); 
        if  (HASEXCEPTION())
        {
            goto ruleT__94Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__94Ex; /* Prevent compiler warnings */
    ruleT__94Ex: ;

}
// $ANTLR end T__94

//   Comes from: 48:7: ( '<=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__95
 *
 * Looks to match the characters the constitute the token T__95
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__95(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__95;
       
    
    // ../../model/subgoal_learning/Pddl.g:48:7: ( '<=' )
    // ../../model/subgoal_learning/Pddl.g:48:9: '<='
    {
        MATCHS(lit_33); 
        if  (HASEXCEPTION())
        {
            goto ruleT__95Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__95Ex; /* Prevent compiler warnings */
    ruleT__95Ex: ;

}
// $ANTLR end T__95

//   Comes from: 49:7: ( 'assign' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__96
 *
 * Looks to match the characters the constitute the token T__96
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__96(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__96;
       
    
    // ../../model/subgoal_learning/Pddl.g:49:7: ( 'assign' )
    // ../../model/subgoal_learning/Pddl.g:49:9: 'assign'
    {
        MATCHS(lit_34); 
        if  (HASEXCEPTION())
        {
            goto ruleT__96Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__96Ex; /* Prevent compiler warnings */
    ruleT__96Ex: ;

}
// $ANTLR end T__96

//   Comes from: 50:7: ( 'scale-up' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__97
 *
 * Looks to match the characters the constitute the token T__97
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__97(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__97;
       
    
    // ../../model/subgoal_learning/Pddl.g:50:7: ( 'scale-up' )
    // ../../model/subgoal_learning/Pddl.g:50:9: 'scale-up'
    {
        MATCHS(lit_35); 
        if  (HASEXCEPTION())
        {
            goto ruleT__97Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__97Ex; /* Prevent compiler warnings */
    ruleT__97Ex: ;

}
// $ANTLR end T__97

//   Comes from: 51:7: ( 'scale-down' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__98
 *
 * Looks to match the characters the constitute the token T__98
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__98(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__98;
       
    
    // ../../model/subgoal_learning/Pddl.g:51:7: ( 'scale-down' )
    // ../../model/subgoal_learning/Pddl.g:51:9: 'scale-down'
    {
        MATCHS(lit_36); 
        if  (HASEXCEPTION())
        {
            goto ruleT__98Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__98Ex; /* Prevent compiler warnings */
    ruleT__98Ex: ;

}
// $ANTLR end T__98

//   Comes from: 52:7: ( 'increase' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__99
 *
 * Looks to match the characters the constitute the token T__99
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__99(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__99;
       
    
    // ../../model/subgoal_learning/Pddl.g:52:7: ( 'increase' )
    // ../../model/subgoal_learning/Pddl.g:52:9: 'increase'
    {
        MATCHS(lit_37); 
        if  (HASEXCEPTION())
        {
            goto ruleT__99Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__99Ex; /* Prevent compiler warnings */
    ruleT__99Ex: ;

}
// $ANTLR end T__99

//   Comes from: 53:8: ( 'decrease' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__100
 *
 * Looks to match the characters the constitute the token T__100
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__100(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__100;
       
    
    // ../../model/subgoal_learning/Pddl.g:53:8: ( 'decrease' )
    // ../../model/subgoal_learning/Pddl.g:53:10: 'decrease'
    {
        MATCHS(lit_38); 
        if  (HASEXCEPTION())
        {
            goto ruleT__100Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__100Ex; /* Prevent compiler warnings */
    ruleT__100Ex: ;

}
// $ANTLR end T__100

//   Comes from: 54:8: ( '?duration' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__101
 *
 * Looks to match the characters the constitute the token T__101
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__101(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__101;
       
    
    // ../../model/subgoal_learning/Pddl.g:54:8: ( '?duration' )
    // ../../model/subgoal_learning/Pddl.g:54:10: '?duration'
    {
        MATCHS(lit_39); 
        if  (HASEXCEPTION())
        {
            goto ruleT__101Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__101Ex; /* Prevent compiler warnings */
    ruleT__101Ex: ;

}
// $ANTLR end T__101

//   Comes from: 55:8: ( 'problem' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__102
 *
 * Looks to match the characters the constitute the token T__102
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__102(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__102;
       
    
    // ../../model/subgoal_learning/Pddl.g:55:8: ( 'problem' )
    // ../../model/subgoal_learning/Pddl.g:55:10: 'problem'
    {
        MATCHS(lit_40); 
        if  (HASEXCEPTION())
        {
            goto ruleT__102Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__102Ex; /* Prevent compiler warnings */
    ruleT__102Ex: ;

}
// $ANTLR end T__102

//   Comes from: 56:8: ( ':domain' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__103
 *
 * Looks to match the characters the constitute the token T__103
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__103(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__103;
       
    
    // ../../model/subgoal_learning/Pddl.g:56:8: ( ':domain' )
    // ../../model/subgoal_learning/Pddl.g:56:10: ':domain'
    {
        MATCHS(lit_41); 
        if  (HASEXCEPTION())
        {
            goto ruleT__103Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__103Ex; /* Prevent compiler warnings */
    ruleT__103Ex: ;

}
// $ANTLR end T__103

//   Comes from: 57:8: ( ':objects' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__104
 *
 * Looks to match the characters the constitute the token T__104
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__104(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__104;
       
    
    // ../../model/subgoal_learning/Pddl.g:57:8: ( ':objects' )
    // ../../model/subgoal_learning/Pddl.g:57:10: ':objects'
    {
        MATCHS(lit_42); 
        if  (HASEXCEPTION())
        {
            goto ruleT__104Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__104Ex; /* Prevent compiler warnings */
    ruleT__104Ex: ;

}
// $ANTLR end T__104

//   Comes from: 58:8: ( ':init' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__105
 *
 * Looks to match the characters the constitute the token T__105
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__105(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__105;
       
    
    // ../../model/subgoal_learning/Pddl.g:58:8: ( ':init' )
    // ../../model/subgoal_learning/Pddl.g:58:10: ':init'
    {
        MATCHS(lit_43); 
        if  (HASEXCEPTION())
        {
            goto ruleT__105Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__105Ex; /* Prevent compiler warnings */
    ruleT__105Ex: ;

}
// $ANTLR end T__105

//   Comes from: 59:8: ( ':goal' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__106
 *
 * Looks to match the characters the constitute the token T__106
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__106(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__106;
       
    
    // ../../model/subgoal_learning/Pddl.g:59:8: ( ':goal' )
    // ../../model/subgoal_learning/Pddl.g:59:10: ':goal'
    {
        MATCHS(lit_44); 
        if  (HASEXCEPTION())
        {
            goto ruleT__106Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__106Ex; /* Prevent compiler warnings */
    ruleT__106Ex: ;

}
// $ANTLR end T__106

//   Comes from: 60:8: ( ':metric' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__107
 *
 * Looks to match the characters the constitute the token T__107
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__107(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__107;
       
    
    // ../../model/subgoal_learning/Pddl.g:60:8: ( ':metric' )
    // ../../model/subgoal_learning/Pddl.g:60:10: ':metric'
    {
        MATCHS(lit_45); 
        if  (HASEXCEPTION())
        {
            goto ruleT__107Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__107Ex; /* Prevent compiler warnings */
    ruleT__107Ex: ;

}
// $ANTLR end T__107

//   Comes from: 61:8: ( 'minimize' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__108
 *
 * Looks to match the characters the constitute the token T__108
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__108(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__108;
       
    
    // ../../model/subgoal_learning/Pddl.g:61:8: ( 'minimize' )
    // ../../model/subgoal_learning/Pddl.g:61:10: 'minimize'
    {
        MATCHS(lit_46); 
        if  (HASEXCEPTION())
        {
            goto ruleT__108Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__108Ex; /* Prevent compiler warnings */
    ruleT__108Ex: ;

}
// $ANTLR end T__108

//   Comes from: 62:8: ( 'maximize' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__109
 *
 * Looks to match the characters the constitute the token T__109
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__109(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__109;
       
    
    // ../../model/subgoal_learning/Pddl.g:62:8: ( 'maximize' )
    // ../../model/subgoal_learning/Pddl.g:62:10: 'maximize'
    {
        MATCHS(lit_47); 
        if  (HASEXCEPTION())
        {
            goto ruleT__109Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__109Ex; /* Prevent compiler warnings */
    ruleT__109Ex: ;

}
// $ANTLR end T__109

//   Comes from: 63:8: ( 'total-time' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__110
 *
 * Looks to match the characters the constitute the token T__110
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__110(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__110;
       
    
    // ../../model/subgoal_learning/Pddl.g:63:8: ( 'total-time' )
    // ../../model/subgoal_learning/Pddl.g:63:10: 'total-time'
    {
        MATCHS(lit_48); 
        if  (HASEXCEPTION())
        {
            goto ruleT__110Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__110Ex; /* Prevent compiler warnings */
    ruleT__110Ex: ;

}
// $ANTLR end T__110

//   Comes from: 64:8: ( 'is-violated' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__111
 *
 * Looks to match the characters the constitute the token T__111
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__111(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__111;
       
    
    // ../../model/subgoal_learning/Pddl.g:64:8: ( 'is-violated' )
    // ../../model/subgoal_learning/Pddl.g:64:10: 'is-violated'
    {
        MATCHS(lit_49); 
        if  (HASEXCEPTION())
        {
            goto ruleT__111Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__111Ex; /* Prevent compiler warnings */
    ruleT__111Ex: ;

}
// $ANTLR end T__111

//   Comes from: 65:8: ( 'always' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__112
 *
 * Looks to match the characters the constitute the token T__112
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__112(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__112;
       
    
    // ../../model/subgoal_learning/Pddl.g:65:8: ( 'always' )
    // ../../model/subgoal_learning/Pddl.g:65:10: 'always'
    {
        MATCHS(lit_50); 
        if  (HASEXCEPTION())
        {
            goto ruleT__112Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__112Ex; /* Prevent compiler warnings */
    ruleT__112Ex: ;

}
// $ANTLR end T__112

//   Comes from: 66:8: ( 'sometime' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__113
 *
 * Looks to match the characters the constitute the token T__113
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__113(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__113;
       
    
    // ../../model/subgoal_learning/Pddl.g:66:8: ( 'sometime' )
    // ../../model/subgoal_learning/Pddl.g:66:10: 'sometime'
    {
        MATCHS(lit_51); 
        if  (HASEXCEPTION())
        {
            goto ruleT__113Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__113Ex; /* Prevent compiler warnings */
    ruleT__113Ex: ;

}
// $ANTLR end T__113

//   Comes from: 67:8: ( 'within' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__114
 *
 * Looks to match the characters the constitute the token T__114
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__114(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__114;
       
    
    // ../../model/subgoal_learning/Pddl.g:67:8: ( 'within' )
    // ../../model/subgoal_learning/Pddl.g:67:10: 'within'
    {
        MATCHS(lit_52); 
        if  (HASEXCEPTION())
        {
            goto ruleT__114Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__114Ex; /* Prevent compiler warnings */
    ruleT__114Ex: ;

}
// $ANTLR end T__114

//   Comes from: 68:8: ( 'at-most-once' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__115
 *
 * Looks to match the characters the constitute the token T__115
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__115(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__115;
       
    
    // ../../model/subgoal_learning/Pddl.g:68:8: ( 'at-most-once' )
    // ../../model/subgoal_learning/Pddl.g:68:10: 'at-most-once'
    {
        MATCHS(lit_53); 
        if  (HASEXCEPTION())
        {
            goto ruleT__115Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__115Ex; /* Prevent compiler warnings */
    ruleT__115Ex: ;

}
// $ANTLR end T__115

//   Comes from: 69:8: ( 'sometime-after' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__116
 *
 * Looks to match the characters the constitute the token T__116
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__116(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__116;
       
    
    // ../../model/subgoal_learning/Pddl.g:69:8: ( 'sometime-after' )
    // ../../model/subgoal_learning/Pddl.g:69:10: 'sometime-after'
    {
        MATCHS(lit_54); 
        if  (HASEXCEPTION())
        {
            goto ruleT__116Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__116Ex; /* Prevent compiler warnings */
    ruleT__116Ex: ;

}
// $ANTLR end T__116

//   Comes from: 70:8: ( 'sometime-before' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__117
 *
 * Looks to match the characters the constitute the token T__117
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__117(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__117;
       
    
    // ../../model/subgoal_learning/Pddl.g:70:8: ( 'sometime-before' )
    // ../../model/subgoal_learning/Pddl.g:70:10: 'sometime-before'
    {
        MATCHS(lit_55); 
        if  (HASEXCEPTION())
        {
            goto ruleT__117Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__117Ex; /* Prevent compiler warnings */
    ruleT__117Ex: ;

}
// $ANTLR end T__117

//   Comes from: 71:8: ( 'always-within' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__118
 *
 * Looks to match the characters the constitute the token T__118
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__118(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__118;
       
    
    // ../../model/subgoal_learning/Pddl.g:71:8: ( 'always-within' )
    // ../../model/subgoal_learning/Pddl.g:71:10: 'always-within'
    {
        MATCHS(lit_56); 
        if  (HASEXCEPTION())
        {
            goto ruleT__118Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__118Ex; /* Prevent compiler warnings */
    ruleT__118Ex: ;

}
// $ANTLR end T__118

//   Comes from: 72:8: ( 'hold-during' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__119
 *
 * Looks to match the characters the constitute the token T__119
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__119(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__119;
       
    
    // ../../model/subgoal_learning/Pddl.g:72:8: ( 'hold-during' )
    // ../../model/subgoal_learning/Pddl.g:72:10: 'hold-during'
    {
        MATCHS(lit_57); 
        if  (HASEXCEPTION())
        {
            goto ruleT__119Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__119Ex; /* Prevent compiler warnings */
    ruleT__119Ex: ;

}
// $ANTLR end T__119

//   Comes from: 73:8: ( 'hold-after' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__120
 *
 * Looks to match the characters the constitute the token T__120
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__120(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__120;
       
    
    // ../../model/subgoal_learning/Pddl.g:73:8: ( 'hold-after' )
    // ../../model/subgoal_learning/Pddl.g:73:10: 'hold-after'
    {
        MATCHS(lit_58); 
        if  (HASEXCEPTION())
        {
            goto ruleT__120Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__120Ex; /* Prevent compiler warnings */
    ruleT__120Ex: ;

}
// $ANTLR end T__120

//   Comes from: 510:5: ( ':strips' | ':typing' | ':negative-preconditions' | ':disjunctive-preconditions' | ':equality' | ':existential-preconditions' | ':universal-preconditions' | ':quantified-preconditions' | ':conditional-effects' | ':fluents' | ':adl' | ':durative-actions' | ':derived-predicates' | ':timed-initial-literals' | ':preferences' | ':constraints' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REQUIRE_KEY
 *
 * Looks to match the characters the constitute the token REQUIRE_KEY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREQUIRE_KEY(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REQUIRE_KEY;
       
    
    {
        //  ../../model/subgoal_learning/Pddl.g:510:5: ( ':strips' | ':typing' | ':negative-preconditions' | ':disjunctive-preconditions' | ':equality' | ':existential-preconditions' | ':universal-preconditions' | ':quantified-preconditions' | ':conditional-effects' | ':fluents' | ':adl' | ':durative-actions' | ':derived-predicates' | ':timed-initial-literals' | ':preferences' | ':constraints' )
        
        ANTLR3_UINT32 alt1;

        alt1=16;

        alt1 = cdfa1.predict(ctx, RECOGNIZER, ISTREAM, &cdfa1);
        if  (HASEXCEPTION())
        {
            goto ruleREQUIRE_KEYEx;
        }

        switch (alt1) 
        {
    	case 1:
    	    // ../../model/subgoal_learning/Pddl.g:510:7: ':strips'
    	    {
    	        MATCHS(lit_59); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // ../../model/subgoal_learning/Pddl.g:511:7: ':typing'
    	    {
    	        MATCHS(lit_60); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // ../../model/subgoal_learning/Pddl.g:512:7: ':negative-preconditions'
    	    {
    	        MATCHS(lit_61); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // ../../model/subgoal_learning/Pddl.g:513:7: ':disjunctive-preconditions'
    	    {
    	        MATCHS(lit_62); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // ../../model/subgoal_learning/Pddl.g:514:7: ':equality'
    	    {
    	        MATCHS(lit_63); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // ../../model/subgoal_learning/Pddl.g:515:7: ':existential-preconditions'
    	    {
    	        MATCHS(lit_64); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // ../../model/subgoal_learning/Pddl.g:516:7: ':universal-preconditions'
    	    {
    	        MATCHS(lit_65); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // ../../model/subgoal_learning/Pddl.g:517:7: ':quantified-preconditions'
    	    {
    	        MATCHS(lit_66); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // ../../model/subgoal_learning/Pddl.g:518:7: ':conditional-effects'
    	    {
    	        MATCHS(lit_67); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // ../../model/subgoal_learning/Pddl.g:519:7: ':fluents'
    	    {
    	        MATCHS(lit_68); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // ../../model/subgoal_learning/Pddl.g:520:7: ':adl'
    	    {
    	        MATCHS(lit_69); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // ../../model/subgoal_learning/Pddl.g:521:7: ':durative-actions'
    	    {
    	        MATCHS(lit_70); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // ../../model/subgoal_learning/Pddl.g:522:7: ':derived-predicates'
    	    {
    	        MATCHS(lit_71); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // ../../model/subgoal_learning/Pddl.g:523:7: ':timed-initial-literals'
    	    {
    	        MATCHS(lit_72); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // ../../model/subgoal_learning/Pddl.g:524:7: ':preferences'
    	    {
    	        MATCHS(lit_73); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // ../../model/subgoal_learning/Pddl.g:525:7: ':constraints'
    	    {
    	        MATCHS(lit_10); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleREQUIRE_KEYEx;
    	        }



    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleREQUIRE_KEYEx; /* Prevent compiler warnings */
    ruleREQUIRE_KEYEx: ;

}
// $ANTLR end REQUIRE_KEY

//   Comes from: 529:5: ( LETTER ( ANY_CHAR )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NAME
 *
 * Looks to match the characters the constitute the token NAME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNAME(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NAME;
       
    
    // ../../model/subgoal_learning/Pddl.g:529:5: ( LETTER ( ANY_CHAR )* )
    // ../../model/subgoal_learning/Pddl.g:529:10: LETTER ( ANY_CHAR )*
    {
        /* 529:10: LETTER ( ANY_CHAR )* */
        mLETTER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleNAMEEx;
        }


        // ../../model/subgoal_learning/Pddl.g:529:17: ( ANY_CHAR )*

        for (;;)
        {
            int alt2=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA2_0 = LA(1);
                if ( (LA2_0 == '-' || ((LA2_0 >= '0') && (LA2_0 <= '9')) || ((LA2_0 >= 'A') && (LA2_0 <= 'Z')) || LA2_0 == '_' || ((LA2_0 >= 'a') && (LA2_0 <= 'z'))) ) 
                {
                    alt2=1;
                }

            }
            switch (alt2) 
            {
        	case 1:
        	    // ../../model/subgoal_learning/Pddl.g:529:17: ANY_CHAR
        	    {
        	        /* 529:17: ANY_CHAR */
        	        mANY_CHAR(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleNAMEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop2;	/* break out of the loop */
        	    break;
            }
        }
        loop2: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNAMEEx; /* Prevent compiler warnings */
    ruleNAMEEx: ;

}
// $ANTLR end NAME

//   Comes from: 531:16: ( 'a' .. 'z' | 'A' .. 'Z' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LETTER
 *
 * Looks to match the characters the constitute the token LETTER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLETTER(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // ../../model/subgoal_learning/Pddl.g:531:16: ( 'a' .. 'z' | 'A' .. 'Z' )
    // ../../model/subgoal_learning/Pddl.g:
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleLETTEREx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleLETTEREx; /* Prevent compiler warnings */
    ruleLETTEREx: ;

}
// $ANTLR end LETTER

//   Comes from: 533:18: ( LETTER | '0' .. '9' | '-' | '_' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ANY_CHAR
 *
 * Looks to match the characters the constitute the token ANY_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mANY_CHAR(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // ../../model/subgoal_learning/Pddl.g:533:18: ( LETTER | '0' .. '9' | '-' | '_' )
    // ../../model/subgoal_learning/Pddl.g:
    {
        if ( LA(1) == '-' || ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleANY_CHAREx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleANY_CHAREx; /* Prevent compiler warnings */
    ruleANY_CHAREx: ;

}
// $ANTLR end ANY_CHAR

//   Comes from: 535:10: ( '?' LETTER ( ANY_CHAR )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start VARIABLE
 *
 * Looks to match the characters the constitute the token VARIABLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mVARIABLE(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = VARIABLE;
       
    
    // ../../model/subgoal_learning/Pddl.g:535:10: ( '?' LETTER ( ANY_CHAR )* )
    // ../../model/subgoal_learning/Pddl.g:535:12: '?' LETTER ( ANY_CHAR )*
    {
        MATCHC('?'); 
        if  (HASEXCEPTION())
        {
            goto ruleVARIABLEEx;
        }

        /* 535:12: '?' LETTER ( ANY_CHAR )* */
        mLETTER(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleVARIABLEEx;
        }


        // ../../model/subgoal_learning/Pddl.g:535:23: ( ANY_CHAR )*

        for (;;)
        {
            int alt3=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA3_0 = LA(1);
                if ( (LA3_0 == '-' || ((LA3_0 >= '0') && (LA3_0 <= '9')) || ((LA3_0 >= 'A') && (LA3_0 <= 'Z')) || LA3_0 == '_' || ((LA3_0 >= 'a') && (LA3_0 <= 'z'))) ) 
                {
                    alt3=1;
                }

            }
            switch (alt3) 
            {
        	case 1:
        	    // ../../model/subgoal_learning/Pddl.g:535:23: ANY_CHAR
        	    {
        	        /* 535:23: ANY_CHAR */
        	        mANY_CHAR(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleVARIABLEEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop3;	/* break out of the loop */
        	    break;
            }
        }
        loop3: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleVARIABLEEx; /* Prevent compiler warnings */
    ruleVARIABLEEx: ;

}
// $ANTLR end VARIABLE

//   Comes from: 537:8: ( ( DIGIT )+ ( '.' ( DIGIT )+ )? )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NUMBER
 *
 * Looks to match the characters the constitute the token NUMBER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNUMBER(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NUMBER;
       
    
    // ../../model/subgoal_learning/Pddl.g:537:8: ( ( DIGIT )+ ( '.' ( DIGIT )+ )? )
    // ../../model/subgoal_learning/Pddl.g:537:10: ( DIGIT )+ ( '.' ( DIGIT )+ )?
    {
        // ../../model/subgoal_learning/Pddl.g:537:10: ( DIGIT )+
        {
            int cnt4=0;

            for (;;)
            {
                int alt4=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA4_0 = LA(1);
        	    if ( (((LA4_0 >= '0') && (LA4_0 <= '9'))) ) 
        	    {
        	        alt4=1;
        	    }

        	}
        	switch (alt4) 
        	{
        	    case 1:
        	        // ../../model/subgoal_learning/Pddl.g:537:10: DIGIT
        	        {
        	            /* 537:10: DIGIT */
        	            mDIGIT(ctx ); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleNUMBEREx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt4 >= 1 )
        		{
        		    goto loop4;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleNUMBEREx;
        	}
        	cnt4++;
            }
            loop4: ;	/* Jump to here if this rule does not match */
        }

        // ../../model/subgoal_learning/Pddl.g:537:17: ( '.' ( DIGIT )+ )?
        {
            int alt6=2;
            {
                int LA6_0 = LA(1);
                if ( (LA6_0 == '.') ) 
                {
                    alt6=1;
                }
            }
            switch (alt6) 
            {
        	case 1:
        	    // ../../model/subgoal_learning/Pddl.g:537:18: '.' ( DIGIT )+
        	    {
        	        MATCHC('.'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleNUMBEREx;
        	        }

        	        // ../../model/subgoal_learning/Pddl.g:537:22: ( DIGIT )+
        	        {
        	            int cnt5=0;

        	            for (;;)
        	            {
        	                int alt5=2;
        	        	{
        	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	        	    */
        	        	    int LA5_0 = LA(1);
        	        	    if ( (((LA5_0 >= '0') && (LA5_0 <= '9'))) ) 
        	        	    {
        	        	        alt5=1;
        	        	    }

        	        	}
        	        	switch (alt5) 
        	        	{
        	        	    case 1:
        	        	        // ../../model/subgoal_learning/Pddl.g:537:22: DIGIT
        	        	        {
        	        	            /* 537:22: DIGIT */
        	        	            mDIGIT(ctx ); 
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto ruleNUMBEREx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:
        	        	    
        	        		if ( cnt5 >= 1 )
        	        		{
        	        		    goto loop5;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto ruleNUMBEREx;
        	        	}
        	        	cnt5++;
        	            }
        	            loop5: ;	/* Jump to here if this rule does not match */
        	        }

        	    }
        	    break;

            }
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNUMBEREx; /* Prevent compiler warnings */
    ruleNUMBEREx: ;

}
// $ANTLR end NUMBER

//   Comes from: 539:15: ( '0' .. '9' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIGIT
 *
 * Looks to match the characters the constitute the token DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIGIT(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // ../../model/subgoal_learning/Pddl.g:539:15: ( '0' .. '9' )
    // ../../model/subgoal_learning/Pddl.g:539:17: '0' .. '9'
    {
        MATCHRANGE('0', '9'); 
        if  (HASEXCEPTION())
        {
            goto ruleDIGITEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleDIGITEx; /* Prevent compiler warnings */
    ruleDIGITEx: ;

}
// $ANTLR end DIGIT

//   Comes from: 542:5: ( ';' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LINE_COMMENT
 *
 * Looks to match the characters the constitute the token LINE_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLINE_COMMENT(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LINE_COMMENT;
       
    
    // ../../model/subgoal_learning/Pddl.g:542:5: ( ';' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
    // ../../model/subgoal_learning/Pddl.g:542:7: ';' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    {
        MATCHC(';'); 
        if  (HASEXCEPTION())
        {
            goto ruleLINE_COMMENTEx;
        }


        // ../../model/subgoal_learning/Pddl.g:542:11: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt7=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA7_0 = LA(1);
                if ( (((LA7_0 >= 0x0000) && (LA7_0 <= '\t')) || ((LA7_0 >= 0x000B) && (LA7_0 <= '\f')) || ((LA7_0 >= 0x000E) && (LA7_0 <= 0xFFFF))) ) 
                {
                    alt7=1;
                }

            }
            switch (alt7) 
            {
        	case 1:
        	    // ../../model/subgoal_learning/Pddl.g:542:11: ~ ( '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleLINE_COMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop7;	/* break out of the loop */
        	    break;
            }
        }
        loop7: ; /* Jump out to here if this rule does not match */


        // ../../model/subgoal_learning/Pddl.g:542:25: ( '\\r' )?
        {
            int alt8=2;
            {
                int LA8_0 = LA(1);
                if ( (LA8_0 == '\r') ) 
                {
                    alt8=1;
                }
            }
            switch (alt8) 
            {
        	case 1:
        	    // ../../model/subgoal_learning/Pddl.g:542:25: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleLINE_COMMENTEx;
        	        }


        	    }
        	    break;

            }
        }
        MATCHC('\n'); 
        if  (HASEXCEPTION())
        {
            goto ruleLINE_COMMENTEx;
        }

        {
             LEXSTATE->channel = HIDDEN; 
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLINE_COMMENTEx; /* Prevent compiler warnings */
    ruleLINE_COMMENTEx: ;

}
// $ANTLR end LINE_COMMENT

//   Comes from: 546:5: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHITESPACE
 *
 * Looks to match the characters the constitute the token WHITESPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHITESPACE(pPddlLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHITESPACE;
       
    
    // ../../model/subgoal_learning/Pddl.g:546:5: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
    // ../../model/subgoal_learning/Pddl.g:546:9: ( ' ' | '\\t' | '\\r' | '\\n' )+
    {
        // ../../model/subgoal_learning/Pddl.g:546:9: ( ' ' | '\\t' | '\\r' | '\\n' )+
        {
            int cnt9=0;

            for (;;)
            {
                int alt9=2;
        	{
        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
        	    */
        	    int LA9_0 = LA(1);
        	    if ( (((LA9_0 >= '\t') && (LA9_0 <= '\n')) || LA9_0 == '\r' || LA9_0 == ' ') ) 
        	    {
        	        alt9=1;
        	    }

        	}
        	switch (alt9) 
        	{
        	    case 1:
        	        // ../../model/subgoal_learning/Pddl.g:
        	        {
        	            if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || LA(1) == '\r' || LA(1) == ' ' )
        	            {
        	                CONSUME();

        	            }
        	            else 
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleWHITESPACEEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt9 >= 1 )
        		{
        		    goto loop9;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleWHITESPACEEx;
        	}
        	cnt9++;
            }
            loop9: ;	/* Jump to here if this rule does not match */
        }
        {
             LEXSTATE->channel = HIDDEN; 
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWHITESPACEEx; /* Prevent compiler warnings */
    ruleWHITESPACEEx: ;

}
// $ANTLR end WHITESPACE

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pPddlLexer ctx)
{
    {
        //  ../../model/subgoal_learning/Pddl.g:1:8: ( T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | T__94 | T__95 | T__96 | T__97 | T__98 | T__99 | T__100 | T__101 | T__102 | T__103 | T__104 | T__105 | T__106 | T__107 | T__108 | T__109 | T__110 | T__111 | T__112 | T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | REQUIRE_KEY | NAME | VARIABLE | NUMBER | LINE_COMMENT | WHITESPACE )
        
        ANTLR3_UINT32 alt10;

        alt10=73;

        alt10 = cdfa10.predict(ctx, RECOGNIZER, ISTREAM, &cdfa10);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }

        switch (alt10) 
        {
    	case 1:
    	    // ../../model/subgoal_learning/Pddl.g:1:10: T__54
    	    {
    	        /* 1:10: T__54 */
    	        mT__54(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // ../../model/subgoal_learning/Pddl.g:1:16: T__55
    	    {
    	        /* 1:16: T__55 */
    	        mT__55(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // ../../model/subgoal_learning/Pddl.g:1:22: T__56
    	    {
    	        /* 1:22: T__56 */
    	        mT__56(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // ../../model/subgoal_learning/Pddl.g:1:28: T__57
    	    {
    	        /* 1:28: T__57 */
    	        mT__57(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 5:
    	    // ../../model/subgoal_learning/Pddl.g:1:34: T__58
    	    {
    	        /* 1:34: T__58 */
    	        mT__58(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 6:
    	    // ../../model/subgoal_learning/Pddl.g:1:40: T__59
    	    {
    	        /* 1:40: T__59 */
    	        mT__59(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 7:
    	    // ../../model/subgoal_learning/Pddl.g:1:46: T__60
    	    {
    	        /* 1:46: T__60 */
    	        mT__60(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 8:
    	    // ../../model/subgoal_learning/Pddl.g:1:52: T__61
    	    {
    	        /* 1:52: T__61 */
    	        mT__61(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 9:
    	    // ../../model/subgoal_learning/Pddl.g:1:58: T__62
    	    {
    	        /* 1:58: T__62 */
    	        mT__62(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 10:
    	    // ../../model/subgoal_learning/Pddl.g:1:64: T__63
    	    {
    	        /* 1:64: T__63 */
    	        mT__63(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 11:
    	    // ../../model/subgoal_learning/Pddl.g:1:70: T__64
    	    {
    	        /* 1:70: T__64 */
    	        mT__64(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 12:
    	    // ../../model/subgoal_learning/Pddl.g:1:76: T__65
    	    {
    	        /* 1:76: T__65 */
    	        mT__65(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 13:
    	    // ../../model/subgoal_learning/Pddl.g:1:82: T__66
    	    {
    	        /* 1:82: T__66 */
    	        mT__66(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 14:
    	    // ../../model/subgoal_learning/Pddl.g:1:88: T__67
    	    {
    	        /* 1:88: T__67 */
    	        mT__67(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 15:
    	    // ../../model/subgoal_learning/Pddl.g:1:94: T__68
    	    {
    	        /* 1:94: T__68 */
    	        mT__68(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 16:
    	    // ../../model/subgoal_learning/Pddl.g:1:100: T__69
    	    {
    	        /* 1:100: T__69 */
    	        mT__69(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 17:
    	    // ../../model/subgoal_learning/Pddl.g:1:106: T__70
    	    {
    	        /* 1:106: T__70 */
    	        mT__70(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 18:
    	    // ../../model/subgoal_learning/Pddl.g:1:112: T__71
    	    {
    	        /* 1:112: T__71 */
    	        mT__71(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 19:
    	    // ../../model/subgoal_learning/Pddl.g:1:118: T__72
    	    {
    	        /* 1:118: T__72 */
    	        mT__72(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 20:
    	    // ../../model/subgoal_learning/Pddl.g:1:124: T__73
    	    {
    	        /* 1:124: T__73 */
    	        mT__73(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 21:
    	    // ../../model/subgoal_learning/Pddl.g:1:130: T__74
    	    {
    	        /* 1:130: T__74 */
    	        mT__74(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 22:
    	    // ../../model/subgoal_learning/Pddl.g:1:136: T__75
    	    {
    	        /* 1:136: T__75 */
    	        mT__75(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 23:
    	    // ../../model/subgoal_learning/Pddl.g:1:142: T__76
    	    {
    	        /* 1:142: T__76 */
    	        mT__76(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 24:
    	    // ../../model/subgoal_learning/Pddl.g:1:148: T__77
    	    {
    	        /* 1:148: T__77 */
    	        mT__77(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 25:
    	    // ../../model/subgoal_learning/Pddl.g:1:154: T__78
    	    {
    	        /* 1:154: T__78 */
    	        mT__78(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 26:
    	    // ../../model/subgoal_learning/Pddl.g:1:160: T__79
    	    {
    	        /* 1:160: T__79 */
    	        mT__79(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 27:
    	    // ../../model/subgoal_learning/Pddl.g:1:166: T__80
    	    {
    	        /* 1:166: T__80 */
    	        mT__80(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 28:
    	    // ../../model/subgoal_learning/Pddl.g:1:172: T__81
    	    {
    	        /* 1:172: T__81 */
    	        mT__81(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 29:
    	    // ../../model/subgoal_learning/Pddl.g:1:178: T__82
    	    {
    	        /* 1:178: T__82 */
    	        mT__82(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 30:
    	    // ../../model/subgoal_learning/Pddl.g:1:184: T__83
    	    {
    	        /* 1:184: T__83 */
    	        mT__83(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 31:
    	    // ../../model/subgoal_learning/Pddl.g:1:190: T__84
    	    {
    	        /* 1:190: T__84 */
    	        mT__84(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 32:
    	    // ../../model/subgoal_learning/Pddl.g:1:196: T__85
    	    {
    	        /* 1:196: T__85 */
    	        mT__85(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 33:
    	    // ../../model/subgoal_learning/Pddl.g:1:202: T__86
    	    {
    	        /* 1:202: T__86 */
    	        mT__86(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 34:
    	    // ../../model/subgoal_learning/Pddl.g:1:208: T__87
    	    {
    	        /* 1:208: T__87 */
    	        mT__87(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 35:
    	    // ../../model/subgoal_learning/Pddl.g:1:214: T__88
    	    {
    	        /* 1:214: T__88 */
    	        mT__88(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 36:
    	    // ../../model/subgoal_learning/Pddl.g:1:220: T__89
    	    {
    	        /* 1:220: T__89 */
    	        mT__89(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 37:
    	    // ../../model/subgoal_learning/Pddl.g:1:226: T__90
    	    {
    	        /* 1:226: T__90 */
    	        mT__90(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 38:
    	    // ../../model/subgoal_learning/Pddl.g:1:232: T__91
    	    {
    	        /* 1:232: T__91 */
    	        mT__91(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 39:
    	    // ../../model/subgoal_learning/Pddl.g:1:238: T__92
    	    {
    	        /* 1:238: T__92 */
    	        mT__92(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 40:
    	    // ../../model/subgoal_learning/Pddl.g:1:244: T__93
    	    {
    	        /* 1:244: T__93 */
    	        mT__93(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 41:
    	    // ../../model/subgoal_learning/Pddl.g:1:250: T__94
    	    {
    	        /* 1:250: T__94 */
    	        mT__94(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 42:
    	    // ../../model/subgoal_learning/Pddl.g:1:256: T__95
    	    {
    	        /* 1:256: T__95 */
    	        mT__95(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 43:
    	    // ../../model/subgoal_learning/Pddl.g:1:262: T__96
    	    {
    	        /* 1:262: T__96 */
    	        mT__96(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 44:
    	    // ../../model/subgoal_learning/Pddl.g:1:268: T__97
    	    {
    	        /* 1:268: T__97 */
    	        mT__97(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 45:
    	    // ../../model/subgoal_learning/Pddl.g:1:274: T__98
    	    {
    	        /* 1:274: T__98 */
    	        mT__98(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 46:
    	    // ../../model/subgoal_learning/Pddl.g:1:280: T__99
    	    {
    	        /* 1:280: T__99 */
    	        mT__99(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 47:
    	    // ../../model/subgoal_learning/Pddl.g:1:286: T__100
    	    {
    	        /* 1:286: T__100 */
    	        mT__100(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 48:
    	    // ../../model/subgoal_learning/Pddl.g:1:293: T__101
    	    {
    	        /* 1:293: T__101 */
    	        mT__101(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 49:
    	    // ../../model/subgoal_learning/Pddl.g:1:300: T__102
    	    {
    	        /* 1:300: T__102 */
    	        mT__102(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 50:
    	    // ../../model/subgoal_learning/Pddl.g:1:307: T__103
    	    {
    	        /* 1:307: T__103 */
    	        mT__103(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 51:
    	    // ../../model/subgoal_learning/Pddl.g:1:314: T__104
    	    {
    	        /* 1:314: T__104 */
    	        mT__104(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 52:
    	    // ../../model/subgoal_learning/Pddl.g:1:321: T__105
    	    {
    	        /* 1:321: T__105 */
    	        mT__105(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 53:
    	    // ../../model/subgoal_learning/Pddl.g:1:328: T__106
    	    {
    	        /* 1:328: T__106 */
    	        mT__106(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 54:
    	    // ../../model/subgoal_learning/Pddl.g:1:335: T__107
    	    {
    	        /* 1:335: T__107 */
    	        mT__107(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 55:
    	    // ../../model/subgoal_learning/Pddl.g:1:342: T__108
    	    {
    	        /* 1:342: T__108 */
    	        mT__108(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 56:
    	    // ../../model/subgoal_learning/Pddl.g:1:349: T__109
    	    {
    	        /* 1:349: T__109 */
    	        mT__109(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 57:
    	    // ../../model/subgoal_learning/Pddl.g:1:356: T__110
    	    {
    	        /* 1:356: T__110 */
    	        mT__110(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 58:
    	    // ../../model/subgoal_learning/Pddl.g:1:363: T__111
    	    {
    	        /* 1:363: T__111 */
    	        mT__111(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 59:
    	    // ../../model/subgoal_learning/Pddl.g:1:370: T__112
    	    {
    	        /* 1:370: T__112 */
    	        mT__112(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 60:
    	    // ../../model/subgoal_learning/Pddl.g:1:377: T__113
    	    {
    	        /* 1:377: T__113 */
    	        mT__113(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 61:
    	    // ../../model/subgoal_learning/Pddl.g:1:384: T__114
    	    {
    	        /* 1:384: T__114 */
    	        mT__114(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 62:
    	    // ../../model/subgoal_learning/Pddl.g:1:391: T__115
    	    {
    	        /* 1:391: T__115 */
    	        mT__115(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 63:
    	    // ../../model/subgoal_learning/Pddl.g:1:398: T__116
    	    {
    	        /* 1:398: T__116 */
    	        mT__116(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 64:
    	    // ../../model/subgoal_learning/Pddl.g:1:405: T__117
    	    {
    	        /* 1:405: T__117 */
    	        mT__117(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 65:
    	    // ../../model/subgoal_learning/Pddl.g:1:412: T__118
    	    {
    	        /* 1:412: T__118 */
    	        mT__118(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 66:
    	    // ../../model/subgoal_learning/Pddl.g:1:419: T__119
    	    {
    	        /* 1:419: T__119 */
    	        mT__119(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 67:
    	    // ../../model/subgoal_learning/Pddl.g:1:426: T__120
    	    {
    	        /* 1:426: T__120 */
    	        mT__120(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 68:
    	    // ../../model/subgoal_learning/Pddl.g:1:433: REQUIRE_KEY
    	    {
    	        /* 1:433: REQUIRE_KEY */
    	        mREQUIRE_KEY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 69:
    	    // ../../model/subgoal_learning/Pddl.g:1:445: NAME
    	    {
    	        /* 1:445: NAME */
    	        mNAME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 70:
    	    // ../../model/subgoal_learning/Pddl.g:1:450: VARIABLE
    	    {
    	        /* 1:450: VARIABLE */
    	        mVARIABLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 71:
    	    // ../../model/subgoal_learning/Pddl.g:1:459: NUMBER
    	    {
    	        /* 1:459: NUMBER */
    	        mNUMBER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 72:
    	    // ../../model/subgoal_learning/Pddl.g:1:466: LINE_COMMENT
    	    {
    	        /* 1:466: LINE_COMMENT */
    	        mLINE_COMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 73:
    	    // ../../model/subgoal_learning/Pddl.g:1:479: WHITESPACE
    	    {
    	        /* 1:479: WHITESPACE */
    	        mWHITESPACE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 

#pragma GCC diagnostic pop

/* End of code
 * =============================================================================
 */
