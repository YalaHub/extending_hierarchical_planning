#include <iostream>
#include <fstream>
using namespace std;


void DumpSource (void)
{
	{
		ofstream file ("Feature.cpp", ios_base::out);
		file << "#include <assert.h>\n";
		file << "#include <math.h>\n";
		file << "#include <nlp_macros.h>\n";
		file << "#include <nlp_config.h>\n";
		file << "#include <nlp_filesystem.h>\n";
		file << "#include \"Feature.h\"\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "FeatureSpace::FeatureSpace (void)\n";
		file << "{\n";
		file << "	i_BagOfWordsOffset = 0;\n";
		file << "	i_MaxIndex = 0;\n";
		file << "	pthread_rwlock_init (&rwl_IndexMap, NULL);\n";
		file << "}\n";
		file << "\n";
		file << "FeatureSpace::~FeatureSpace (void)\n";
		file << "{\n";
		file << "	map_FeatureValueToIndex.clear ();\n";
		file << "	pthread_rwlock_destroy (&rwl_IndexMap);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int FeatureSpace::GetFeatureIndex (const String& _rName, bool _bCheckExists)\n";
		file << "{\n";
		file << "	pthread_rwlock_rdlock (&rwl_IndexMap);\n";
		file << "\n";
		file << "	FeatureValueToIndex_map_t::iterator	ite;\n";
		file << "	ite = map_FeatureValueToIndex.find (_rName);\n";
		file << "	if (map_FeatureValueToIndex.end () != ite)\n";
		file << "	{\n";
		file << "		pthread_rwlock_unlock (&rwl_IndexMap);\n";
		file << "		return ite->second;\n";
		file << "	}\n";
		file << "	pthread_rwlock_unlock (&rwl_IndexMap);\n";
		file << "    if (true == _bCheckExists)\n";
		file << "		return 0;\n";
		file << "\n";
		file << "\n";
		file << "	pthread_rwlock_wrlock (&rwl_IndexMap);\n";
		file << "	int iIndex = map_FeatureValueToIndex.size ()\n";
		file << "					+ i_BagOfWordsOffset;\n";
		file << "	if (i_MaxIndex < iIndex)\n";
		file << "		i_MaxIndex = iIndex;\n";
		file << "\n";
		file << "	map_FeatureValueToIndex.insert (make_pair (_rName, iIndex));\n";
		file << "	map_IndexToFeatureValue.insert (make_pair (iIndex, _rName));\n";
		file << "	pthread_rwlock_unlock (&rwl_IndexMap);\n";
		file << "	return iIndex;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "String FeatureSpace::GetFeatureString(int _iIndex) const\n";
		file << "{\n";
		file << "    return map_IndexToFeatureValue.find(_iIndex)->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void FeatureSpace::SetBagOfWordsOffset (int _iOffset)\n";
		file << "{\n";
		file << "	assert ((0 == i_BagOfWordsOffset) || (i_BagOfWordsOffset == _iOffset));\n";
		file << "	i_BagOfWordsOffset = _iOffset;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool FeatureSpace::SaveFeatureMapping (String _sName)\n";
		file << "{\n";
		file << "	File file;\n";
		file << "	if (false == file.Open((config)(_sName + \":feature_mapping_file\"), ios_base::out))\n";
		file << "		return false;\n";
		file << "\n";
		file << "	ITERATE (FeatureValueToIndex_map_t, map_FeatureValueToIndex, ite)\n";
		file << "		file << ite->second << '\\x01' << ite->first << endl;\n";
		file << "\n";
		file << "	file.Close ();\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool FeatureSpace::LoadFeatureMapping (String _sName)\n";
		file << "{\n";
		file << "	String_dq_t dqLines;\n";
		file << "	if (false == File::ReadLines ((config)(_sName + \":feature_mapping_file\"), dqLines))\n";
		file << "		return false;\n";
		file << "\n";
		file << "	map_FeatureValueToIndex.clear ();\n";
		file << "	ITERATE (String_dq_t, dqLines, ite)\n";
		file << "	{\n";
		file << "		String_dq_t dqValues;\n";
		file << "		ite->Split (dqValues, '\\x01');\n";
		file << "		map_FeatureValueToIndex.insert (make_pair (dqValues [1], (int)dqValues [0]));\n";
		file << "	}\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Features::Features (void)\n";
		file << "{\n";
		file << "	i_Current = 0;\n";
		file << "    i_MaxSize = 0;\n";
		file << "}\n";
		file << "\n";
		file << "Features::Features (const Features& _rFeatures)\n";
		file << "{\n";
		file << "	vec_Indices.Copy (_rFeatures.vec_Indices);\n";
		file << "	vec_Features.Copy (_rFeatures.vec_Features);\n";
		file << "	i_Current = _rFeatures.i_Current;\n";
		file << "	#ifndef NDEBUG\n";
		file << "	set_Indices = _rFeatures.set_Indices;\n";
		file << "	#endif\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "Features::~Features (void)\n";
		file << "{\n";
		file << "	i_Current = 0xDEADBEEF + 1;\n";
		file << "	i_MaxSize = 0xDEADBEEF;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::SetSize (int _iSize)\n";
		file << "{\n";
		file << "	assert (0 == i_Current);\n";
		file << "\n";
		file << "	vec_Indices.Reserve (_iSize);\n";
		file << "	vec_Features.Reserve (_iSize);\n";
		file << "	i_MaxSize = _iSize;\n";
		file << "}\n";
		file << "\n";
		file << "//\n";
		file << "void Features::IncreaseSizeBy (int _iSize)\n";
		file << "{\n";
		file << "    //NK: using resize here because Branvan's Vector class doesn't allow reserve to resize\n";
		file << "	vec_Indices.Resize (vec_Indices.Size() + _iSize);\n";
		file << "	vec_Features.Resize (vec_Features.Size() + _iSize);\n";
		file << "	i_MaxSize += _iSize;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Features& Features::operator= (const Features& _rFeatures)\n";
		file << "{\n";
		file << "	vec_Indices.Copy (_rFeatures.vec_Indices);\n";
		file << "	vec_Features.Copy (_rFeatures.vec_Features);\n";
		file << "	i_Current = _rFeatures.i_Current;\n";
		file << "	assert (i_Current < i_MaxSize);\n";
		file << "\n";
		file << "	#ifndef NDEBUG\n";
		file << "	set_Indices = _rFeatures.set_Indices;\n";
		file << "	#endif\n";
		file << "	return *this;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::Set (FeatureSpace& _rSpace, int _iIndex, float _fValue)\n";
		file << "{\n";
		file << "	assert (false == isnan (_fValue));\n";
		file << "	assert (_iIndex < _rSpace.BagOfWordsOffset ());\n";
		file << "	assert (_iIndex >= 0);\n";
		file << "	if (0 == _fValue)\n";
		file << "		return;\n";
		file << "	#ifdef NAN_CHECK\n";
		file << "	if ((_fValue < -100) || (_fValue > 100))\n";
		file << "	{\n";
		file << "		cout << \"[WARNING] large feature value Features::Set (): \" << _fValue << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	assert (i_Current < i_MaxSize);\n";
		file << "	vec_Indices [i_Current] = _iIndex;\n";
		file << "	vec_Features [i_Current] = _fValue;\n";
		file << "	#ifndef NDEBUG\n";
		file << "	assert (set_Indices.end () == set_Indices.find (_iIndex));\n";
		file << "	set_Indices.insert (_iIndex);\n";
		file << "	#endif\n";
		file << "\n";
		file << "	++ i_Current;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::Set (int _iIndex, float _fValue, bool _bCheckDuplicate)\n";
		file << "{\n";
		file << "	assert (false == isnan (_fValue));\n";
		file << "	assert (_iIndex >= 0);\n";
		file << "	if (0 == _fValue)\n";
		file << "		return;\n";
		file << "	#ifdef NAN_CHECK\n";
		file << "	if ((_fValue < -100) || (_fValue > 100))\n";
		file << "	{\n";
		file << "		cout << \"[WARNING] large feature value Features::Set (): \" << _fValue << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	assert (i_Current < i_MaxSize);\n";
		file << "	vec_Indices [i_Current] = _iIndex;\n";
		file << "	vec_Features [i_Current] = _fValue;\n";
		file << "	#ifndef NDEBUG\n";
		file << "	if (true == _bCheckDuplicate)\n";
		file << "		assert (set_Indices.end () == set_Indices.find (_iIndex));\n";
		file << "	set_Indices.insert (_iIndex);\n";
		file << "	#endif\n";
		file << "\n";
		file << "	++ i_Current;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::Set (const Features& _rFeatures)\n";
		file << "{\n";
		file << "	size_t iNewFeatures = _rFeatures.Size ();\n";
		file << "	assert (i_Current + iNewFeatures <= i_MaxSize);\n";
		file << "\n";
		file << "	#ifdef NAN_CHECK\n";
		file << "	if (i_Current + iNewFeatures > i_MaxSize)\n";
		file << "	{\n";
		file << "		cout << i_Current << \" + \" << iNewFeatures << \" > \" << i_MaxSize << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	vec_Indices.InsertDataBlock (i_Current,\n";
		file << "								 (int*)((Features&)_rFeatures).vec_Indices,\n";
		file << "								 iNewFeatures);\n";
		file << "	vec_Features.InsertDataBlock (i_Current,\n";
		file << "								  (float*)((Features&)_rFeatures).vec_Features,\n";
		file << "								  iNewFeatures);\n";
		file << "	i_Current += iNewFeatures;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::SetBagOfWords (FeatureSpace& _rSpace, const char* _zFeature, float _fValue)\n";
		file << "{\n";
		file << "	String sFeature (_zFeature);\n";
		file << "	int iIndex = _rSpace.GetFeatureIndex (sFeature);\n";
		file << "	assert (iIndex >= 0);\n";
		file << "\n";
		file << "	#ifdef NAN_CHECK\n";
		file << "	if ((_fValue < -100) || (_fValue > 100))\n";
		file << "	{\n";
		file << "		cout << \"[WARNING] large feature value Features::SetBagOfWords (): \"\n";
		file << "			 << _fValue << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	assert (i_Current < i_MaxSize);\n";
		file << "	vec_Indices [i_Current] = iIndex;\n";
		file << "	vec_Features [i_Current] = _fValue;\n";
		file << "	#ifndef NDEBUG\n";
		file << "	assert (set_Indices.end () == set_Indices.find (iIndex));\n";
		file << "	set_Indices.insert (iIndex);\n";
		file << "	#endif\n";
		file << "\n";
		file << "	++ i_Current;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::SetBagOfWords (FeatureSpace& _rSpace, String& _rFeature, float _fValue)\n";
		file << "{\n";
		file << "	int iIndex = _rSpace.GetFeatureIndex (_rFeature);\n";
		file << "	assert (iIndex >= 0);\n";
		file << "\n";
		file << "	#ifdef NAN_CHECK\n";
		file << "	if ((_fValue < -100) || (_fValue > 100))\n";
		file << "	{\n";
		file << "		cout << \"[WARNING] large feature value Features::SetBagOfWords (): \"\n";
		file << "			 << _fValue << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	assert (i_Current < i_MaxSize);\n";
		file << "	vec_Indices [i_Current] = iIndex;\n";
		file << "	vec_Features [i_Current] = _fValue;\n";
		file << "	#ifndef NDEBUG\n";
		file << "	assert (set_Indices.end () == set_Indices.find (iIndex));\n";
		file << "	set_Indices.insert (iIndex);\n";
		file << "	#endif\n";
		file << "\n";
		file << "	++ i_Current;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::SetBagOfWords (FeatureSpace& _rSpace, String_dq_t& _rdqFeatures, float _fValue)\n";
		file << "{\n";
		file << "	#ifdef NAN_CHECK\n";
		file << "	if ((_fValue < -100) || (_fValue > 100))\n";
		file << "	{\n";
		file << "		cout << \"[WARNING] large feature value Features::SetBagOfWords (): \" << _fValue << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	ITERATE (String_dq_t, _rdqFeatures, iteValue)\n";
		file << "	{\n";
		file << "		int iIndex = _rSpace.GetFeatureIndex (*iteValue);\n";
		file << "		assert (iIndex >= 0);\n";
		file << "		assert (i_Current < i_MaxSize);\n";
		file << "\n";
		file << "		vec_Indices [i_Current] = iIndex;\n";
		file << "		vec_Features [i_Current] = _fValue;\n";
		file << "		#ifndef NDEBUG\n";
		file << "		assert (set_Indices.end () == set_Indices.find (iIndex));\n";
		file << "		set_Indices.insert (iIndex);\n";
		file << "		#endif\n";
		file << "\n";
		file << "		++ i_Current;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::SetBagOfWords (FeatureSpace& _rSpace, const char* _zPrefix, char* _zFeatures, float _fValue)\n";
		file << "{\n";
		file << "	assert (false);\n";
		file << "	// zchar_dq_t dqValues = String::DestructiveSplit (_zFeatures, LCP_BOW_SEPARATOR);\n";
		file << "	// SetBagOfWords (_rSpace, _zPrefix, dqValues, _fValue);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::SetBagOfWords (FeatureSpace& _rSpace, const char* _zPrefix, zchar_dq_t& _rdqFeatures, float _fValue)\n";
		file << "{\n";
		file << "	#ifdef NAN_CHECK\n";
		file << "	if ((_fValue < -100) || (_fValue > 100))\n";
		file << "	{\n";
		file << "		cout << \"[WARNING] large feature value Features::SetBagOfWords (): \" << _fValue << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	ITERATE (zchar_dq_t, _rdqFeatures, iteValue)\n";
		file << "	{\n";
		file << "		String sName;\n";
		file << "		sName << _zPrefix << '\\x01' << *iteValue;\n";
		file << "\n";
		file << "		int iIndex = _rSpace.GetFeatureIndex (sName);\n";
		file << "		assert (iIndex >= 0);\n";
		file << "\n";
		file << "		#ifdef NAN_CHECK\n";
		file << "		if (i_Current >= i_MaxSize)\n";
		file << "		{\n";
		file << "			cout << \"array bounds : \" << i_Current << \" >= \" << i_MaxSize << endl;\n";
		file << "			ITERATE (zchar_dq_t, _rdqFeatures, ite)\n";
		file << "				cout << '[' << *ite << \"], \";\n";
		file << "			cout << endl;\n";
		file << "			abort ();\n";
		file << "		}\n";
		file << "		#endif\n";
		file << "\n";
		file << "		vec_Indices [i_Current] = iIndex;\n";
		file << "		vec_Features [i_Current] = _fValue;\n";
		file << "		#ifndef NDEBUG\n";
		file << "		assert (set_Indices.end () == set_Indices.find (iIndex));\n";
		file << "		set_Indices.insert (iIndex);\n";
		file << "		#endif\n";
		file << "\n";
		file << "		++ i_Current;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::SetBagOfWords (FeatureSpace& _rSpace, const char* _zPrefix, String_dq_t& _rdqFeatures, float _fValue)\n";
		file << "{\n";
		file << "	#ifdef NAN_CHECK\n";
		file << "	if ((_fValue < -100) || (_fValue > 100))\n";
		file << "	{\n";
		file << "		cout << \"[WARNING] large feature value Features::SetBagOfWords (): \" << _fValue << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	ITERATE (String_dq_t, _rdqFeatures, iteValue)\n";
		file << "	{\n";
		file << "		String sName;\n";
		file << "		sName << _zPrefix << '\\x01' << *iteValue;\n";
		file << "\n";
		file << "		int iIndex = _rSpace.GetFeatureIndex (sName);\n";
		file << "		assert (iIndex >= 0);\n";
		file << "		assert (i_Current < i_MaxSize);\n";
		file << "\n";
		file << "		vec_Indices [i_Current] = iIndex;\n";
		file << "		vec_Features [i_Current] = _fValue;\n";
		file << "		#ifndef NDEBUG\n";
		file << "		assert (set_Indices.end () == set_Indices.find (iIndex));\n";
		file << "		set_Indices.insert (iIndex);\n";
		file << "		#endif\n";
		file << "\n";
		file << "		++ i_Current;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double Features::DotProduct (double_vec_t& _rvecWeights)\n";
		file << "{\n";
		file << "	double dResult = 0;\n";
		file << "	for (int i = 0; i < Size (); ++ i)\n";
		file << "		dResult += vec_Features [i] * _rvecWeights [vec_Indices [i]];\n";
		file << "\n";
		file << "	return dResult;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Features::Normalize (void)\n";
		file << "{\n";
		file << "	double dSum = 0;\n";
		file << "	for (int i = 0; i < Size (); ++ i)\n";
		file << "		dSum += vec_Features [i];\n";
		file << "\n";
		file << "	if (0 == dSum)\n";
		file << "		return;\n";
		file << "	for (int i = 0; i < Size (); ++ i)\n";
		file << "		vec_Features [i] /= dSum;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const Features& _rFeatures)\n";
		file << "{\n";
		file << "	if (0 == _rFeatures.Size ())\n";
		file << "		return _rStream;\n";
		file << "\n";
		file << "	_rStream << _rFeatures.Index (0) << ':' << _rFeatures.Feature (0);\n";
		file << "	for (int i = 1; i < _rFeatures.Size (); ++ i)\n";
		file << "		_rStream << \", \" << _rFeatures.Index (i) << ':' << _rFeatures.Feature (i);\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const double_vec_t& _rvecValues)\n";
		file << "{\n";
		file << "	if (true == _rvecValues.empty ())\n";
		file << "		return _rStream;\n";
		file << "\n";
		file << "	_rStream << _rvecValues [0];\n";
		file << "	for (size_t i = 1; i < _rvecValues.size (); ++ i)\n";
		file << "		_rStream << \", \" << _rvecValues [i];\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "bool Features::Check (void) const\n";
		file << "{\n";
		file << "	for (size_t i = 0; i < i_Current; ++ i)\n";
		file << "	{\n";
		file << "		if (vec_Indices [i] < 0)\n";
		file << "			return false;\n";
		file << "	}\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "void Features::From(const int_set_t& _setFeatures)\n";
		file << "{\n";
		file << "    this->IncreaseSizeBy(_setFeatures.size());\n";
		file << "\n";
		file << "    CONST_ITERATE(int_set_t, _setFeatures, iter){\n";
		file << "        this->Set(*iter, 1);\n";
		file << "    }\n";
		file << "}\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("Feature.h", ios_base::out);
		file << "#ifndef __FEATURES__\n";
		file << "#define __FEATURES__\n";
		file << "\n";
		file << "#include <map>\n";
		file << "#include <deque>\n";
		file << "#include <vector>\n";
		file << "#include <hash_map>\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <nlp_vector.h>\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "\n";
		file << "class Features;\n";
		file << "typedef map <String, int>		FeatureValueToIndex_map_t;\n";
		file << "typedef map <int, String>       IndexToFeatureValue_map_t;\n";
		file << "typedef Vector <int>			int_Vec_t;\n";
		file << "typedef Vector <float>			float_Vec_t;\n";
		file << "typedef vector <double>			double_vec_t;\n";
		file << "typedef vector <Features*>		Feature_vec_t;\n";
		file << "typedef deque <Features*>		Feature_dq_t;\n";
		file << "typedef hash_map <int, float>	int_float_map_t;\n";
		file << "typedef set<int> int_set_t;\n";
		file << "\n";
		file << "class SubgoalSequenceState;\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class FeatureSpace\n";
		file << "{\n";
		file << "	friend class SubgoalSequenceState;\n";
		file << "\n";
		file << "	private:\n";
		file << "		FeatureValueToIndex_map_t	map_FeatureValueToIndex;\n";
		file << "		IndexToFeatureValue_map_t	map_IndexToFeatureValue;\n";
		file << "		int							i_BagOfWordsOffset;\n";
		file << "		int							i_MaxIndex;\n";
		file << "		pthread_rwlock_t			rwl_IndexMap;\n";
		file << "\n";
		file << "	public:\n";
		file << "		FeatureSpace (void);\n";
		file << "		~FeatureSpace (void);\n";
		file << "\n";
		file << "        String GetFeatureString(int _iIndex) const;\n";
		file << "		int GetFeatureIndex (const String& _rName, bool _bAssertExists = false);\n";
		file << "		int MaxIndex (void) const\n";
		file << "		{ return ((0 != i_MaxIndex)? i_MaxIndex : i_BagOfWordsOffset); };\n";
		file << "		int BagOfWordsOffset (void) const\n";
		file << "		{ return i_BagOfWordsOffset; };\n";
		file << "\n";
		file << "		void SetBagOfWordsOffset (int _iOffset);\n";
		file << "\n";
		file << "		bool SaveFeatureMapping (String _sName);\n";
		file << "		bool LoadFeatureMapping (String _sName);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class Features\n";
		file << "{\n";
		file << "	private:\n";
		file << "		int_Vec_t	vec_Indices;\n";
		file << "		float_Vec_t	vec_Features;\n";
		file << "		size_t		i_Current;\n";
		file << "		size_t		i_MaxSize;\n";
		file << "		#ifndef NDEBUG\n";
		file << "		int_set_t	set_Indices;\n";
		file << "		#endif\n";
		file << "\n";
		file << "	public:\n";
		file << "		Features (void);\n";
		file << "		Features (const Features& _rFeatures);\n";
		file << "		~Features (void);\n";
		file << "\n";
		file << "		void SetSize (int _iSize);\n";
		file << "        void IncreaseSizeBy (int _iSize);\n";
		file << "\n";
		file << "		void Set (FeatureSpace& _rSpace, int _iIndex, float _fValue);\n";
		file << "		void Set (int _iIndex, float _fValue, bool _bCheckDuplicate = true);\n";
		file << "		void Set (const Features& _rFeatures);\n";
		file << "\n";
		file << "		void SetBagOfWords (FeatureSpace& _rSpace,\n";
		file << "							const char* _zFeature,\n";
		file << "							float _fValue = 1);\n";
		file << "		void SetBagOfWords (FeatureSpace& _rSpace,\n";
		file << "							String& _rFeature,\n";
		file << "							float _fValue = 1);\n";
		file << "		void SetBagOfWords (FeatureSpace& _rSpace,\n";
		file << "							String_dq_t& _rdqFeatures,\n";
		file << "							float _fValue = 1);\n";
		file << "		void SetBagOfWords (FeatureSpace& _rSpace,\n";
		file << "							const char* _zPrefix,\n";
		file << "							char* _zFeatures,\n";
		file << "							float _fValue = 1);\n";
		file << "		void SetBagOfWords (FeatureSpace& _rSpace,\n";
		file << "							const char* _zPrefix,\n";
		file << "							zchar_dq_t& _rdqFeatures,\n";
		file << "							float _fValue = 1);\n";
		file << "		void SetBagOfWords (FeatureSpace& _rSpace,\n";
		file << "							const char* _zPrefix,\n";
		file << "							String_dq_t& _rdqFeatures,\n";
		file << "							float _fValue = 1);\n";
		file << "\n";
		file << "		Features& operator= (const Features& _rFeatures);\n";
		file << "\n";
		file << "		int Size (void) const\n";
		file << "		{ return i_Current; };\n";
		file << "		int Index (int _i) const\n";
		file << "		{\n";
		file << "			assert (vec_Indices [_i] >= 0);\n";
		file << "			assert ((size_t)_i < i_Current);\n";
		file << "			return vec_Indices [_i];\n";
		file << "		};\n";
		file << "		float Feature (int _i) const\n";
		file << "		{\n";
		file << "			assert (_i >= 0);\n";
		file << "			assert ((size_t)_i < i_Current);\n";
		file << "			return vec_Features [_i];\n";
		file << "		};\n";
		file << "\n";
		file << "		double DotProduct (double_vec_t& _rvecWeights);\n";
		file << "		bool Check (void) const;\n";
		file << "		bool HasNan (void)\n";
		file << "		{\n";
		file << "			for (size_t i = 0; i < i_Current; ++ i)\n";
		file << "			{\n";
		file << "				if (true == isnan (vec_Features [i]))\n";
		file << "					return true;\n";
		file << "			}\n";
		file << "			return false;\n";
		file << "		}\n";
		file << "		bool HasLargeValue (float _fLarge)\n";
		file << "		{\n";
		file << "			for (size_t i = 0; i < i_Current; ++ i)\n";
		file << "			{\n";
		file << "				if ((vec_Features [i] < - _fLarge) ||\n";
		file << "					(vec_Features [i] > _fLarge))\n";
		file << "					return true;\n";
		file << "			}\n";
		file << "			return false;\n";
		file << "		}\n";
		file << "\n";
		file << "		void Normalize (void);\n";
		file << "\n";
		file << "        void From(const int_set_t & _setFeatures);\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator<< (ostream& _rStream, const Features& _rFeatures);\n";
		file << "ostream& operator<< (ostream& _rStream, const double_vec_t& _rvecValues);\n";
		file << "\n";
		file << "#endif\n";
		file.close ();
	}



	{
		ofstream file ("SubgoalPolicy.h", ios_base::out);
		file << "#ifndef __SUBGOAL_POLCY__\n";
		file << "#define __SUBGOAL_POLCY__\n";
		file << "\n";
		file << "#include \"LogLinearPolicy.h\"\n";
		file << "#include \"FFInterface.h\"\n";
		file << "#include <nlp_distr.h>\n";
		file << "#include <nlp_time.h>\n";
		file << "#include <nlp_filesystem.h>\n";
		file << "#include <nlp_matrix.h>\n";
		file << "#include <deque>\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "#define	SEQUENCE_END	(int)1\n";
		file << "#define FEEDBACK_NEG_PLAN_FAIL			0\n";
		file << "#define FEEDBACK_NEG_NOT_IN_PREFIX		1\n";
		file << "#define FEEDBACK_POS_PLAN_OK			2\n";
		file << "\n";
		file << "\n";
		file << "class Problem;\n";
		file << "class Subgoal;\n";
		file << "class SubgoalSequence;\n";
		file << "class SentenceConnection;\n";
		file << "typedef deque <int>							int_dq_t;\n";
		file << "typedef deque <Subgoal>						Subgoal_dq_t;\n";
		file << "typedef deque <SubgoalSequence*>			SubgoalSequence_dq_t;\n";
		file << "typedef hash_map<int, PddlPredicate*>		int_PddlPredicate_map_t;\n";
		file << "typedef hash_map<String, PddlPredicate*>	PddlStringToPredicate_map_t;\n";
		file << "typedef vector<vector<int> >				int_vec_vec_t;\n";
		file << "typedef vector<int>							int_vec_t;\n";
		file << "typedef vector<int_vec_t>					ReachabilityEquivalent_vec_t;\n";
		file << "typedef vector<char>						char_vec_t;\n";
		file << "typedef hash_map<String, int>				String_int_map_t;\n";
		file << "typedef hash_map<int, String>				int_String_map_t;\n";
		file << "typedef hash_map<String, set<int> >			String_intset_map_t;\n";
		file << "typedef set<String>							String_set_t;\n";
		file << "typedef hash_map<int, hash_map<int, int> >	int_int_int_map_map_t;\n";
		file << "typedef hash_map<int,int>					int_int_map_t;\n";
		file << "typedef hash_map<int,float>					FeatureToValue_map_t;\n";
		file << "typedef hash_map<String,int>				FeatureToIndex_hmp_t;\n";
		file << "typedef vector <PddlPredicate*>				PddlPredicate_vec_t;\n";
		file << "typedef vector <SentenceConnection*>		SentenceConnection_vec_t;\n";
		file << "typedef map <String, FeatureToValue_map_t*> ConnectionHashToFeatures_map_t;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "enum enum_subgoal_t{START, SUBGOAL, GOAL};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class SentenceConnection\n";
		file << "{\n";
		file << "	public:\n";
		file << "		Features*	p_PositiveFeatures;\n";
		file << "		Features*	p_NegativeFeatures;\n";
		file << "		int			i_Sentence;\n";
		file << "		int			i_From;\n";
		file << "		int			i_To;\n";
		file << "\n";
		file << "		SentenceConnection (void)\n";
		file << "		{\n";
		file << "			p_PositiveFeatures = NULL;\n";
		file << "			p_NegativeFeatures = NULL;\n";
		file << "		};\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class Subgoal\n";
		file << "{\n";
		file << "	public:\n";
		file << "		LogProbability	lprb_SequenceEnd;\n";
		file << "		LogProbability	lprb_Subgoal;\n";
		file << "		Features_vec_t	vec_SequenceEndFeatureVectors;\n";
		file << "		Features_vec_t	vec_SubgoalFeatureVectors;\n";
		file << "\n";
		file << "		String			s_StartStatePredicates;\n";
		file << "		String			s_ProblemPddl;\n";
		file << "		String			s_FFOutput;\n";
		file << "		String			s_Plan;\n";
		file << "\n";
		file << "		Features*       p_SelectedPredicateFeatures;\n";
		file << "		PddlPredicate*	p_PddlSubgoalPredicate;\n";
		file << "		PddlProblem*	p_PddlProblem;\n";
		file << "		PddlProblem*	p_PddlTargetProblem;\n";
		file << "\n";
		file << "		long			l_States;\n";
		file << "		long			i_SubgoalSelection;\n";
		file << "		int				i_SequenceEnd;\n";
		file << "		FFPlaningOutcome_e	e_PlanningOutcome;\n";
		file << "		bool			b_IsLastSubgoalToTarget;\n";
		file << "		bool			b_ForcedSequenceEnd;\n";
		file << "\n";
		file << "		Subgoal (void);\n";
		file << "		~Subgoal (void);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class SubgoalSequence\n";
		file << "{\n";
		file << "	friend class SubgoalPolicy;\n";
		file << "	public:\n";
		file << "		Subgoal_dq_t	dq_Subgoals;\n";
		file << "		char_vec_t		vec_PredicatesInSequence;\n";
		file << "		String			s_ProblemPddlPreamble;\n";
		file << "		Problem*		p_TargetProblem;\n";
		file << "\n";
		file << "		bool			b_UseSimpleConnectionFeatures;\n";
		file << "		bool			b_UseTextConnectionFeatures;\n";
		file << "		bool			b_UseComplexNonConnectionFeatures;\n";
		file << "\n";
		file << "\n";
		file << "		SubgoalSequence (void);\n";
		file << "		~SubgoalSequence (void);\n";
		file << "\n";
		file << "		int Length (void)\n";
		file << "		{ return dq_Subgoals.size (); };\n";
		file << "\n";
		file << "		Subgoal* AddSubgoalToFront (void)\n";
		file << "		{\n";
		file << "			dq_Subgoals.push_front (Subgoal ());\n";
		file << "			return &dq_Subgoals.front ();\n";
		file << "		}\n";
		file << "		Subgoal* AddSubgoalToBack (void)\n";
		file << "		{\n";
		file << "			dq_Subgoals.push_back (Subgoal ());\n";
		file << "			return &dq_Subgoals.back ();\n";
		file << "		}\n";
		file << "\n";
		file << "		Subgoal* GetSubgoal (unsigned int _iIndex)\n";
		file << "		{\n";
		file << "			assert (_iIndex < dq_Subgoals.size ());\n";
		file << "			return &dq_Subgoals [_iIndex];\n";
		file << "		};\n";
		file << "\n";
		file << "		void SetSubtaskFFResponse (unsigned int _iIndex, FFResponse& _rResponse);\n";
		file << "		bool GetSubtask (unsigned int _iIndex, String* _pProblemPddl);\n";
		file << "		void SetSubtask (unsigned int _iIndex,\n";
		file << "						 String _rProblemPddl,\n";
		file << "						 PddlProblem* _pPddlProblem);\n";
		file << "\n";
		file << "		String ToLogString (void);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "enum ExplorationType_e\n";
		file << "{\n";
		file << "	et_epsilon_greedy,\n";
		file << "	et_softmax,\n";
		file << "	et_epsilon_softmax,\n";
		file << "	et_unknown\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class ExplorationParameters\n";
		file << "{\n";
		file << "	public:\n";
		file << "		ExplorationType_e	e_ExplorationType;\n";
		file << "		float				f_Epsilon;\n";
		file << "		float				f_EpsilonMin;\n";
		file << "		float				f_EpsilonRange;\n";
		file << "		float				f_Beta;\n";
		file << "		float				f_BetaMin;\n";
		file << "		float				f_BetaRange;\n";
		file << "\n";
		file << "		ExplorationParameters (void)\n";
		file << "		{\n";
		file << "			e_ExplorationType = et_unknown;\n";
		file << "			f_Epsilon = 0;\n";
		file << "			f_EpsilonMin = 0;\n";
		file << "			f_EpsilonRange = 0;\n";
		file << "			f_Beta = 0;\n";
		file << "			f_BetaMin = 0;\n";
		file << "			f_BetaRange = 0;\n";
		file << "		}\n";
		file << "\n";
		file << "		ExplorationType_e ToEnum (String _sType);\n";
		file << "		const char* ToString (ExplorationType_e _eType);\n";
		file << "\n";
		file << "		void SetParamsFromConfig (String _rPrefix);\n";
		file << "		String SampleParameters (Sample& _rSample);\n";
		file << "		void PrintConfiguration (const char* _zPrefix);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "enum ConnectionRewardType_e\n";
		file << "{\n";
		file << "	crt_linear,\n";
		file << "	crt_single_success,\n";
		file << "	crt_unknown\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class SubgoalPolicy\n";
		file << "{\n";
		file << "	friend class SubgoalLearner;\n";
		file << "\n";
		file << "	private:\n";
		file << "		LogLinearModel	o_SequenceEndModel;\n";
		file << "		LogLinearModel	o_SubgoalSelectionModel;\n";
		file << "		LogLinearModel	o_TextConnectionModel;\n";
		file << "\n";
		file << "		FeatureSpace	o_SequenceEndFeatureSpace;\n";
		file << "		FeatureSpace	o_SubgoalFeatureSpace;\n";
		file << "		FeatureSpace	o_TextConnectionFeatureSpace;\n";
		file << "		Sample			o_Sample;\n";
		file << "\n";
		file << "		LogProbability	lprb_SentenceConnection;\n";
		file << "\n";
		file << "		double_Vec_t	vec_ConnectionFE;\n";
		file << "		double_Vec_t	vec_SequenceEndFE;\n";
		file << "		double_Vec_t	vec_SubgoalFE;\n";
		file << "\n";
		file << "		FeatureToIndex_hmp_t	hmp_ParameterValueToIndex;\n";
		file << "		FeatureToIndex_hmp_t	hmp_PredicateNameToIndex;\n";
		file << "		FeatureToIndex_hmp_t	hmp_PredicateWithoutNumberToIndex;\n";
		file << "		FeatureToIndex_hmp_t	hmp_PredicateIdToIndex;\n";
		file << "		String_int_map_t        map_ProblemToGoldLength;\n";
		file << "		int_String_map_t        map_FeatureIndexToFeatureString;\n";
		file << "		int_dq_t                dq_FeaturesToDebugPrint;\n";
		file << "\n";
		file << "\n";
		file << "		PddlStringToPredicate_map_t	map_PddlStringToCandidatePredicate;\n";
		file << "		PddlPredicate_vec_t			vec_CandidatePredicates;\n";
		file << "		char_vec_t					vec_CanReachCandidatePredicate;\n";
		file << "\n";
		file << "		Matrix <char,2>	mtx_PredicateConnectionsFromTo;\n";
		file << "		Matrix <char,2>	mtx_PredicateConnectionsToFrom;\n";
		file << "		Matrix <int_dq_t*,2>	mtx_SentencesPositiveFromTo;\n";
		file << "		Matrix <int_dq_t*,2>	mtx_SentencesNegativeFromTo;\n";
		file << "		Matrix <int, 3>	mtx_FeedbackOnSentenceConnections;\n";
		file << "\n";
		file << "		SentenceConnection_vec_t	vec_SentenceConnections;\n";
		file << "		ReachabilityEquivalent_vec_t	vec_ReachabilityPredicateEqulivalents;\n";
		file << "\n";
		file << "		size_t			i_OffsetToConnectionFeatures;\n";
		file << "		size_t			i_OffsetToPredicateNameFeatures;\n";
		file << "		size_t			i_OffsetToParameterValueFeatures;\n";
		file << "		size_t			i_OffsetToPredicateIdentityFeatures;\n";
		file << "		size_t			i_PredicateNames;\n";
		file << "		size_t			i_ParameterValues;\n";
		file << "		size_t			i_PredicateIdentities;\n";
		file << "		int				i_MaxConnectionDepth;\n";
		file << "		int				i_MaxPredicateValue;\n";
		file << "		int				i_MaxSequenceLength;\n";
		file << "\n";
		file << "		ExplorationParameters	o_SequenceEndExploration;\n";
		file << "		ExplorationParameters	o_SubgoalExploration;\n";
		file << "		ExplorationParameters	o_ConnectionExploration;\n";
		file << "		ConnectionRewardType_e	e_ConnectionRewardType;\n";
		file << "\n";
		file << "		long			i_CandidatePredicates;\n";
		file << "		long			i_CandidatePredicateNumbersMerged;\n";
		file << "		float			f_UseSimpleConnectionFeatures;\n";
		file << "		bool			b_UseSimpleConnectionFeatures;\n";
		file << "		float			f_UseTextConnectionFeatures;\n";
		file << "		bool			b_UseTextConnectionFeatures;\n";
		file << "		float			f_UseComplexNonConnectionFeatures;\n";
		file << "		bool			b_UseComplexNonConnectionFeatures;\n";
		file << "		float			f_NonConnectionFeatureImportance;\n";
		file << "		bool			b_DisallowNeighboringDuplicateSubgoals;\n";
		file << "		bool			b_DisallowAnyDuplicateSubgoals;\n";
		file << "		bool			b_UseLogarithmicDistanceScore;\n";
		file << "		bool			b_ForceConnectionWeights;\n";
		file << "		double			d_ForcedConnectionWeightToInit;\n";
		file << "		double			d_ForcedConnectionWeightToTarget;\n";
		file << "		bool			b_UsePredicateValueFeature;\n";
		file << "		bool			b_UseReachableSubgoalFeature;\n";
		file << "		bool			b_UseReachabilityEquivalents;\n";
		file << "		float			f_PredicateIdentityPairFeatureWeight;\n";
		file << "		float			f_ConnectionSuccessReward;\n";
		file << "		float			f_ConnectionFailurePenalty;\n";
		file << "\n";
		file << "		bool			b_UseOnlyPreviousSubgoal;\n";
		file << "		bool			b_IncludeInit;\n";
		file << "		bool            b_UseGoldLength;\n";
		file << "		bool			b_PrintTextConnectionFeatures;\n";
		file << "		bool			b_LogConnectionPredictions;\n";
		file << "		bool			b_LogConnectionFeedback;\n";
		file << "		bool			b_RetainPredicateConnectionFeedback;\n";
		file << "		bool			b_UseSuccessFailureCountsInFeedback;\n";
		file << "		int				i_UpdatesPerIteration;\n";
		file << "\n";
		file << "\n";
		file << "		float DistanceScore (float _fDistance)\n";
		file << "		{\n";
		file << "			if (true == b_UseLogarithmicDistanceScore)\n";
		file << "				return 1 / (float)(1 + log (_fDistance));\n";
		file << "			else\n";
		file << "				return 1 / (float)_fDistance;\n";
		file << "		};\n";
		file << "		int GetPredicateIdentityFeatureIndex (const String& _rPredicate);\n";
		file << "		int GetPredicateNameFeatureIndex (const String& _rName);\n";
		file << "		int GetPredicateWithoutNumberIndex (const PddlPredicate& _rPredicate);\n";
		file << "		int GetParameterValueFeatureIndex (const String& _rValue);\n";
		file << "\n";
		file << "		void ComputeSubgoalFeatures (int _iIndex,\n";
		file << "									 const Problem& _rProblem,\n";
		file << "									 SubgoalSequence* _pSequence);\n";
		file << "		void ComputeSequenceEndFeatures (int _iIndex,\n";
		file << "										 const Problem& _rProblem,\n";
		file << "										 SubgoalSequence* _pSequence);\n";
		file << "\n";
		file << "		bool LoadSimpleConnectionFile (void);\n";
		file << "		bool LoadFeatureConnectionFile (void);\n";
		file << "		bool LoadPredDictFile (void);\n";
		file << "		void LoadGoldLengthFile (void);\n";
		file << "		void LoadFeaturesToDebugPrintFile(void);\n";
		file << "		void LogDebugFeatureWeights(File *file);\n";
		file << "\n";
		file << "		PddlPredicate* FindEquivalentPredicateCandidate (PddlPredicate& _rPredicate);\n";
		file << "		int FindPredicateCandidateIndex (PddlPredicate& _rPredicate);\n";
		file << "		int FindInitPredicateCandidateIndex (PddlPredicate& _rPredicate);\n";
		file << "		void AssignIndicesToTargetProblemPredicates (void);\n";
		file << "\n";
		file << "		void AddLastSubgoal (const Problem& _rProblem,\n";
		file << "							 SubgoalSequence* _pSequence);\n";
		file << "		void AddForcedSequenceEnd (const Problem& _rProblem,\n";
		file << "								   SubgoalSequence* _pSequence);\n";
		file << "		inline size_t SampleDecision (LogProbability& _rLogProb,\n";
		file << "									  ExplorationParameters& _rExploration,\n";
		file << "									  bool _bTestMode);\n";
		file << "		inline size_t SampleSequenceEnd (int _iSubgoalIndex,\n";
		file << "										 const Problem& _rProblem,\n";
		file << "										 LogProbability& _rLogProb,\n";
		file << "										 bool _bTestMode);\n";
		file << "		void UpdateConnectionParameters (void);\n";
		file << "		void DebugPrintFeatureVectors (const Subgoal& subgoal,\n";
		file << "									   ostream* osOut,\n";
		file << "									   const String& sPrefix) const;\n";
		file << "\n";
		file << "		void SetFeatures (const int_Vec_t& _rvecFI,\n";
		file << "						  size_t _iOffset,\n";
		file << "						  Features* _pFV,\n";
		file << "						  float _fValue = 1,\n";
		file << "						  bool _bCheckDuplicates = true)\n";
		file << "		{\n";
		file << "			for (size_t i = 0; i < _rvecFI.Size (); ++ i)\n";
		file << "				_pFV->Set (_iOffset + _rvecFI [i], _fValue, _bCheckDuplicates);\n";
		file << "		}\n";
		file << "\n";
		file << "	public:\n";
		file << "		SubgoalPolicy (void);\n";
		file << "		~SubgoalPolicy (void);\n";
		file << "\n";
		file << "		bool Init (void);\n";
		file << "\n";
		file << "		void SampleExplorationParameters (void);\n";
		file << "		void ForceConnectionUseFlags (void);\n";
		file << "		void SampleConnectionUseFlags (void);\n";
		file << "\n";
		file << "		void SampleConnections (bool _bTestMode);\n";
		file << "		void SampleSubgoalSequence (const Problem& _rProblem,\n";
		file << "									bool _bTestMode,\n";
		file << "									SubgoalSequence* _pSequence);\n";
		file << "		void SampleZeroSubgoalSequence (const Problem& _rProblem,\n";
		file << "										SubgoalSequence* _pSequence);\n";
		file << "\n";
		file << "		void InitUpdate (void);\n";
		file << "		void UpdateParameters (SubgoalSequence& _rSequence,\n";
		file << "							   double _dReward,\n";
		file << "							   bool _bTaskComplete,\n";
		file << "							   bool _bWithConnections);\n";
		file << "		void CompleteUpdate (void);\n";
		file << "\n";
		file << "		void AddReachableSubgoals (const int_set_t& _rsetReachableSubgoals);\n";
		file << "		bool SaveWeights (int _iIteration);\n";
		file << "		void Test(void);\n";
		file << "		double WeightVectorNorm (void);\n";
		file << "		String GetFeatureString (int _iIndex) const;\n";
		file << "		void WriteConnectionFeedback (void);\n";
		file << "		void WriteConnectionPredictionHeader (void);\n";
		file << "		void WriteConnectionPredictions (void);\n";
		file << "		String ConnectionPredictionRatio (void);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file.close ();
	}



	{
		ofstream file ("FFInterface.cpp", ios_base::out);
		file << "#include \"FFInterface.h\"\n";
		file << "#include \"CompressedBuffer.h\"\n";
		file << "#include <nlp_config.h>\n";
		file << "#include <nlp_macros.h>\n";
		file << "#include <nlp_filesystem.h>\n";
		file << "#include <assert.h>\n";
		file << "\n";
		file << "#define RECEIVE_BUFFER	2048\n";
		file << "\n";
		file << "bool FFInterface::b_Active = false;\n";
		file << "FFInterface* FFInterface::p_FFInterface = NULL;\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "FFInterface::FFInterface (void)\n";
		file << "{\n";
		file << "	p_Callback = NULL;\n";
		file << "	pthread_mutex_init (&mtx_TaskList, NULL);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "FFInterface::~FFInterface (void)\n";
		file << "{\n";
		file << "	Disconnect ();\n";
		file << "	ClearTasks ();\n";
		file << "	pthread_mutex_destroy (&mtx_TaskList);\n";
		file << "\n";
		file << "	ITERATE (GoalToPrerequisites_hmp_t, hmp_GoalToPrerequisites, ite)\n";
		file << "		delete ite->second;\n";
		file << "	ITERATE (GoalToPlan_hmp_t, hmp_GoalToPlan, ite)\n";
		file << "		delete ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool FFInterface::SendMessage (const String& _rMessage)\n";
		file << "{\n";
		file << "	size_t iLength = _rMessage.length () + sizeof (size_t) + 1;\n";
		file << "\n";
		file << "	Buffer bufMsg;\n";
		file << "	bufMsg.Append (&iLength, sizeof (size_t));\n";
		file << "	bufMsg.Append ((const char*)_rMessage, _rMessage.length () + 1);\n";
		file << "\n";
		file << "	assert (iLength == bufMsg.Length ());\n";
		file << "	return ClientSocket::SendBlocking (bufMsg.GetData (), bufMsg.Length ());\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool FFInterface::SendMessage (const Buffer& _rMessage)\n";
		file << "{\n";
		file << "	size_t iLength = _rMessage.Length () + sizeof (size_t);\n";
		file << "\n";
		file << "	Buffer bufMsg;\n";
		file << "	bufMsg.Append (&iLength, sizeof (size_t));\n";
		file << "	bufMsg.Append (_rMessage);\n";
		file << "\n";
		file << "	assert (iLength == bufMsg.Length ());\n";
		file << "	return ClientSocket::SendNonBlocking (bufMsg.GetData (), bufMsg.Length ());\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool FFInterface::Connect (void)\n";
		file << "{\n";
		file << "	b_UseLocalHeuristicEvaluator = (1 == (int)(config)\"use_local_heuristic_evaluator\");\n";
		file << "	if (true == b_UseLocalHeuristicEvaluator)\n";
		file << "	{\n";
		file << "		if (false == InitHeuristicEvaluator ())\n";
		file << "			return false;\n";
		file << "\n";
		file << "		b_Active = true;\n";
		file << "		p_FFInterface = this;\n";
		file << "		pthread_create (&thr_SocketLoop, NULL, RunThread, this);\n";
		file << "		pthread_detach (thr_SocketLoop);\n";
		file << "		return true;\n";
		file << "	}\n";
		file << "\n";
		file << "	String sServer = (config)\"cache_host\";\n";
		file << "	String sPort = (config)\"cache_service\";\n";
		file << "\n";
		file << "	if (false == ClientSocket::ConnectBlocking (sServer, sPort))\n";
		file << "	{\n";
		file << "		cout << \"   [EE] Failed to connect to cache server at \"\n";
		file << "			 << sServer << ':' << sPort << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	b_KnownWorldOnly = (1 == (int)(config)\"known_world_only\");\n";
		file << "	if (true == b_KnownWorldOnly)\n";
		file << "	{\n";
		file << "		cout << \"Activating known-world-only mode.\" << endl;\n";
		file << "		SendMessage (String (\":[known world only]\"));\n";
		file << "\n";
		file << "		SetStandalone (true);\n";
		file << "\n";
		file << "		Buffer bufTemp;\n";
		file << "		size_t iMessageSize = 0;\n";
		file << "		while (true)\n";
		file << "		{\n";
		file << "			char zData [RECEIVE_BUFFER + 1];\n";
		file << "			long lBytes = ReceiveBlocking (zData, RECEIVE_BUFFER, 100);\n";
		file << "			if (lBytes > 0)\n";
		file << "				bufTemp.Append (zData, lBytes);\n";
		file << "\n";
		file << "			if (false == bufTemp.ReadFromIndex (0, &iMessageSize, sizeof (size_t)))\n";
		file << "				continue;\n";
		file << "			if (iMessageSize > bufTemp.Length ())\n";
		file << "				continue;\n";
		file << "			break;\n";
		file << "		}\n";
		file << "\n";
		file << "		Buffer bufResponse = bufTemp.PopFirstMessageAsBuffer (iMessageSize);\n";
		file << "		bufResponse.DropFront (sizeof (size_t));\n";
		file << "		String sMessage = bufResponse;\n";
		file << "		if (\":Known-world-only mode active\" == sMessage)\n";
		file << "			cout << \"   Known world only mode active.\" << endl;\n";
		file << "		else\n";
		file << "		{\n";
		file << "			cout << \"   [WARNING] Failed to activate known-world-only mode.\\n\"\n";
		file << "					\"   Got following response from cache: [\"\n";
		file << "				 << sMessage << ']' << endl;\n";
		file << "		}\n";
		file << "		SetStandalone (false);\n";
		file << "	}\n";
		file << "\n";
		file << "	ClearConnection ();\n";
		file << "\n";
		file << "	b_Active = true;\n";
		file << "	pthread_create (&thr_SocketLoop, NULL, RunThread, this);\n";
		file << "	pthread_detach (thr_SocketLoop);\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void FFInterface::Disconnect (void)\n";
		file << "{\n";
		file << "	b_Active = false;\n";
		file << "	if (true == b_UseLocalHeuristicEvaluator)\n";
		file << "		return;\n";
		file << "	sleep (1);\n";
		file << "	Socket::Close ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "long FFInterface::RegisterDomain (String& _rDomain)\n";
		file << "{\n";
		file << "	if (true == b_UseLocalHeuristicEvaluator)\n";
		file << "		return 0;\n";
		file << "\n";
		file << "	SetStandalone (true);\n";
		file << "\n";
		file << "	// send request ...\n";
		file << "	String sRequest;\n";
		file << "	sRequest << \"+\" << _rDomain;\n";
		file << "	if (false == SendMessage (sRequest))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Request failed on RegisterDomain.\" << endl;\n";
		file << "		SetStandalone (false);\n";
		file << "		return -1;\n";
		file << "	}\n";
		file << "\n";
		file << "	// get response ...\n";
		file << "	Buffer bufTemp;\n";
		file << "	size_t iMessageSize = 0;\n";
		file << "	while (true)\n";
		file << "	{\n";
		file << "		char zData [RECEIVE_BUFFER + 1];\n";
		file << "		long lBytes = ReceiveBlocking (zData, RECEIVE_BUFFER, 100);\n";
		file << "		if (lBytes > 0)\n";
		file << "			bufTemp.Append (zData, lBytes);\n";
		file << "\n";
		file << "		if (false == bufTemp.ReadFromIndex (0, &iMessageSize, sizeof (size_t)))\n";
		file << "			continue;\n";
		file << "		if (iMessageSize > bufTemp.Length ())\n";
		file << "			continue;\n";
		file << "		break;\n";
		file << "	}\n";
		file << "	SetStandalone (false);\n";
		file << "\n";
		file << "	Buffer bufResponse = bufTemp.PopFirstMessageAsBuffer (iMessageSize);\n";
		file << "	char cType = bufResponse [sizeof (size_t)];\n";
		file << "	if ('d' != cType)\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Bad line format in response to domain registration.\"\n";
		file << "			 << \" expected 'd', got '\" << cType << \"'.\" << endl;\n";
		file << "		return -1;\n";
		file << "	}\n";
		file << "	long lDomainId;\n";
		file << "	if (false == bufResponse.ReadFromIndex (1 + sizeof (size_t),\n";
		file << "											&lDomainId,\n";
		file << "											sizeof (size_t)))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed to read domain id from domain registration reponse.\"\n";
		file << "			 << endl;\n";
		file << "		return -1;\n";
		file << "	}\n";
		file << "\n";
		file << "	return lDomainId;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool FFInterface::SendTask (size_t _iId,\n";
		file << "							size_t _iDomain,\n";
		file << "							String& _rProblem,\n";
		file << "							size_t _iTimelimit)\n";
		file << "{\n";
		file << "	if (NULL == p_Callback)\n";
		file << "	{\n";
		file << "		cerr << \"   [EE] Callback not set for FFInterface. Will not be able to relay FF responses back. Not sending task to FF.\" << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	pthread_mutex_lock (&mtx_TaskList);\n";
		file << "	pair <TaskIdToFFResponse_hmp_t::iterator, bool> pairInsert;\n";
		file << "	FFResponse* pResponse = new FFResponse;\n";
		file << "	pairInsert = hmp_TaskIdToFFResponse.insert (make_pair (_iId, pResponse));\n";
		file << "\n";
		file << "	_rProblem.Strip ();\n";
		file << "	pResponse->i_Domain = _iDomain;\n";
		file << "	pResponse->s_Problem = _rProblem;\n";
		file << "	pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "\n";
		file << "	if (true == b_UseLocalHeuristicEvaluator)\n";
		file << "		return true;\n";
		file << "\n";
		file << "	// send request to cache...\n";
		file << "	CompressedBuffer bufProblem (_rProblem);\n";
		file << "	size_t iCompressedSize = bufProblem.CompressedSize ();\n";
		file << "	size_t iUncompressedSize = bufProblem.UncompressedSize ();\n";
		file << "\n";
		file << "	Buffer bufRequest;\n";
		file << "	bufRequest.Append (\"?\", 1);\n";
		file << "	bufRequest.Append (&_iId, sizeof (size_t));\n";
		file << "	bufRequest.Append (&_iTimelimit, sizeof (size_t));\n";
		file << "	bufRequest.Append (&_iDomain, sizeof (size_t));\n";
		file << "	bufRequest.Append (&iCompressedSize, sizeof (size_t));\n";
		file << "	bufRequest.Append (&iUncompressedSize, sizeof (size_t));\n";
		file << "	bufRequest.Append (bufProblem);\n";
		file << "\n";
		file << "	if (false == SendMessage (bufRequest))\n";
		file << "		return false;\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void FFInterface::ClearTasks (void)\n";
		file << "{\n";
		file << "	pthread_mutex_lock (&mtx_TaskList);\n";
		file << "	ITERATE (TaskIdToFFResponse_hmp_t, hmp_TaskIdToFFResponse, ite)\n";
		file << "		delete ite->second;\n";
		file << "	hmp_TaskIdToFFResponse.clear ();\n";
		file << "	pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool FFInterface::TestTasksClear (void)\n";
		file << "{\n";
		file << "	pthread_mutex_lock (&mtx_TaskList);\n";
		file << "	if (false == hmp_TaskIdToFFResponse.empty ())\n";
		file << "	{\n";
		file << "		pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "	pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void FFInterface::OnReceive (const void* _zData, long _lBytes)\n";
		file << "{\n";
		file << "	o_Data.Append (_zData, _lBytes);\n";
		file << "\n";
		file << "	while (true)\n";
		file << "	{\n";
		file << "		size_t iMessageSize;\n";
		file << "		if (false == o_Data.ReadFromIndex (0, &iMessageSize, sizeof (size_t)))\n";
		file << "			return;\n";
		file << "		if (iMessageSize > o_Data.Length ())\n";
		file << "			return;\n";
		file << "\n";
		file << "		// process reply...\n";
		file << "		Buffer bufResponse = o_Data.PopFirstMessageAsBuffer (iMessageSize);\n";
		file << "		char cType = bufResponse [sizeof (size_t)];\n";
		file << "\n";
		file << "		// cout << \"OnReceive \" << iMessageSize  << \" \" << cType << endl;\n";
		file << "\n";
		file << "		if (('c' == cType) || ('f' == cType))\n";
		file << "		{\n";
		file << "			// Cache hit. This message has plan.\n";
		file << "			size_t iOffset = sizeof (size_t) + 1;\n";
		file << "\n";
		file << "			size_t iTaskId;\n";
		file << "			if (false == bufResponse.ReadFromIndex (iOffset, &iTaskId, sizeof (size_t)))\n";
		file << "			{\n";
		file << "				cerr << \"[ERROR] Failed to read task id from cache response.\" << endl;\n";
		file << "				break;\n";
		file << "			}\n";
		file << "			iOffset += sizeof (size_t);\n";
		file << "\n";
		file << "			size_t iCompressedSize;\n";
		file << "			if (false == bufResponse.ReadFromIndex (iOffset,\n";
		file << "													&iCompressedSize,\n";
		file << "													sizeof (size_t)))\n";
		file << "			{\n";
		file << "				cerr << \"[ERROR] Failed to read compressed size from cache response.\"\n";
		file << "					 << endl;\n";
		file << "				break;\n";
		file << "			}\n";
		file << "			iOffset += sizeof (size_t);\n";
		file << "\n";
		file << "			size_t iUncompressedSize;\n";
		file << "			if (false == bufResponse.ReadFromIndex (iOffset,\n";
		file << "													&iUncompressedSize,\n";
		file << "													sizeof (size_t)))\n";
		file << "			{\n";
		file << "				cerr << \"[ERROR] Failed to read uncompressed size from cache response.\"\n";
		file << "					 << endl;\n";
		file << "				break;\n";
		file << "			}\n";
		file << "			iOffset += sizeof (size_t);\n";
		file << "\n";
		file << "			// cout << \"compressed data : \" << iCompressedSize << \" \"\n";
		file << "			//	 << iUncompressedSize << endl;\n";
		file << "			void* pCompressedFFResponse = (char*) bufResponse.GetData () + iOffset;\n";
		file << "			CompressedBuffer bufCompressedFFResponse;\n";
		file << "			bufCompressedFFResponse.SetData (pCompressedFFResponse,\n";
		file << "											 iCompressedSize,\n";
		file << "											 iUncompressedSize);\n";
		file << "\n";
		file << "\n";
		file << "			// find task in sent-task map...\n";
		file << "			pthread_mutex_lock (&mtx_TaskList);\n";
		file << "			TaskIdToFFResponse_hmp_t::iterator	iteTask;\n";
		file << "			iteTask = hmp_TaskIdToFFResponse.find (iTaskId);\n";
		file << "			if (hmp_TaskIdToFFResponse.end () == iteTask)\n";
		file << "			{\n";
		file << "				cerr << \"   [WW] task id not found [\"\n";
		file << "					 << iTaskId << ']' << endl;\n";
		file << "				pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "				return;\n";
		file << "			}\n";
		file << "\n";
		file << "			// update task attributes...\n";
		file << "			FFResponse* pResponse = iteTask->second;\n";
		file << "			if (false == bufCompressedFFResponse.Uncompress (&pResponse->s_FFOutput))\n";
		file << "			{\n";
		file << "				cerr << \"[ERROR] Failed to uncompress FF response.\" << endl;\n";
		file << "				pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "				break;\n";
		file << "			}\n";
		file << "			pResponse->e_PlanningOutcome\n";
		file << "				= FFInterface::FFExtractOutcome (pResponse->s_FFOutput);\n";
		file << "			if (po_plan_found == pResponse->e_PlanningOutcome)\n";
		file << "			{\n";
		file << "				pResponse->s_Plan = FFInterface::ExtractPlan (pResponse->s_FFOutput);\n";
		file << "				pResponse->l_States = FFInterface::StatesEvaluated (pResponse->s_FFOutput);\n";
		file << "			}\n";
		file << "\n";
		file << "			// clear local information about task\n";
		file << "			hmp_TaskIdToFFResponse.erase (iteTask);\n";
		file << "			pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "\n";
		file << "			// callback with received response...\n";
		file << "			p_Callback->OnFFResponse (iTaskId, *pResponse);\n";
		file << "			delete pResponse;\n";
		file << "		}\n";
		file << "\n";
		file << "		else if ('u' == cType)\n";
		file << "		{\n";
		file << "			// used for restricted world runs.\n";
		file << "			size_t iOffset = sizeof (size_t) + 1;\n";
		file << "			size_t iTaskId;\n";
		file << "			if (false == bufResponse.ReadFromIndex (iOffset, &iTaskId, sizeof (size_t)))\n";
		file << "			{\n";
		file << "				cerr << \"[ERROR] Failed to read task id from cache response.\" << endl;\n";
		file << "				break;\n";
		file << "			}\n";
		file << "\n";
		file << "			// find task from id ...\n";
		file << "			pthread_mutex_lock (&mtx_TaskList);\n";
		file << "			TaskIdToFFResponse_hmp_t::iterator	iteTask;\n";
		file << "			iteTask = hmp_TaskIdToFFResponse.find (iTaskId);\n";
		file << "			if (hmp_TaskIdToFFResponse.end () == iteTask)\n";
		file << "			{\n";
		file << "				cerr << \"   [WW] task id not found [\"\n";
		file << "					 << iTaskId << ']' << endl;\n";
		file << "				pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "				return;\n";
		file << "			}\n";
		file << "\n";
		file << "			// update task attributes ...\n";
		file << "			FFResponse* pResponse = iteTask->second;\n";
		file << "			pResponse->e_PlanningOutcome = po_outside_known_world;\n";
		file << "			if (false == b_KnownWorldOnly)\n";
		file << "			{\n";
		file << "				cerr << \"   [WW] 'Outside-known-world' respose received from \"\n";
		file << "						\"cache, but learner is not in 'known-world-only' mode.\"\n";
		file << "					 << endl;\n";
		file << "			}\n";
		file << "\n";
		file << "			// clear local information about task\n";
		file << "			hmp_TaskIdToFFResponse.erase (iteTask);\n";
		file << "			pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "\n";
		file << "			// callback with received response...\n";
		file << "			p_Callback->OnFFResponse (iTaskId, *pResponse);\n";
		file << "			delete pResponse;\n";
		file << "		}\n";
		file << "\n";
		file << "		else\n";
		file << "		{\n";
		file << "			// This shouldn't happen!\n";
		file << "			cerr << \"[EE]  Unknown response from cache \"\n";
		file << "				 << cType << endl;\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void FFInterface::OnDisconnect (void)\n";
		file << "{\n";
		file << "	cout << \"[EE] Socket connection to cache server lost, attempting to reconnect.\"\n";
		file << "		 << endl;\n";
		file << "\n";
		file << "	exit (1);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void FFInterface::ClearConnection (void)\n";
		file << "{\n";
		file << "	SetStandalone (true);\n";
		file << "	char zData [RECEIVE_BUFFER + 1];\n";
		file << "	long lBytes = ReceiveBlocking (zData, RECEIVE_BUFFER, 100);\n";
		file << "	long lTotalBytes = lBytes;\n";
		file << "\n";
		file << "	while (lBytes > 0)\n";
		file << "	{\n";
		file << "		long lBytes = ReceiveBlocking (zData, RECEIVE_BUFFER, 100);\n";
		file << "		if (lBytes > 0)\n";
		file << "			lTotalBytes += lBytes;\n";
		file << "	}\n";
		file << "	SetStandalone (false);\n";
		file << "\n";
		file << "	if (lTotalBytes > 0)\n";
		file << "		cout << \"[INFO] Discarding \" << lTotalBytes << \" of unexpected data.\" << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void* FFInterface::RunThread (void* _pArg)\n";
		file << "{\n";
		file << "	if (NULL != p_FFInterface)\n";
		file << "	{\n";
		file << "		while (true == b_Active)\n";
		file << "		{\n";
		file << "			usleep (100);\n";
		file << "			p_FFInterface->RunLocalHeuristicEvaluator ();\n";
		file << "		}\n";
		file << "	}\n";
		file << "	else\n";
		file << "	{\n";
		file << "		while (true == b_Active)\n";
		file << "			AllSockets::ProcessEvents (1000);\n";
		file << "	}\n";
		file << "\n";
		file << "	pthread_exit (&((FFInterface*)_pArg)->thr_SocketLoop);\n";
		file << "	return NULL;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "FFPlaningOutcome_e FFInterface::FFExtractOutcome (String& _rFFResponse)\n";
		file << "{\n";
		file << "	if (true == _rFFResponse.Has (\"ff: found legal plan as follows\"))\n";
		file << "	{\n";
		file << "		if (false == _rFFResponse.HasPattern (\"step *0:\"))\n";
		file << "			return po_goal_already_satisfied;\n";
		file << "		return po_plan_found;\n";
		file << "	}\n";
		file << "\n";
		file << "	else if (true == _rFFResponse.Has (\"ff: goal can be simplified to true. the empty plan solves it\"))\n";
		file << "		return po_goal_already_satisfied;\n";
		file << "\n";
		file << "	else if ((true == _rFFResponse.Has (\"ff: goal can be simplified to false. no plan will solve it\")) ||\n";
		file << "			(true == _rFFResponse.Has (\"problem unsolvable.\")) ||\n";
		file << "			(true == _rFFResponse.Has (\"problem proven unsolvable.\")))\n";
		file << "		return po_unsolvable;\n";
		file << "\n";
		file << "	else if (true == _rFFResponse.Has (\"[killed planner on timeout]\"))\n";
		file << "		return po_timeout;\n";
		file << "\n";
		file << "	else if ((true == _rFFResponse.Has (\"syntax error in line\")) ||\n";
		file << "			 (true == _rFFResponse.Has (\"undeclared predicate \")) ||\n";
		file << "			 (true == _rFFResponse.Has (\"undeclared predicate \")))\n";
		file << "		return po_syntax_error;\n";
		file << "	else if (true == _rFFResponse.Has (\" increase max_\"))\n";
		file << "	{\n";
		file << "		cerr << \"[WARNING] FF requests code change. -------------------\\n\"\n";
		file << "			 << _rFFResponse << '\\n'\n";
		file << "			 << \"------------------------------------------------------\\n\"\n";
		file << "			 << endl;\n";
		file << "		return po_ff_code_change_required;\n";
		file << "	}\n";
		file << "\n";
		file << "	cerr << \"[WARNING] Unknown planning outcome. ------------------\\n\"\n";
		file << "		 << _rFFResponse << '\\n'\n";
		file << "		 << \"------------------------------------------------------\\n\"\n";
		file << "		 << endl;\n";
		file << "	return po_unknown;\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String FFInterface::ExtractPlan (String& _rFFResponse)\n";
		file << "{\n";
		file << "	if (po_plan_found != FFInterface::FFExtractOutcome (_rFFResponse))\n";
		file << "		return \"\";\n";
		file << "\n";
		file << "	String_dq_t dqLines;\n";
		file << "	_rFFResponse.SplitLines (dqLines);\n";
		file << "\n";
		file << "	String sPlan;\n";
		file << "	bool bInPlan = false;\n";
		file << "	ITERATE (String_dq_t, dqLines, ite)\n";
		file << "	{\n";
		file << "		if ((true == ite->StartsWith (\"step \"))\n";
		file << "			&& (true == ite->Has (\":\")))\n";
		file << "			bInPlan = true;\n";
		file << "		if (false == ite->Has (\":\"))\n";
		file << "		{\n";
		file << "			bInPlan = false;\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "\n";
		file << "		if (true == bInPlan)\n";
		file << "		{\n";
		file << "			String_dq_t dqValues;\n";
		file << "			ite->Split (dqValues, ':');\n";
		file << "			dqValues [1].Strip ();\n";
		file << "\n";
		file << "			sPlan << dqValues [1] << '\\n';\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	sPlan.Strip ();\n";
		file << "	return sPlan;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "long FFInterface::StatesEvaluated (String& _rFFResponse)\n";
		file << "{\n";
		file << "	String_dq_t dqLines;\n";
		file << "	_rFFResponse.SplitLines (dqLines);\n";
		file << "\n";
		file << "	long lStates = -1;\n";
		file << "	ITERATE (String_dq_t, dqLines, ite)\n";
		file << "	{\n";
		file << "		if (false == ite->Has (\" searching, evaluating \"))\n";
		file << "			continue;\n";
		file << "		if (false == ite->Has (\" states, to a max depth of\"))\n";
		file << "			continue;\n";
		file << "\n";
		file << "		String_dq_t dqValues;\n";
		file << "		ite->SplitByString (dqValues, \", evaluating \");\n";
		file << "\n";
		file << "		lStates = dqValues [1];\n";
		file << "	}\n";
		file << "\n";
		file << "	return lStates;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool FFInterface::InitHeuristicEvaluator (void)\n";
		file << "{\n";
		file << "	String_dq_t dqLines;\n";
		file << "	if (false == File::ReadLines ((config)\"heuristic_evaluator_rules\", dqLines))\n";
		file << "		return false;\n";
		file << "\n";
		file << "	b_IgnoreNumericValues = (1 == (int)(config)\"ignore_predicate_numerics\");\n";
		file << "\n";
		file << "	String_set_t* psetCurrentPrerequisites = NULL;\n";
		file << "	String* pCurrentPlan = NULL;\n";
		file << "	ITERATE (String_dq_t, dqLines, ite)\n";
		file << "	{\n";
		file << "		ite->Strip ();\n";
		file << "		if (\"\" == *ite)\n";
		file << "			continue;\n";
		file << "		if (true == ite->StartsWith (\"#\"))\n";
		file << "			continue;\n";
		file << "\n";
		file << "		if (true == ite->StartsWith (\":\"))\n";
		file << "		{\n";
		file << "			String_dq_t dqTokens;\n";
		file << "			ite->Split (dqTokens);\n";
		file << "\n";
		file << "			PddlFunctionValuePredicate oPredicate;\n";
		file << "			oPredicate.c_Operator = '>';\n";
		file << "			oPredicate.b_IsFunction = true;\n";
		file << "			oPredicate.s_Name = \"thing-available\";\n";
		file << "			oPredicate.dq_Parameters.push_back (PddlParameter ());\n";
		file << "			oPredicate.dq_Parameters [0].SetValue (dqTokens [1]);\n";
		file << "			oPredicate.l_Value = (true == b_IgnoreNumericValues)? 0 : (int)dqTokens [2];\n";
		file << "\n";
		file << "			psetCurrentPrerequisites->insert (oPredicate.GetPddlString ());\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "\n";
		file << "		if (true == ite->StartsWith (\">>\"))\n";
		file << "		{\n";
		file << "			String_dq_t dqTokens;\n";
		file << "			ite->Split (dqTokens);\n";
		file << "\n";
		file << "			PddlFunctionValuePredicate oPredicate;\n";
		file << "			oPredicate.c_Operator = '>';\n";
		file << "			oPredicate.b_IsFunction = true;\n";
		file << "			oPredicate.s_Name = \"thing-available\";\n";
		file << "			oPredicate.dq_Parameters.push_back (PddlParameter ());\n";
		file << "			oPredicate.dq_Parameters [0].SetValue (dqTokens [1]);\n";
		file << "			oPredicate.l_Value = (true == b_IgnoreNumericValues)? 0 : (int)dqTokens [2];\n";
		file << "\n";
		file << "			// cout << \"  [\" << oPredicate.GetPddlString () << \"]\" << endl;\n";
		file << "			psetCurrentPrerequisites = new String_set_t;\n";
		file << "			hmp_GoalToPrerequisites.insert (make_pair (oPredicate.GetPddlString (),\n";
		file << "													   psetCurrentPrerequisites));\n";
		file << "			pCurrentPlan = new String;\n";
		file << "			hmp_GoalToPlan.insert (make_pair (oPredicate.GetPddlString (), pCurrentPlan));\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "\n";
		file << "		*pCurrentPlan << *ite << \"\\n\";\n";
		file << "	}\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void FFInterface::RunLocalHeuristicEvaluator (void)\n";
		file << "{\n";
		file << "	TaskIdToFFResponse_hmp_t hmpLocal;\n";
		file << "\n";
		file << "	pthread_mutex_lock (&mtx_TaskList);\n";
		file << "	ITERATE (TaskIdToFFResponse_hmp_t, hmp_TaskIdToFFResponse, ite)\n";
		file << "	{\n";
		file << "		FFResponse* pResponse = ite->second;\n";
		file << "		PddlProblem* pPddlProblem = PddlInterface::ParseProblemPddl (pResponse->s_Problem);\n";
		file << "		pResponse->e_PlanningOutcome = HasPrerequisites (*pPddlProblem,\n";
		file << "														 pResponse->s_Problem,\n";
		file << "														 pResponse->s_Plan);\n";
		file << "		delete pPddlProblem;\n";
		file << "\n";
		file << "		if (po_plan_found == pResponse->e_PlanningOutcome)\n";
		file << "			pResponse->l_States = 1;\n";
		file << "\n";
		file << "		hmpLocal.insert (make_pair (ite->first, pResponse));\n";
		file << "	}\n";
		file << "	hmp_TaskIdToFFResponse.clear ();\n";
		file << "	pthread_mutex_unlock (&mtx_TaskList);\n";
		file << "\n";
		file << "\n";
		file << "	ITERATE (TaskIdToFFResponse_hmp_t, hmpLocal, ite)\n";
		file << "	{\n";
		file << "		FFResponse* pResponse = ite->second;\n";
		file << "		p_Callback->OnFFResponse (ite->first, *pResponse);\n";
		file << "		delete pResponse;\n";
		file << "	}\n";
		file << "	hmpLocal.clear ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "FFPlaningOutcome_e FFInterface::HasPrerequisites (PddlProblem& _rPddlProblem,\n";
		file << "												  String& _rProblem,\n";
		file << "												  String& _rPlan)\n";
		file << "{\n";
		file << "	// first find prerequisites...\n";
		file << "	if (true == _rPddlProblem.o_PartialGoalState.dq_Predicates.empty ())\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Problem goal empty in FFInterface::HasPrerequisites.\" << endl;\n";
		file << "		return po_goal_already_satisfied;\n";
		file << "	}\n";
		file << "	if (_rPddlProblem.o_PartialGoalState.dq_Predicates.size () > 1)\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Problem goal has multiple predicates.\" << endl;\n";
		file << "		cout << _rPddlProblem.o_PartialGoalState.dq_Predicates.size () << endl;\n";
		file << "		return po_syntax_error;\n";
		file << "	}\n";
		file << "\n";
		file << "	PddlPredicate* pGoalPredicate = _rPddlProblem.o_PartialGoalState.dq_Predicates [0];\n";
		file << "	if (true == b_IgnoreNumericValues)\n";
		file << "		pGoalPredicate->l_Value = 0;\n";
		file << "	String sGoalPddl (pGoalPredicate->GetPddlString ());\n";
		file << "\n";
		file << "	GoalToPrerequisites_hmp_t::iterator	iteGoal;\n";
		file << "	iteGoal = hmp_GoalToPrerequisites.find (sGoalPddl);\n";
		file << "	if (hmp_GoalToPrerequisites.end () == iteGoal)\n";
		file << "	{\n";
		file << "		// cerr << \"[ERROR] Unknown goal predicate in FFInterface::HasPrerequisites : \"\n";
		file << "		//	 << pGoalPredicate->GetPddlString () << endl;\n";
		file << "		// return po_unsolvable;\n";
		file << "		return po_plan_found;\n";
		file << "	}\n";
		file << "\n";
		file << "	String_set_t* psetPrerequisites = iteGoal->second;\n";
		file << "\n";
		file << "	// cout << \"[goal] \" << sGoalPddl << \" \" << psetPrerequisites->size () << endl;\n";
		file << "\n";
		file << "	// check if prerequisites are satisfied...\n";
		file << "	String_set_t setSatisfiedPrerequisites;\n";
		file << "	ITERATE (PddlPredicate_dq_t, _rPddlProblem.o_StartState.dq_Predicates, ite)\n";
		file << "	{\n";
		file << "		PddlPredicate* pInitPredicate = *ite;\n";
		file << "		if ((true == b_IgnoreNumericValues) &&\n";
		file << "			(true == pInitPredicate->b_IsFunction))\n";
		file << "		{\n";
		file << "			if (pInitPredicate->l_Value > 0)\n";
		file << "			{\n";
		file << "				((PddlFunctionValuePredicate*)pInitPredicate)->c_Operator = '>';\n";
		file << "				pInitPredicate->l_Value = 0;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		String sInitPredicate (pInitPredicate->GetPddlString ());\n";
		file << "		if (psetPrerequisites->end () != psetPrerequisites->find (sInitPredicate))\n";
		file << "		{\n";
		file << "			// cout << \"      \" << sInitPredicate << endl;\n";
		file << "			setSatisfiedPrerequisites.insert (sInitPredicate);\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	if (psetPrerequisites->size () == setSatisfiedPrerequisites.size ())\n";
		file << "	{\n";
		file << "		GoalToPlan_hmp_t::iterator	itePlan;\n";
		file << "		itePlan = hmp_GoalToPlan.find (sGoalPddl);\n";
		file << "		if (hmp_GoalToPlan.end () == itePlan)\n";
		file << "		{\n";
		file << "			cerr << \"[ERROR] plan not found for solvable goal in FFInterface::HasPrerequisites.\"\n";
		file << "				 << endl;\n";
		file << "			return po_ff_code_change_required;\n";
		file << "		}\n";
		file << "\n";
		file << "		_rPlan = *itePlan->second;\n";
		file << "		return po_plan_found;\n";
		file << "	}\n";
		file << "	return po_unsolvable;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("FFInterface.h", ios_base::out);
		file << "#ifndef __FF_INTERFACE__\n";
		file << "#define __FF_INTERFACE__\n";
		file << "\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <nlp_socket.h>\n";
		file << "#include <hash_map>\n";
		file << "#include \"PddlInterface.h\"\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "class FFResponse;\n";
		file << "typedef hash_map <int, FFResponse*>			TaskIdToFFResponse_hmp_t;\n";
		file << "typedef hash_map <String, int>				CacheIdToTaskId_hmp_t;\n";
		file << "typedef hash_map <String, String_set_t*>	GoalToPrerequisites_hmp_t;\n";
		file << "typedef hash_map <String, String*>			GoalToPlan_hmp_t;\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "enum FFPlaningOutcome_e\n";
		file << "{\n";
		file << "	po_plan_found,\n";
		file << "	po_goal_already_satisfied,\n";
		file << "	po_unsolvable,\n";
		file << "	po_timeout,\n";
		file << "	po_syntax_error,\n";
		file << "	po_ff_code_change_required,\n";
		file << "	po_outside_known_world,\n";
		file << "	po_unknown\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class FFResponse\n";
		file << "{\n";
		file << "	public:\n";
		file << "		size_t				i_Domain;\n";
		file << "		String				s_Problem;\n";
		file << "\n";
		file << "		String				s_FFOutput;\n";
		file << "		String				s_EndStatePredicates;\n";
		file << "		String				s_Plan;\n";
		file << "		long				l_States;\n";
		file << "		FFPlaningOutcome_e	e_PlanningOutcome;\n";
		file << "\n";
		file << "		FFResponse (void)\n";
		file << "		{\n";
		file << "			l_States = -1;\n";
		file << "			e_PlanningOutcome = po_unknown;\n";
		file << "		};\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class FFCallback\n";
		file << "{\n";
		file << "	public:\n";
		file << "		virtual void OnFFResponse (int _iIndex, FFResponse& _rResponse) = 0;\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class FFInterface : public ClientSocket, private PddlInterface\n";
		file << "{\n";
		file << "	private:\n";
		file << "		static bool					b_Active;\n";
		file << "		static FFInterface*			p_FFInterface;\n";
		file << "\n";
		file << "		TaskIdToFFResponse_hmp_t	hmp_TaskIdToFFResponse;\n";
		file << "		Buffer						o_Data;\n";
		file << "		bool						b_KnownWorldOnly;\n";
		file << "\n";
		file << "		pthread_t					thr_SocketLoop;\n";
		file << "		pthread_mutex_t				mtx_TaskList;\n";
		file << "\n";
		file << "		FFCallback*					p_Callback;\n";
		file << "\n";
		file << "		GoalToPrerequisites_hmp_t	hmp_GoalToPrerequisites;\n";
		file << "		GoalToPlan_hmp_t			hmp_GoalToPlan;\n";
		file << "		bool						b_UseLocalHeuristicEvaluator;\n";
		file << "		bool						b_IgnoreNumericValues;\n";
		file << "\n";
		file << "		bool InitHeuristicEvaluator (void);\n";
		file << "		void RunLocalHeuristicEvaluator (void);\n";
		file << "		FFPlaningOutcome_e HasPrerequisites (PddlProblem& _rPddlProblem,\n";
		file << "											 String& _rProblem,\n";
		file << "											 String& _rPlan);\n";
		file << "		bool SendMessage (const String& _rMessage);\n";
		file << "		bool SendMessage (const Buffer& _rMessage);\n";
		file << "\n";
		file << "	public:\n";
		file << "		FFInterface (void);\n";
		file << "		~FFInterface (void);\n";
		file << "\n";
		file << "		bool Connect (void);\n";
		file << "		void Disconnect (void);\n";
		file << "		void SetCallback (FFCallback* _pCallback)\n";
		file << "		{ p_Callback = _pCallback; };\n";
		file << "\n";
		file << "		long RegisterDomain (String& _rDomain);\n";
		file << "		bool SendTask (size_t _iId,\n";
		file << "					   size_t _iDomain,\n";
		file << "					   String& _rProblem,\n";
		file << "					   size_t _iTimelimit);\n";
		file << "		void ClearTasks (void);\n";
		file << "		bool TestTasksClear (void);\n";
		file << "\n";
		file << "		//\n";
		file << "		void OnReceive (const void* _zData, long _lBytes);\n";
		file << "		void OnDisconnect (void);\n";
		file << "		void ClearConnection (void);\n";
		file << "\n";
		file << "		//\n";
		file << "		static FFPlaningOutcome_e FFExtractOutcome (String& _rFFResponse);\n";
		file << "		static String ExtractPlan (String& _rFFResponse);\n";
		file << "		static long StatesEvaluated (String& _rFFResponse);\n";
		file << "\n";
		file << "		//\n";
		file << "		static void* RunThread (void* _pArg);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file.close ();
	}



	{
		ofstream file ("Zlib.cpp", ios_base::out);
		file << "#include \"Zlib.h\"\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool ZlibWrapper::Compress (const String& _rState,\n";
		file << "							Buffer* _pBuffer)\n";
		file << "{\n";
		file << "	int iLength = _rState.length () + 1;\n";
		file << "	uLongf iCompressedLength = compressBound (iLength);\n";
		file << "	char pCompressed [iCompressedLength];\n";
		file << "	int iRet = compress2 ((Bytef*)pCompressed,\n";
		file << "						  &iCompressedLength,\n";
		file << "						  (const Bytef*)(const char*)_rState,\n";
		file << "						  iLength,\n";
		file << "						  9);\n";
		file << "	if (Z_OK != iRet)\n";
		file << "		return false;\n";
		file << "\n";
		file << "	_pBuffer->SetData (pCompressed, iCompressedLength);\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool ZlibWrapper::Uncompress (const Buffer& _rBuffer,\n";
		file << "							  int _iUncompressedLength,\n";
		file << "							  String* _pText)\n";
		file << "{\n";
		file << "	char pUncompressed [_iUncompressedLength];\n";
		file << "	uLongf iUncompressedLength = _iUncompressedLength;\n";
		file << "	int iRet = uncompress ((Bytef*) pUncompressed,\n";
		file << "							&iUncompressedLength,\n";
		file << "							(Bytef*) ((Buffer&)_rBuffer).GetData (),\n";
		file << "							_rBuffer.Length ());\n";
		file << "	if (Z_OK != iRet)\n";
		file << "	{\n";
		file << "		if (Z_MEM_ERROR == iRet)\n";
		file << "			cerr << \"[ERROR] ZlibWrapper::Uncompress failed - Not enough memory.\"\n";
		file << "				 << endl;\n";
		file << "		else if (Z_BUF_ERROR == iRet)\n";
		file << "			cerr << \"[ERROR] ZlibWrapper::Uncompress failed - Output buffer too small.\"\n";
		file << "				 << endl;\n";
		file << "		else if (Z_DATA_ERROR == iRet)\n";
		file << "			cerr << \"[ERROR] ZlibWrapper::Uncompress failed - Data corrupted or incomplete.\"\n";
		file << "				 << endl;\n";
		file << "		else\n";
		file << "			cerr << \"[ERROR] ZlibWrapper::Uncompress failed - Unknown error.\"\n";
		file << "				 << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	assert (iUncompressedLength == (uLongf)_iUncompressedLength);\n";
		file << "	*_pText = pUncompressed;\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("Learner.cpp", ios_base::out);
		file << "#include \"Learner.h\"\n";
		file << "#include \"Problems.h\"\n";
		file << "#include <stdio.h>\n";
		file << "#include <limits.h>\n";
		file << "#include <iomanip>\n";
		file << "#include <omp.h>\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const SubgoalSequence& _rSequence)\n";
		file << "{\n";
		file << "	bool bFirst = true;\n";
		file << "	CONST_ITERATE (Subgoal_dq_t, _rSequence.dq_Subgoals, ite)\n";
		file << "	{\n";
		file << "		const Subgoal& rSubgoal = *ite;\n";
		file << "		if (SEQUENCE_END == rSubgoal.i_SequenceEnd)\n";
		file << "			continue;\n";
		file << "		if (false == bFirst)\n";
		file << "			_rStream << \" | \";\n";
		file << "		bFirst = false;\n";
		file << "		_rStream << rSubgoal.p_PddlSubgoalPredicate->GetPddlString ();\n";
		file << "		switch (rSubgoal.e_PlanningOutcome)\n";
		file << "		{\n";
		file << "			case po_plan_found:\n";
		file << "				_rStream << \"|plan-found\";\n";
		file << "				break;\n";
		file << "			case po_goal_already_satisfied:\n";
		file << "				_rStream << \"|trivial-goal\";\n";
		file << "				break;\n";
		file << "			case po_unsolvable:\n";
		file << "				_rStream << \"|unsolvable\";\n";
		file << "				break;\n";
		file << "			case po_timeout:\n";
		file << "				_rStream << \"|timeout\";\n";
		file << "				break;\n";
		file << "			case po_syntax_error:\n";
		file << "				_rStream << \"|pdd-syntax-error\";\n";
		file << "				break;\n";
		file << "			case po_ff_code_change_required:\n";
		file << "				_rStream << \"|ff-code-change\";\n";
		file << "				break;\n";
		file << "			case po_outside_known_world:\n";
		file << "				_rStream << \"|outside-known-world\";\n";
		file << "				break;\n";
		file << "			default:\n";
		file << "				_rStream << \"|<?\?>\";\n";
		file << "		}\n";
		file << "	}\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "SubgoalLearner::SubgoalLearner (void)\n";
		file << "{\n";
		file << "	pthread_mutex_init (&mtx_WaitForSequences, NULL);\n";
		file << "	pthread_cond_init (&cv_WaitForSequences, NULL);\n";
		file << "	p_PddlDomain = NULL;\n";
		file << "}\n";
		file << "\n";
		file << "SubgoalLearner::~SubgoalLearner (void)\n";
		file << "{\n";
		file << "	pthread_mutex_destroy (&mtx_WaitForSequences);\n";
		file << "	pthread_cond_destroy (&cv_WaitForSequences);\n";
		file << "	delete p_PddlDomain;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalLearner::Init (void)\n";
		file << "{\n";
		file << "	d_TaskCompletionReward = (config)\"task_completion_reward\";\n";
		file << "	d_PlanFailureReward = (config)\"plan_failure_penalty\";\n";
		file << "	d_SuccessfulStepRewardBase = (config)\"successful_step_reward_base\";\n";
		file << "	d_UnnecessarySubgoalPenalty = (config)\"unnecessary_subgoal_penalty\";\n";
		file << "	d_RewardForHittingCachePeriphery = (config)\"reward_for_hitting_cache_periphery\";\n";
		file << "	i_SequencesOnFirstIteration = (config)\"sequences_on_first_iteration\";\n";
		file << "	i_SequencesPerIteration = (config)\"sequences_per_iteration\";\n";
		file << "\n";
		file << "	i_TrainingTimeFFTimelimit = (config)\"training_time_ff_time_limit\";\n";
		file << "	i_TestTimeFFTimelimit = (config)\"test_time_ff_time_limit\";\n";
		file << "\n";
		file << "	b_LearnFromAlternateSequences = (1 == (int)(config)\"learn_from_alternate_sequences\");\n";
		file << "	b_LearnOnSubgoalFreeProblems = (1 == (int)(config)\"learn_on_subgoal_free_problems\");\n";
		file << "	b_RememberSolutions = (1 == (int)(config)\"remember_solutions\");\n";
		file << "	b_DisplayFFProgress = (1 == (int)(config)\"display_ff_progress\");\n";
		file << "	b_LogPredictions = (1 == (int)(config)\"log_predictions\");\n";
		file << "	b_UseLocalHeuristicEvaluator = (1 == (int)(config)\"use_local_heuristic_evaluator\");\n";
		file << "\n";
		file << "	assert (Problem::GetProblemCount () > 0);\n";
		file << "	vec_TargetGoalCompletions.Create (Problem::GetProblemCount ());\n";
		file << "\n";
		file << "	if (false == o_SubgoalPolicy.Init ())\n";
		file << "		return false;\n";
		file << "	o_FFInterface.SetCallback (this);\n";
		file << "	if (false == o_FFInterface.Connect ())\n";
		file << "		return false;\n";
		file << "\n";
		file << "	String_dq_t dqLines;\n";
		file << "	if (false == File::ReadLines ((config)\"domain_pddl_file\", dqLines))\n";
		file << "		return false;\n";
		file << "\n";
		file << "	String sDomainPddl;\n";
		file << "	sDomainPddl.Join (dqLines, '\\n');\n";
		file << "	p_PddlDomain = PddlInterface::ParseDomainPddl (sDomainPddl);\n";
		file << "\n";
		file << "	i_DomainPddlId = o_FFInterface.RegisterDomain (sDomainPddl);\n";
		file << "	return (-1 != i_DomainPddlId);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalLearner::OnFFResponse (int _iIndex, FFResponse& _rResponse)\n";
		file << "{\n";
		file << "	pthread_mutex_lock (&mtx_WaitForSequences);\n";
		file << "	if (true == b_DisplayFFProgress)\n";
		file << "		cout << \"\\x08 \\x08\" << flush;\n";
		file << "\n";
		file << "	// keep count of the types of responses...\n";
		file << "	switch (_rResponse.e_PlanningOutcome)\n";
		file << "	{\n";
		file << "		case po_plan_found:\n";
		file << "			++ i_OutcomePlansFound;\n";
		file << "			break;\n";
		file << "		case po_goal_already_satisfied:\n";
		file << "			++ i_OutcomeGoalsAlreadySatisfied;\n";
		file << "			break;\n";
		file << "		case po_unsolvable:\n";
		file << "			++ i_OutcomeUnsolvable;\n";
		file << "			break;\n";
		file << "		case po_timeout:\n";
		file << "			++ i_OutcomeTimeouts;\n";
		file << "			break;\n";
		file << "		case po_syntax_error:\n";
		file << "			++ i_OutcomeSyntaxError;\n";
		file << "			break;\n";
		file << "		case po_outside_known_world:\n";
		file << "			++ i_OutcomeOutsideKnownWorld;\n";
		file << "			break;\n";
		file << "		case po_unknown:\n";
		file << "			++ i_OutcomeUnknown;\n";
		file << "			break;\n";
		file << "		default:\n";
		file << "			;\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	// find the sequence for this response...\n";
		file << "	IndexToSubgoalSequenceState_hmp_t::iterator	ite;\n";
		file << "	ite = hmp_IndexToSequenceState.find (_iIndex);\n";
		file << "	if (hmp_IndexToSequenceState.end () == ite)\n";
		file << "	{\n";
		file << "		cerr << \"   [EE] Sequence state index [\" << _iIndex\n";
		file << "			 << \"] not found in Callback.\" << endl;\n";
		file << "		return;\n";
		file << "	}\n";
		file << "	SubgoalSequenceState& rState = ite->second;\n";
		file << "	Subgoal* pLastSubgoal = rState.p_Sequence->GetSubgoal (rState.i_CurrentStep);\n";
		file << "	pLastSubgoal->e_PlanningOutcome = _rResponse.e_PlanningOutcome;\n";
		file << "\n";
		file << "\n";
		file << "	// check for syntax error responses ...\n";
		file << "	if (po_syntax_error == _rResponse.e_PlanningOutcome)\n";
		file << "	{\n";
		file << "		Subgoal* pSubgoal = rState.p_Sequence->GetSubgoal (rState.i_CurrentStep);\n";
		file << "		cout << \"\\n[WARNING] Syntax error ---------------------------\\n\"\n";
		file << "			 << _rResponse.s_FFOutput << '\\n'\n";
		file << "			 << \"----------------------------------------------------\\n\"\n";
		file << "			 << pSubgoal->s_ProblemPddl << '\\n'\n";
		file << "			 << \"----------------------------------------------------\\n\"\n";
		file << "			 << endl;\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	// stop this sequence we couldn't find a plan ...\n";
		file << "	if ((po_plan_found != _rResponse.e_PlanningOutcome) &&\n";
		file << "		(po_goal_already_satisfied != _rResponse.e_PlanningOutcome))\n";
		file << "	{\n";
		file << "		f_TotalPlanDepthReached += rState.i_CurrentStep\n";
		file << "									/ (float) rState.p_Sequence->Length ();\n";
		file << "\n";
		file << "		set_PendingSequences.erase (_iIndex);\n";
		file << "\n";
		file << "		if (true == set_PendingSequences.empty ())\n";
		file << "			pthread_cond_signal (&cv_WaitForSequences);\n";
		file << "		pthread_mutex_unlock (&mtx_WaitForSequences);\n";
		file << "		return;\n";
		file << "	}\n";
		file << "\n";
		file << "	// Compute the end state of the plan for this subgoal.\n";
		file << "	// We need this to test the next subgoal...\n";
		file << "	{\n";
		file << "		if (true == b_UseLocalHeuristicEvaluator)\n";
		file << "		{\n";
		file << "			PddlState& rInitState\n";
		file << "				= pLastSubgoal->p_PddlProblem->o_StartState;\n";
		file << "			PddlPredicate_dq_t& rdqPredicatesToSet\n";
		file << "				= pLastSubgoal->p_PddlProblem->o_PartialGoalState.dq_Predicates;\n";
		file << "\n";
		file << "			// most of our subgoal predicates are of the form\n";
		file << "			// (> (thing-available x) n).  In this case, l_Value\n";
		file << "			// is actually n, and we need to increment it to\n";
		file << "			// n+1 to make sure the end-state computation is\n";
		file << "			// correct...\n";
		file << "			ITERATE (PddlPredicate_dq_t, rdqPredicatesToSet, ite)\n";
		file << "			{\n";
		file << "				PddlPredicate* pToSet = *ite;\n";
		file << "				if (false == pToSet->b_IsFunction)\n";
		file << "					continue;\n";
		file << "				if ('>' != ((PddlFunctionValuePredicate*)pToSet)->c_Operator)\n";
		file << "					continue;\n";
		file << "				++ pToSet->l_Value;\n";
		file << "			}\n";
		file << "\n";
		file << "			// cout << \"=========================================\" << endl;\n";
		file << "			// cout << _iIndex << endl;\n";
		file << "			// cout << pLastSubgoal->p_PddlProblem->o_PartialGoalState << endl;\n";
		file << "\n";
		file << "			PddlState* pEndState\n";
		file << "				= PddlInterface::ComputeApproximateFutureInit (rInitState,\n";
		file << "															   rdqPredicatesToSet);\n";
		file << "			_rResponse.s_EndStatePredicates = pEndState->GetPredicatePddlString ();\n";
		file << "\n";
		file << "\n";
		file << "			//cout << pLastSubgoal->p_PddlProblem->o_PartialGoalState << endl;\n";
		file << "			//cout << \"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\" << endl;\n";
		file << "			//cout << rInitState << endl;\n";
		file << "			//cout << \"-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\" << endl;\n";
		file << "			//cout << *pEndState << endl;\n";
		file << "			//cout << \"=========================================\" << endl;\n";
		file << "			delete pEndState;\n";
		file << "		}\n";
		file << "\n";
		file << "		else if (po_goal_already_satisfied != _rResponse.e_PlanningOutcome)\n";
		file << "		{\n";
		file << "			PddlPlan* pPddlPlan = PddlInterface::ParsePlan (*p_PddlDomain,\n";
		file << "															_rResponse.s_Plan);\n";
		file << "\n";
		file << "			PddlPredicate_dq_t* pdqPredicates = new PddlPredicate_dq_t;\n";
		file << "			rState.dq_PlanSubgoalSequences.push_back (pdqPredicates);\n";
		file << "			PddlState* pEndState\n";
		file << "				= PddlInterface::ComputeEndStateFast (*pLastSubgoal->p_PddlProblem,\n";
		file << "													  *pPddlPlan,\n";
		file << "													  *pdqPredicates);\n";
		file << "\n";
		file << "			_rResponse.s_EndStatePredicates = pEndState->GetPredicatePddlString ();\n";
		file << "\n";
		file << "			delete pEndState;\n";
		file << "			delete pPddlPlan;\n";
		file << "		}\n";
		file << "\n";
		file << "		else\n";
		file << "		{\n";
		file << "			_rResponse.s_EndStatePredicates\n";
		file << "				= pLastSubgoal->p_PddlProblem->o_StartState.GetPredicatePddlString ();\n";
		file << "\n";
		file << "			PddlPredicate_dq_t* pdqPredicates = new PddlPredicate_dq_t;\n";
		file << "			rState.dq_PlanSubgoalSequences.push_back (pdqPredicates);\n";
		file << "		}\n";
		file << "	}\n";
		file << "	delete pLastSubgoal->p_PddlProblem;\n";
		file << "	pLastSubgoal->p_PddlProblem = NULL;\n";
		file << "	rState.p_Sequence->SetSubtaskFFResponse (rState.i_CurrentStep, _rResponse);\n";
		file << "\n";
		file << "\n";
		file << "	// check for task completion ...\n";
		file << "	if (true == pLastSubgoal->b_IsLastSubgoalToTarget)\n";
		file << "	{\n";
		file << "		// this sequence is gets us to the target goal !!\n";
		file << "		f_TotalPlanDepthReached += 1;\n";
		file << "		vec_TargetGoalCompletions [rState.i_ProblemId] = 1;\n";
		file << "\n";
		file << "		rState.b_TaskComplete = true;\n";
		file << "		Problem* pProblem = Problem::GetProblem (rState.i_ProblemId);\n";
		file << "		if (true == rState.b_FullTask)\n";
		file << "			pProblem->b_SubgoalsNotNeeded = true;\n";
		file << "\n";
		file << "		set_PendingSequences.erase (_iIndex);\n";
		file << "\n";
		file << "		if (true == set_PendingSequences.empty ())\n";
		file << "			pthread_cond_signal (&cv_WaitForSequences);\n";
		file << "		pthread_mutex_unlock (&mtx_WaitForSequences);\n";
		file << "		return;\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	// Get the next subtask....\n";
		file << "	String sProblemPddl;\n";
		file << "	if (false == rState.p_Sequence->GetSubtask (++ rState.i_CurrentStep,\n";
		file << "											    &sProblemPddl))\n";
		file << "	{\n";
		file << "		// we have already checked for task completion,\n";
		file << "		// so we should never get to this code point...\n";
		file << "		assert (false);\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	sProblemPddl.Strip ();\n";
		file << "	if (\"\" == sProblemPddl)\n";
		file << "	{\n";
		file << "		cout << \"[ERROR] problem pddl is empty in OnFFResponse ()!\" << endl;\n";
		file << "		if (po_goal_already_satisfied == _rResponse.e_PlanningOutcome)\n";
		file << "			cout << \"        previous problem had 0 length plan.\" << endl;\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	// send out the subtask to FF...\n";
		file << "	PddlProblem* pPddlProblem = PddlInterface::ParseProblemPddl (sProblemPddl);\n";
		file << "	rState.p_Sequence->SetSubtask (rState.i_CurrentStep,\n";
		file << "								   sProblemPddl,\n";
		file << "								   pPddlProblem);\n";
		file << "\n";
		file << "	pthread_mutex_unlock (&mtx_WaitForSequences);\n";
		file << "\n";
		file << "	++ i_TotalPlanJobs;\n";
		file << "	o_FFInterface.SendTask (_iIndex,\n";
		file << "							i_DomainPddlId,\n";
		file << "							sProblemPddl,\n";
		file << "							i_CurrentFFTimelimit);\n";
		file << "	if (true == b_DisplayFFProgress)\n";
		file << "		cout << '.' << flush;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double SubgoalLearner::ComputeReward (SubgoalSequenceState& _rState)\n";
		file << "{\n";
		file << "	assert (false == _rState.p_Sequence->dq_Subgoals.empty ());\n";
		file << "\n";
		file << "	double dReward = 0;\n";
		file << "	bool bTaskComplete = true;\n";
		file << "\n";
		file << "	ITERATE (Subgoal_dq_t, _rState.p_Sequence->dq_Subgoals, ite)\n";
		file << "	{\n";
		file << "		Subgoal& rSubgoal = *ite;\n";
		file << "		if (SEQUENCE_END == rSubgoal.i_SequenceEnd)\n";
		file << "			continue;\n";
		file << "\n";
		file << "		if (po_ff_code_change_required == rSubgoal.e_PlanningOutcome)\n";
		file << "		{\n";
		file << "			// if FF asked for a code change, we don't know\n";
		file << "			// the correct outcome, so don't learn on this...\n";
		file << "			_rState.d_Reward = 0;\n";
		file << "			return 0;\n";
		file << "		}\n";
		file << "\n";
		file << "		if ((po_plan_found != rSubgoal.e_PlanningOutcome) &&\n";
		file << "			(po_goal_already_satisfied != rSubgoal.e_PlanningOutcome))\n";
		file << "		{\n";
		file << "			bTaskComplete = false;\n";
		file << "			break;\n";
		file << "		}\n";
		file << "\n";
		file << "		if (po_goal_already_satisfied  == rSubgoal.e_PlanningOutcome)\n";
		file << "			dReward -= d_UnnecessarySubgoalPenalty;\n";
		file << "		else if (po_plan_found == rSubgoal.e_PlanningOutcome)\n";
		file << "			dReward += d_SuccessfulStepRewardBase;\n";
		file << "		else if (po_outside_known_world == rSubgoal.e_PlanningOutcome)\n";
		file << "			dReward += d_RewardForHittingCachePeriphery;\n";
		file << "	}\n";
		file << "\n";
		file << "	_rState.d_Reward = dReward;\n";
		file << "	if (true == bTaskComplete)\n";
		file << "		_rState.d_Reward += d_TaskCompletionReward;\n";
		file << "	else\n";
		file << "		_rState.d_Reward -= d_PlanFailureReward;\n";
		file << "\n";
		file << "	return _rState.d_Reward;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalLearner::TrimPlanSubgoalSequences (PlanSubgoalSequences_dq_t& _rdqPlanSubgoals)\n";
		file << "{\n";
		file << "	ITERATE (PlanSubgoalSequences_dq_t, _rdqPlanSubgoals, iteSequence)\n";
		file << "	{\n";
		file << "		PddlPredicate_dq_t* pdqOld = *iteSequence;\n";
		file << "		PddlPredicate_dq_t* pdqNew = new PddlPredicate_dq_t;\n";
		file << "		*iteSequence = pdqNew;\n";
		file << "\n";
		file << "		PddlPredicate* pLastPred = NULL;\n";
		file << "		ITERATE (PddlPredicate_dq_t, (*pdqOld), ite)\n";
		file << "		{\n";
		file << "			PddlPredicate* pPred = *ite;\n";
		file << "			bool bSkipThisPredicate\n";
		file << "				= (NULL == o_SubgoalPolicy.FindEquivalentPredicateCandidate (*pPred));\n";
		file << "			if ((NULL != pLastPred) &&\n";
		file << "				(true == pPred->b_IsFunction) &&\n";
		file << "				(true == pLastPred->b_IsFunction))\n";
		file << "			{\n";
		file << "				// check if the current predicate is the\n";
		file << "				// same as the last one (with different value)\n";
		file << "				if (*pPred == *pLastPred)\n";
		file << "					bSkipThisPredicate = true;\n";
		file << "			}\n";
		file << "\n";
		file << "			if (true == bSkipThisPredicate)\n";
		file << "				delete pPred;\n";
		file << "			else\n";
		file << "			{\n";
		file << "				pdqNew->push_back (pPred);\n";
		file << "				pLastPred = pPred;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		delete pdqOld;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalLearner::ProposeAlternateSequences (SubgoalSequenceState& _rState,\n";
		file << "										SubgoalSequence_dq_t& _rdqAlternateSequences)\n";
		file << "{\n";
		file << "	if (true == _rState.dq_PlanSubgoalSequences.empty ())\n";
		file << "		return;\n";
		file << "	assert (_rState.p_Sequence->dq_Subgoals.size () - 1\n";
		file << "			>= _rState.dq_PlanSubgoalSequences.size ());\n";
		file << "\n";
		file << "	TrimPlanSubgoalSequences (_rState.dq_PlanSubgoalSequences);\n";
		file << "\n";
		file << "	SubgoalSequence* pNewSequence = new SubgoalSequence;\n";
		file << "	_rdqAlternateSequences.push_back (pNewSequence);\n";
		file << "	pNewSequence->s_ProblemPddlPreamble = _rState.p_Sequence->s_ProblemPddlPreamble;\n";
		file << "	pNewSequence->p_TargetProblem = _rState.p_Sequence->p_TargetProblem;\n";
		file << "\n";
		file << "	Subgoal& rObservedLastSubgoal = _rState.p_Sequence->dq_Subgoals.back ();\n";
		file << "	#ifndef NDEBUG\n";
		file << "	bool bPlanFound = ((po_plan_found == rObservedLastSubgoal.e_PlanningOutcome) ||\n";
		file << "					   (po_goal_already_satisfied == rObservedLastSubgoal.e_PlanningOutcome));\n";
		file << "	assert (false == (bPlanFound ^ _rState.b_TaskComplete));\n";
		file << "	#endif\n";
		file << "\n";
		file << "	// SEQUENCE_END subgoal...\n";
		file << "	{\n";
		file << "		Subgoal* pSubgoal = pNewSequence->AddSubgoalToBack ();\n";
		file << "		pSubgoal->i_SequenceEnd = SEQUENCE_END;\n";
		file << "	}\n";
		file << "\n";
		file << "	// subgoals ...\n";
		file << "	Subgoal* pSubgoal = NULL;\n";
		file << "	{\n";
		file << "		ITERATE (PlanSubgoalSequences_dq_t, _rState.dq_PlanSubgoalSequences, ite)\n";
		file << "		{\n";
		file << "			PddlPredicate_dq_t* pdqPlanSubgoals = *ite;\n";
		file << "			ITERATE (PddlPredicate_dq_t, (*pdqPlanSubgoals), iteSubgoal)\n";
		file << "			{\n";
		file << "				PddlPredicate* pEquivalentCandidate\n";
		file << "					= o_SubgoalPolicy.FindEquivalentPredicateCandidate (**iteSubgoal);\n";
		file << "				if (NULL == pEquivalentCandidate)\n";
		file << "					continue;\n";
		file << "\n";
		file << "				pSubgoal = pNewSequence->AddSubgoalToBack ();\n";
		file << "				pSubgoal->i_SequenceEnd = 0;\n";
		file << "				pSubgoal->b_IsLastSubgoalToTarget = false;\n";
		file << "				pSubgoal->i_SubgoalSelection = pEquivalentCandidate->i_PredicateCandidateIndex;\n";
		file << "				pSubgoal->p_PddlSubgoalPredicate = pEquivalentCandidate;\n";
		file << "				pSubgoal->e_PlanningOutcome = po_plan_found;\n";
		file << "			}\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	// target subgoal...\n";
		file << "	if ((po_plan_found == rObservedLastSubgoal.e_PlanningOutcome) ||\n";
		file << "		(po_goal_already_satisfied == rObservedLastSubgoal.e_PlanningOutcome))\n";
		file << "	{\n";
		file << "		if ((NULL != pSubgoal) &&\n";
		file << "			(pSubgoal->i_SubgoalSelection == rObservedLastSubgoal.i_SubgoalSelection))\n";
		file << "		{\n";
		file << "			pSubgoal->b_IsLastSubgoalToTarget = true;\n";
		file << "			pSubgoal->p_PddlSubgoalPredicate = rObservedLastSubgoal.p_PddlSubgoalPredicate;\n";
		file << "			pSubgoal->p_PddlTargetProblem = rObservedLastSubgoal.p_PddlTargetProblem;\n";
		file << "			pSubgoal->e_PlanningOutcome = rObservedLastSubgoal.e_PlanningOutcome;\n";
		file << "		}\n";
		file << "		else\n";
		file << "		{\n";
		file << "			Subgoal* pSubgoal = pNewSequence->AddSubgoalToBack ();\n";
		file << "			pSubgoal->i_SequenceEnd = 0;\n";
		file << "			pSubgoal->b_IsLastSubgoalToTarget = true;\n";
		file << "			pSubgoal->i_SubgoalSelection = rObservedLastSubgoal.i_SubgoalSelection;\n";
		file << "			pSubgoal->p_PddlSubgoalPredicate = rObservedLastSubgoal.p_PddlSubgoalPredicate;\n";
		file << "			pSubgoal->p_PddlTargetProblem = rObservedLastSubgoal.p_PddlTargetProblem;\n";
		file << "			pSubgoal->e_PlanningOutcome = rObservedLastSubgoal.e_PlanningOutcome;\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalLearner::TryPlanningOnFullTasks (void)\n";
		file << "{\n";
		file << "	vec_TargetGoalCompletions.Memset (0);\n";
		file << "	i_TotalPlanJobs = 0;\n";
		file << "	i_OutcomePlansFound = 0;\n";
		file << "	i_OutcomeGoalsAlreadySatisfied = 0;\n";
		file << "	i_OutcomeUnsolvable = 0;\n";
		file << "	i_OutcomeSyntaxError = 0;\n";
		file << "	i_OutcomeTimeouts = 0;\n";
		file << "	i_OutcomeOutsideKnownWorld = 0;\n";
		file << "	i_OutcomeUnknown = 0;\n";
		file << "	f_TotalPlanDepthReached = 0;\n";
		file << "\n";
		file << "	i_CurrentFFTimelimit = i_TrainingTimeFFTimelimit;\n";
		file << "\n";
		file << "	// These flags are supposed to be randomly\n";
		file << "	// sampled. But on the first iteration we\n";
		file << "	// set them to true to force some learning.\n";
		file << "	o_SubgoalPolicy.ForceConnectionUseFlags ();\n";
		file << "\n";
		file << "	o_SubgoalPolicy.SampleConnections (false);\n";
		file << "	for (int d = 0; d < Problem::GetProblemCount (); ++ d)\n";
		file << "	{\n";
		file << "		Problem* pProblem = Problem::GetProblem (d);\n";
		file << "		SubgoalSequence* pSequence = new SubgoalSequence;\n";
		file << "		pSequence->s_ProblemPddlPreamble = pProblem->s_PddlPreamble;\n";
		file << "\n";
		file << "		pSequence->p_TargetProblem = pProblem;\n";
		file << "		o_SubgoalPolicy.SampleZeroSubgoalSequence (*pProblem, pSequence);\n";
		file << "\n";
		file << "		// The PddlProblem we pass into SetSubtask is deleted\n";
		file << "		// when the pSequence is deleted at the end of this\n";
		file << "		// learning iteration.  So we need to make a copy of the\n";
		file << "		// PddlProblem here...\n";
		file << "		PddlProblem* pPddlProblem = new PddlProblem (pProblem->GetPddlProblem ());\n";
		file << "		pSequence->SetSubtask (1, pProblem->s_Problem, pPddlProblem);\n";
		file << "\n";
		file << "		++ i_TotalPlanJobs;\n";
		file << "		int iIndex = d;\n";
		file << "\n";
		file << "		pthread_mutex_lock (&mtx_WaitForSequences);\n";
		file << "		pair <IndexToSubgoalSequenceState_hmp_t::iterator, bool> pairInsert;\n";
		file << "		pairInsert = hmp_IndexToSequenceState.insert (make_pair (iIndex,\n";
		file << "										 SubgoalSequenceState (pSequence, 1, d)));\n";
		file << "		SubgoalSequenceState& rState = pairInsert.first->second;\n";
		file << "		rState.b_FullTask = true;\n";
		file << "		rState.p_TargetProblem = pProblem;\n";
		file << "		set_PendingSequences.insert (iIndex);\n";
		file << "		pthread_mutex_unlock (&mtx_WaitForSequences);\n";
		file << "\n";
		file << "\n";
		file << "		o_FFInterface.SendTask (iIndex,\n";
		file << "								i_DomainPddlId,\n";
		file << "								pProblem->s_Problem,\n";
		file << "								i_CurrentFFTimelimit);\n";
		file << "		if (true == b_DisplayFFProgress)\n";
		file << "			cout << '.' << flush;\n";
		file << "	}\n";
		file << "\n";
		file << "	// condition wait for sequences to complete...\n";
		file << "	pthread_mutex_lock (&mtx_WaitForSequences);\n";
		file << "	pthread_cond_wait (&cv_WaitForSequences, &mtx_WaitForSequences);\n";
		file << "	pthread_mutex_unlock (&mtx_WaitForSequences);\n";
		file << "\n";
		file << "	// update parameters ...\n";
		file << "	double dTotalReward = 0;\n";
		file << "	long lTotalLength = 0;\n";
		file << "	int iCount = 0;\n";
		file << "	long lTotalAltenateLength = 0;\n";
		file << "	int iAlternateCount = 0;\n";
		file << "\n";
		file << "	o_SubgoalPolicy.InitUpdate ();\n";
		file << "	ITERATE (IndexToSubgoalSequenceState_hmp_t, hmp_IndexToSequenceState, ite)\n";
		file << "	{\n";
		file << "		SubgoalSequenceState& rState = ite->second;\n";
		file << "		double dReward = ComputeReward (rState);\n";
		file << "		dTotalReward += dReward;\n";
		file << "		++ iCount;\n";
		file << "\n";
		file << "		lTotalLength += rState.p_Sequence->dq_Subgoals.size () - 1;\n";
		file << "		if ((true == b_LearnOnSubgoalFreeProblems) ||\n";
		file << "			(false == rState.p_TargetProblem->b_SubgoalsNotNeeded))\n";
		file << "		{\n";
		file << "			o_SubgoalPolicy.UpdateParameters (*rState.p_Sequence,\n";
		file << "											  dReward,\n";
		file << "											  rState.b_TaskComplete,\n";
		file << "											  true);\n";
		file << "			//o_SubgoalPolicy.UpdateParameters (*rState.p_Sequence,\n";
		file << "			//								  dReward,\n";
		file << "			//								  rState.b_TaskComplete,\n";
		file << "			//								  false);\n";
		file << "\n";
		file << "			if ((true == b_LearnFromAlternateSequences) &&\n";
		file << "				(true == rState.b_TaskComplete))\n";
		file << "			{\n";
		file << "				SubgoalSequence_dq_t dqAlternates;\n";
		file << "				ProposeAlternateSequences (rState, dqAlternates);\n";
		file << "				ITERATE (SubgoalSequence_dq_t, dqAlternates, iteAlternate)\n";
		file << "				{\n";
		file << "					SubgoalSequence* pAlternate = *iteAlternate;\n";
		file << "					lTotalAltenateLength += pAlternate->dq_Subgoals.size ();\n";
		file << "					++ iAlternateCount;\n";
		file << "					o_SubgoalPolicy.UpdateParameters (*pAlternate,\n";
		file << "													  dReward,\n";
		file << "													  rState.b_TaskComplete,\n";
		file << "													  true);\n";
		file << "					//o_SubgoalPolicy.UpdateParameters (*pAlternate,\n";
		file << "					//								  dReward,\n";
		file << "					//								  rState.b_TaskComplete,\n";
		file << "					//								  false);\n";
		file << "					delete *iteAlternate;\n";
		file << "				}\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		if (true == rState.b_TaskComplete)\n";
		file << "			// (true == b_RememberSolutions))\n";
		file << "		{\n";
		file << "			assert (true == rState.p_TargetProblem->b_SubgoalsNotNeeded);\n";
		file << "			if (false == rState.p_TargetProblem->AddSolution (rState.p_Sequence,\n";
		file << "															  dReward, -1))\n";
		file << "				delete rState.p_Sequence;\n";
		file << "		}\n";
		file << "		else\n";
		file << "			delete rState.p_Sequence;\n";
		file << "\n";
		file << "\n";
		file << "		// cleanup...\n";
		file << "		ITERATE (PlanSubgoalSequences_dq_t, rState.dq_PlanSubgoalSequences, ite)\n";
		file << "		{\n";
		file << "			PddlPredicate_dq_t* pdqPredicates = *ite;\n";
		file << "			ITERATE (PddlPredicate_dq_t, (*pdqPredicates), itePred)\n";
		file << "				delete *itePred;\n";
		file << "			delete pdqPredicates;\n";
		file << "		}\n";
		file << "		rState.dq_PlanSubgoalSequences.clear ();\n";
		file << "	}\n";
		file << "\n";
		file << "	o_SubgoalPolicy.CompleteUpdate ();\n";
		file << "\n";
		file << "	cout << \"pf:\" << i_OutcomePlansFound\n";
		file << "		 << \" gs:\" << i_OutcomeGoalsAlreadySatisfied\n";
		file << "		 << \" us:\" << i_OutcomeUnsolvable\n";
		file << "		 << \" to:\" << i_OutcomeTimeouts\n";
		file << "		 << \" uw:\" << i_OutcomeOutsideKnownWorld\n";
		file << "		 << \" uk:\" << i_OutcomeUnknown\n";
		file << "		 << \" / \" << i_TotalPlanJobs\n";
		file << "		 << \", tc:\" << vec_TargetGoalCompletions.Sum ()\n";
		file << "		 << \", ts:\" << Problem::TotalSolvedProblems ()\n";
		file << "		 << setprecision (2)\n";
		file << "		 << \", al:\" << lTotalLength / (float)iCount\n";
		file << "		 << \", aal:\" << lTotalAltenateLength / (float)iAlternateCount\n";
		file << "		 << \", dpth:\" << f_TotalPlanDepthReached / (float)i_TotalPlanJobs\n";
		file << "		 << \", tcr:\" << o_SubgoalPolicy.ConnectionPredictionRatio ()\n";
		file << "		 << \", rwd:\" << dTotalReward / (double)iCount\n";
		file << "		 << \", wvn:\" << o_SubgoalPolicy.WeightVectorNorm ()\n";
		file << "		 << setprecision (5)\n";
		file << "		 << endl;\n";
		file << "\n";
		file << "\n";
		file << "	hmp_IndexToSequenceState.clear ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalLearner::Iterate (int _iIteration, bool _bTestMode)\n";
		file << "{\n";
		file << "	vec_TargetGoalCompletions.Memset (0);\n";
		file << "	i_TotalPlanJobs = 0;\n";
		file << "	i_OutcomePlansFound = 0;\n";
		file << "	i_OutcomeGoalsAlreadySatisfied = 0;\n";
		file << "	i_OutcomeUnsolvable = 0;\n";
		file << "	i_OutcomeSyntaxError = 0;\n";
		file << "	i_OutcomeTimeouts = 0;\n";
		file << "	i_OutcomeOutsideKnownWorld = 0;\n";
		file << "	i_OutcomeUnknown = 0;\n";
		file << "	f_TotalPlanDepthReached = 0;\n";
		file << "\n";
		file << "	if (true == _bTestMode)\n";
		file << "		i_CurrentFFTimelimit = i_TestTimeFFTimelimit;\n";
		file << "	else\n";
		file << "		i_CurrentFFTimelimit = i_TrainingTimeFFTimelimit;\n";
		file << "\n";
		file << "	o_SubgoalPolicy.SampleExplorationParameters ();\n";
		file << "	o_SubgoalPolicy.SampleConnections (_bTestMode);\n";
		file << "\n";
		file << "	// generate subgoal sequences ...\n";
		file << "	int iSequencesPerIteration = (_iIteration <= 1)?\n";
		file << "									i_SequencesOnFirstIteration :\n";
		file << "									i_SequencesPerIteration;\n";
		file << "	iSequencesPerIteration = (true == _bTestMode)? 1 : iSequencesPerIteration;\n";
		file << "	for (int i = 0; i < iSequencesPerIteration; ++ i)\n";
		file << "	{\n";
		file << "		for (int d = 0; d < Problem::GetProblemCount (); ++ d)\n";
		file << "		{\n";
		file << "			o_SubgoalPolicy.SampleConnectionUseFlags ();\n";
		file << "\n";
		file << "			Problem* pProblem = Problem::GetProblem (d);\n";
		file << "			SubgoalSequence* pSequence = new SubgoalSequence;\n";
		file << "			pSequence->s_ProblemPddlPreamble = pProblem->s_PddlPreamble;\n";
		file << "\n";
		file << "			pSequence->p_TargetProblem = pProblem;\n";
		file << "			if (true == pProblem->b_SubgoalsNotNeeded)\n";
		file << "				o_SubgoalPolicy.SampleZeroSubgoalSequence (*pProblem, pSequence);\n";
		file << "\n";
		file << "			else\n";
		file << "				o_SubgoalPolicy.SampleSubgoalSequence (*pProblem,\n";
		file << "													   _bTestMode,\n";
		file << "													   pSequence);\n";
		file << "\n";
		file << "\n";
		file << "			Subgoal* pSubgoal = pSequence->GetSubgoal (1);\n";
		file << "			pSubgoal->s_StartStatePredicates\n";
		file << "				= pProblem->p_PddlProblem->o_StartState.GetPredicatePddlString ();\n";
		file << "\n";
		file << "\n";
		file << "			String sProblemPddl;\n";
		file << "			pSequence->GetSubtask (1, &sProblemPddl);\n";
		file << "\n";
		file << "			sProblemPddl.Strip ();\n";
		file << "			if (\"\" == sProblemPddl)\n";
		file << "			{\n";
		file << "				cout << \"[ERROR] problem pddl is empty in Learn ()!\" << endl;\n";
		file << "				cout << \"start state predicates ----------------------\\n\"\n";
		file << "					 << pSubgoal->s_StartStatePredicates << '\\n'\n";
		file << "					 << \"pddl subgoal predicates ---------------------\\n\"\n";
		file << "					 << *pSubgoal->p_PddlSubgoalPredicate << '\\n'\n";
		file << "					 << \"---------------------------------------------\\n\"\n";
		file << "					 << endl;\n";
		file << "			}\n";
		file << "\n";
		file << "			PddlProblem* pPddlProblem = PddlInterface::ParseProblemPddl (sProblemPddl);\n";
		file << "			pSequence->SetSubtask (1, sProblemPddl, pPddlProblem);\n";
		file << "\n";
		file << "			++ i_TotalPlanJobs;\n";
		file << "\n";
		file << "			int iIndex = 1000 * i + d;\n";
		file << "\n";
		file << "			//\n";
		file << "			pair <IndexToSubgoalSequenceState_hmp_t::iterator, bool> pairInsert;\n";
		file << "			pairInsert = hmp_IndexToSequenceState.insert (make_pair (iIndex,\n";
		file << "											 SubgoalSequenceState (pSequence, 1, d)));\n";
		file << "			SubgoalSequenceState& rState = pairInsert.first->second;\n";
		file << "			rState.b_FullTask = false;\n";
		file << "			rState.p_TargetProblem = pProblem;\n";
		file << "			set_PendingSequences.insert (iIndex);\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	pthread_mutex_lock (&mtx_WaitForSequences);\n";
		file << "	ITERATE (IndexToSubgoalSequenceState_hmp_t, hmp_IndexToSequenceState, ite)\n";
		file << "	{\n";
		file << "		int iIndex = ite->first;\n";
		file << "		SubgoalSequenceState& rState = ite->second;\n";
		file << "		Subgoal* pSubgoal = rState.p_Sequence->GetSubgoal (1);\n";
		file << "\n";
		file << "		o_FFInterface.SendTask (iIndex,\n";
		file << "								i_DomainPddlId,\n";
		file << "								pSubgoal->s_ProblemPddl,\n";
		file << "								i_CurrentFFTimelimit);\n";
		file << "		if (true == b_DisplayFFProgress)\n";
		file << "			cout << '.' << flush;\n";
		file << "	}\n";
		file << "	pthread_mutex_unlock (&mtx_WaitForSequences);\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "	// condition wait for sequences to complete...\n";
		file << "	pthread_mutex_lock (&mtx_WaitForSequences);\n";
		file << "	pthread_cond_wait (&cv_WaitForSequences, &mtx_WaitForSequences);\n";
		file << "	pthread_mutex_unlock (&mtx_WaitForSequences);\n";
		file << "\n";
		file << "\n";
		file << "	if (true == b_LogPredictions)\n";
		file << "		LogPredictions (_iIteration);\n";
		file << "\n";
		file << "\n";
		file << "	// update parameters ...\n";
		file << "	double dTotalReward = 0;\n";
		file << "	long lTotalLength = 0;\n";
		file << "	int iCount = 0;\n";
		file << "	long lTotalAltenateLength = 0;\n";
		file << "	int iAlternateCount = 0;\n";
		file << "	int_set_t setSolvedSubgoals;\n";
		file << "\n";
		file << "	o_SubgoalPolicy.InitUpdate ();\n";
		file << "	ITERATE (IndexToSubgoalSequenceState_hmp_t, hmp_IndexToSequenceState, ite)\n";
		file << "	{\n";
		file << "		SubgoalSequenceState& rState = ite->second;\n";
		file << "		Problem* pTargetProblem = rState.p_TargetProblem;\n";
		file << "\n";
		file << "		if (true == rState.b_TaskComplete)\n";
		file << "		{\n";
		file << "			ITERATE (Subgoal_dq_t, rState.p_Sequence->dq_Subgoals, iteSubgoal)\n";
		file << "			{\n";
		file << "				Subgoal& rSubgoal = *iteSubgoal;\n";
		file << "				if (SEQUENCE_END == rSubgoal.i_SequenceEnd)\n";
		file << "					continue;\n";
		file << "				assert (rSubgoal.i_SubgoalSelection >= 0);\n";
		file << "				setSolvedSubgoals.insert (rSubgoal.i_SubgoalSelection);\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		double dReward = ComputeReward (rState);\n";
		file << "		dTotalReward += dReward;\n";
		file << "		++ iCount;\n";
		file << "\n";
		file << "		lTotalLength += rState.p_Sequence->dq_Subgoals.size () - 1;\n";
		file << "		if (false == _bTestMode)\n";
		file << "		{\n";
		file << "			if ((true == b_LearnOnSubgoalFreeProblems) ||\n";
		file << "				(false == pTargetProblem->b_SubgoalsNotNeeded))\n";
		file << "			{\n";
		file << "				o_SubgoalPolicy.UpdateParameters (*rState.p_Sequence,\n";
		file << "												  dReward,\n";
		file << "												  rState.b_TaskComplete,\n";
		file << "												  true);\n";
		file << "				//o_SubgoalPolicy.UpdateParameters (*rState.p_Sequence,\n";
		file << "				//								  dReward,\n";
		file << "				//								  rState.b_TaskComplete,\n";
		file << "				//								  false);\n";
		file << "\n";
		file << "				if (true == b_RememberSolutions)\n";
		file << "				{\n";
		file << "					SubgoalSequence* pBestObserved = pTargetProblem->GetCurrentSolution ();\n";
		file << "					int iBestIteration = pTargetProblem->GetCurrentSolutionIteration ();\n";
		file << "					if ((NULL != pBestObserved) && (_iIteration != iBestIteration))\n";
		file << "					{\n";
		file << "						double dBestReward = pTargetProblem->GetCurrentSolutionReward ();\n";
		file << "						o_SubgoalPolicy.UpdateParameters (*pBestObserved,\n";
		file << "														  dBestReward,\n";
		file << "														  rState.b_TaskComplete,\n";
		file << "														  true);\n";
		file << "						//o_SubgoalPolicy.UpdateParameters (*pBestObserved,\n";
		file << "						//								  dBestReward,\n";
		file << "						//								  rState.b_TaskComplete,\n";
		file << "						//								  false);\n";
		file << "					}\n";
		file << "				}\n";
		file << "\n";
		file << "				if ((true == b_LearnFromAlternateSequences) &&\n";
		file << "					(true == rState.b_TaskComplete))\n";
		file << "				{\n";
		file << "					SubgoalSequence_dq_t dqAlternates;\n";
		file << "					ProposeAlternateSequences (rState, dqAlternates);\n";
		file << "					ITERATE (SubgoalSequence_dq_t, dqAlternates, iteAlternate)\n";
		file << "					{\n";
		file << "						SubgoalSequence* pAlternate = *iteAlternate;\n";
		file << "						// cout << \"      \" << pAlternate->ToLogString () << endl;\n";
		file << "						lTotalAltenateLength += pAlternate->dq_Subgoals.size ();\n";
		file << "						++ iAlternateCount;\n";
		file << "						o_SubgoalPolicy.UpdateParameters (*pAlternate,\n";
		file << "														  dReward,\n";
		file << "														  rState.b_TaskComplete,\n";
		file << "														  true);\n";
		file << "						//o_SubgoalPolicy.UpdateParameters (*pAlternate,\n";
		file << "						//								  dReward,\n";
		file << "						//								  rState.b_TaskComplete,\n";
		file << "						//								  false);\n";
		file << "						delete *iteAlternate;\n";
		file << "					}\n";
		file << "				}\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		if ((true == rState.b_TaskComplete) &&\n";
		file << "			// (true == b_RememberSolutions) &&\n";
		file << "			(false == pTargetProblem->b_SubgoalsNotNeeded))\n";
		file << "		{\n";
		file << "			if (false == pTargetProblem->AddSolution (rState.p_Sequence,\n";
		file << "													  dReward,\n";
		file << "													  _iIteration))\n";
		file << "				delete rState.p_Sequence;\n";
		file << "		}\n";
		file << "		else\n";
		file << "			delete rState.p_Sequence;\n";
		file << "\n";
		file << "\n";
		file << "		// cleanup...\n";
		file << "		ITERATE (PlanSubgoalSequences_dq_t, rState.dq_PlanSubgoalSequences, ite)\n";
		file << "		{\n";
		file << "			PddlPredicate_dq_t* pdqPredicates = *ite;\n";
		file << "			ITERATE (PddlPredicate_dq_t, (*pdqPredicates), itePred)\n";
		file << "				delete *itePred;\n";
		file << "			delete pdqPredicates;\n";
		file << "		}\n";
		file << "		rState.dq_PlanSubgoalSequences.clear ();\n";
		file << "	}\n";
		file << "	o_SubgoalPolicy.CompleteUpdate ();\n";
		file << "\n";
		file << "	// add solved subgoals to policy for feature computation...\n";
		file << "	o_SubgoalPolicy.AddReachableSubgoals (setSolvedSubgoals);\n";
		file << "\n";
		file << "\n";
		file << "	float fAvgAlternateLength = 0;\n";
		file << "	if (iAlternateCount > 0)\n";
		file << "		fAvgAlternateLength = lTotalAltenateLength / (float)iAlternateCount;\n";
		file << "\n";
		file << "	cout << \"pf:\" << i_OutcomePlansFound\n";
		file << "		 << \" gs:\" << i_OutcomeGoalsAlreadySatisfied\n";
		file << "		 << \" us:\" << i_OutcomeUnsolvable\n";
		file << "		 << \" to:\" << i_OutcomeTimeouts\n";
		file << "		 << \" uw:\" << i_OutcomeOutsideKnownWorld\n";
		file << "		 << \" uk:\" << i_OutcomeUnknown\n";
		file << "		 << \" / \" << i_TotalPlanJobs\n";
		file << "		 << \", tc:\" << vec_TargetGoalCompletions.Sum ()\n";
		file << "		 << \", ts:\" << Problem::TotalSolvedProblems ()\n";
		file << "		 << setprecision (2)\n";
		file << "		 << \", al:\" << lTotalLength / (float)iCount\n";
		file << "		 << \", aal:\" << fAvgAlternateLength\n";
		file << "		 << \", dpth:\" << f_TotalPlanDepthReached / (float)i_TotalPlanJobs\n";
		file << "		 << \", tcr:\" << o_SubgoalPolicy.ConnectionPredictionRatio ()\n";
		file << "		 << \", rwd:\" << dTotalReward / (double)iCount\n";
		file << "		 << \", wvn:\" << o_SubgoalPolicy.WeightVectorNorm ()\n";
		file << "		 << setprecision (5)\n";
		file << "		 << endl;\n";
		file << "\n";
		file << "	hmp_IndexToSequenceState.clear ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalLearner::LogPredictions (int _iIteration)\n";
		file << "{\n";
		file << "	String sLogFile;\n";
		file << "	sLogFile << ((config)\"prediction_log_path\") << _iIteration;\n";
		file << "	File file;\n";
		file << "	if (false == file.Open (sLogFile, ios_base::out))\n";
		file << "		return;\n";
		file << "\n";
		file << "	ITERATE (IndexToSubgoalSequenceState_hmp_t, hmp_IndexToSequenceState, ite)\n";
		file << "	{\n";
		file << "		SubgoalSequenceState& rState = ite->second;\n";
		file << "\n";
		file << "		PddlProblem* pPddlProblem = rState.p_TargetProblem->p_PddlProblem;\n";
		file << "		String sTarget;\n";
		file << "		sTarget << ((true == rState.b_TaskComplete)? \"1 : \" : \"0 : \");\n";
		file << "		sTarget << pPddlProblem->o_PartialGoalState.GetPredicatePddlString ();\n";
		file << "		sTarget.Strip ();\n";
		file << "\n";
		file << "		file << sTarget << \" : PRED :\";\n";
		file << "		if (true == rState.p_TargetProblem->b_SubgoalsNotNeeded)\n";
		file << "			file << \" [SUBGOALS NOT NEEDED]\" << endl;\n";
		file << "		else\n";
		file << "			file << *rState.p_Sequence << endl;\n";
		file << "\n";
		file << "		SubgoalSequence_dq_t dqAlternates;\n";
		file << "		ProposeAlternateSequences (rState, dqAlternates);\n";
		file << "		ITERATE (SubgoalSequence_dq_t, dqAlternates, iteAlternate)\n";
		file << "		{\n";
		file << "			SubgoalSequence* pAlternate = *iteAlternate;\n";
		file << "			file << sTarget << \" : FF :\" << *pAlternate << endl;\n";
		file << "		}\n";
		file << "		if (true == dqAlternates.empty ())\n";
		file << "			file << sTarget << \" : FF :\" << endl;\n";
		file << "\n";
		file << "	}\n";
		file << "\n";
		file << "	file.flush ();\n";
		file << "	file.Close ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("Learner.h", ios_base::out);
		file << "#ifndef __SUBGOAL_LEARNER__\n";
		file << "#define __SUBGOAL_LEARNER__\n";
		file << "\n";
		file << "#include \"SubgoalPolicy.h\"\n";
		file << "#include \"Problems.h\"\n";
		file << "#include \"FFInterface.h\"\n";
		file << "#include <set>\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "class SubgoalSequenceState;\n";
		file << "typedef hash_map <int, SubgoalSequenceState>	IndexToSubgoalSequenceState_hmp_t;\n";
		file << "typedef set <int>								int_set_t;\n";
		file << "typedef deque <PddlPredicate_dq_t*>				PlanSubgoalSequences_dq_t;\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class SubgoalSequenceState\n";
		file << "{\n";
		file << "	public:\n";
		file << "		SubgoalSequence*			p_Sequence;\n";
		file << "		Problem*					p_TargetProblem;\n";
		file << "		PlanSubgoalSequences_dq_t	dq_PlanSubgoalSequences;\n";
		file << "		double						d_Reward;\n";
		file << "		int							i_CurrentStep;\n";
		file << "		int							i_ProblemId;\n";
		file << "		bool						b_TaskComplete;\n";
		file << "		bool						b_FullTask;\n";
		file << "\n";
		file << "		SubgoalSequenceState (SubgoalSequence* _pSequence, int _iStep, int _iId)\n";
		file << "		{\n";
		file << "			p_Sequence = _pSequence;\n";
		file << "			p_TargetProblem = NULL;\n";
		file << "			i_CurrentStep = _iStep;\n";
		file << "			i_ProblemId = _iId;\n";
		file << "			d_Reward = 0;\n";
		file << "			b_TaskComplete = false;\n";
		file << "			b_FullTask = false;\n";
		file << "		};\n";
		file << "\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator<< (ostream& _rStream, const SubgoalSequence& _rSequence);\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class SubgoalLearner : public FFCallback\n";
		file << "{\n";
		file << "	private:\n";
		file << "		SubgoalPolicy	o_SubgoalPolicy;\n";
		file << "		FFInterface		o_FFInterface;\n";
		file << "		double			d_PlanFailureReward;\n";
		file << "		double			d_TaskCompletionReward;\n";
		file << "		double			d_SuccessfulStepRewardBase;\n";
		file << "		double			d_UnnecessarySubgoalPenalty;\n";
		file << "		double			d_RewardForHittingCachePeriphery;\n";
		file << "		int				i_SequencesOnFirstIteration;\n";
		file << "		int				i_SequencesPerIteration;\n";
		file << "\n";
		file << "		int_Vec_t		vec_TargetGoalCompletions;\n";
		file << "		int				i_TotalPlanJobs;\n";
		file << "		int				i_OutcomePlansFound;\n";
		file << "		int				i_OutcomeGoalsAlreadySatisfied;\n";
		file << "		int				i_OutcomeUnsolvable;\n";
		file << "		int				i_OutcomeSyntaxError;\n";
		file << "		int				i_OutcomeTimeouts;\n";
		file << "		int				i_OutcomeOutsideKnownWorld;\n";
		file << "		int				i_OutcomeUnknown;\n";
		file << "		float			f_TotalPlanDepthReached;\n";
		file << "\n";
		file << "		int				i_CurrentFFTimelimit;\n";
		file << "		int				i_TestTimeFFTimelimit;\n";
		file << "		int				i_TrainingTimeFFTimelimit;\n";
		file << "\n";
		file << "		bool			b_LearnFromAlternateSequences;\n";
		file << "		bool			b_LearnOnSubgoalFreeProblems;\n";
		file << "		bool			b_RememberSolutions;\n";
		file << "		bool			b_UseLocalHeuristicEvaluator;\n";
		file << "		bool			b_LogPredictions;\n";
		file << "		bool			b_DisplayFFProgress;\n";
		file << "\n";
		file << "		long			i_DomainPddlId;\n";
		file << "		PddlDomain*		p_PddlDomain;\n";
		file << "		IndexToSubgoalSequenceState_hmp_t	hmp_IndexToSequenceState;\n";
		file << "		int_set_t							set_PendingSequences;\n";
		file << "\n";
		file << "		pthread_mutex_t	mtx_WaitForSequences;\n";
		file << "		pthread_cond_t	cv_WaitForSequences;\n";
		file << "\n";
		file << "\n";
		file << "		void OnFFResponse (int _iIndex, FFResponse& _rResponse);\n";
		file << "		double ComputeReward (SubgoalSequenceState& _rState);\n";
		file << "		void LogPredictions (int _iIteration);\n";
		file << "		void TrimPlanSubgoalSequences (PlanSubgoalSequences_dq_t& _rdqPlanSubgoals);\n";
		file << "		void ProposeAlternateSequences (SubgoalSequenceState& _rState,\n";
		file << "										SubgoalSequence_dq_t& _rdqAlternateSequences);\n";
		file << "\n";
		file << "	public:\n";
		file << "		SubgoalLearner (void);\n";
		file << "		~SubgoalLearner (void);\n";
		file << "\n";
		file << "		bool Init (void);\n";
		file << "\n";
		file << "		void TryPlanningOnFullTasks (void);\n";
		file << "		void Iterate (int _iIteration, bool _bTestMode);\n";
		file << "		void SaveWeights (int _iIteration)\n";
		file << "		{ o_SubgoalPolicy.SaveWeights (_iIteration); };\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file.close ();
	}



	{
		ofstream file ("info.svn", ios_base::out);
		file << "Thu Jan  5 20:27:09 EST 2012\n";
		file << "----------------------------\n";
		file << "\n";
		file << "----------------------------\n";
		file << "\n";
		file << "----------------------------\n";
		file.close ();
	}



	{
		ofstream file ("LogLinearPolicy.cpp", ios_base::out);
		file << "#include \"LogLinearPolicy.h\"\n";
		file << "#include \"Feature.h\"\n";
		file << "#include <nlp_config.h>\n";
		file << "#include <nlp_filesystem.h>\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "LogLinearModel::LogLinearModel (void)\n";
		file << "{\n";
		file << "	i_Features = 0;\n";
		file << "	d_LearningRate = 0;\n";
		file << "	d_RegularizationFactor = 0;\n";
		file << "	d_MaxWeightCeiling = 0;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "LogLinearModel::~LogLinearModel (void)\n";
		file << "{\n";
		file << "	i_Features = 0;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void LogLinearModel::Init (String _sName)\n";
		file << "{\n";
		file << "	d_LearningRate = (config)(_sName + \":learning_rate\");\n";
		file << "	d_RegularizationFactor = (config)(_sName + \":regularization_factor\");\n";
		file << "	if (1 == (int)(config)(_sName + \":load_weights\"))\n";
		file << "		LoadWeights (_sName);\n";
		file << "	else if (true == Path::Exists ((config)(_sName + \":weights_file\")))\n";
		file << "		Path::RemoveFile ((config)(_sName + \":weights_file\"));\n";
		file << "	d_MaxWeightCeiling = (config)(_sName + \":max_weight_ceiling\");\n";
		file << "\n";
		file << "	cout << \"Initializing log-linear model (\" << _sName << ')' << endl;\n";
		file << "	cout << \"   Learning rate  : \" << d_LearningRate << endl;\n";
		file << "	cout << \"   Regularization : \" << d_RegularizationFactor << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double LogLinearModel::ComputeLogProb (Features& _rFeatures)\n";
		file << "{\n";
		file << "	double dResult = 0;\n";
		file << "\n";
		file << "	for (int i = 0; i < _rFeatures.Size (); ++ i)\n";
		file << "	{\n";
		file << "		int iIndex = _rFeatures.Index (i);\n";
		file << "		if (iIndex >= i_Features)\n";
		file << "			continue;\n";
		file << "		dResult += _rFeatures.Feature (i) * vec_Weights [iIndex];\n";
		file << "	}\n";
		file << "\n";
		file << "	return dResult;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void LogLinearModel::InitializeFeatureExpectationVector (double_Vec_t& _rvecExpectedFeatures,\n";
		file << "														 int _iFeatureCount)\n";
		file << "{\n";
		file << "	// _rvecExpectedFeatures.Create (_iFeatureCount);\n";
		file << "	_rvecExpectedFeatures.Resize (_iFeatureCount);\n";
		file << "	_rvecExpectedFeatures.Memset (0);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void LogLinearModel::ComputeNegativeFeatureExpectation (LogProbability& _rLogProb,\n";
		file << "														Features_vec_t& _rvecFeatures,\n";
		file << "														double _dReward,\n";
		file << "														double_Vec_t& _rvecExpectedFeatures)\n";
		file << "{\n";
		file << "	size_t iProbs = _rLogProb.Size ();\n";
		file << "	if (0 == iProbs)\n";
		file << "		return;\n";
		file << "\n";
		file << "	Probability oProb (_rLogProb);\n";
		file << "	for (size_t i = 0; i < iProbs; ++ i)\n";
		file << "	{\n";
		file << "		Features* pFeatures = _rvecFeatures [i];\n";
		file << "		double dProb = oProb [i] * _dReward;\n";
		file << "\n";
		file << "		for (int f = 0; f < pFeatures->Size (); ++ f)\n";
		file << "		{\n";
		file << "			size_t iIndex = pFeatures->Index (f);\n";
		file << "			if (iIndex >= _rvecExpectedFeatures.Size ())\n";
		file << "				cerr << \"[ERROR] out-of-bounds \" << iIndex\n";
		file << "					 << \" >= \" << _rvecExpectedFeatures.Size ()\n";
		file << "					 << endl;\n";
		file << "			_rvecExpectedFeatures [pFeatures->Index (f)] -= dProb * pFeatures->Feature (f);\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void LogLinearModel::UpdateWeights (double _dReward,\n";
		file << "									double_Vec_t& _rvecTrace)\n";
		file << "{\n";
		file << "	int iSize = _rvecTrace.Size ();\n";
		file << "	if ((int)vec_Weights.Size () < iSize)\n";
		file << "		vec_Weights.Resize (iSize, 0);\n";
		file << "	i_Features = iSize;\n";
		file << "\n";
		file << "	int iLastNonZeroWeight = 0;\n";
		file << "	for (int i = 0; i < iSize; ++ i)\n";
		file << "	{\n";
		file << "		#ifdef NAN_CHECK\n";
		file << "		double dOldWeights = vec_Weights [i];\n";
		file << "		#endif\n";
		file << "\n";
		file << "		vec_Weights [i] += d_LearningRate *\n";
		file << "							(_dReward * _rvecTrace [i]\n";
		file << "							- d_RegularizationFactor * vec_Weights [i]);\n";
		file << "		if (0 != vec_Weights [i])\n";
		file << "			iLastNonZeroWeight = i;\n";
		file << "\n";
		file << "		#ifdef NAN_CHECK\n";
		file << "		if (true == isnan (vec_Weights [i]))\n";
		file << "		{\n";
		file << "			cout << \"[ERROR] LogLinearModel::UpdateWeights (). Weight vector has NAN.\"\n";
		file << "				 << endl;\n";
		file << "			cout << \"weights[i]    : \" << vec_Weights [i] << endl;\n";
		file << "			cout << \"learning rate : \" << d_LearningRate << endl;\n";
		file << "			cout << \"reward        : \" << _dReward << endl;\n";
		file << "			cout << \"trace[i]      : \" << _rvecTrace [i] << endl;\n";
		file << "			cout << \"regularization: \" << d_RegularizationFactor << endl;\n";
		file << "			cout << \"old weights[i]: \" << dOldWeights << endl;\n";
		file << "			cout << endl;\n";
		file << "		}\n";
		file << "		#endif\n";
		file << "	}\n";
		file << "\n";
		file << "	i_Features = iLastNonZeroWeight + 1;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void LogLinearModel::ResetWeights (double _dRatio)\n";
		file << "{\n";
		file << "	if (i_Features > 0)\n";
		file << "	{\n";
		file << "		if (0 == _dRatio)\n";
		file << "			vec_Weights.Memset (0);\n";
		file << "		else\n";
		file << "		{\n";
		file << "			for (size_t i = 0; i < vec_Weights.Size (); ++ i)\n";
		file << "				vec_Weights [i] *= _dRatio;\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool LogLinearModel::SaveWeights (const char* _zName)\n";
		file << "{\n";
		file << "	// LogLinearModelFeatures::SaveIndices (_zName);\n";
		file << "	ios_base::openmode eMode = ios_base::out;\n";
		file << "	{\n";
		file << "		String sName;\n";
		file << "		sName << _zName << \":retain_weight_history\";\n";
		file << "		if (1 == (int)(config)sName)\n";
		file << "			eMode |= ios_base::app;\n";
		file << "	}\n";
		file << "\n";
		file << "	{\n";
		file << "		if (0 == vec_Weights.Size ())\n";
		file << "			return true;\n";
		file << "\n";
		file << "		String sName;\n";
		file << "		sName << _zName << \":weights_file\";\n";
		file << "		CsvFile file;\n";
		file << "		if (false == file.Open ((config)sName, eMode))\n";
		file << "			return false;\n";
		file << "\n";
		file << "		file << vec_Weights [0];\n";
		file << "		for (int i = 1; i < i_Features; ++ i)\n";
		file << "			file << ',' << vec_Weights [i];\n";
		file << "		file << endl;\n";
		file << "		file.Close ();\n";
		file << "	}\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool LogLinearModel::LoadWeights (const char* _zName)\n";
		file << "{\n";
		file << "	cout << \"Loading weights for log linear model : \"\n";
		file << "		 << _zName << endl;\n";
		file << "	// LogLinearModelFeatures::LoadIndices (_zName);\n";
		file << "\n";
		file << "	String sName;\n";
		file << "	sName << _zName << \":weights_file\";\n";
		file << "\n";
		file << "	File file;\n";
		file << "	if (false == file.Open ((config)sName))\n";
		file << "		return false;\n";
		file << "	String sLine;\n";
		file << "	if (false == file.ReadLastLine (sLine))\n";
		file << "		return false;\n";
		file << "\n";
		file << "	String_dq_t dqValues;\n";
		file << "	sLine.Split (dqValues, ',');\n";
		file << "\n";
		file << "	i_Features = dqValues.size ();\n";
		file << "	vec_Weights.Resize (i_Features, 0);\n";
		file << "	for (int i = 0; i < i_Features; ++ i)\n";
		file << "		vec_Weights [i] = dqValues [i];\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void LogLinearModel::CheckForNan (const char* _zId)\n";
		file << "{\n";
		file << "	bool bHasNan = false;\n";
		file << "	for (int i = 0; i < i_Features; ++ i)\n";
		file << "	{\n";
		file << "		if (true == isnan (vec_Weights [i]))\n";
		file << "		{\n";
		file << "			bHasNan = true;\n";
		file << "			break;\n";
		file << "		}\n";
		file << "	}\n";
		file << "	if (true == bHasNan)\n";
		file << "	{\n";
		file << "		cout << \"[ERROR] {\" << _zId << \"} weigths has nan:\" << endl;\n";
		file << "		for (int i = 0; i < i_Features; ++ i)\n";
		file << "		{\n";
		file << "			cout << vec_Weights [i] << \", \";\n";
		file << "		}\n";
		file << "		cout << endl << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double LogLinearModel::WeightVectorNorm (void)\n";
		file << "{\n";
		file << "	double dSum = 0;\n";
		file << "	for (int i = 0; i < i_Features; ++ i)\n";
		file << "		dSum += vec_Weights [i] * vec_Weights [i];\n";
		file << "	return sqrt (dSum);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("LogLinearPolicy.h", ios_base::out);
		file << "#ifndef __LOG_LINEAR_MODEL__\n";
		file << "#define __LOG_LINEAR_MODEL__\n";
		file << "\n";
		file << "#include <vector>\n";
		file << "#include <pthread.h>\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <nlp_vector.h>\n";
		file << "#include \"Feature.h\"\n";
		file << "#include \"Probability.h\"\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "typedef Vector<double>		double_Vec_t;\n";
		file << "typedef vector<Features*>	Features_vec_t;\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class LogLinearModel\n";
		file << "{\n";
		file << "	private:\n";
		file << "		double_Vec_t		vec_Weights;\n";
		file << "		int					i_Features;\n";
		file << "		double				d_LearningRate;\n";
		file << "		double				d_RegularizationFactor;\n";
		file << "		double				d_MaxWeightCeiling;\n";
		file << "\n";
		file << "		void CheckForNan (const char* _zId);\n";
		file << "\n";
		file << "	public:\n";
		file << "		LogLinearModel (void);\n";
		file << "		~LogLinearModel (void);\n";
		file << "\n";
		file << "		void Init (String _sName);\n";
		file << "\n";
		file << "		double ComputeLogProb (Features& _rFeatures);\n";
		file << "		void InitializeFeatureExpectationVector (double_Vec_t& _rvecExpectedFeatures,\n";
		file << "												 int _iFeatureCount);\n";
		file << "		void ComputeNegativeFeatureExpectation (LogProbability& _rLogProb,\n";
		file << "												Features_vec_t& _rvecFeatures,\n";
		file << "												double _dReward,\n";
		file << "												double_Vec_t& _rvecExpectedFeatures);\n";
		file << "		void UpdateWeights (double _dReward,\n";
		file << "							double_Vec_t& _rvecTraces);\n";
		file << "\n";
		file << "		double GetWeight (int _iIndex)\n";
		file << "		{\n";
		file << "			if (_iIndex >= i_Features)\n";
		file << "				return 0;\n";
		file << "			return vec_Weights [_iIndex];\n";
		file << "		}\n";
		file << "		void SetWeight (int _iIndex, double _dValue)\n";
		file << "		{\n";
		file << "			if (_iIndex >= i_Features)\n";
		file << "				return;\n";
		file << "			vec_Weights [_iIndex] = _dValue;\n";
		file << "		}\n";
		file << "		void ResetWeights (double _dRatio = 0);\n";
		file << "		bool SaveWeights (const char* _zName);\n";
		file << "		bool LoadWeights (const char* _zName);\n";
		file << "		double WeightVectorNorm (void);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file.close ();
	}



	{
		ofstream file ("SubgoalPolicy.cpp", ios_base::out);
		file << "#include \"SubgoalPolicy.h\"\n";
		file << "#include <nlp_config.h>\n";
		file << "#include <nlp_filesystem.h>\n";
		file << "#include <nlp_macros.h>\n";
		file << "#include <assert.h>\n";
		file << "#include \"Problems.h\"\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Subgoal::Subgoal (void)\n";
		file << "{\n";
		file << "	l_States = -1;\n";
		file << "	i_SubgoalSelection = -1;\n";
		file << "	i_SequenceEnd = -1;\n";
		file << "	e_PlanningOutcome = po_unknown;\n";
		file << "	p_PddlProblem = NULL;\n";
		file << "	p_PddlTargetProblem = NULL;\n";
		file << "	p_PddlSubgoalPredicate = NULL;\n";
		file << "	b_IsLastSubgoalToTarget = false;\n";
		file << "	b_ForcedSequenceEnd = false;\n";
		file << "	p_SelectedPredicateFeatures = NULL;\n";
		file << "}\n";
		file << "\n";
		file << "Subgoal::~Subgoal (void)\n";
		file << "{\n";
		file << "	l_States = -2;\n";
		file << "	e_PlanningOutcome = po_unknown;\n";
		file << "	delete p_PddlProblem;\n";
		file << "\n";
		file << "	ITERATE (Features_vec_t, vec_SequenceEndFeatureVectors, ite)\n";
		file << "		delete *ite;\n";
		file << "	vec_SequenceEndFeatureVectors.clear ();\n";
		file << "	delete p_SelectedPredicateFeatures;\n";
		file << "\n";
		file << "	ITERATE (Features_vec_t, vec_SubgoalFeatureVectors, ite)\n";
		file << "		delete *ite;\n";
		file << "	vec_SubgoalFeatureVectors.clear ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "SubgoalSequence::SubgoalSequence (void)\n";
		file << "{\n";
		file << "}\n";
		file << "\n";
		file << "SubgoalSequence::~SubgoalSequence (void)\n";
		file << "{\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalSequence::SetSubtaskFFResponse (unsigned int _iIndex,\n";
		file << "										   FFResponse& _rResponse)\n";
		file << "{\n";
		file << "	// current subgoal ...\n";
		file << "	#ifndef NDEBUG\n";
		file << "	if (_iIndex > dq_Subgoals.size ())\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] subgoal index in SetSubtaskFFResponse [\"\n";
		file << "			 << _iIndex << \"] out-of-bounds of sequence (length \"\n";
		file << "			 << dq_Subgoals.size () << \").\" << endl;\n";
		file << "		assert (false);\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	Subgoal& rCurrentSubgoal = dq_Subgoals [_iIndex];\n";
		file << "	rCurrentSubgoal.s_FFOutput = _rResponse.s_FFOutput;\n";
		file << "	rCurrentSubgoal.s_Plan = _rResponse.s_Plan;\n";
		file << "	rCurrentSubgoal.l_States = _rResponse.l_States;\n";
		file << "	rCurrentSubgoal.e_PlanningOutcome = _rResponse.e_PlanningOutcome;\n";
		file << "\n";
		file << "\n";
		file << "	// next subgoal ...\n";
		file << "	unsigned int iSubgoalIndex = _iIndex + 1;\n";
		file << "	if (iSubgoalIndex == dq_Subgoals.size ())\n";
		file << "	{\n";
		file << "		assert (true == dq_Subgoals [_iIndex].b_IsLastSubgoalToTarget);\n";
		file << "		// This is the last subgoal, so no need to\n";
		file << "		// the init state of next subgoal.\n";
		file << "		return;\n";
		file << "	}\n";
		file << "\n";
		file << "	#ifndef NDEBUG\n";
		file << "	if (iSubgoalIndex > dq_Subgoals.size ())\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] next subgoal index in SetSubtaskFFResponse [\"\n";
		file << "			 << iSubgoalIndex << \"] out-of-bounds of sequence (length \"\n";
		file << "			 << dq_Subgoals.size () << \").\" << endl;\n";
		file << "		assert (false);\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	Subgoal& rNextSubgoal = dq_Subgoals [iSubgoalIndex];\n";
		file << "	assert (\"\" == rNextSubgoal.s_StartStatePredicates);\n";
		file << "	rNextSubgoal.s_StartStatePredicates = _rResponse.s_EndStatePredicates;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalSequence::GetSubtask (unsigned int _iIndex,\n";
		file << "								  String* _pProblemPddl)\n";
		file << "{\n";
		file << "	if (_iIndex >= dq_Subgoals.size ())\n";
		file << "		return false;\n";
		file << "	Subgoal& rSubgoal = dq_Subgoals [_iIndex];\n";
		file << "	assert (SEQUENCE_END != rSubgoal.i_SequenceEnd);\n";
		file << "\n";
		file << "	assert (\"\" != s_ProblemPddlPreamble);\n";
		file << "	assert (\"\" != rSubgoal.s_StartStatePredicates);\n";
		file << "\n";
		file << "	String sGoal;\n";
		file << "	if (_iIndex + 1 == dq_Subgoals.size ())\n";
		file << "	{\n";
		file << "		if (false == rSubgoal.b_IsLastSubgoalToTarget)\n";
		file << "			return false;\n";
		file << "\n";
		file << "		assert (true == rSubgoal.b_IsLastSubgoalToTarget);\n";
		file << "		sGoal = rSubgoal.p_PddlTargetProblem->o_PartialGoalState.GetPredicatePddlString ();\n";
		file << "	}\n";
		file << "	else\n";
		file << "	{\n";
		file << "		assert (false == rSubgoal.b_IsLastSubgoalToTarget);\n";
		file << "		sGoal = rSubgoal.p_PddlSubgoalPredicate->GetPddlString ();\n";
		file << "	}\n";
		file << "\n";
		file << "	sGoal.Strip ();\n";
		file << "	if (\"\" == sGoal)\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] empty goal\";\n";
		file << "		if (true == rSubgoal.b_IsLastSubgoalToTarget)\n";
		file << "		{\n";
		file << "			cerr << \", last subgoal to target\" << endl;\n";
		file << "			cerr << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\";\n";
		file << "			cerr << rSubgoal.p_PddlTargetProblem->o_PartialGoalState << '\\n';\n";
		file << "			cerr << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\" << endl;\n";
		file << "		}\n";
		file << "		else\n";
		file << "		{\n";
		file << "			cerr << \", NOT last subgoal to target\" << endl;\n";
		file << "			cerr << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\";\n";
		file << "			cerr << *rSubgoal.p_PddlSubgoalPredicate << '\\n';\n";
		file << "			cerr << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\" << endl;\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	assert (\"\" != sGoal);\n";
		file << "\n";
		file << "	*_pProblemPddl = \"\";\n";
		file << "	*_pProblemPddl << \"(define\\n\"\n";
		file << "				   << s_ProblemPddlPreamble << \"\\n\\n\"\n";
		file << "				   << \"(:init \\n\"\n";
		file << "				   << rSubgoal.s_StartStatePredicates\n";
		file << "				   << \")\\n\"\n";
		file << "				   // << \"(:goal\\ (and \\n\"\n";
		file << "				   << \"(:goal \\n\"\n";
		file << "				   << sGoal\n";
		file << "				   << \"\\n)\\n)\";\n";
		file << "				   //<< \"\\n)\\n)\\n)\";\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalSequence::SetSubtask (unsigned int _iIndex,\n";
		file << "								  String _rProblemPddl,\n";
		file << "								  PddlProblem* _pPddlProblem)\n";
		file << "{\n";
		file << "	assert (_iIndex < dq_Subgoals.size ());\n";
		file << "	dq_Subgoals [_iIndex].s_ProblemPddl = _rProblemPddl;\n";
		file << "	dq_Subgoals [_iIndex].p_PddlProblem = _pPddlProblem;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String SubgoalSequence::ToLogString (void)\n";
		file << "{\n";
		file << "	String sReturn;\n";
		file << "	ITERATE (Subgoal_dq_t, dq_Subgoals, ite)\n";
		file << "	{\n";
		file << "		Subgoal& rSubgoal = *ite;\n";
		file << "		if (SEQUENCE_END == rSubgoal.i_SequenceEnd)\n";
		file << "			continue;\n";
		file << "		if (true == rSubgoal.b_IsLastSubgoalToTarget)\n";
		file << "			continue;\n";
		file << "\n";
		file << "		if (\"\" != sReturn)\n";
		file << "			sReturn << '\\n';\n";
		file << "		sReturn << rSubgoal.p_PddlSubgoalPredicate->GetPddlString ();\n";
		file << "	}\n";
		file << "	return sReturn;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void ExplorationParameters::SetParamsFromConfig (String _rPrefix)\n";
		file << "{\n";
		file << "	f_EpsilonMin		= (config)(_rPrefix + \":epsilon-min\");\n";
		file << "	f_EpsilonRange		= ((float)(config)(_rPrefix + \":epsilon-max\")) - f_EpsilonMin;\n";
		file << "	f_BetaMin			= log2 ((config)(_rPrefix + \":beta-min\"));\n";
		file << "	f_BetaRange			= log2 ((config)(_rPrefix + \":beta-max\")) - f_BetaMin;\n";
		file << "	e_ExplorationType	= ToEnum ((config)(_rPrefix + \":exploration_type\"));\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String ExplorationParameters::SampleParameters (Sample& _rSample)\n";
		file << "{\n";
		file << "	String sExploration;\n";
		file << "\n";
		file << "	if ((et_epsilon_greedy == e_ExplorationType) ||\n";
		file << "		(et_epsilon_softmax == e_ExplorationType))\n";
		file << "	{\n";
		file << "		f_Epsilon = f_EpsilonMin + f_EpsilonRange * _rSample.SampleUniform ();\n";
		file << "		sExploration << \"e:\" << f_Epsilon << ' ';\n";
		file << "	}\n";
		file << "\n";
		file << "	if ((et_softmax == e_ExplorationType) ||\n";
		file << "		(et_epsilon_softmax == e_ExplorationType))\n";
		file << "	{\n";
		file << "		f_Beta = pow (2, f_BetaMin + f_BetaRange * _rSample.SampleUniform ());\n";
		file << "		sExploration << \"b:\" << f_Beta << ' ';\n";
		file << "	}\n";
		file << "\n";
		file << "	return sExploration;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void ExplorationParameters::PrintConfiguration (const char* _zPrefix)\n";
		file << "{\n";
		file << "	cout << \"   \" << _zPrefix << \" exploration : \"\n";
		file << "		 << ToString (e_ExplorationType)\n";
		file << "		 << endl;\n";
		file << "	if ((et_epsilon_greedy == e_ExplorationType) ||\n";
		file << "		(et_epsilon_softmax == e_ExplorationType))\n";
		file << "	{\n";
		file << "		cout << \"   \" << _zPrefix << \" epsilon     : \"\n";
		file << "			 << f_EpsilonMin << \" < \"\n";
		file << "			 << f_EpsilonMin + f_EpsilonRange\n";
		file << "			 << endl;\n";
		file << "	}\n";
		file << "	if ((et_softmax == e_ExplorationType) ||\n";
		file << "		(et_epsilon_softmax == e_ExplorationType))\n";
		file << "	{\n";
		file << "		cout << \"   \" << _zPrefix << \" beta        : \"\n";
		file << "			 << f_BetaMin << \" < \"\n";
		file << "			 << f_BetaMin + f_BetaRange\n";
		file << "			 << endl;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "SubgoalPolicy::SubgoalPolicy (void)\n";
		file << "{\n";
		file << "	Random::Init ();\n";
		file << "\n";
		file << "	b_UseSimpleConnectionFeatures = false;\n";
		file << "	b_UseTextConnectionFeatures = false;\n";
		file << "	b_UseComplexNonConnectionFeatures = false;\n";
		file << "}\n";
		file << "\n";
		file << "SubgoalPolicy::~SubgoalPolicy (void)\n";
		file << "{\n";
		file << "	Random::Destroy ();\n";
		file << "\n";
		file << "	ITERATE (PddlPredicate_vec_t, vec_CandidatePredicates, ite)\n";
		file << "		delete *ite;\n";
		file << "	vec_CandidatePredicates.clear ();\n";
		file << "\n";
		file << "	ITERATE (SentenceConnection_vec_t, vec_SentenceConnections, iteConn)\n";
		file << "	{\n";
		file << "		SentenceConnection* pConnection = *iteConn;\n";
		file << "		delete pConnection->p_PositiveFeatures;\n";
		file << "		delete pConnection->p_NegativeFeatures;\n";
		file << "		delete pConnection;\n";
		file << "	}\n";
		file << "	vec_SentenceConnections.clear ();\n";
		file << "\n";
		file << "	if (true == mtx_SentencesPositiveFromTo.IsInitialized ())\n";
		file << "	{\n";
		file << "		for (int f = 0; f < i_CandidatePredicateNumbersMerged; ++ f)\n";
		file << "		{\n";
		file << "			for (int t = 0; t < i_CandidatePredicateNumbersMerged; ++ t)\n";
		file << "			{\n";
		file << "				if (NULL != mtx_SentencesPositiveFromTo (f, t))\n";
		file << "					delete mtx_SentencesPositiveFromTo (f, t);\n";
		file << "				if (NULL != mtx_SentencesNegativeFromTo (f, t))\n";
		file << "					delete mtx_SentencesNegativeFromTo (f, t);\n";
		file << "			}\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ExplorationType_e ExplorationParameters::ToEnum (String _sType)\n";
		file << "{\n";
		file << "	if (\"epsilon-greedy\" == _sType)\n";
		file << "		return et_epsilon_greedy;\n";
		file << "	else if (\"softmax\" == _sType)\n";
		file << "		return et_softmax;\n";
		file << "	else if (\"epsilon-softmax\" == _sType)\n";
		file << "		return et_epsilon_softmax;\n";
		file << "	return et_unknown;\n";
		file << "}\n";
		file << "\n";
		file << "const char* ExplorationParameters::ToString (ExplorationType_e _eType)\n";
		file << "{\n";
		file << "	if (et_epsilon_greedy == _eType)\n";
		file << "		return \"epsilon-greedy\";\n";
		file << "	else if (et_softmax == _eType)\n";
		file << "		return \"softmax\";\n";
		file << "	else if (et_epsilon_softmax == _eType)\n";
		file << "		return \"epsilon-softmax\";\n";
		file << "	return \"unknown\";\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::Init (void)\n";
		file << "{\n";
		file << "	o_SequenceEndModel.Init (\"end\");\n";
		file << "	o_SubgoalSelectionModel.Init (\"subgoal\");\n";
		file << "	o_TextConnectionModel.Init (\"connection\");\n";
		file << "\n";
		file << "	o_SequenceEndExploration.SetParamsFromConfig (\"end\");\n";
		file << "	o_SubgoalExploration.SetParamsFromConfig (\"subgoal\");\n";
		file << "	o_ConnectionExploration.SetParamsFromConfig (\"connection\");\n";
		file << "\n";
		file << "	i_MaxSequenceLength = (config)\"max_subgoal_sequence_length\";\n";
		file << "	b_DisallowNeighboringDuplicateSubgoals = (1 == (int)(config)\"disallow_neighboring_duplicate_subgoals\");\n";
		file << "	b_DisallowAnyDuplicateSubgoals = (1 == (int)(config)\"disallow_any_duplicate_subgoals\");\n";
		file << "	b_UseLogarithmicDistanceScore = (1 == (int)(config)\"use_logarithmic_distance_score\");\n";
		file << "\n";
		file << "	b_ForceConnectionWeights = (1 == (int)(config)\"force_connection_weights\");\n";
		file << "	d_ForcedConnectionWeightToInit = (config)\"forced_connection_weight_to_init\";\n";
		file << "	d_ForcedConnectionWeightToTarget = (config)\"forced_connection_weight_to_target\";\n";
		file << "	b_UsePredicateValueFeature = (1 == (int)(config)\"use_predicate_value_feature\");\n";
		file << "	b_UseReachableSubgoalFeature = (1 == (int)(config)\"use_reachable_subgoal_feature\");\n";
		file << "	b_UseReachabilityEquivalents = (1 == (int)(config)\"use_reachability_equivalents\");\n";
		file << "\n";
		file << "	b_UseOnlyPreviousSubgoal = (1 == (int)(config)\"features:use_only_previous_subgoal\");\n";
		file << "	b_IncludeInit = (0 != (int)(config)\"features:include_init\");\n";
		file << "	f_PredicateIdentityPairFeatureWeight = (config)\"predicate_identity_pair_feature_weight\";\n";
		file << "	String sConnectionRewardType ((config)\"connection:reward_type\");\n";
		file << "	if (\"linear\" == sConnectionRewardType)\n";
		file << "		e_ConnectionRewardType = crt_linear;\n";
		file << "	else if (\"single_success\" == sConnectionRewardType)\n";
		file << "		e_ConnectionRewardType = crt_single_success;\n";
		file << "	else\n";
		file << "	{\n";
		file << "		cout << \"[ERROR] Unknown connection reward type '\"\n";
		file << "			 << sConnectionRewardType << \"'.\" << endl;\n";
		file << "		e_ConnectionRewardType = crt_unknown;\n";
		file << "	}\n";
		file << "	f_ConnectionSuccessReward = (config)\"connection:success_reward\";\n";
		file << "	f_ConnectionFailurePenalty = (config)\"connection:failure_penalty\";\n";
		file << "	b_RetainPredicateConnectionFeedback\n";
		file << "		= (1 == (int)(config)\"connection:retain_connection_feedback\");\n";
		file << "	b_UseSuccessFailureCountsInFeedback\n";
		file << "		= (1 == (int)(config)\"use_success_failure_counts_in_feedback\");\n";
		file << "	i_UpdatesPerIteration = (config)\"text_updates_per_iteration\";\n";
		file << "\n";
		file << "	cout << \"Initializing subgoal policy\" << endl;\n";
		file << "	cout << \"   Max sequence length : \" << i_MaxSequenceLength << endl;\n";
		file << "	if (true == b_DisallowAnyDuplicateSubgoals)\n";
		file << "		cout << \"   Disallowing any duplicate subgoals.\" << endl;\n";
		file << "	else if (true == b_DisallowNeighboringDuplicateSubgoals)\n";
		file << "		cout << \"   Disallowing neighboring duplicate subgoals.\" << endl;\n";
		file << "	else\n";
		file << "		cout << \"   Allowing duplicate subgoals.\" << endl;\n";
		file << "	if (true == b_UseLogarithmicDistanceScore)\n";
		file << "		cout << \"   Using logarithmic distance score.\" << endl;\n";
		file << "	else\n";
		file << "		cout << \"   Using normal distance score.\" << endl;\n";
		file << "	if (true == b_UsePredicateValueFeature)\n";
		file << "		cout << \"   Using predicate value feature.\" << endl;\n";
		file << "	if (true == b_UseReachableSubgoalFeature)\n";
		file << "		cout << \"   Using reachable-subgoal feature.\" << endl;\n";
		file << "	if (true == b_UseReachabilityEquivalents)\n";
		file << "		cout << \"   Using reachability equivalents.\" << endl;\n";
		file << "	cout << \"   predicate identity pair feature weight : \"\n";
		file << "		 << f_PredicateIdentityPairFeatureWeight << endl;\n";
		file << "\n";
		file << "	o_SequenceEndExploration.PrintConfiguration (\"Seq end\");\n";
		file << "	o_SubgoalExploration.PrintConfiguration (\"Subgoal\");\n";
		file << "	o_ConnectionExploration.PrintConfiguration (\"Connect\");\n";
		file << "\n";
		file << "\n";
		file << "	f_NonConnectionFeatureImportance = (double)(config)\"non_connection_feature_importance\";\n";
		file << "\n";
		file << "	if (false == LoadPredDictFile ())\n";
		file << "		return false;\n";
		file << "	AssignIndicesToTargetProblemPredicates ();\n";
		file << "\n";
		file << "	i_PredicateNames = hmp_PredicateNameToIndex.size ();\n";
		file << "	i_ParameterValues = hmp_ParameterValueToIndex.size ();\n";
		file << "	i_PredicateIdentities = hmp_PredicateIdToIndex.size ();\n";
		file << "\n";
		file << "\n";
		file << "	o_SequenceEndFeatureSpace.SetBagOfWordsOffset (2 * pow (i_PredicateIdentities, 2));\n";
		file << "\n";
		file << "	size_t iFeatureSet = i_MaxPredicateValue + 1 + 6\n";
		file << "						 + 2 * pow (i_PredicateNames, 2)\n";
		file << "						 + 2 * pow (i_ParameterValues, 2)\n";
		file << "						 + 2 * pow (i_PredicateIdentities, 2);\n";
		file << "	o_SubgoalFeatureSpace.SetBagOfWordsOffset (iFeatureSet);\n";
		file << "\n";
		file << "	i_OffsetToConnectionFeatures = i_MaxPredicateValue + 1;\n";
		file << "	i_OffsetToPredicateNameFeatures = 14 + i_OffsetToConnectionFeatures;\n";
		file << "	i_OffsetToParameterValueFeatures = i_OffsetToPredicateNameFeatures\n";
		file << "										+ 2 * pow (i_PredicateNames, 2);\n";
		file << "	i_OffsetToPredicateIdentityFeatures = i_OffsetToParameterValueFeatures\n";
		file << "										+ 2 * pow (i_ParameterValues, 2);\n";
		file << "\n";
		file << "	b_PrintTextConnectionFeatures\n";
		file << "		= (1 == (int)(config)\"features:print_text_connection_features\");\n";
		file << "	if (true == b_PrintTextConnectionFeatures)\n";
		file << "	{\n";
		file << "		//first three features\n";
		file << "		for (int i = 0; i < i_MaxPredicateValue; ++ i)\n";
		file << "		{\n";
		file << "			String sFeature;\n";
		file << "			sFeature << \"PredVal:\" << i;\n";
		file << "			map_FeatureIndexToFeatureString[i] = sFeature;\n";
		file << "		}\n";
		file << "\n";
		file << "		map_FeatureIndexToFeatureString [i_MaxPredicateValue] = \"<unused>\";\n";
		file << "		map_FeatureIndexToFeatureString [i_OffsetToConnectionFeatures] = \"<unused>\";\n";
		file << "		map_FeatureIndexToFeatureString [1 + i_OffsetToConnectionFeatures] = \"ReachableSubgoal\";\n";
		file << "		map_FeatureIndexToFeatureString [2 + i_OffsetToConnectionFeatures] = \"ConnInit\";\n";
		file << "		map_FeatureIndexToFeatureString [3 + i_OffsetToConnectionFeatures] = \"ConnInit+Reachable\";\n";
		file << "		map_FeatureIndexToFeatureString [4 + i_OffsetToConnectionFeatures] = \"NoConnInit\";\n";
		file << "\n";
		file << "		for (int d = 1; d < 5; ++ d)\n";
		file << "		{\n";
		file << "			map_FeatureIndexToFeatureString [5 + 2*(d-1) + i_OffsetToConnectionFeatures]\n";
		file << "									= \"ConnFuture\";\n";
		file << "			map_FeatureIndexToFeatureString [6 + 2*(d-1) + i_OffsetToConnectionFeatures]\n";
		file << "									= \"ConnFuture+Reachable\";\n";
		file << "		}\n";
		file << "		map_FeatureIndexToFeatureString [13 + i_OffsetToConnectionFeatures] = \"NoConnFuture\";\n";
		file << "\n";
		file << "\n";
		file << "		// populate Feature Strings -- names\n";
		file << "		ITERATE(FeatureToIndex_hmp_t, hmp_PredicateNameToIndex, itrFrom)\n";
		file << "		{\n";
		file << "			ITERATE(FeatureToIndex_hmp_t, hmp_PredicateNameToIndex, itrTo)\n";
		file << "			{\n";
		file << "				int iIndexInit = i_OffsetToPredicateNameFeatures\n";
		file << "								 + (2 * i_PredicateNames * itrFrom->second\n";
		file << "										+ itrTo->second);\n";
		file << "				int iIndexFuture = i_OffsetToPredicateNameFeatures\n";
		file << "								   + (2 * i_PredicateNames * itrFrom->second\n";
		file << "										  + itrTo->second\n";
		file << "										  + i_PredicateNames);\n";
		file << "				map_FeatureIndexToFeatureString [iIndexInit]\n";
		file << "					= \"NameInit::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "				map_FeatureIndexToFeatureString [iIndexFuture]\n";
		file << "					= \"NameFuture::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		// populate Feature Strings -- values\n";
		file << "		ITERATE(FeatureToIndex_hmp_t, hmp_ParameterValueToIndex, itrFrom)\n";
		file << "		{\n";
		file << "			ITERATE(FeatureToIndex_hmp_t, hmp_ParameterValueToIndex, itrTo)\n";
		file << "			{\n";
		file << "				int iIndexInit = i_OffsetToParameterValueFeatures\n";
		file << "								 + (2 * i_ParameterValues * itrFrom->second\n";
		file << "										+ itrTo->second);\n";
		file << "				int iIndexFuture = i_OffsetToParameterValueFeatures\n";
		file << "								   + (2 * i_ParameterValues * itrFrom->second\n";
		file << "										  + itrTo->second\n";
		file << "										  + i_ParameterValues);\n";
		file << "				map_FeatureIndexToFeatureString [iIndexInit]\n";
		file << "					= \"ValueInit::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "				map_FeatureIndexToFeatureString [iIndexFuture]\n";
		file << "					= \"ValueFuture::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		// populate Feature Strings -- identity\n";
		file << "		ITERATE(FeatureToIndex_hmp_t, hmp_PredicateIdToIndex, itrFrom)\n";
		file << "		{\n";
		file << "			ITERATE(FeatureToIndex_hmp_t, hmp_PredicateIdToIndex, itrTo)\n";
		file << "			{\n";
		file << "				int iIndexInit = i_OffsetToPredicateIdentityFeatures\n";
		file << "								 + (2 * i_PredicateIdentities*itrFrom->second\n";
		file << "										+ itrTo->second);\n";
		file << "				int iIndexFuture = i_OffsetToPredicateIdentityFeatures\n";
		file << "								   + (2 * i_PredicateIdentities * itrFrom->second\n";
		file << "										  + itrTo->second\n";
		file << "										  + i_PredicateIdentities);\n";
		file << "				map_FeatureIndexToFeatureString [iIndexInit]\n";
		file << "					= \"PredIdInit::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "				map_FeatureIndexToFeatureString [iIndexFuture]\n";
		file << "					= \"PredIdFuture::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		#ifndef NDEBUG\n";
		file << "		// make sure all the values are there\n";
		file << "		for(unsigned int i = 0; i < map_FeatureIndexToFeatureString.size(); i++)\n";
		file << "		{\n";
		file << "			assert (map_FeatureIndexToFeatureString.find(i)\n";
		file << "					!= map_FeatureIndexToFeatureString.end());\n";
		file << "		}\n";
		file << "		#endif\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	f_UseSimpleConnectionFeatures = (config)\"use_pddl_connection_features\";\n";
		file << "	f_UseTextConnectionFeatures = (config)\"use_text_connection_features\";\n";
		file << "	f_UseComplexNonConnectionFeatures = (config)\"use_complex_non_connection_features\";\n";
		file << "\n";
		file << "	b_LogConnectionPredictions = false;\n";
		file << "	b_LogConnectionFeedback = false;\n";
		file << "	if (f_UseTextConnectionFeatures > 0)\n";
		file << "	{\n";
		file << "		b_LogConnectionPredictions = (1 == (int)(config)\"log_connection_predictions\");\n";
		file << "		b_LogConnectionFeedback = (1 == (int)(config)\"log_connection_feedback\");\n";
		file << "	}\n";
		file << "\n";
		file << "	if ((f_UseSimpleConnectionFeatures > 0) &&\n";
		file << "		(f_UseTextConnectionFeatures > 0))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Conflicting configuration options set:\\n\"\n";
		file << "				\"Both 'use_pddl_connection_features' and 'use_text_connection_features'\\n\"\n";
		file << "				\"options have been set to true. Only one can be active at one time.\"\n";
		file << "			 << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	if (f_UseSimpleConnectionFeatures > 0)\n";
		file << "	{\n";
		file << "		if (false == LoadSimpleConnectionFile ())\n";
		file << "			return false;\n";
		file << "	}\n";
		file << "	else if (f_UseTextConnectionFeatures > 0)\n";
		file << "	{\n";
		file << "		if (false == LoadFeatureConnectionFile ())\n";
		file << "			return false;\n";
		file << "		if (true == b_PrintTextConnectionFeatures)\n";
		file << "			LoadFeaturesToDebugPrintFile();\n";
		file << "	}\n";
		file << "\n";
		file << "	if (true == b_LogConnectionPredictions)\n";
		file << "		WriteConnectionPredictionHeader ();\n";
		file << "\n";
		file << "	//NK: my debug stuff\n";
		file << "	b_UseGoldLength = (1 == (int)(config)\"use_gold_length\");\n";
		file << "	if (true == b_UseGoldLength)\n";
		file << "		LoadGoldLengthFile();\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::LoadFeaturesToDebugPrintFile(void)\n";
		file << "{\n";
		file << "	String sGoldLengthFile = (config)\"features:debug_features_to_print_file\";\n";
		file << "	// read in the dict file\n";
		file << "	String_dq_t dqLines;\n";
		file << "	File::ReadLines (sGoldLengthFile, dqLines);\n";
		file << "\n";
		file << "	ITERATE (String_dq_t, dqLines, iterLine)\n";
		file << "	{\n";
		file << "		String sFeature = *iterLine;\n";
		file << "		int iIndex = o_SubgoalFeatureSpace.GetFeatureIndex (sFeature, true);\n";
		file << "		if(iIndex == 0)\n";
		file << "		{\n";
		file << "			cout << \"Couldn't find feature:\" << sFeature << endl;\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		dq_FeaturesToDebugPrint.push_back(iIndex);\n";
		file << "	}\n";
		file << "\n";
		file << "	cout << \"   loaded \" << this->dq_FeaturesToDebugPrint.size()\n";
		file << "		 << \" features to debug print \" << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::LogDebugFeatureWeights (File* _pFile)\n";
		file << "{\n";
		file << "	if (false == b_PrintTextConnectionFeatures)\n";
		file << "		return;\n";
		file << "\n";
		file << "	*_pFile << \"Text Features:\" << endl;\n";
		file << "	ITERATE(int_dq_t, dq_FeaturesToDebugPrint, iter)\n";
		file << "	{\n";
		file << "		int iFeature = *iter;\n";
		file << "		*_pFile << \"Feature: \"\n";
		file << "				<< o_SubgoalSelectionModel.GetWeight(iFeature)\n";
		file << "				<< \":\" << GetFeatureString(iFeature)\n";
		file << "				<< \":\" <<  iFeature << endl;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String SubgoalPolicy::GetFeatureString(int _iIndex) const\n";
		file << "{\n";
		file << "	if (_iIndex >= o_SubgoalFeatureSpace.BagOfWordsOffset())\n";
		file << "	{\n";
		file << "		return o_SubgoalFeatureSpace.GetFeatureString(_iIndex);\n";
		file << "	}\n";
		file << "\n";
		file << "	int_String_map_t::const_iterator iter =  map_FeatureIndexToFeatureString.find(_iIndex);\n";
		file << "	assert(iter != map_FeatureIndexToFeatureString.end());\n";
		file << "	return iter->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::GetPredicateIdentityFeatureIndex (const String& _rPredicate)\n";
		file << "{\n";
		file << "	FeatureToIndex_hmp_t::iterator	ite;\n";
		file << "	ite = hmp_PredicateIdToIndex.find (_rPredicate);\n";
		file << "	if (hmp_PredicateIdToIndex.end () == ite)\n";
		file << "	{\n";
		file << "		int iIndex = hmp_PredicateIdToIndex.size ();\n";
		file << "		hmp_PredicateIdToIndex.insert (make_pair (_rPredicate, iIndex));\n";
		file << "		return iIndex;\n";
		file << "	}\n";
		file << "	return ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::GetPredicateNameFeatureIndex (const String& _rName)\n";
		file << "{\n";
		file << "	FeatureToIndex_hmp_t::iterator	ite;\n";
		file << "	ite = hmp_PredicateNameToIndex.find (_rName);\n";
		file << "	if (hmp_PredicateNameToIndex.end () == ite)\n";
		file << "	{\n";
		file << "		int iIndex = hmp_PredicateNameToIndex.size ();\n";
		file << "		hmp_PredicateNameToIndex.insert (make_pair (_rName, iIndex));\n";
		file << "		return iIndex;\n";
		file << "	}\n";
		file << "	return ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::GetPredicateWithoutNumberIndex (const PddlPredicate& _rPredicate)\n";
		file << "{\n";
		file << "	String sPddlWithoutNumber;\n";
		file << "	if (true == _rPredicate.b_IsFunction)\n";
		file << "	{\n";
		file << "		PddlFunctionValuePredicate* pClone\n";
		file << "			= (PddlFunctionValuePredicate*)((PddlPredicate&)_rPredicate).Clone ();\n";
		file << "		pClone->l_Value = 0;\n";
		file << "		sPddlWithoutNumber = pClone->GetPddlString ();\n";
		file << "		delete pClone;\n";
		file << "	}\n";
		file << "	else\n";
		file << "		sPddlWithoutNumber = _rPredicate.GetPddlString ();\n";
		file << "\n";
		file << "\n";
		file << "	FeatureToIndex_hmp_t::iterator	ite;\n";
		file << "	ite = hmp_PredicateWithoutNumberToIndex.find (sPddlWithoutNumber);\n";
		file << "	if (hmp_PredicateWithoutNumberToIndex.end () == ite)\n";
		file << "	{\n";
		file << "		int iIndex = hmp_PredicateWithoutNumberToIndex.size ();\n";
		file << "		hmp_PredicateWithoutNumberToIndex.insert (make_pair (sPddlWithoutNumber, iIndex));\n";
		file << "		return iIndex;\n";
		file << "	}\n";
		file << "	return ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::GetParameterValueFeatureIndex (const String& _rValue)\n";
		file << "{\n";
		file << "	FeatureToIndex_hmp_t::iterator	ite;\n";
		file << "	ite = hmp_ParameterValueToIndex.find (_rValue);\n";
		file << "	if (hmp_ParameterValueToIndex.end () == ite)\n";
		file << "	{\n";
		file << "		int iIndex = hmp_ParameterValueToIndex.size ();\n";
		file << "		hmp_ParameterValueToIndex.insert (make_pair (_rValue, iIndex));\n";
		file << "		return iIndex;\n";
		file << "	}\n";
		file << "	return ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::AssignIndicesToTargetProblemPredicates (void)\n";
		file << "{\n";
		file << "	cout << \"Assigning indices to problem predicates.\" << endl;\n";
		file << "	String_set_t setMissingInitPredicates;\n";
		file << "	String_set_t setMissingTargetPredicates;\n";
		file << "	for (long i = 0; i < Problem::GetProblemCount (); ++ i)\n";
		file << "	{\n";
		file << "		Problem* pProblem = Problem::GetProblem (i);\n";
		file << "		PddlProblem& rPddlProblem = pProblem->GetPddlProblem ();\n";
		file << "\n";
		file << "		int_set_t	setPredicateIdentityFI;\n";
		file << "		int_set_t	setPredicateNameFI;\n";
		file << "		int_set_t	setParameterValueFI;\n";
		file << "\n";
		file << "		// init state ...\n";
		file << "		ITERATE (PddlPredicate_dq_t, rPddlProblem.o_StartState.dq_Predicates, ite)\n";
		file << "		{\n";
		file << "			PddlPredicate* pPredicate = *ite;\n";
		file << "\n";
		file << "			// assign predicate candidate index ...\n";
		file << "			pPredicate->i_PredicateCandidateIndex = FindInitPredicateCandidateIndex (*pPredicate);\n";
		file << "			if (-1 == pPredicate->i_PredicateCandidateIndex)\n";
		file << "				setMissingInitPredicates.insert (pPredicate->GetPddlString ());\n";
		file << "\n";
		file << "			// assign feature indices to predicate\n";
		file << "			pPredicate->i_PredicateIdentityFeatureIndex\n";
		file << "				= GetPredicateIdentityFeatureIndex (pPredicate->GetPddlString ());\n";
		file << "			pPredicate->i_PredicateNameFeatureIndex\n";
		file << "				= GetPredicateNameFeatureIndex (pPredicate->s_Name);\n";
		file << "			pPredicate->i_PredicateCandidateWithoutNumber\n";
		file << "				= GetPredicateWithoutNumberIndex (*pPredicate);\n";
		file << "\n";
		file << "			int_set_t setValueFI;\n";
		file << "			CONST_ITERATE (PddlParameter_dq_t, pPredicate->dq_Parameters, iteParam)\n";
		file << "				setValueFI.insert (GetParameterValueFeatureIndex (*iteParam->p_ResolvedValue));\n";
		file << "\n";
		file << "			pPredicate->vec_ParameterValueFeatureIndex.Create (setValueFI.size ());\n";
		file << "			int x = 0;\n";
		file << "			ITERATE (int_set_t, setValueFI, iteFI)\n";
		file << "				pPredicate->vec_ParameterValueFeatureIndex [x++] = *iteFI;\n";
		file << "\n";
		file << "			// collect feature indicies for problem\n";
		file << "			setPredicateIdentityFI.insert (pPredicate->i_PredicateIdentityFeatureIndex);\n";
		file << "			setPredicateNameFI.insert (pPredicate->i_PredicateNameFeatureIndex);\n";
		file << "			setParameterValueFI.insert (setValueFI.begin (), setValueFI.end ());\n";
		file << "		}\n";
		file << "\n";
		file << "		// assign init feature indices to problem\n";
		file << "		pProblem->vec_InitPredicateIdentityFI.Create (setPredicateIdentityFI.size ());\n";
		file << "		int x = 0;\n";
		file << "		ITERATE (int_set_t, setPredicateIdentityFI, ite)\n";
		file << "			pProblem->vec_InitPredicateIdentityFI [x++] = *ite;\n";
		file << "\n";
		file << "		pProblem->vec_InitPredicateNameFI.Create (setPredicateNameFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setPredicateNameFI, ite)\n";
		file << "			pProblem->vec_InitPredicateNameFI [x++] = *ite;\n";
		file << "\n";
		file << "		pProblem->vec_InitParameterValueFI.Create (setParameterValueFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setParameterValueFI, ite)\n";
		file << "			pProblem->vec_InitParameterValueFI [x++] = *ite;\n";
		file << "\n";
		file << "\n";
		file << "		// goal state ...\n";
		file << "		setPredicateIdentityFI.clear ();\n";
		file << "		setPredicateNameFI.clear ();\n";
		file << "		setParameterValueFI.clear ();\n";
		file << "\n";
		file << "		ITERATE (PddlPredicate_dq_t, rPddlProblem.o_PartialGoalState.dq_Predicates, ite)\n";
		file << "		{\n";
		file << "			PddlPredicate* pPredicate = *ite;\n";
		file << "\n";
		file << "			// assign predicate candidate index ...\n";
		file << "			pPredicate->i_PredicateCandidateIndex = FindPredicateCandidateIndex (*pPredicate);\n";
		file << "			if (-1 == pPredicate->i_PredicateCandidateIndex)\n";
		file << "				setMissingTargetPredicates.insert (pPredicate->GetPddlString ());\n";
		file << "\n";
		file << "			// assign feature indices to predicate\n";
		file << "			pPredicate->i_PredicateIdentityFeatureIndex\n";
		file << "				= GetPredicateIdentityFeatureIndex (pPredicate->GetPddlString ());\n";
		file << "			pPredicate->i_PredicateNameFeatureIndex\n";
		file << "				= GetPredicateNameFeatureIndex (pPredicate->s_Name);\n";
		file << "			pPredicate->i_PredicateCandidateWithoutNumber\n";
		file << "				= GetPredicateWithoutNumberIndex (*pPredicate);\n";
		file << "\n";
		file << "			int_set_t setValueFI;\n";
		file << "			CONST_ITERATE (PddlParameter_dq_t, pPredicate->dq_Parameters, iteParam)\n";
		file << "				setValueFI.insert (GetParameterValueFeatureIndex (*iteParam->p_ResolvedValue));\n";
		file << "\n";
		file << "			pPredicate->vec_ParameterValueFeatureIndex.Create (setValueFI.size ());\n";
		file << "			int x = 0;\n";
		file << "			ITERATE (int_set_t, setValueFI, iteFI)\n";
		file << "				pPredicate->vec_ParameterValueFeatureIndex [x++] = *iteFI;\n";
		file << "\n";
		file << "			// collect feature indicies for problem\n";
		file << "			setPredicateIdentityFI.insert (pPredicate->i_PredicateIdentityFeatureIndex);\n";
		file << "			setPredicateNameFI.insert (pPredicate->i_PredicateNameFeatureIndex);\n";
		file << "			setParameterValueFI.insert (setValueFI.begin (), setValueFI.end ());\n";
		file << "		}\n";
		file << "\n";
		file << "		// assign target feature indices to problem\n";
		file << "		pProblem->vec_TargetPredicateIdentityFI.Create (setPredicateIdentityFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setPredicateIdentityFI, ite)\n";
		file << "			pProblem->vec_TargetPredicateIdentityFI [x++] = *ite;\n";
		file << "\n";
		file << "		pProblem->vec_TargetPredicateNameFI.Create (setPredicateNameFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setPredicateNameFI, ite)\n";
		file << "			pProblem->vec_TargetPredicateNameFI [x++] = *ite;\n";
		file << "\n";
		file << "		pProblem->vec_TargetParameterValueFI.Create (setParameterValueFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setParameterValueFI, ite)\n";
		file << "			pProblem->vec_TargetParameterValueFI [x++] = *ite;\n";
		file << "	}\n";
		file << "\n";
		file << "	cout << \"   \" << setMissingInitPredicates.size ()\n";
		file << "		 << \" init predicates not present in candidate list.\" << endl;\n";
		file << "	cout << \"   \" << setMissingTargetPredicates.size ()\n";
		file << "		 << \" target predicates not present in candidate list.\" << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::LoadGoldLengthFile(void)\n";
		file << "{\n";
		file << "	String sGoldLengthFile = (config)\"gold_length_file\";\n";
		file << "	// read in the dict file\n";
		file << "	String_dq_t dqLines;\n";
		file << "	File::ReadLines (sGoldLengthFile, dqLines);\n";
		file << "\n";
		file << "	ITERATE (String_dq_t, dqLines, iterLine)\n";
		file << "	{\n";
		file << "		// Problem | length\n";
		file << "		String_dq_t dqSplit;\n";
		file << "		iterLine->Split (dqSplit, '|');\n";
		file << "		assert (dqSplit.size () == 2);\n";
		file << "		String sProblem = dqSplit[0];\n";
		file << "		int iLength = dqSplit[1];\n";
		file << "		this->map_ProblemToGoldLength[sProblem] = iLength;\n";
		file << "	}\n";
		file << "\n";
		file << "	cout << \"   loaded \" << this->map_ProblemToGoldLength.size()\n";
		file << "		 << \" gold lengths \" << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::LoadPredDictFile (void)\n";
		file << "{\n";
		file << "	String sPddlDictFile = (config)\"pddl_dict_file\";\n";
		file << "	cout << \"   loading dict: \" << sPddlDictFile << endl;\n";
		file << "	// read in the dict file\n";
		file << "	String_dq_t dqLines;\n";
		file << "	if (false == File::ReadLines (sPddlDictFile, dqLines))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed to read predicate dictionary file.\" << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	i_MaxPredicateValue = 0;\n";
		file << "	vec_CandidatePredicates.reserve (dqLines.size ());\n";
		file << "	ITERATE (String_dq_t, dqLines, iterLine)\n";
		file << "	{\n";
		file << "		// id | 0/1 predicate/function | name\n";
		file << "		String_dq_t dqSplit;\n";
		file << "		iterLine->Split (dqSplit, '|');\n";
		file << "		assert (dqSplit.size () == 3);\n";
		file << "\n";
		file << "		int iIndex = dqSplit [0];\n";
		file << "		int iValue = (int)dqSplit [1];\n";
		file << "		bool bIsFunction = (iValue > 0);\n";
		file << "		String sPredicate = dqSplit[2];\n";
		file << "		sPredicate.Strip ();\n";
		file << "\n";
		file << "		String_dq_t dqPred;\n";
		file << "		sPredicate.Split (dqPred, ' ');\n";
		file << "\n";
		file << "		PddlPredicate* pPred;\n";
		file << "		if (true == bIsFunction)\n";
		file << "			pPred = new PddlFunctionValuePredicate;\n";
		file << "		else\n";
		file << "			pPred = new PddlPredicate;\n";
		file << "\n";
		file << "		pPred->i_PredicateCandidateIndex = iIndex;\n";
		file << "		pPred->s_Name = dqPred [0];\n";
		file << "		pPred->b_IsFunction = bIsFunction;\n";
		file << "		pPred->l_Value = iValue;\n";
		file << "\n";
		file << "		if (true == bIsFunction)\n";
		file << "		{\n";
		file << "			pPred->l_Value --;\n";
		file << "			((PddlFunctionValuePredicate*)pPred)->c_Operator = '>';\n";
		file << "			if (i_MaxPredicateValue < pPred->l_Value)\n";
		file << "				i_MaxPredicateValue = pPred->l_Value;\n";
		file << "		}\n";
		file << "\n";
		file << "		int_set_t setValueFI;\n";
		file << "		for (unsigned int i = 1; i < dqPred.size (); i++)\n";
		file << "		{\n";
		file << "			pPred->dq_Parameters.push_back (PddlParameter());\n";
		file << "			pPred->dq_Parameters [i-1].SetValue (dqPred [i]);\n";
		file << "			setValueFI.insert (GetParameterValueFeatureIndex (dqPred [i]));\n";
		file << "		}\n";
		file << "		pPred->vec_ParameterValueFeatureIndex.Create (setValueFI.size ());\n";
		file << "		int x = 0;\n";
		file << "		ITERATE (int_set_t, setValueFI, iteFI)\n";
		file << "			pPred->vec_ParameterValueFeatureIndex [x++] = *iteFI;\n";
		file << "\n";
		file << "		assert ((long) vec_CandidatePredicates.size () == iIndex);\n";
		file << "		vec_CandidatePredicates.push_back (pPred);\n";
		file << "\n";
		file << "		String sPddlString (pPred->GetPddlString ());\n";
		file << "		pair <PddlStringToPredicate_map_t::iterator, bool> pairInsert;\n";
		file << "		pairInsert = map_PddlStringToCandidatePredicate.insert (make_pair (sPddlString, pPred));\n";
		file << "		if (false == pairInsert.second)\n";
		file << "		{\n";
		file << "			cerr << \"[ERROR] Duplicate predicate in candidate dictionary?\\n\"\n";
		file << "				 << sPddlString << endl;\n";
		file << "		}\n";
		file << "\n";
		file << "		pPred->i_PredicateIdentityFeatureIndex\n";
		file << "			= GetPredicateIdentityFeatureIndex (pPred->GetPddlString ());\n";
		file << "		pPred->i_PredicateNameFeatureIndex\n";
		file << "			= GetPredicateNameFeatureIndex (pPred->s_Name);\n";
		file << "		pPred->i_PredicateCandidateWithoutNumber\n";
		file << "			= GetPredicateWithoutNumberIndex (*pPred);\n";
		file << "\n";
		file << "\n";
		file << "		if (true == pPred->b_IsFunction)\n";
		file << "		{\n";
		file << "			PddlFunctionValuePredicate* pClone = (PddlFunctionValuePredicate*)pPred->Clone ();\n";
		file << "			pClone->c_Operator = '=';\n";
		file << "			++ pClone->l_Value;\n";
		file << "\n";
		file << "			map_PddlStringToCandidatePredicate [pClone->GetPddlString ()] = pPred;\n";
		file << "			delete pClone;\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	// '0' is a valid predicate value, so we need to add 1 here...\n";
		file << "	++ i_MaxPredicateValue;\n";
		file << "\n";
		file << "	i_CandidatePredicates = vec_CandidatePredicates.size ();\n";
		file << "	vec_CanReachCandidatePredicate.resize (i_CandidatePredicates, 0);\n";
		file << "\n";
		file << "	i_CandidatePredicateNumbersMerged = hmp_PredicateWithoutNumberToIndex.size ();\n";
		file << "\n";
		file << "	// compute reachability predicate equivalents...\n";
		file << "	vector <int_set_t>	vecReachabilityEquivalents;\n";
		file << "	vecReachabilityEquivalents.resize (i_CandidatePredicates);\n";
		file << "	for (int i = 0; i < i_CandidatePredicates; ++ i)\n";
		file << "	{\n";
		file << "		PddlPredicate* pPred = vec_CandidatePredicates [i];\n";
		file << "		if (false == pPred->b_IsFunction)\n";
		file << "			continue;\n";
		file << "\n";
		file << "		PddlFunctionValuePredicate* pClone = (PddlFunctionValuePredicate*)pPred->Clone ();\n";
		file << "		pClone->l_Value = 0;\n";
		file << "\n";
		file << "		PddlPredicate* pEquivalent = FindEquivalentPredicateCandidate (*pClone);\n";
		file << "		delete pClone;\n";
		file << "		if (NULL == pEquivalent)\n";
		file << "		{\n";
		file << "			cerr << \"[ERROR] Predicate candidate with numeric value 0 not found: \"\n";
		file << "				 << pClone->GetPddlString () << endl;\n";
		file << "			abort ();\n";
		file << "		}\n";
		file << "\n";
		file << "		vecReachabilityEquivalents [pEquivalent->i_PredicateCandidateIndex].insert (pPred->i_PredicateCandidateIndex);\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	for (int i = 0; i < i_CandidatePredicates; ++ i)\n";
		file << "	{\n";
		file << "		ITERATE (int_set_t, vecReachabilityEquivalents [i], ite)\n";
		file << "		{\n";
		file << "			vecReachabilityEquivalents [*ite].insert (i);\n";
		file << "			ITERATE (int_set_t, vecReachabilityEquivalents [i], iteOther)\n";
		file << "				vecReachabilityEquivalents [*ite].insert (*iteOther);\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	vec_ReachabilityPredicateEqulivalents.resize (i_CandidatePredicates);\n";
		file << "	for (int i = 0; i < i_CandidatePredicates; ++ i)\n";
		file << "	{\n";
		file << "		ITERATE (int_set_t, vecReachabilityEquivalents [i], ite)\n";
		file << "			vec_ReachabilityPredicateEqulivalents [i].push_back (*ite);\n";
		file << "	}\n";
		file << "\n";
		file << "	mtx_PredicateConnectionsFromTo.Create (i_CandidatePredicates,\n";
		file << "										   i_CandidatePredicates);\n";
		file << "	mtx_PredicateConnectionsFromTo.Memset (0);\n";
		file << "	mtx_PredicateConnectionsToFrom.Create (i_CandidatePredicates,\n";
		file << "										   i_CandidatePredicates);\n";
		file << "	mtx_PredicateConnectionsToFrom.Memset (0);\n";
		file << "\n";
		file << "\n";
		file << "	cout << \"   loaded \" << i_CandidatePredicates\n";
		file << "		 << \" candidate predicates.  Max value of \"\n";
		file << "		 << i_MaxPredicateValue << endl;\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::LoadSimpleConnectionFile (void)\n";
		file << "{\n";
		file << "	i_MaxConnectionDepth = 0;\n";
		file << "	cout << \"   loading simple connection file: \"\n";
		file << "		 << (config)\"pddl_connection_file\" << endl;\n";
		file << "\n";
		file << "	String_dq_t dqLines;\n";
		file << "	if (false == File::ReadLines ((config)\"pddl_connection_file\", dqLines))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed to open connection file.\" << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "	ITERATE(String_dq_t, dqLines, ite)\n";
		file << "	{\n";
		file << "		String_dq_t dqSplit;\n";
		file << "		ite->Split(dqSplit, '|');\n";
		file << "\n";
		file << "		assert(dqSplit.size() >= 3);\n";
		file << "		int iDepth = dqSplit[0];\n";
		file << "		int iFrom = dqSplit[1];\n";
		file << "		int iTo = dqSplit[2];\n";
		file << "		mtx_PredicateConnectionsFromTo (iFrom, iTo) = iDepth;\n";
		file << "		mtx_PredicateConnectionsToFrom (iTo, iFrom) = iDepth;\n";
		file << "\n";
		file << "		if (i_MaxConnectionDepth < iDepth)\n";
		file << "			i_MaxConnectionDepth = iDepth;\n";
		file << "	}\n";
		file << "	cout << \"   loaded \" << dqLines.size ()\n";
		file << "		 << \" pddl relationships, with max depth \"\n";
		file << "		 << i_MaxConnectionDepth << endl;\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::LoadFeatureConnectionFile (void)\n";
		file << "{\n";
		file << "	i_MaxConnectionDepth = 0;\n";
		file << "	cout << \"   loading feature connection file : \"\n";
		file << "		 << (config)\"text_connection_file\" << endl;\n";
		file << "\n";
		file << "	ConnectionHashToFeatures_map_t	mapConnectionHashToFeatures;\n";
		file << "\n";
		file << "	//\n";
		file << "	File file;\n";
		file << "	if (false == file.Open ((config)\"text_connection_file\"))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed open connection file.\" << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	size_t iLines = 0;\n";
		file << "	String sLine;\n";
		file << "	while (true == file.ReadLine (sLine))\n";
		file << "	{\n";
		file << "		++ iLines;\n";
		file << "		String_dq_t dqSplit;\n";
		file << "		sLine.Split(dqSplit, '|');\n";
		file << "\n";
		file << "		assert(dqSplit.size() >= 5);\n";
		file << "		String sFeature = dqSplit [0];\n";
		file << "		float fFeatureValue = (double) dqSplit [1];\n";
		file << "		int iFrom = dqSplit [2];\n";
		file << "		int iTo = dqSplit [3];\n";
		file << "		int iSentenceId = dqSplit [4];\n";
		file << "\n";
		file << "		String sHash;\n";
		file << "		sHash << iFrom << '|' << iTo << '|' << iSentenceId;\n";
		file << "		FeatureToValue_map_t* pmapFeatureToValuePos;\n";
		file << "		// FeatureToValue_map_t* pmapFeatureToValueNeg;\n";
		file << "		ConnectionHashToFeatures_map_t::iterator	iteFeatures;\n";
		file << "		iteFeatures = mapConnectionHashToFeatures.find (sHash);\n";
		file << "		if (mapConnectionHashToFeatures.end () == iteFeatures)\n";
		file << "		{\n";
		file << "			SentenceConnection* pConnection = new SentenceConnection;\n";
		file << "			vec_SentenceConnections.push_back (pConnection);\n";
		file << "			pConnection->i_Sentence = iSentenceId;\n";
		file << "			pConnection->i_From = iFrom;\n";
		file << "			pConnection->i_To = iTo;\n";
		file << "\n";
		file << "			pmapFeatureToValuePos = new FeatureToValue_map_t;\n";
		file << "			// pmapFeatureToValueNeg = new FeatureToValue_map_t;\n";
		file << "			mapConnectionHashToFeatures.insert (make_pair (sHash, pmapFeatureToValuePos));\n";
		file << "		}\n";
		file << "		else\n";
		file << "		{\n";
		file << "			pmapFeatureToValuePos = iteFeatures->second;\n";
		file << "			// pmapFeatureToValuePos = iteFeatures->second.first;\n";
		file << "			// pmapFeatureToValueNeg = iteFeatures->second.second;\n";
		file << "		}\n";
		file << "\n";
		file << "		// String sPositiveFeature;\n";
		file << "		// sPositiveFeature << \"pos\\x01\" << sFeature;\n";
		file << "		int iFeature = o_TextConnectionFeatureSpace.GetFeatureIndex (sFeature);\n";
		file << "		pmapFeatureToValuePos->insert (make_pair (iFeature, fFeatureValue));\n";
		file << "\n";
		file << "		// String sNegativeFeature;\n";
		file << "		// sNegativeFeature << \"neg\\x01\" << sFeature;\n";
		file << "		// int iNegativeFeature = o_TextConnectionFeatureSpace.GetFeatureIndex (sNegativeFeature);\n";
		file << "		// pmapFeatureToValueNeg->insert (make_pair (iNegativeFeature, fFeatureValue));\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	//\n";
		file << "	mtx_SentencesPositiveFromTo.Create (i_CandidatePredicateNumbersMerged, i_CandidatePredicateNumbersMerged);\n";
		file << "	mtx_SentencesPositiveFromTo.Memset (0);\n";
		file << "	mtx_SentencesNegativeFromTo.Create (i_CandidatePredicateNumbersMerged, i_CandidatePredicateNumbersMerged);\n";
		file << "	mtx_SentencesNegativeFromTo.Memset (0);\n";
		file << "\n";
		file << "	ITERATE (SentenceConnection_vec_t, vec_SentenceConnections, iteConn)\n";
		file << "	{\n";
		file << "		SentenceConnection* pConnection = *iteConn;\n";
		file << "		pConnection->p_PositiveFeatures = new Features;\n";
		file << "		pConnection->p_NegativeFeatures = new Features;\n";
		file << "\n";
		file << "		String sHash;\n";
		file << "		sHash << pConnection->i_From << '|'\n";
		file << "			  << pConnection->i_To << '|'\n";
		file << "			  << pConnection->i_Sentence;\n";
		file << "\n";
		file << "		ConnectionHashToFeatures_map_t::iterator	iteFeatures;\n";
		file << "		iteFeatures = mapConnectionHashToFeatures.find (sHash);\n";
		file << "		assert (mapConnectionHashToFeatures.end () != iteFeatures);\n";
		file << "\n";
		file << "		FeatureToValue_map_t* pmapFeatureToValuePos = iteFeatures->second;\n";
		file << "		pConnection->p_PositiveFeatures->SetSize (pmapFeatureToValuePos->size ());\n";
		file << "		pConnection->p_NegativeFeatures->SetSize (pmapFeatureToValuePos->size ());\n";
		file << "		ITERATE (FeatureToValue_map_t, (*pmapFeatureToValuePos), ite)\n";
		file << "		{\n";
		file << "			pConnection->p_PositiveFeatures->Set (ite->first, ite->second);\n";
		file << "			pConnection->p_NegativeFeatures->Set (ite->first, - ite->second);\n";
		file << "		}\n";
		file << "\n";
		file << "		// FeatureToValue_map_t* pmapFeatureToValueNeg = iteFeatures->second.second;\n";
		file << "		// pConnection->p_NegativeFeatures->SetSize (pmapFeatureToValueNeg->size ());\n";
		file << "		// ITERATE (FeatureToValue_map_t, (*pmapFeatureToValueNeg), ite)\n";
		file << "		//	pConnection->p_NegativeFeatures->Set (ite->first, ite->second);\n";
		file << "\n";
		file << "		delete pmapFeatureToValuePos;\n";
		file << "		// delete pmapFeatureToValueNeg;\n";
		file << "\n";
		file << "		PddlPredicate* pFrom = vec_CandidatePredicates [pConnection->i_From];\n";
		file << "		int iFrom = pFrom->i_PredicateCandidateWithoutNumber;\n";
		file << "		PddlPredicate* pTo = vec_CandidatePredicates [pConnection->i_To];\n";
		file << "		int iTo = pTo->i_PredicateCandidateWithoutNumber;\n";
		file << "\n";
		file << "		if (NULL == mtx_SentencesPositiveFromTo (iFrom, iTo))\n";
		file << "			mtx_SentencesPositiveFromTo (iFrom, iTo) = new int_dq_t;\n";
		file << "		if (NULL == mtx_SentencesNegativeFromTo (iFrom, iTo))\n";
		file << "			mtx_SentencesNegativeFromTo (iFrom, iTo) = new int_dq_t;\n";
		file << "	}\n";
		file << "	mapConnectionHashToFeatures.clear ();\n";
		file << "\n";
		file << "	lprb_SentenceConnection.Create (2);\n";
		file << "	mtx_FeedbackOnSentenceConnections.Create (i_CandidatePredicateNumbersMerged,\n";
		file << "											  i_CandidatePredicateNumbersMerged,\n";
		file << "											  3);\n";
		file << "	mtx_FeedbackOnSentenceConnections.Memset (0);\n";
		file << "\n";
		file << "\n";
		file << "	cout << \"   loaded \" << vec_SentenceConnections.size ()\n";
		file << "		 << \" text relationships, and \" << iLines\n";
		file << "		 << \" features for an average feature size of \"\n";
		file << "		 << iLines / (float)vec_SentenceConnections.size () << endl;\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::ComputeSequenceEndFeatures (int _iIndex,\n";
		file << "												const Problem& _rProblem,\n";
		file << "												SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	// features look at last subgoal & init state.\n";
		file << "	// [predicate identity]^2\n";
		file << "	// [connections]\n";
		file << "	Subgoal* pSubgoal = _pSequence->GetSubgoal (_iIndex);\n";
		file << "	pSubgoal->vec_SequenceEndFeatureVectors.resize (2);\n";
		file << "\n";
		file << "	// all features are computed by comparing the\n";
		file << "	// next subgoal in the sequence with the init\n";
		file << "	// state...\n";
		file << "	Subgoal* pNextSubgoal = _pSequence->GetSubgoal (_iIndex + 1);\n";
		file << "	assert (NULL != pNextSubgoal);\n";
		file << "\n";
		file << "\n";
		file << "	for (int e = 0; e < 2; ++ e)\n";
		file << "	{\n";
		file << "		Features* pFeatures = new Features;\n";
		file << "		pSubgoal->vec_SequenceEndFeatureVectors [e] = pFeatures;\n";
		file << "\n";
		file << "		size_t iFeatureCount = _rProblem.vec_InitPredicateIdentityFI.Size ();\n";
		file << "		pFeatures->SetSize (iFeatureCount);\n";
		file << "		// pFeatures->SetSize (1);\n";
		file << "\n";
		file << "		// predicate identity...\n";
		file << "		size_t iOffset = pNextSubgoal->p_PddlSubgoalPredicate->i_PredicateIdentityFeatureIndex\n";
		file << "						 * 2 * i_PredicateIdentities\n";
		file << "						 + e * i_PredicateIdentities;\n";
		file << "		SetFeatures (_rProblem.vec_InitPredicateIdentityFI,\n";
		file << "					 iOffset,\n";
		file << "					 pFeatures);\n";
		file << "		/*\n";
		file << "		size_t iOffset = pNextSubgoal->p_PddlSubgoalPredicate->i_PredicateIdentityFeatureIndex\n";
		file << "						 + e * i_PredicateIdentities;\n";
		file << "		pFeatures->Set (iOffset, 1);\n";
		file << "		*/\n";
		file << "\n";
		file << "		// connections ...\n";
		file << "		// [SB] I'm not sure connection features\n";
		file << "		// are good to have here.  We're assuming\n";
		file << "		// that connection features will encode\n";
		file << "		// long distance relationships, whereas\n";
		file << "		// predicting sequence-end requires short\n";
		file << "		// distance relationships...\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::ComputeSubgoalFeatures (int _iIndex,\n";
		file << "											const Problem& _rProblem,\n";
		file << "											SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	PddlProblem& rPddlProblem = ((Problem&)_rProblem).GetPddlProblem ();\n";
		file << "	Subgoal* pSubgoal = _pSequence->GetSubgoal (_iIndex);\n";
		file << "	pSubgoal->vec_SubgoalFeatureVectors.resize (i_CandidatePredicates);\n";
		file << "\n";
		file << "	int iSubgoals = (int)_pSequence->dq_Subgoals.size ();\n";
		file << "	// include the target\n";
		file << "	bool bIncludeTarget = (!b_UseOnlyPreviousSubgoal || (_iIndex == iSubgoals-1));\n";
		file << "	size_t iEndSubgoal = b_UseOnlyPreviousSubgoal ? min(iSubgoals,_iIndex+2) : iSubgoals;\n";
		file << "\n";
		file << "\n";
		file << "	float fDistanceFactorToTarget = DistanceScore (_pSequence->Length () - _iIndex);\n";
		file << "	for (int c = 0; c < i_CandidatePredicates; ++ c)\n";
		file << "	{\n";
		file << "		const PddlPredicate* pCandidatePredicate = vec_CandidatePredicates [c];\n";
		file << "		int iReachableSubgoal = 0;\n";
		file << "		if ((true == b_UseReachableSubgoalFeature) &&\n";
		file << "			(true == b_UseComplexNonConnectionFeatures))\n";
		file << "			iReachableSubgoal = (int) vec_CanReachCandidatePredicate [c];\n";
		file << "		Features* pFeatures = new Features;\n";
		file << "		pSubgoal->vec_SubgoalFeatureVectors [c] = pFeatures;\n";
		file << "\n";
		file << "		int iCandidatePredicateParameters\n";
		file << "			= pCandidatePredicate->vec_ParameterValueFeatureIndex.Size ();\n";
		file << "\n";
		file << "\n";
		file << "		// set feature vector size ...\n";
		file << "		size_t iFeatureCount = 2;\n";
		file << "		if (0 != f_NonConnectionFeatureImportance)\n";
		file << "		{\n";
		file << "			iFeatureCount += _rProblem.vec_InitPredicateNameFI.Size ()\n";
		file << "							 + _rProblem.vec_TargetPredicateNameFI.Size ()\n";
		file << "							 + _rProblem.vec_InitPredicateIdentityFI.Size ()\n";
		file << "							 + _rProblem.vec_TargetPredicateIdentityFI.Size ()\n";
		file << "							 + iCandidatePredicateParameters\n";
		file << "								* (_rProblem.vec_InitParameterValueFI.Size ()\n";
		file << "									+ _rProblem.vec_TargetParameterValueFI.Size ());\n";
		file << "\n";
		file << "			for (size_t i = _iIndex + 1; i < _pSequence->dq_Subgoals.size (); ++ i)\n";
		file << "			{\n";
		file << "				Subgoal& rSubgoal = _pSequence->dq_Subgoals [i];\n";
		file << "				PddlPredicate* pSubgoalPredicate = rSubgoal.p_PddlSubgoalPredicate;\n";
		file << "				iFeatureCount += 2 + pSubgoalPredicate->vec_ParameterValueFeatureIndex.Size ();\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		//\n";
		file << "		iFeatureCount += 4;\n";
		file << "		pFeatures->SetSize (iFeatureCount);\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "		// predicate numerics feature...\n";
		file << "		if ((true == b_UsePredicateValueFeature) &&\n";
		file << "			(true == b_UseComplexNonConnectionFeatures))\n";
		file << "		{\n";
		file << "			assert (pCandidatePredicate->l_Value >= 0);\n";
		file << "			// pFeatures->Set (0, 0.1 * pCandidatePredicate->l_Value);\n";
		file << "			// pFeatures->Set (pCandidatePredicate->l_Value, 0.01);\n";
		file << "		}\n";
		file << "		// pFeatures->Set (1 + i_OffsetToConnectionFeatures, iReachableSubgoal);\n";
		file << "\n";
		file << "\n";
		file << "		// features to init & target ...\n";
		file << "		if (0 != f_NonConnectionFeatureImportance)\n";
		file << "		{\n";
		file << "			// predicate name...\n";
		file << "			size_t iOffset = i_OffsetToPredicateNameFeatures\n";
		file << "							 + pCandidatePredicate->i_PredicateNameFeatureIndex\n";
		file << "							 * 2 * i_PredicateNames;\n";
		file << "			if(true == b_IncludeInit)\n";
		file << "			{\n";
		file << "				SetFeatures (_rProblem.vec_InitPredicateNameFI,\n";
		file << "							 iOffset,\n";
		file << "							 pFeatures,\n";
		file << "							 f_NonConnectionFeatureImportance);\n";
		file << "			}\n";
		file << "			if (true == bIncludeTarget)\n";
		file << "			{\n";
		file << "				SetFeatures (_rProblem.vec_TargetPredicateNameFI,\n";
		file << "							 iOffset + i_PredicateNames,\n";
		file << "							 pFeatures,\n";
		file << "							 fDistanceFactorToTarget * f_NonConnectionFeatureImportance);\n";
		file << "			}\n";
		file << "\n";
		file << "			// predicate identity...\n";
		file << "			iOffset = i_OffsetToPredicateIdentityFeatures\n";
		file << "					  + pCandidatePredicate->i_PredicateIdentityFeatureIndex\n";
		file << "					  * 2 * i_PredicateIdentities;\n";
		file << "			if(true == b_IncludeInit)\n";
		file << "			{\n";
		file << "				SetFeatures (_rProblem.vec_InitPredicateIdentityFI,\n";
		file << "							 iOffset,\n";
		file << "							 pFeatures,\n";
		file << "							 f_PredicateIdentityPairFeatureWeight\n";
		file << "							 * f_NonConnectionFeatureImportance);\n";
		file << "			}\n";
		file << "			if (true == bIncludeTarget)\n";
		file << "			{\n";
		file << "				SetFeatures (_rProblem.vec_TargetPredicateIdentityFI,\n";
		file << "							 iOffset + i_PredicateIdentities,\n";
		file << "							 pFeatures,\n";
		file << "							 f_PredicateIdentityPairFeatureWeight\n";
		file << "							 	 * fDistanceFactorToTarget\n";
		file << "							 	 * f_NonConnectionFeatureImportance);\n";
		file << "			}\n";
		file << "\n";
		file << "			// parameter values...\n";
		file << "			for (int v = 0; v < iCandidatePredicateParameters; ++ v)\n";
		file << "			{\n";
		file << "				iOffset = i_OffsetToParameterValueFeatures\n";
		file << "						  + pCandidatePredicate->vec_ParameterValueFeatureIndex [v]\n";
		file << "						  * 2 * i_ParameterValues;\n";
		file << "				if(true == b_IncludeInit)\n";
		file << "				{\n";
		file << "					SetFeatures (_rProblem.vec_InitParameterValueFI,\n";
		file << "								 iOffset,\n";
		file << "								 pFeatures,\n";
		file << "								 f_NonConnectionFeatureImportance);\n";
		file << "				}\n";
		file << "\n";
		file << "				if (true == bIncludeTarget)\n";
		file << "				{\n";
		file << "					SetFeatures (_rProblem.vec_TargetParameterValueFI,\n";
		file << "								 iOffset + i_ParameterValues,\n";
		file << "								 pFeatures,\n";
		file << "								 fDistanceFactorToTarget * f_NonConnectionFeatureImportance);\n";
		file << "				}\n";
		file << "			}\n";
		file << "\n";
		file << "\n";
		file << "			// features to other subgoals ...\n";
		file << "			for (size_t i = _iIndex + 1; i < iEndSubgoal; ++ i)\n";
		file << "			{\n";
		file << "				Subgoal& rSubgoal = _pSequence->dq_Subgoals [i];\n";
		file << "				PddlPredicate* pSubgoalPredicate = rSubgoal.p_PddlSubgoalPredicate;\n";
		file << "				float fDistanceFactor = f_NonConnectionFeatureImportance * DistanceScore (i - _iIndex);\n";
		file << "\n";
		file << "				// predicate name...\n";
		file << "				iOffset = i_OffsetToPredicateNameFeatures\n";
		file << "						  + pCandidatePredicate->i_PredicateNameFeatureIndex\n";
		file << "						  * 2 * i_PredicateNames + i_PredicateNames;\n";
		file << "				pFeatures->Set (iOffset + pSubgoalPredicate->i_PredicateNameFeatureIndex,\n";
		file << "								fDistanceFactor,\n";
		file << "								false);\n";
		file << "\n";
		file << "				// predicate identity...\n";
		file << "				iOffset = i_OffsetToPredicateIdentityFeatures\n";
		file << "						  + pCandidatePredicate->i_PredicateIdentityFeatureIndex\n";
		file << "						  * 2 * i_PredicateIdentities + i_PredicateIdentities;\n";
		file << "				pFeatures->Set (iOffset + pSubgoalPredicate->i_PredicateIdentityFeatureIndex,\n";
		file << "								f_PredicateIdentityPairFeatureWeight * fDistanceFactor,\n";
		file << "								false);\n";
		file << "\n";
		file << "				// parameter values...\n";
		file << "				for (int v = 0; v < iCandidatePredicateParameters; ++ v)\n";
		file << "				{\n";
		file << "					iOffset = i_OffsetToParameterValueFeatures\n";
		file << "							  + pCandidatePredicate->vec_ParameterValueFeatureIndex [v]\n";
		file << "							  * 2 * i_ParameterValues + i_ParameterValues;\n";
		file << "\n";
		file << "					SetFeatures (pSubgoalPredicate->vec_ParameterValueFeatureIndex,\n";
		file << "								 iOffset,\n";
		file << "								 pFeatures,\n";
		file << "								 fDistanceFactor,\n";
		file << "								 false);\n";
		file << "				}\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		// connection features ...\n";
		file << "		if ((true == b_UseSimpleConnectionFeatures) ||\n";
		file << "			(true == b_UseTextConnectionFeatures))\n";
		file << "		{\n";
		file << "			if(true == b_IncludeInit)\n";
		file << "			{\n";
		file << "				bool bHaveConnToInit = false;\n";
		file << "				// connection distance to init state.\n";
		file << "				Matrix <char,1> mtxSliceFrom;\n";
		file << "				mtxSliceFrom.GetSlice (mtx_PredicateConnectionsToFrom,\n";
		file << "									   pCandidatePredicate->i_PredicateCandidateIndex);\n";
		file << "\n";
		file << "				CONST_ITERATE (PddlPredicate_dq_t, rPddlProblem.o_StartState.dq_Predicates, ite)\n";
		file << "				{\n";
		file << "					PddlPredicate* pInitPredicate = *ite;\n";
		file << "					if (-1 == pInitPredicate->i_PredicateCandidateIndex)\n";
		file << "						continue;\n";
		file << "					if (0 == mtxSliceFrom (pInitPredicate->i_PredicateCandidateIndex))\n";
		file << "						continue;\n";
		file << "\n";
		file << "					pFeatures->Set (2 + i_OffsetToConnectionFeatures, 1);\n";
		file << "					pFeatures->Set (3 + i_OffsetToConnectionFeatures, iReachableSubgoal);\n";
		file << "					bHaveConnToInit = true;\n";
		file << "					break;\n";
		file << "				}\n";
		file << "\n";
		file << "				if (false == bHaveConnToInit)\n";
		file << "					pFeatures->Set (4 + i_OffsetToConnectionFeatures, 1);\n";
		file << "			}\n";
		file << "\n";
		file << "\n";
		file << "			// connection distance to target state.\n";
		file << "			Matrix <char,1> mtxSliceTo;\n";
		file << "			mtxSliceTo.GetSlice (mtx_PredicateConnectionsFromTo,\n";
		file << "								 pCandidatePredicate->i_PredicateCandidateIndex);\n";
		file << "\n";
		file << "			if (true == bIncludeTarget)\n";
		file << "			{\n";
		file << "				CONST_ITERATE (PddlPredicate_dq_t, rPddlProblem.o_PartialGoalState.dq_Predicates, ite)\n";
		file << "				{\n";
		file << "					PddlPredicate* pGoalPredicate = *ite;\n";
		file << "					if (-1 == pGoalPredicate->i_PredicateCandidateIndex)\n";
		file << "						continue;\n";
		file << "					if (0 == mtxSliceTo (pGoalPredicate->i_PredicateCandidateIndex))\n";
		file << "						continue;\n";
		file << "					// The -1 below is to account for the fact that\n";
		file << "					// iSubgoals is the length of the list, and _iIndex\n";
		file << "					// is zero indexed...\n";
		file << "					int iDistance = iSubgoals - _iIndex - 1;\n";
		file << "					if (iDistance < 3)\n";
		file << "					{\n";
		file << "						size_t iOffset = 2 * (iDistance - 1) + i_OffsetToConnectionFeatures;\n";
		file << "						pFeatures->Set (5 + iOffset, 1);\n";
		file << "						pFeatures->Set (6 + iOffset, iReachableSubgoal);\n";
		file << "					}\n";
		file << "					break;\n";
		file << "				}\n";
		file << "			}\n";
		file << "\n";
		file << "\n";
		file << "			// connection distance to future subgoals.\n";
		file << "			bool bHaveConnToFuture = false;\n";
		file << "			for (size_t s = _iIndex + 1; s < iEndSubgoal; ++ s)\n";
		file << "			{\n";
		file << "				Subgoal* pNextSubgoal = _pSequence->GetSubgoal (s);\n";
		file << "				int iNextPredicate = pNextSubgoal->p_PddlSubgoalPredicate->i_PredicateCandidateIndex;\n";
		file << "				if (0 == mtxSliceTo (iNextPredicate))\n";
		file << "					continue;\n";
		file << "				int iDistance = s - _iIndex;\n";
		file << "				if (iDistance > 2)\n";
		file << "					break;\n";
		file << "\n";
		file << "				size_t iOffset = 2 * (iDistance - 1) + i_OffsetToConnectionFeatures;\n";
		file << "				pFeatures->Set (5 + iOffset, 1, false);\n";
		file << "				pFeatures->Set (6 + iOffset, iReachableSubgoal, false);\n";
		file << "				bHaveConnToFuture = true;\n";
		file << "			}\n";
		file << "\n";
		file << "			if (false == bHaveConnToFuture)\n";
		file << "				pFeatures->Set (13 + i_OffsetToConnectionFeatures, 1);\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleExplorationParameters (void)\n";
		file << "{\n";
		file << "	cout << \"   se [\"\n";
		file << "		 << o_SequenceEndExploration.SampleParameters (o_Sample)\n";
		file << "		 << \"]  \";\n";
		file << "	cout << \"sg [\"\n";
		file << "		 << o_SubgoalExploration.SampleParameters (o_Sample)\n";
		file << "		 << \"]  \";\n";
		file << "	cout << \"cn [\"\n";
		file << "		 << o_ConnectionExploration.SampleParameters (o_Sample)\n";
		file << "		 << \"]\";\n";
		file << "	cout << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::ForceConnectionUseFlags (void)\n";
		file << "{\n";
		file << "	if (f_UseSimpleConnectionFeatures > 0)\n";
		file << "		b_UseSimpleConnectionFeatures = true;\n";
		file << "	if (f_UseTextConnectionFeatures > 0)\n";
		file << "		b_UseTextConnectionFeatures = true;\n";
		file << "	if (f_UseComplexNonConnectionFeatures > 0)\n";
		file << "		b_UseComplexNonConnectionFeatures = true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleConnectionUseFlags (void)\n";
		file << "{\n";
		file << "	b_UseSimpleConnectionFeatures = false;\n";
		file << "	if (f_UseSimpleConnectionFeatures > 0)\n";
		file << "		b_UseSimpleConnectionFeatures\n";
		file << "			= (o_Sample.SampleUniform () < f_UseSimpleConnectionFeatures);\n";
		file << "\n";
		file << "	b_UseTextConnectionFeatures = false;\n";
		file << "	if (f_UseTextConnectionFeatures > 0)\n";
		file << "		b_UseTextConnectionFeatures\n";
		file << "			= (o_Sample.SampleUniform () < f_UseTextConnectionFeatures);\n";
		file << "\n";
		file << "	b_UseComplexNonConnectionFeatures = false;\n";
		file << "	if (f_UseComplexNonConnectionFeatures > 0)\n";
		file << "		b_UseComplexNonConnectionFeatures\n";
		file << "			= (o_Sample.SampleUniform () < f_UseComplexNonConnectionFeatures);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "size_t SubgoalPolicy::SampleDecision (LogProbability& _rLogProb,\n";
		file << "									  ExplorationParameters& _rExploration,\n";
		file << "									  bool _bTestMode)\n";
		file << "{\n";
		file << "	if (true == _bTestMode)\n";
		file << "		return o_Sample.Argmax (_rLogProb.GetData (), _rLogProb.Size ());\n";
		file << "\n";
		file << "\n";
		file << "	// epsilon-softmax\n";
		file << "	if (et_epsilon_softmax == _rExploration.e_ExplorationType)\n";
		file << "	{\n";
		file << "		if (o_Sample.SampleUniform () < _rExploration.f_Epsilon)\n";
		file << "			return o_Sample.SampleFromLogPDF (_rLogProb.GetData (),\n";
		file << "											  _rLogProb.Size (),\n";
		file << "											  _rExploration.f_Beta);\n";
		file << "		return o_Sample.Argmax (_rLogProb.GetData (), _rLogProb.Size ());\n";
		file << "	}\n";
		file << "	// epsilon-greedy\n";
		file << "	if (et_epsilon_greedy == _rExploration.e_ExplorationType)\n";
		file << "	{\n";
		file << "		if (o_Sample.SampleUniform () < _rExploration.f_Epsilon)\n";
		file << "			return o_Sample.SampleUniformCategorical (_rLogProb.Size ());\n";
		file << "		return o_Sample.Argmax (_rLogProb.GetData (), _rLogProb.Size ());\n";
		file << "	}\n";
		file << "	// softmax\n";
		file << "	return o_Sample.SampleFromLogPDF (_rLogProb.GetData (),\n";
		file << "									  _rLogProb.Size (),\n";
		file << "									  _rExploration.f_Beta);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "size_t SubgoalPolicy::SampleSequenceEnd (int _iSubgoalIndex,\n";
		file << "										 const Problem& _rProblem,\n";
		file << "										 LogProbability& _rLogProb,\n";
		file << "										 bool _bTestMode)\n";
		file << "{\n";
		file << "	if (true == b_UseGoldLength)\n";
		file << "	{\n";
		file << "		String_int_map_t::iterator	iteLen;\n";
		file << "		iteLen = map_ProblemToGoldLength.find (_rProblem.s_FileName);\n";
		file << "		if (map_ProblemToGoldLength.end () == iteLen)\n";
		file << "		{\n";
		file << "			cerr << \"[ERROR] Was told to use gold solution lengths, \"\n";
		file << "					\"but length not known for problem '\"\n";
		file << "				 << _rProblem.s_FileName << \"'.\" << endl;\n";
		file << "		}\n";
		file << "\n";
		file << "		return (_iSubgoalIndex >= iteLen->second)? SEQUENCE_END : 0;\n";
		file << "	}\n";
		file << "\n";
		file << "	return SampleDecision (_rLogProb, o_SequenceEndExploration, _bTestMode);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleZeroSubgoalSequence (const Problem& _rProblem,\n";
		file << "											   SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	// this vector is an intermediate structure used for feature\n";
		file << "	// computation, and needs to be cleared for each sequence...\n";
		file << "	_pSequence->vec_PredicatesInSequence.resize (i_CandidatePredicates, 0);\n";
		file << "\n";
		file << "	_pSequence->b_UseSimpleConnectionFeatures = b_UseSimpleConnectionFeatures;\n";
		file << "	_pSequence->b_UseTextConnectionFeatures = b_UseTextConnectionFeatures;\n";
		file << "	_pSequence->b_UseComplexNonConnectionFeatures = b_UseComplexNonConnectionFeatures;\n";
		file << "\n";
		file << "	AddLastSubgoal (_rProblem, _pSequence);\n";
		file << "	AddForcedSequenceEnd (_rProblem, _pSequence);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleConnections (bool _bTestMode)\n";
		file << "{\n";
		file << "	if (f_UseTextConnectionFeatures <= 0)\n";
		file << "		return;\n";
		file << "\n";
		file << "	for (int f = 0; f < i_CandidatePredicateNumbersMerged; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicateNumbersMerged; ++ t)\n";
		file << "		{\n";
		file << "			int_dq_t* pdqConnectionHit = mtx_SentencesPositiveFromTo (f, t);\n";
		file << "			if (NULL != pdqConnectionHit)\n";
		file << "				pdqConnectionHit->clear ();\n";
		file << "			pdqConnectionHit = mtx_SentencesNegativeFromTo (f, t);\n";
		file << "			if (NULL != pdqConnectionHit)\n";
		file << "				pdqConnectionHit->clear ();\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	mtx_PredicateConnectionsFromTo.Memset (0);\n";
		file << "	mtx_PredicateConnectionsToFrom.Memset (0);\n";
		file << "\n";
		file << "	int iPositives = 0;\n";
		file << "	int iNegatives = 0;\n";
		file << "	for (size_t i = 0; i < vec_SentenceConnections.size (); ++ i)\n";
		file << "	{\n";
		file << "		SentenceConnection* pConnection = vec_SentenceConnections [i];\n";
		file << "		lprb_SentenceConnection [0]\n";
		file << "			= o_TextConnectionModel.ComputeLogProb (*pConnection->p_NegativeFeatures);\n";
		file << "		lprb_SentenceConnection [1]\n";
		file << "			= o_TextConnectionModel.ComputeLogProb (*pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "		PddlPredicate* pPddlFrom = vec_CandidatePredicates [pConnection->i_From];\n";
		file << "		PddlPredicate* pPddlTo = vec_CandidatePredicates [pConnection->i_To];\n";
		file << "		int iPddlFrom = pPddlFrom->i_PredicateCandidateWithoutNumber;\n";
		file << "		int iPddlTo = pPddlTo->i_PredicateCandidateWithoutNumber;\n";
		file << "\n";
		file << "		if (0 == SampleDecision (lprb_SentenceConnection,\n";
		file << "								 o_ConnectionExploration,\n";
		file << "								 _bTestMode))\n";
		file << "		{\n";
		file << "			++ iNegatives;\n";
		file << "			int_dq_t* pdqConnectionHit\n";
		file << "				= mtx_SentencesNegativeFromTo (iPddlFrom, iPddlTo);\n";
		file << "			if (NULL != pdqConnectionHit)\n";
		file << "				pdqConnectionHit->push_back (i);\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "		++ iPositives;\n";
		file << "\n";
		file << "		// remember which connections are sampled,\n";
		file << "		// and also from which sentences...\n";
		file << "\n";
		file << "		mtx_PredicateConnectionsFromTo (pConnection->i_From, pConnection->i_To) = 1;\n";
		file << "		mtx_PredicateConnectionsToFrom (pConnection->i_To, pConnection->i_From) = 1;\n";
		file << "\n";
		file << "		int_dq_t* pdqConnectionHit\n";
		file << "			= mtx_SentencesPositiveFromTo (iPddlFrom, iPddlTo);\n";
		file << "		if (NULL != pdqConnectionHit)\n";
		file << "			pdqConnectionHit->push_back (i);\n";
		file << "	}\n";
		file << "\n";
		file << "	cout << \"   +\" << iPositives << \"  -\" << iNegatives << endl;\n";
		file << "	if (true == b_LogConnectionPredictions)\n";
		file << "		WriteConnectionPredictions ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleSubgoalSequence (const Problem& _rProblem,\n";
		file << "										   bool _bTestMode,\n";
		file << "										   SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	// Sample sequence length...\n";
		file << "	assert (0 != i_CandidatePredicates);\n";
		file << "	_pSequence->vec_PredicatesInSequence.resize (i_CandidatePredicates, 0);\n";
		file << "\n";
		file << "	_pSequence->b_UseSimpleConnectionFeatures = b_UseSimpleConnectionFeatures;\n";
		file << "	_pSequence->b_UseTextConnectionFeatures = b_UseTextConnectionFeatures;\n";
		file << "	_pSequence->b_UseComplexNonConnectionFeatures = b_UseComplexNonConnectionFeatures;\n";
		file << "\n";
		file << "\n";
		file << "	// we first need the last subgoal to reach the actual target goal...\n";
		file << "	AddLastSubgoal (_rProblem, _pSequence);\n";
		file << "\n";
		file << "	// Sample subgoals...\n";
		file << "	bool bAlreadyAddedSequenceEnd = false;\n";
		file << "	Subgoal* pNextSubgoal = _pSequence->GetSubgoal (0);\n";
		file << "	for (int i = 0; i < i_MaxSequenceLength; ++ i)\n";
		file << "	{\n";
		file << "		Subgoal* pSubgoal = _pSequence->AddSubgoalToFront ();\n";
		file << "\n";
		file << "		// sample END-SEQUENCE symbol...\n";
		file << "		assert (true == pSubgoal->vec_SequenceEndFeatureVectors.empty ());\n";
		file << "		ComputeSequenceEndFeatures (0, _rProblem, _pSequence);\n";
		file << "		pSubgoal->lprb_SequenceEnd.Create (2);\n";
		file << "		for (int e = 0; e < 2; ++ e)\n";
		file << "		{\n";
		file << "			Features* pFV = pSubgoal->vec_SequenceEndFeatureVectors [e];\n";
		file << "			pSubgoal->lprb_SequenceEnd [e] = o_SequenceEndModel.ComputeLogProb (*pFV);\n";
		file << "			delete pFV;\n";
		file << "		}\n";
		file << "		pSubgoal->vec_SequenceEndFeatureVectors.clear ();\n";
		file << "		pSubgoal->i_SequenceEnd = SampleSequenceEnd (i,\n";
		file << "													 _rProblem,\n";
		file << "													 pSubgoal->lprb_SequenceEnd,\n";
		file << "													 _bTestMode);\n";
		file << "		if (SEQUENCE_END == pSubgoal->i_SequenceEnd)\n";
		file << "		{\n";
		file << "			bAlreadyAddedSequenceEnd = true;\n";
		file << "			break;\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		assert (true == pSubgoal->vec_SubgoalFeatureVectors.empty ());\n";
		file << "		ComputeSubgoalFeatures (0, _rProblem, _pSequence);\n";
		file << "\n";
		file << "		// compute log probs\n";
		file << "		pSubgoal->lprb_Subgoal.Create (i_CandidatePredicates);\n";
		file << "		for (long g = 0; g < i_CandidatePredicates; ++ g)\n";
		file << "		{\n";
		file << "			Features* pFV = pSubgoal->vec_SubgoalFeatureVectors [g];\n";
		file << "\n";
		file << "			// check if this is identical to the next subgoal...\n";
		file << "			if ((NULL != pNextSubgoal) &&\n";
		file << "				(g == pNextSubgoal->i_SubgoalSelection))\n";
		file << "				pSubgoal->lprb_Subgoal [g] = -1000;\n";
		file << "\n";
		file << "			// check if this is identical to any future subgoal\n";
		file << "			else if ((true == b_DisallowAnyDuplicateSubgoals) &&\n";
		file << "					 (1 == _pSequence->vec_PredicatesInSequence [g]))\n";
		file << "				pSubgoal->lprb_Subgoal [g] = -1000;\n";
		file << "\n";
		file << "			else\n";
		file << "				pSubgoal->lprb_Subgoal [g] = o_SubgoalSelectionModel.ComputeLogProb (*pFV);\n";
		file << "\n";
		file << "			if (false == b_PrintTextConnectionFeatures)\n";
		file << "				delete pFV;\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		// sample\n";
		file << "		pSubgoal->i_SubgoalSelection\n";
		file << "			= SampleDecision (pSubgoal->lprb_Subgoal, o_SubgoalExploration, _bTestMode);\n";
		file << "		pSubgoal->p_PddlSubgoalPredicate\n";
		file << "			= vec_CandidatePredicates [pSubgoal->i_SubgoalSelection];\n";
		file << "\n";
		file << "		_pSequence->vec_PredicatesInSequence [pSubgoal->i_SubgoalSelection] = 1;\n";
		file << "\n";
		file << "		// delete the old one\n";
		file << "		if (true == b_PrintTextConnectionFeatures)\n";
		file << "		{\n";
		file << "			if (pSubgoal->p_SelectedPredicateFeatures != NULL)\n";
		file << "				delete pSubgoal->p_SelectedPredicateFeatures;\n";
		file << "\n";
		file << "			for (long g = 0; g < i_CandidatePredicates; ++ g)\n";
		file << "			{\n";
		file << "				Features* pFV = pSubgoal->vec_SubgoalFeatureVectors [g];\n";
		file << "				if(g == pSubgoal->i_SubgoalSelection)\n";
		file << "					pSubgoal->p_SelectedPredicateFeatures = pFV;\n";
		file << "				else\n";
		file << "					delete pFV;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		pSubgoal->vec_SubgoalFeatureVectors.clear ();\n";
		file << "\n";
		file << "		if (true == b_DisallowNeighboringDuplicateSubgoals)\n";
		file << "			pNextSubgoal = pSubgoal;\n";
		file << "	}\n";
		file << "\n";
		file << "	if (false == bAlreadyAddedSequenceEnd)\n";
		file << "		AddForcedSequenceEnd (_rProblem, _pSequence);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::AddLastSubgoal (const Problem& _rProblem,\n";
		file << "									SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	assert (0 == _pSequence->Length ());\n";
		file << "	Subgoal* pSubgoal = _pSequence->AddSubgoalToFront ();\n";
		file << "\n";
		file << "	assert (true == pSubgoal->vec_SubgoalFeatureVectors.empty ());\n";
		file << "	ComputeSubgoalFeatures (0, _rProblem, _pSequence);\n";
		file << "	assert (false == pSubgoal->vec_SubgoalFeatureVectors.empty ());\n";
		file << "\n";
		file << "	pSubgoal->lprb_Subgoal.Create (i_CandidatePredicates);\n";
		file << "	for (long g = 0; g < i_CandidatePredicates; ++ g)\n";
		file << "	{\n";
		file << "		Features* pFV = pSubgoal->vec_SubgoalFeatureVectors [g];\n";
		file << "		pSubgoal->lprb_Subgoal [g] = o_SubgoalSelectionModel.ComputeLogProb (*pFV);\n";
		file << "		delete pFV;\n";
		file << "	}\n";
		file << "	pSubgoal->vec_SubgoalFeatureVectors.clear ();\n";
		file << "\n";
		file << "\n";
		file << "	// Identify target goal's predicate indices...\n";
		file << "	PddlProblem& rPddlProblem = ((Problem&)_rProblem).GetPddlProblem ();\n";
		file << "	if (1 != rPddlProblem.o_PartialGoalState.dq_Predicates.size ())\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Target goal has multiple predicates set.\\n\"\n";
		file << "			 << \"        This code cannot handle this scenario :-/\"\n";
		file << "			 << endl;\n";
		file << "		assert (false);\n";
		file << "	}\n";
		file << "\n";
		file << "	PddlPredicate* pTargetGoalPredicate\n";
		file << "		= rPddlProblem.o_PartialGoalState.dq_Predicates [0];\n";
		file << "	pSubgoal->i_SubgoalSelection = pTargetGoalPredicate->i_PredicateCandidateIndex;\n";
		file << "	pSubgoal->p_PddlSubgoalPredicate = vec_CandidatePredicates [pSubgoal->i_SubgoalSelection];\n";
		file << "	if (-1 == pSubgoal->i_SubgoalSelection)\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed to find target goal predicate in candidate predicate list:\"\n";
		file << "			 << *pTargetGoalPredicate << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "\n";
		file << "	_pSequence->vec_PredicatesInSequence [pSubgoal->i_SubgoalSelection] = 1;\n";
		file << "\n";
		file << "	// set other variables in subgoal...\n";
		file << "	pSubgoal->b_IsLastSubgoalToTarget = true;\n";
		file << "	pSubgoal->i_SequenceEnd = 0;\n";
		file << "	pSubgoal->p_PddlTargetProblem = &rPddlProblem;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::AddForcedSequenceEnd (const Problem& _rProblem,\n";
		file << "										  SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	Subgoal* pSubgoal = _pSequence->AddSubgoalToFront ();\n";
		file << "\n";
		file << "	assert (true == pSubgoal->vec_SequenceEndFeatureVectors.empty ());\n";
		file << "	ComputeSequenceEndFeatures (0, _rProblem, _pSequence);\n";
		file << "\n";
		file << "	pSubgoal->lprb_SequenceEnd.Create (2);\n";
		file << "	for (int e = 0; e < 2; ++ e)\n";
		file << "	{\n";
		file << "		Features* pFV = pSubgoal->vec_SequenceEndFeatureVectors [e];\n";
		file << "		pSubgoal->lprb_SequenceEnd [e] = o_SequenceEndModel.ComputeLogProb (*pFV);\n";
		file << "		delete pFV;\n";
		file << "	}\n";
		file << "	pSubgoal->vec_SequenceEndFeatureVectors.clear ();\n";
		file << "	pSubgoal->i_SequenceEnd = SEQUENCE_END;\n";
		file << "	pSubgoal->b_ForcedSequenceEnd = true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::InitUpdate (void)\n";
		file << "{\n";
		file << "	o_SequenceEndModel.InitializeFeatureExpectationVector (vec_SequenceEndFE,\n";
		file << "										o_SequenceEndFeatureSpace.MaxIndex () + 1);\n";
		file << "\n";
		file << "	o_SubgoalSelectionModel.InitializeFeatureExpectationVector (vec_SubgoalFE,\n";
		file << "										o_SubgoalFeatureSpace.MaxIndex () + 1);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::UpdateParameters (SubgoalSequence& _rSequence,\n";
		file << "									  double _dReward,\n";
		file << "									  bool _bTaskComplete,\n";
		file << "									  bool _bWithConnections)\n";
		file << "{\n";
		file << "	/*\n";
		file << "	if (true == _bWithConnections)\n";
		file << "	{\n";
		file << "		b_UseSimpleConnectionFeatures = (f_UseSimpleConnectionFeatures > 0);\n";
		file << "		b_UseTextConnectionFeatures = (f_UseTextConnectionFeatures > 0);\n";
		file << "		b_UseComplexNonConnectionFeatures = (f_UseComplexNonConnectionFeatures > 0);\n";
		file << "	}\n";
		file << "	else\n";
		file << "	{\n";
		file << "		b_UseSimpleConnectionFeatures = false;\n";
		file << "		b_UseTextConnectionFeatures = false;\n";
		file << "	}\n";
		file << "	*/\n";
		file << "\n";
		file << "	b_UseSimpleConnectionFeatures = _rSequence.b_UseSimpleConnectionFeatures;\n";
		file << "	b_UseTextConnectionFeatures = _rSequence.b_UseTextConnectionFeatures;\n";
		file << "	b_UseComplexNonConnectionFeatures = _rSequence.b_UseComplexNonConnectionFeatures;\n";
		file << "\n";
		file << "\n";
		file << "	// connection prediction model...\n";
		file << "	if ((f_UseTextConnectionFeatures > 0) && (true == _bWithConnections))\n";
		file << "	{\n";
		file << "		int_set_t setPreviousSubgoals;\n";
		file << "		size_t iSequenceLength = _rSequence.dq_Subgoals.size ();\n";
		file << "		for (size_t f = 0; f < iSequenceLength; ++ f)\n";
		file << "		{\n";
		file << "			Subgoal* pFrom = _rSequence.GetSubgoal (f);\n";
		file << "			if (true == pFrom->b_ForcedSequenceEnd)\n";
		file << "				continue;\n";
		file << "			if (SEQUENCE_END == pFrom->i_SequenceEnd)\n";
		file << "				continue;\n";
		file << "			if (po_goal_already_satisfied == pFrom->e_PlanningOutcome)\n";
		file << "				continue;\n";
		file << "			if (po_plan_found != pFrom->e_PlanningOutcome)\n";
		file << "				break;\n";
		file << "			int iFrom = pFrom->p_PddlSubgoalPredicate->i_PredicateCandidateWithoutNumber;\n";
		file << "			setPreviousSubgoals.insert (iFrom);\n";
		file << "\n";
		file << "			size_t t = f + 1;\n";
		file << "			if (t >= iSequenceLength)\n";
		file << "				break;\n";
		file << "			Subgoal* pTo = _rSequence.GetSubgoal (t);\n";
		file << "			if (true == pTo->b_ForcedSequenceEnd)\n";
		file << "				continue;\n";
		file << "			if (SEQUENCE_END == pTo->i_SequenceEnd)\n";
		file << "				continue;\n";
		file << "			if ((po_outside_known_world == pTo->e_PlanningOutcome) ||\n";
		file << "				(po_goal_already_satisfied == pTo->e_PlanningOutcome))\n";
		file << "				continue;\n";
		file << "\n";
		file << "			// find sentences that contributed to this connection.\n";
		file << "			int iTo = pTo->p_PddlSubgoalPredicate->i_PredicateCandidateWithoutNumber;\n";
		file << "			if (po_plan_found == pTo->e_PlanningOutcome)\n";
		file << "				mtx_FeedbackOnSentenceConnections (iFrom, iTo, FEEDBACK_POS_PLAN_OK) += 1;\n";
		file << "			else\n";
		file << "				mtx_FeedbackOnSentenceConnections (iFrom, iTo, FEEDBACK_NEG_PLAN_FAIL) += 1;\n";
		file << "\n";
		file << "\n";
		file << "			// negative reward for any subgoal that didn't occur before iTo...\n";
		file << "			if (po_plan_found == pTo->e_PlanningOutcome)\n";
		file << "			{\n";
		file << "				for (int n = 0; n < i_CandidatePredicateNumbersMerged; ++ n)\n";
		file << "				{\n";
		file << "					if (setPreviousSubgoals.end () != setPreviousSubgoals.find (n))\n";
		file << "						continue;\n";
		file << "					mtx_FeedbackOnSentenceConnections (n, iTo, FEEDBACK_NEG_NOT_IN_PREFIX)\n";
		file << "						+= 1;\n";
		file << "				}\n";
		file << "			}\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	// sequence prediction models ...\n";
		file << "	for (int i = _rSequence.dq_Subgoals.size () - 1; i >= 0; -- i)\n";
		file << "	{\n";
		file << "		Subgoal* pSubgoal = _rSequence.GetSubgoal (i);\n";
		file << "		if (true == pSubgoal->b_ForcedSequenceEnd)\n";
		file << "			continue;\n";
		file << "\n";
		file << "		if (false == pSubgoal->b_IsLastSubgoalToTarget)\n";
		file << "		{\n";
		file << "			assert (-1 != pSubgoal->i_SequenceEnd);\n";
		file << "			// sequence end model ...\n";
		file << "			{\n";
		file << "				// recompute features ...\n";
		file << "				assert (true == pSubgoal->vec_SequenceEndFeatureVectors.empty ());\n";
		file << "				ComputeSequenceEndFeatures (i, *_rSequence.p_TargetProblem, &_rSequence);\n";
		file << "\n";
		file << "				// It's possible to have subgoals that don't\n";
		file << "				// the policy distribution already computed.\n";
		file << "				// I.e. in the case where we propose additional\n";
		file << "				// sequences based on the predicted sequence.\n";
		file << "				if (0 == pSubgoal->lprb_SequenceEnd.Size ())\n";
		file << "				{\n";
		file << "					pSubgoal->lprb_SequenceEnd.Create (2);\n";
		file << "					for (int e = 0; e < 2; ++ e)\n";
		file << "					{\n";
		file << "						Features* pFV = pSubgoal->vec_SequenceEndFeatureVectors [e];\n";
		file << "						pSubgoal->lprb_SequenceEnd [e]\n";
		file << "							= o_SequenceEndModel.ComputeLogProb (*pFV);\n";
		file << "					}\n";
		file << "				}\n";
		file << "\n";
		file << "				// compute negative expectation\n";
		file << "				o_SequenceEndModel.ComputeNegativeFeatureExpectation (pSubgoal->lprb_SequenceEnd,\n";
		file << "												pSubgoal->vec_SequenceEndFeatureVectors,\n";
		file << "												_dReward,\n";
		file << "												vec_SequenceEndFE);\n";
		file << "\n";
		file << "				// add selected action features\n";
		file << "				Features* pSelectedFeatures\n";
		file << "					= pSubgoal->vec_SequenceEndFeatureVectors [pSubgoal->i_SequenceEnd];\n";
		file << "				for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "					vec_SequenceEndFE [pSelectedFeatures->Index (f)]\n";
		file << "						+= _dReward * pSelectedFeatures->Feature (f);\n";
		file << "\n";
		file << "				// clear up memory ...\n";
		file << "				ITERATE (Features_vec_t, pSubgoal->vec_SequenceEndFeatureVectors, ite)\n";
		file << "					delete *ite;\n";
		file << "				pSubgoal->vec_SequenceEndFeatureVectors.clear ();\n";
		file << "\n";
		file << "				if (SEQUENCE_END == pSubgoal->i_SequenceEnd)\n";
		file << "					continue;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		// subgoal model ...\n";
		file << "		{\n";
		file << "			assert (-1 != pSubgoal->i_SubgoalSelection);\n";
		file << "\n";
		file << "			// recompute features ...\n";
		file << "			assert (true == pSubgoal->vec_SubgoalFeatureVectors.empty ());\n";
		file << "			ComputeSubgoalFeatures (i, *_rSequence.p_TargetProblem, &_rSequence);\n";
		file << "\n";
		file << "			// It's possible to have subgoals that don't\n";
		file << "			// the policy distribution already computed.\n";
		file << "			// I.e. in the case where we propose additional\n";
		file << "			// sequences based on the predicted sequence.\n";
		file << "			if (0 == pSubgoal->lprb_Subgoal.Size ())\n";
		file << "			{\n";
		file << "				pSubgoal->lprb_Subgoal.Create (i_CandidatePredicates);\n";
		file << "				for (long g = 0; g < i_CandidatePredicates; ++ g)\n";
		file << "				{\n";
		file << "					Features* pFV = pSubgoal->vec_SubgoalFeatureVectors [g];\n";
		file << "					pSubgoal->lprb_Subgoal [g]\n";
		file << "						= o_SubgoalSelectionModel.ComputeLogProb (*pFV);\n";
		file << "				}\n";
		file << "			}\n";
		file << "\n";
		file << "			// compute negative expectation\n";
		file << "			o_SubgoalSelectionModel.ComputeNegativeFeatureExpectation (pSubgoal->lprb_Subgoal,\n";
		file << "											pSubgoal->vec_SubgoalFeatureVectors,\n";
		file << "											_dReward,\n";
		file << "											vec_SubgoalFE);\n";
		file << "\n";
		file << "			// add selected action features\n";
		file << "			Features* pSelectedFeatures\n";
		file << "				= pSubgoal->vec_SubgoalFeatureVectors [pSubgoal->i_SubgoalSelection];\n";
		file << "			for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "				vec_SubgoalFE [pSelectedFeatures->Index (f)]\n";
		file << "					+= _dReward * pSelectedFeatures->Feature (f);\n";
		file << "\n";
		file << "			// clear up memory ...\n";
		file << "			ITERATE (Features_vec_t, pSubgoal->vec_SubgoalFeatureVectors, ite)\n";
		file << "				delete *ite;\n";
		file << "			pSubgoal->vec_SubgoalFeatureVectors.clear ();\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::UpdateConnectionParameters (void)\n";
		file << "{\n";
		file << "	if (f_UseTextConnectionFeatures <= 0)\n";
		file << "		return;\n";
		file << "\n";
		file << "	// collate feedback ...\n";
		file << "	Matrix <int, 2>	mtxCollatedFeedback;\n";
		file << "	mtxCollatedFeedback.Create (i_CandidatePredicateNumbersMerged,\n";
		file << "								i_CandidatePredicateNumbersMerged);\n";
		file << "	mtxCollatedFeedback.Memset (0);\n";
		file << "\n";
		file << "	unsigned long iPositives = 0;\n";
		file << "	unsigned long iNegatives = 0;\n";
		file << "	for (int f = 0; f < i_CandidatePredicateNumbersMerged; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicateNumbersMerged; ++ t)\n";
		file << "		{\n";
		file << "			int iPos = mtx_FeedbackOnSentenceConnections (f, t, FEEDBACK_POS_PLAN_OK);\n";
		file << "			int iNegPlanFail\n";
		file << "				= mtx_FeedbackOnSentenceConnections (f, t, FEEDBACK_NEG_PLAN_FAIL);\n";
		file << "			int iNegNotInPrefix\n";
		file << "				= mtx_FeedbackOnSentenceConnections (f, t, FEEDBACK_NEG_NOT_IN_PREFIX);\n";
		file << "\n";
		file << "			int iFeedback = 0;\n";
		file << "			if (true == b_UseSuccessFailureCountsInFeedback)\n";
		file << "			{\n";
		file << "				if (iNegPlanFail > 0)\n";
		file << "					iFeedback = - iNegPlanFail;\n";
		file << "				if (iPos > 0)\n";
		file << "					iFeedback = iPos;\n";
		file << "				if (iNegNotInPrefix > 0)\n";
		file << "					iFeedback = - iNegNotInPrefix;\n";
		file << "			}\n";
		file << "			else\n";
		file << "			{\n";
		file << "				if (iNegPlanFail > 0)\n";
		file << "					iFeedback = -1;\n";
		file << "				if (iPos > 0)\n";
		file << "					iFeedback = 1;\n";
		file << "				if (iNegNotInPrefix > 0)\n";
		file << "					iFeedback = -1;\n";
		file << "			}\n";
		file << "\n";
		file << "			mtxCollatedFeedback (f, t) = iFeedback;\n";
		file << "			if (iFeedback > 0)\n";
		file << "				iPositives += iFeedback;\n";
		file << "			else if (iFeedback < 0)\n";
		file << "				iNegatives -= iFeedback;\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	if ((0 == iPositives) && (0 == iNegatives))\n";
		file << "	{\n";
		file << "		if (true == b_LogConnectionFeedback)\n";
		file << "			WriteConnectionFeedback ();\n";
		file << "		if (false == b_RetainPredicateConnectionFeedback)\n";
		file << "			mtx_FeedbackOnSentenceConnections.Memset (0);\n";
		file << "		return;\n";
		file << "	}\n";
		file << "\n";
		file << "	// compute normalization factors ...\n";
		file << "	// double dMidpoint = iPositives; //(iPositives + iNegatives) / (double) 2;\n";
		file << "	double dMidpoint = 1;\n";
		file << "	double dPositiveReweighting = 0;\n";
		file << "	if (iPositives > 0)\n";
		file << "		dPositiveReweighting = dMidpoint / (double) iPositives;\n";
		file << "	double dNegativeReweighting = 0;\n";
		file << "	if (iNegatives > 0)\n";
		file << "		dNegativeReweighting = dMidpoint / (double) iNegatives;\n";
		file << "	cout << iPositives << \" \" << iNegatives << \" \"\n";
		file << "		<< dPositiveReweighting << \" \" << dNegativeReweighting << endl;\n";
		file << "\n";
		file << "\n";
		file << "	// update params...\n";
		file << "	for (int i = 0; i < i_UpdatesPerIteration; ++ i)\n";
		file << "	{\n";
		file << "		for (int f = 0; f < i_CandidatePredicateNumbersMerged; ++ f)\n";
		file << "		{\n";
		file << "			for (int t = 0; t < i_CandidatePredicateNumbersMerged; ++ t)\n";
		file << "			{\n";
		file << "				double dReward = mtxCollatedFeedback (f, t);\n";
		file << "				if (0 == dReward)\n";
		file << "					continue;\n";
		file << "				if (dReward > 0)\n";
		file << "					dReward *= dPositiveReweighting * f_ConnectionSuccessReward;\n";
		file << "				else\n";
		file << "					dReward *= dNegativeReweighting * f_ConnectionFailurePenalty;\n";
		file << "\n";
		file << "\n";
		file << "				// positive predictions ...\n";
		file << "				{\n";
		file << "					int_dq_t* pdqSentence = mtx_SentencesPositiveFromTo (f, t);\n";
		file << "					if (NULL != pdqSentence)\n";
		file << "					{\n";
		file << "						ITERATE (int_dq_t, (*pdqSentence), ite)\n";
		file << "						{\n";
		file << "							SentenceConnection* pConnection = vec_SentenceConnections [*ite];\n";
		file << "							lprb_SentenceConnection [0]\n";
		file << "								= o_TextConnectionModel.ComputeLogProb (*pConnection->p_NegativeFeatures);\n";
		file << "							lprb_SentenceConnection [1]\n";
		file << "								= o_TextConnectionModel.ComputeLogProb (*pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "							Features_vec_t vecFeatures;\n";
		file << "							vecFeatures.reserve (2);\n";
		file << "							vecFeatures.push_back (pConnection->p_NegativeFeatures);\n";
		file << "							vecFeatures.push_back (pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "							o_TextConnectionModel.ComputeNegativeFeatureExpectation (lprb_SentenceConnection,\n";
		file << "																					 vecFeatures,\n";
		file << "																					 dReward,\n";
		file << "																					 vec_ConnectionFE);\n";
		file << "\n";
		file << "							// add selected action features\n";
		file << "							Features* pSelectedFeatures = pConnection->p_PositiveFeatures;\n";
		file << "							for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "								vec_ConnectionFE [pSelectedFeatures->Index (f)]\n";
		file << "									+= dReward * pSelectedFeatures->Feature (f);\n";
		file << "\n";
		file << "							/*\n";
		file << "							pSelectedFeatures = pConnection->p_NegativeFeatures;\n";
		file << "							for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "								vec_ConnectionFE [pSelectedFeatures->Index (f)]\n";
		file << "									-= lprb_SentenceConnection [0] * dReward * pSelectedFeatures->Feature (f);\n";
		file << "							*/\n";
		file << "						}\n";
		file << "					}\n";
		file << "				}\n";
		file << "\n";
		file << "\n";
		file << "				// negative predictions ...\n";
		file << "				{\n";
		file << "					dReward *= -1.0;\n";
		file << "\n";
		file << "					int_dq_t* pdqSentence = mtx_SentencesNegativeFromTo (f, t);\n";
		file << "					if (NULL != pdqSentence)\n";
		file << "					{\n";
		file << "						ITERATE (int_dq_t, (*pdqSentence), ite)\n";
		file << "						{\n";
		file << "							SentenceConnection* pConnection = vec_SentenceConnections [*ite];\n";
		file << "							lprb_SentenceConnection [0]\n";
		file << "								= o_TextConnectionModel.ComputeLogProb (*pConnection->p_NegativeFeatures);\n";
		file << "							lprb_SentenceConnection [1]\n";
		file << "								= o_TextConnectionModel.ComputeLogProb (*pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "							Features_vec_t vecFeatures;\n";
		file << "							vecFeatures.reserve (2);\n";
		file << "							vecFeatures.push_back (pConnection->p_NegativeFeatures);\n";
		file << "							vecFeatures.push_back (pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "							o_TextConnectionModel.ComputeNegativeFeatureExpectation (lprb_SentenceConnection,\n";
		file << "																					 vecFeatures,\n";
		file << "																					 dReward,\n";
		file << "																					 vec_ConnectionFE);\n";
		file << "\n";
		file << "							// add selected action features\n";
		file << "							Features* pSelectedFeatures = pConnection->p_NegativeFeatures;\n";
		file << "							for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "								vec_ConnectionFE [pSelectedFeatures->Index (f)]\n";
		file << "									+= dReward * pSelectedFeatures->Feature (f);\n";
		file << "\n";
		file << "							/*\n";
		file << "							pSelectedFeatures = pConnection->p_PositiveFeatures;\n";
		file << "							for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "								vec_ConnectionFE [pSelectedFeatures->Index (f)]\n";
		file << "									-= lprb_SentenceConnection [1] * dReward * pSelectedFeatures->Feature (f);\n";
		file << "							*/\n";
		file << "						}\n";
		file << "					}\n";
		file << "				}\n";
		file << "			}\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	if (true == b_LogConnectionFeedback)\n";
		file << "		WriteConnectionFeedback ();\n";
		file << "	if (false == b_RetainPredicateConnectionFeedback)\n";
		file << "		mtx_FeedbackOnSentenceConnections.Memset (0);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::CompleteUpdate (void)\n";
		file << "{\n";
		file << "	o_SequenceEndModel.UpdateWeights (1, vec_SequenceEndFE);\n";
		file << "	o_SubgoalSelectionModel.UpdateWeights (1, vec_SubgoalFE);\n";
		file << "\n";
		file << "	o_TextConnectionModel.InitializeFeatureExpectationVector (vec_ConnectionFE,\n";
		file << "										o_TextConnectionFeatureSpace.MaxIndex () + 1);\n";
		file << "	UpdateConnectionParameters ();\n";
		file << "	o_TextConnectionModel.UpdateWeights (1, vec_ConnectionFE);\n";
		file << "\n";
		file << "	if (true == b_ForceConnectionWeights)\n";
		file << "	{\n";
		file << "		size_t f = 2 + i_OffsetToConnectionFeatures;\n";
		file << "		if (o_SubgoalSelectionModel.GetWeight (f) < d_ForcedConnectionWeightToInit)\n";
		file << "			o_SubgoalSelectionModel.SetWeight (f, d_ForcedConnectionWeightToInit);\n";
		file << "		f = 3 + i_OffsetToConnectionFeatures;\n";
		file << "		if (o_SubgoalSelectionModel.GetWeight (f) < d_ForcedConnectionWeightToInit)\n";
		file << "			o_SubgoalSelectionModel.SetWeight (f, d_ForcedConnectionWeightToInit);\n";
		file << "\n";
		file << "		for (int d = 1; d < 5; ++ d)\n";
		file << "		{\n";
		file << "			f = 5 + 2*(d-1) + i_OffsetToConnectionFeatures;\n";
		file << "			if (o_SubgoalSelectionModel.GetWeight (f) < d_ForcedConnectionWeightToTarget)\n";
		file << "				o_SubgoalSelectionModel.SetWeight (f, d_ForcedConnectionWeightToTarget);\n";
		file << "			f = 6 + 2*(d-1) + i_OffsetToConnectionFeatures;\n";
		file << "			if (o_SubgoalSelectionModel.GetWeight (f) < d_ForcedConnectionWeightToTarget)\n";
		file << "				o_SubgoalSelectionModel.SetWeight (f, d_ForcedConnectionWeightToTarget);\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::AddReachableSubgoals (const int_set_t& _rsetReachableSubgoals)\n";
		file << "{\n";
		file << "	ITERATE (int_set_t, _rsetReachableSubgoals, ite)\n";
		file << "	{\n";
		file << "		assert (*ite < i_CandidatePredicates);\n";
		file << "		assert (*ite < (long)vec_CanReachCandidatePredicate.size ());\n";
		file << "		assert (i_CandidatePredicates == (long)vec_CanReachCandidatePredicate.size ());\n";
		file << "\n";
		file << "		vec_CanReachCandidatePredicate [*ite] = 1;\n";
		file << "\n";
		file << "		if (true == b_UseReachabilityEquivalents)\n";
		file << "		{\n";
		file << "			ITERATE (int_vec_t, vec_ReachabilityPredicateEqulivalents [*ite], iteEquiv)\n";
		file << "				vec_CanReachCandidatePredicate [*iteEquiv] = 1;\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::FindInitPredicateCandidateIndex (PddlPredicate& _rPredicate)\n";
		file << "{\n";
		file << "	int i = -1;\n";
		file << "	CONST_ITERATE (PddlPredicate_vec_t, vec_CandidatePredicates, ite)\n";
		file << "	{\n";
		file << "		++ i;\n";
		file << "		PddlPredicate* pCandidate = *ite;\n";
		file << "		if (*(PddlPredicate*)pCandidate != (PddlPredicate&)_rPredicate)\n";
		file << "			continue;\n";
		file << "		return i;\n";
		file << "	}\n";
		file << "	return -1;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::FindPredicateCandidateIndex (PddlPredicate& _rPredicate)\n";
		file << "{\n";
		file << "	int i = -1;\n";
		file << "	CONST_ITERATE (PddlPredicate_vec_t, vec_CandidatePredicates, ite)\n";
		file << "	{\n";
		file << "		++ i;\n";
		file << "		PddlPredicate* pCandidate = *ite;\n";
		file << "		if (*pCandidate != _rPredicate)\n";
		file << "			continue;\n";
		file << "		return i;\n";
		file << "	}\n";
		file << "	return -1;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlPredicate* SubgoalPolicy::FindEquivalentPredicateCandidate (PddlPredicate& _rPredicate)\n";
		file << "{\n";
		file << "	PddlStringToPredicate_map_t::iterator	ite;\n";
		file << "	ite = map_PddlStringToCandidatePredicate.find (_rPredicate.GetPddlString ());\n";
		file << "	if (map_PddlStringToCandidatePredicate.end () == ite)\n";
		file << "		return NULL;\n";
		file << "	return ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::SaveWeights (int _iIteration)\n";
		file << "{\n";
		file << "	if (1 == (int)(config)\"save_global_feature_map\")\n";
		file << "	{\n";
		file << "		File file ((config)\"global_feature_mapping_file\", ios_base::out);\n";
		file << "		ITERATE (int_String_map_t, map_FeatureIndexToFeatureString, ite)\n";
		file << "			file << ite->first << '\\x01' << ite->second << endl;\n";
		file << "		file.Close ();\n";
		file << "	}\n";
		file << "\n";
		file << "	int iPeriod = (config)\"end:param_save_period\";\n";
		file << "	if ((iPeriod > 0) && (0 == (_iIteration % iPeriod)))\n";
		file << "	{\n";
		file << "		if (false == o_SequenceEndFeatureSpace.SaveFeatureMapping (\"end\"))\n";
		file << "			return false;\n";
		file << "		if (false == o_SequenceEndModel.SaveWeights (\"end\"))\n";
		file << "			return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	iPeriod = (config)\"subgoal:param_save_period\";\n";
		file << "	if ((iPeriod > 0) && (0 == (_iIteration % iPeriod)))\n";
		file << "	{\n";
		file << "		if (false == o_SubgoalFeatureSpace.SaveFeatureMapping (\"subgoal\"))\n";
		file << "			return false;\n";
		file << "		if (false == o_SubgoalSelectionModel.SaveWeights (\"subgoal\"))\n";
		file << "			return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	iPeriod = (config)\"connection:param_save_period\";\n";
		file << "	if ((iPeriod > 0) && (0 == (_iIteration % iPeriod)))\n";
		file << "	{\n";
		file << "		if (false == o_TextConnectionFeatureSpace.SaveFeatureMapping (\"connection\"))\n";
		file << "			return false;\n";
		file << "		if (false == o_TextConnectionModel.SaveWeights (\"connection\"))\n";
		file << "			return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double SubgoalPolicy::WeightVectorNorm (void)\n";
		file << "{\n";
		file << "	return o_SequenceEndModel.WeightVectorNorm ()\n";
		file << "			+ o_SubgoalSelectionModel.WeightVectorNorm ()\n";
		file << "			+ o_TextConnectionModel.WeightVectorNorm ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::DebugPrintFeatureVectors (const Subgoal& subgoal,\n";
		file << "											  ostream* osOut,\n";
		file << "											  const String& sPrefix) const\n";
		file << "{\n";
		file << "	// iterate over possible\n";
		file << "	for(unsigned int iPred = 0; iPred < subgoal.vec_SubgoalFeatureVectors.size(); iPred++){\n";
		file << "		const Features& featuresCur = *subgoal.vec_SubgoalFeatureVectors[iPred];\n";
		file << "		const PddlPredicate& predCur = *vec_CandidatePredicates [iPred];\n";
		file << "		*osOut << sPrefix << \":\" << iPred << \":\" << predCur.GetPddlString() << \"\\n\";\n";
		file << "		for (int iFeatureListIndex = 0; iFeatureListIndex < featuresCur.Size(); iFeatureListIndex++){\n";
		file << "			int iFeature = featuresCur.Index(iFeatureListIndex);\n";
		file << "			const String& sFeature = o_SubgoalFeatureSpace.GetFeatureString(iFeature);\n";
		file << "			*osOut << \"\\t\" << iFeature << \"-->\" << sFeature << \"\\n\";\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::WriteConnectionPredictionHeader (void)\n";
		file << "{\n";
		file << "	File file;\n";
		file << "	if (false == file.Open ((config)\"connection_prediction_log_file\",\n";
		file << "						    ios_base::out))\n";
		file << "		return;\n";
		file << "\n";
		file << "	for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "		{\n";
		file << "			PddlPredicate* pPddlFrom = vec_CandidatePredicates [f];\n";
		file << "			int iPddlFrom = pPddlFrom->i_PredicateCandidateWithoutNumber;\n";
		file << "			PddlPredicate* pPddlTo = vec_CandidatePredicates [t];\n";
		file << "			int iPddlTo = pPddlTo->i_PredicateCandidateWithoutNumber;\n";
		file << "			if (NULL == mtx_SentencesPositiveFromTo (iPddlFrom, iPddlTo))\n";
		file << "				continue;\n";
		file << "			file << f << ':' << t << ' ';\n";
		file << "		}\n";
		file << "	}\n";
		file << "	file << endl;\n";
		file << "	file.flush ();\n";
		file << "	file.Close ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::WriteConnectionPredictions (void)\n";
		file << "{\n";
		file << "	File file;\n";
		file << "	if (false == file.Open ((config)\"connection_prediction_log_file\",\n";
		file << "						    ios_base::out|ios_base::app))\n";
		file << "		return;\n";
		file << "\n";
		file << "	for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "		{\n";
		file << "			PddlPredicate* pPddlFrom = vec_CandidatePredicates [f];\n";
		file << "			int iPddlFrom = pPddlFrom->i_PredicateCandidateWithoutNumber;\n";
		file << "			PddlPredicate* pPddlTo = vec_CandidatePredicates [t];\n";
		file << "			int iPddlTo = pPddlTo->i_PredicateCandidateWithoutNumber;\n";
		file << "			if (NULL == mtx_SentencesPositiveFromTo (iPddlFrom, iPddlTo))\n";
		file << "				continue;\n";
		file << "			file << ((0 == mtx_PredicateConnectionsFromTo (f, t))? '0' : '1') << ' ';\n";
		file << "		}\n";
		file << "	}\n";
		file << "	file << endl;\n";
		file << "	file.flush ();\n";
		file << "	file.Close ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String SubgoalPolicy::ConnectionPredictionRatio (void)\n";
		file << "{\n";
		file << "	// if (f_UseTextConnectionFeatures <= 0)\n";
		file << "		return String (\"0/0\");\n";
		file << "\n";
		file << "	/*\n";
		file << "	long lTotal = 0;\n";
		file << "	long lPredictedConnections = 0;\n";
		file << "	for (int f = 0; f < i_CandidatePredicateNumbersMerged; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicateNumbersMerged; ++ t)\n";
		file << "		{\n";
		file << "			if (NULL == mtx_SentencesPositiveFromTo (f, t))\n";
		file << "				continue;\n";
		file << "			++ lTotal;\n";
		file << "			lPredictedConnections +=  mtx_PredicateConnectionsFromTo (f, t);\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	String sRet;\n";
		file << "	sRet << lPredictedConnections << '/' << lTotal;\n";
		file << "	return sRet;\n";
		file << "	*/\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::WriteConnectionFeedback (void)\n";
		file << "{\n";
		file << "	/*\n";
		file << "	File file;\n";
		file << "	if (false == file.Open ((config)\"connection_feedback_log_file\",\n";
		file << "						    ios_base::out|ios_base::app))\n";
		file << "		return;\n";
		file << "\n";
		file << "	for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "		{\n";
		file << "			int iSuccesses = mtx_FeedbackOnSentenceConnections (f, t, 1);\n";
		file << "			int iFailures = mtx_FeedbackOnSentenceConnections (f, t, 0);\n";
		file << "			if ((0 == iSuccesses) && (0 == iFailures))\n";
		file << "				continue;\n";
		file << "\n";
		file << "			file << f << ':' << t << ':' << iSuccesses << ':' << iFailures << ' ';\n";
		file << "		}\n";
		file << "	}\n";
		file << "	file << endl;\n";
		file << "	file.flush ();\n";
		file << "	file.Close ();\n";
		file << "	*/\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("main.cpp", ios_base::out);
		file << "#include <iostream>\n";
		file << "#include \"Learner.h\"\n";
		file << "#include \"Problems.h\"\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <nlp_filesystem.h>\n";
		file << "#include <nlp_config.h>\n";
		file << "\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "Problem_dq_t	Problem::dq_Problems;\n";
		file << "\n";
		file << "extern void DumpSource (void);\n";
		file << "\n";
		file << "//\n";
		file << "String GetFileName (String _sPath)\n";
		file << "{\n";
		file << "	String sTarget;\n";
		file << "	size_t iNameStart = _sPath.ReverseFind (\"/\");\n";
		file << "	if (string::npos != iNameStart)\n";
		file << "		sTarget << _sPath.substr (iNameStart);\n";
		file << "	else\n";
		file << "		sTarget << _sPath;\n";
		file << "	return sTarget;\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void TestPddlLibrary (void)\n";
		file << "{\n";
		file << "    PddlDomain* domain;\n";
		file << "    PddlProblem* problem;\n";
		file << "    PddlPlan* plan = NULL;\n";
		file << "    {\n";
		file << "        String_dq_t	dqLines;\n";
		file << "        File::ReadLines ((config)\"test_domain\", dqLines);\n";
		file << "        String sPddl;\n";
		file << "        sPddl.Join (dqLines, '\\n');\n";
		file << "        domain = PddlInterface::ParseDomainPddl (sPddl);\n";
		file << "        // cout << *domain << endl;\n";
		file << "        //delete domain;\n";
		file << "    }\n";
		file << "    {\n";
		file << "        String_dq_t	dqLines;\n";
		file << "        File::ReadLines ((config)\"test_problem\", dqLines);\n";
		file << "        String sPddl;\n";
		file << "        sPddl.Join (dqLines, '\\n');\n";
		file << "        problem = PddlInterface::ParseProblemPddl (sPddl);\n";
		file << "        // cout << *problem << endl;\n";
		file << "        //delete problem;\n";
		file << "    }\n";
		file << "    {\n";
		file << "        String_dq_t dqLines;\n";
		file << "        File::ReadLines ((config)\"test_plan\", dqLines);\n";
		file << "        String sPlan;\n";
		file << "        sPlan.Join(dqLines, '\\n');\n";
		file << "        FFPlaningOutcome_e eOutcome = FFInterface::FFExtractOutcome(sPlan);\n";
		file << "        if (eOutcome == po_plan_found || eOutcome == po_goal_already_satisfied)\n";
		file << "        {\n";
		file << "            sPlan = FFInterface::ExtractPlan(sPlan);\n";
		file << "            plan = PddlInterface::ParsePlan(*domain, sPlan);\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "    if (plan != NULL)\n";
		file << "    {\n";
		file << "		PddlPredicate_dq_t dqPredicates;\n";
		file << "        PddlState* endState = PddlInterface::ComputeEndStateFast (*problem, *plan, dqPredicates);\n";
		file << "        String sNextPddl = endState->GetPddlString();\n";
		file << "        cout << sNextPddl << endl;\n";
		file << "    }\n";
		file << "    // String sPlan = \"move m0_0 m0_1\\nmove m0_1 m1_1\\n\";\n";
		file << "    // PddlPlan* plan = PddlInterface::ParsePlan(*domain, sPlan);\n";
		file << "\n";
		file << "    //cout << \"Computing end state..\" << endl;\n";
		file << "    // PddlState* endState = PddlInterface::ComputeEndStateFast (*domain, *problem, *plan);\n";
		file << "    //cout << \"The end state is: \" << endl;\n";
		file << "    // cout << endState->GetPddlString () << endl;\n";
		file << "    // cout << endState->s_Preamble << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int main (int argc, const char** argv)\n";
		file << "{\n";
		file << "	Config::SetCommandLine (argc, argv);\n";
		file << "\n";
		file << "	// dump source code if requested\n";
		file << "	if (1 == (int)(config)\"dump_source\")\n";
		file << "	{\n";
		file << "		DumpSource ();\n";
		file << "		return 0;\n";
		file << "	}\n";
		file << "\n";
		file << "	// pddl readup test code...\n";
		file << "	if (1 == (int)(config)\"test_pddl\")\n";
		file << "	{\n";
		file << "		TestPddlLibrary ();\n";
		file << "		return 1;\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	cout << \"High-level planning learner. Version \"\n";
		file << "		 << __DATE__ << ' ' << __TIME__ << endl;\n";
		file << "\n";
		file << "\n";
		file << "	// copy run configuration to output path.\n";
		file << "	{\n";
		file << "		// copy config file to output path ...\n";
		file << "		{\n";
		file << "			String sConfigFile (Config::GetConfigFileName ());\n";
		file << "			String sTarget;\n";
		file << "			sTarget << (config)\"output_path\" << '/'\n";
		file << "					<< GetFileName (sConfigFile);\n";
		file << "			if (true == Path::Exists (sTarget))\n";
		file << "				Path::RemoveFile (sTarget);\n";
		file << "			Config::WriteConfig (sTarget);\n";
		file << "		}\n";
		file << "\n";
		file << "		// copy binary to output path ...\n";
		file << "		if (1 == (int)(config)\"copy_binary_to_output_path\")\n";
		file << "		{\n";
		file << "			String sTarget;\n";
		file << "			sTarget << (config)\"output_path\" << '/'\n";
		file << "					<< GetFileName (argv [0]);\n";
		file << "			if (true == Path::Exists (sTarget))\n";
		file << "				Path::RemoveFile (sTarget);\n";
		file << "			Path::CopyFile (argv [0], sTarget);\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	// test feature computation...\n";
		file << "    if(1 == (int)(config)\"test_pddl_features\")\n";
		file << "	{\n";
		file << "        // SubgoalPolicy policy;\n";
		file << "        // policy.Init();\n";
		file << "        // policy.Test();\n";
		file << "        return 1;\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "	// learner...\n";
		file << "	SubgoalLearner	o_Learner;\n";
		file << "	if (false == Problem::Load ())\n";
		file << "		return 1;\n";
		file << "	cout << \"Learner init...\" << endl;\n";
		file << "	if (false == o_Learner.Init ())\n";
		file << "		return 1;\n";
		file << "\n";
		file << "	cout << \"Trying planning on full tasks...\" << endl;\n";
		file << "	o_Learner.TryPlanningOnFullTasks ();\n";
		file << "    int iSolutionLogPeriod = (config)\"solution_log_period\";\n";
		file << "	if (iSolutionLogPeriod > 0)\n";
		file << "		Problem::LogSolutions ((config)\"solution_log_path\");\n";
		file << "\n";
		file << "	cout << \"Learning...\" << endl;\n";
		file << "    int iLearningIterations = (config)\"learning_iterations\";\n";
		file << "    int iTestingPeriod = (config)\"test_period\";\n";
		file << "\n";
		file << "\n";
		file << "	Time oTimer;\n";
		file << "	oTimer.StartTimer ();\n";
		file << "	for (int i = 1; i < iLearningIterations + 1; ++ i)\n";
		file << "	{\n";
		file << "		cout << i << ' ' << flush;\n";
		file << "		bool bTestMode = (0 == (i % iTestingPeriod));\n";
		file << "		o_Learner.Iterate (i, bTestMode);\n";
		file << "\n";
		file << "		o_Learner.SaveWeights (i);\n";
		file << "		if ((iSolutionLogPeriod > 0) && (0 == (i % iSolutionLogPeriod)))\n";
		file << "			Problem::LogSolutions ((config)\"solution_log_path\");\n";
		file << "\n";
		file << "		cout << '[' << oTimer.sTimeToCompletion (i, iLearningIterations)\n";
		file << "			 << \"]  [\" << oTimer.sTotalRunTime () << ']' << endl;\n";
		file << "	}\n";
		file << "\n";
		file << "	o_Learner.SaveWeights (iLearningIterations);\n";
		file << "	if (iSolutionLogPeriod > 0)\n";
		file << "		Problem::LogSolutions ((config)\"solution_log_path\");\n";
		file << "\n";
		file << "	cout << \"----------------------------------------------\" << endl;\n";
		file << "	cout << \" List of solved problems \" << endl;\n";
		file << "	cout << \"----------------------------------------------\" << endl;\n";
		file << "	Problem::PrintSolvedProblems ();\n";
		file << "	cout << \"----------------------------------------------\" << endl;\n";
		file << "\n";
		file << "	Problem::Clear ();\n";
		file << "}\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("Pddl.cpp", ios_base::out);
		file << "#include \"Pddl.h\"\n";
		file << "#include <nlp_macros.h>\n";
		file << "#include <map>\n";
		file << "#include <assert.h>\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlParameter::PddlParameter (void)\n";
		file << "{\n";
		file << "	p_ResolvedValue = &s_Value;\n";
		file << "	// p_ResolvedValue = &s_VariableName;\n";
		file << "};\n";
		file << "\n";
		file << "PddlParameter::PddlParameter (const PddlParameter& _rParam)\n";
		file << "{\n";
		file << "	s_Type = _rParam.s_Type;\n";
		file << "	s_VariableName = _rParam.s_VariableName;\n";
		file << "\n";
		file << "	s_Value = _rParam.s_Value;\n";
		file << "    if (&_rParam.s_Value == _rParam.p_ResolvedValue)\n";
		file << "        p_ResolvedValue = &s_Value;\n";
		file << "    else\n";
		file << "        p_ResolvedValue = _rParam.p_ResolvedValue;\n";
		file << "	// p_ResolvedValue = &s_VariableName;\n";
		file << "}\n";
		file << "\n";
		file << "void PddlParameter::SetValue (String& _rValue)\n";
		file << "{\n";
		file << "	s_Value = _rValue;\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String PddlParameter::GetPddlString (void) const\n";
		file << "{\n";
		file << "	return *p_ResolvedValue;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlPredicate::PddlPredicate (void)\n";
		file << "{\n";
		file << "	l_Value = 0;\n";
		file << "	b_IsFunction = false;\n";
		file << "	i_PredicateCandidateIndex = -1;\n";
		file << "	i_PredicateIdentityFeatureIndex = -1;\n";
		file << "	i_PredicateNameFeatureIndex = -1;\n";
		file << "	i_PredicateCandidateWithoutNumber = -1;\n";
		file << "}\n";
		file << "\n";
		file << "PddlPredicate::PddlPredicate (const PddlPredicate& _rPredicate)\n";
		file << "{\n";
		file << "	s_Name = ((PddlPredicate&)_rPredicate).s_Name;\n";
		file << "	l_Value = ((PddlPredicate&)_rPredicate).l_Value;\n";
		file << "	b_IsFunction = ((PddlPredicate&)_rPredicate).b_IsFunction;\n";
		file << "	dq_Parameters = ((PddlPredicate&)_rPredicate).dq_Parameters;\n";
		file << "	s_BoundIdentityHash = ((PddlPredicate&)_rPredicate).s_BoundIdentityHash;\n";
		file << "\n";
		file << "	i_PredicateCandidateIndex = _rPredicate.i_PredicateCandidateIndex;\n";
		file << "	i_PredicateIdentityFeatureIndex = _rPredicate.i_PredicateIdentityFeatureIndex;\n";
		file << "	i_PredicateNameFeatureIndex = _rPredicate.i_PredicateNameFeatureIndex;\n";
		file << "	i_PredicateCandidateWithoutNumber = _rPredicate.i_PredicateCandidateWithoutNumber;\n";
		file << "	vec_ParameterValueFeatureIndex.Copy (_rPredicate.vec_ParameterValueFeatureIndex);\n";
		file << "\n";
		file << "	// fix parameter bindings ...\n";
		file << "	ITERATE (PddlParameter_dq_t, dq_Parameters, ite)\n";
		file << "	{\n";
		file << "		PddlParameter& rParam = *ite;\n";
		file << "		if (&rParam.s_Value == rParam.p_ResolvedValue)\n";
		file << "			continue;\n";
		file << "		rParam.s_Value = *rParam.p_ResolvedValue;\n";
		file << "		rParam.p_ResolvedValue = &rParam.s_Value;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "String PddlPredicate::InstanceHash(void) const\n";
		file << "{\n";
		file << "    // NK: I added this where I dereference the p_ResolvedValue\n";
		file << "    // because I wasn't sure if other code was relying on different hashing\n";
		file << "    // also removed the type because it seemed unecessary and I didn't have it\n";
		file << "	String sHash;\n";
		file << "	sHash << s_Name << '\\x01'; //<< b_IsFunction << '\\x03';\n";
		file << "	CONST_ITERATE (PddlParameter_dq_t, dq_Parameters, ite)\n";
		file << "	{\n";
		file << "		const PddlParameter& rParam = *ite;\n";
		file << "		sHash << *rParam.p_ResolvedValue << '\\x02';\n";
		file << "	}\n";
		file << "	return sHash;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String PddlPredicate::GetPddlString (void) const\n";
		file << "{\n";
		file << "	assert (false == b_IsFunction);\n";
		file << "\n";
		file << "	String sPddl;\n";
		file << "	if (true == b_IsFunction)\n";
		file << "		sPddl << \"(= (\";\n";
		file << "	else\n";
		file << "		sPddl << \"(\";\n";
		file << "\n";
		file << "	sPddl << s_Name;\n";
		file << "	CONST_ITERATE (PddlParameter_dq_t, dq_Parameters, ite)\n";
		file << "		sPddl << ' ' << ite->GetPddlString ();\n";
		file << "\n";
		file << "	if (true == b_IsFunction)\n";
		file << "		sPddl << \") \" << (int)l_Value;\n";
		file << "\n";
		file << "	sPddl << ')';\n";
		file << "	return sPddl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String& PddlPredicate::BoundIdentityHash (void)\n";
		file << "{\n";
		file << "	assert (false == b_IsFunction);\n";
		file << "\n";
		file << "	if (\"\" == s_BoundIdentityHash)\n";
		file << "	{\n";
		file << "		s_BoundIdentityHash << s_Name << '\\x01'; //<< b_IsFunction << '\\x03';\n";
		file << "		ITERATE (PddlParameter_dq_t, dq_Parameters, ite)\n";
		file << "		{\n";
		file << "			PddlParameter& rParam = *ite;\n";
		file << "			s_BoundIdentityHash << rParam.s_Type << '\\x01'\n";
		file << "								<< *rParam.p_ResolvedValue << '\\x02';\n";
		file << "		}\n";
		file << "	}\n";
		file << "	return s_BoundIdentityHash;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String PddlPredicate::UnBoundIdentityHash (void)\n";
		file << "{\n";
		file << "	String sHash;\n";
		file << "	sHash << s_Name << '\\x01' << b_IsFunction << '\\x03';\n";
		file << "	ITERATE (PddlParameter_dq_t, dq_Parameters, ite)\n";
		file << "	{\n";
		file << "		PddlParameter& rParam = *ite;\n";
		file << "		sHash << rParam.s_Type << '\\x02';\n";
		file << "	}\n";
		file << "	return sHash;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool PddlPredicate::operator== (const PddlPredicate& _rRight) const\n";
		file << "{\n";
		file << "	if (b_IsFunction != _rRight.b_IsFunction)\n";
		file << "		return false;\n";
		file << "	if (s_Name != _rRight.s_Name)\n";
		file << "		return false;\n";
		file << "\n";
		file << "	if (dq_Parameters.size () != _rRight.dq_Parameters.size ())\n";
		file << "		return false;\n";
		file << "	for (size_t i = 0; i < dq_Parameters.size (); ++i)\n";
		file << "	{\n";
		file << "		const PddlParameter& rLeftParam = dq_Parameters [i];\n";
		file << "		const PddlParameter& rRightParam = _rRight.dq_Parameters [i];\n";
		file << "\n";
		file << "		if ((NULL == rLeftParam.p_ResolvedValue) &&\n";
		file << "			(NULL == rRightParam.p_ResolvedValue))\n";
		file << "			continue;\n";
		file << "		if ((NULL == rLeftParam.p_ResolvedValue) ^\n";
		file << "			(NULL == rRightParam.p_ResolvedValue))\n";
		file << "			return false;\n";
		file << "		if (*rLeftParam.p_ResolvedValue != *rRightParam.p_ResolvedValue)\n";
		file << "			return false;\n";
		file << "\n";
		file << "		// if (dq_Parameters [i].s_Type != _rRight.dq_Parameters [i].s_Type)\n";
		file << "		//	return false;\n";
		file << "		//if (dq_Parameters [i].s_VariableName != _rRight.dq_Parameters [i].s_VariableName)\n";
		file << "		//	return false;\n";
		file << "	}\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlFunctionValuePredicate::PddlFunctionValuePredicate (const PddlFunctionValuePredicate& _rPredicate)\n";
		file << "	: PddlPredicate (_rPredicate)\n";
		file << "{\n";
		file << "	c_Operator = ((PddlFunctionValuePredicate&)_rPredicate).c_Operator;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String PddlFunctionValuePredicate::InstanceHash(void) const\n";
		file << "{\n";
		file << "	String sHash;\n";
		file << "	sHash << c_Operator << '\\x01' << s_Name << '\\x01';\n";
		file << "	CONST_ITERATE (PddlParameter_dq_t, dq_Parameters, ite)\n";
		file << "	{\n";
		file << "		const PddlParameter& rParam = *ite;\n";
		file << "		sHash << *rParam.p_ResolvedValue << '\\x02';\n";
		file << "	}\n";
		file << "	return sHash;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String PddlFunctionValuePredicate::GetPddlString (void) const\n";
		file << "{\n";
		file << "	String sPddl;\n";
		file << "	sPddl << \"(\" << c_Operator << \" (\" << s_Name;\n";
		file << "	CONST_ITERATE (PddlParameter_dq_t, dq_Parameters, ite)\n";
		file << "		sPddl << ' ' << ite->GetPddlString ();\n";
		file << "\n";
		file << "	sPddl << \") \" << (int)l_Value << ')';\n";
		file << "	return sPddl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String& PddlFunctionValuePredicate::BoundIdentityHash (void)\n";
		file << "{\n";
		file << "	if (\"\" == s_BoundIdentityHash)\n";
		file << "	{\n";
		file << "		s_BoundIdentityHash << s_Name << '\\x01';\n";
		file << "		ITERATE (PddlParameter_dq_t, dq_Parameters, ite)\n";
		file << "		{\n";
		file << "			PddlParameter& rParam = *ite;\n";
		file << "			s_BoundIdentityHash << rParam.s_Type << '\\x01'\n";
		file << "								<< *rParam.p_ResolvedValue << '\\x02';\n";
		file << "		}\n";
		file << "	}\n";
		file << "	return s_BoundIdentityHash;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "String PddlFunctionValuePredicate::UnBoundIdentityHash (void)\n";
		file << "{\n";
		file << "	String sHash;\n";
		file << "	sHash << c_Operator << '\\x01' << s_Name << '\\x01' << b_IsFunction << '\\x03';\n";
		file << "	ITERATE (PddlParameter_dq_t, dq_Parameters, ite)\n";
		file << "	{\n";
		file << "		PddlParameter& rParam = *ite;\n";
		file << "		sHash << rParam.s_Type << '\\x02';\n";
		file << "	}\n";
		file << "	return sHash;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool PddlFunctionValuePredicate::operator== (const PddlFunctionValuePredicate& _rRight) const\n";
		file << "{\n";
		file << "	if (c_Operator != _rRight.c_Operator)\n";
		file << "		return false;\n";
		file << "	return ((PddlPredicate&)*this == (PddlPredicate&)_rRight);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlEffect::PddlEffect (const PddlEffect& _rEffect)\n";
		file << " : PddlPredicate (_rEffect)\n";
		file << "{\n";
		file << "	e_Effect = ((PddlEffect&)_rEffect).e_Effect;\n";
		file << "	f_FunctionEffectValue = ((PddlEffect&)_rEffect).f_FunctionEffectValue;\n";
		file << "	o_FunctionEffectValue = ((PddlEffect&)_rEffect).o_FunctionEffectValue;\n";
		file << "	b_EffectValueIsPredicate = ((PddlEffect&)_rEffect).b_EffectValueIsPredicate;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlAction::PddlAction (const PddlAction& _rAction)\n";
		file << "{\n";
		file << "    s_Name = ((PddlAction&)_rAction).s_Name;\n";
		file << "    dq_Parameters = ((PddlAction&)_rAction).dq_Parameters;\n";
		file << "    dq_Effects = ((PddlAction&)_rAction).dq_Effects;\n";
		file << "    LinkEffectsToParameters ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void PddlAction::LinkEffectsToParameters (void)\n";
		file << "{\n";
		file << "	map<String,int>	mapVariableToIndex;\n";
		file << "	for (size_t i = 0; i < dq_Parameters.size (); ++ i)\n";
		file << "		mapVariableToIndex [dq_Parameters [i].s_VariableName] = i;\n";
		file << "\n";
		file << "	ITERATE (PddlEffect_dq_t, dq_Effects, iteEffect)\n";
		file << "	{\n";
		file << "		PddlEffect& rEffect = *iteEffect;\n";
		file << "		ITERATE (PddlParameter_dq_t, rEffect.dq_Parameters, iteParam)\n";
		file << "		{\n";
		file << "			PddlParameter& rVariable = *iteParam;\n";
		file << "			if ('?' != rVariable.s_VariableName.at (0))\n";
		file << "				// this is a literal value ...\n";
		file << "				rVariable.p_ResolvedValue = &rVariable.s_VariableName;\n";
		file << "			else\n";
		file << "			{\n";
		file << "				// this is a variable value...\n";
		file << "				map<String,int>::iterator	ite;\n";
		file << "				ite = mapVariableToIndex.find (rVariable.s_VariableName);\n";
		file << "				if (mapVariableToIndex.end () == ite)\n";
		file << "				{\n";
		file << "					cerr << \"   [EE] Variable in effect clause not found \"\n";
		file << "							\"in action parameters.\" << endl;\n";
		file << "					cout << rVariable.s_VariableName << endl;\n";
		file << "					cout << *this << endl;\n";
		file << "					assert (false);\n";
		file << "				}\n";
		file << "				int iParamIndex = mapVariableToIndex [rVariable.s_VariableName];\n";
		file << "				PddlParameter& rParam = dq_Parameters [iParamIndex];\n";
		file << "				rVariable.p_ResolvedValue = rParam.p_ResolvedValue;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "        if (rEffect.b_EffectValueIsPredicate)\n";
		file << "        {\n";
		file << "            ITERATE (PddlParameter_dq_t, rEffect.o_FunctionEffectValue.dq_Parameters, iteParam)\n";
		file << "            {\n";
		file << "                PddlParameter& rVariable = *iteParam;\n";
		file << "                if ('?' != rVariable.s_VariableName.at (0))\n";
		file << "                    // this is a literal value ...\n";
		file << "                    rVariable.p_ResolvedValue = &rVariable.s_VariableName;\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    // this is a variable value...\n";
		file << "                    map<String,int>::iterator	ite;\n";
		file << "                    ite = mapVariableToIndex.find (rVariable.s_VariableName);\n";
		file << "                    if (mapVariableToIndex.end () == ite)\n";
		file << "                    {\n";
		file << "                        cerr << \"   [EE] Variable in effect clause not found \"\n";
		file << "                                \"in action parameters.\" << endl;\n";
		file << "                        cout << rVariable.s_VariableName << endl;\n";
		file << "                        cout << *this << endl;\n";
		file << "                        assert (false);\n";
		file << "                    }\n";
		file << "                    int iParamIndex = mapVariableToIndex [rVariable.s_VariableName];\n";
		file << "                    PddlParameter& rParam = dq_Parameters [iParamIndex];\n";
		file << "                    rVariable.p_ResolvedValue = rParam.p_ResolvedValue;\n";
		file << "                }\n";
		file << "            }\n";
		file << "        }\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlDomain::~PddlDomain (void)\n";
		file << "{\n";
		file << "	ITERATE (NameToPddlAction_hmp_t, hmp_NameToActions, ite)\n";
		file << "		delete ite->second;\n";
		file << "	hmp_NameToActions.clear ();\n";
		file << "\n";
		file << "	ITERATE (PddlPredicate_dq_t, dq_Predicates, ite)\n";
		file << "		delete *ite;\n";
		file << "	dq_Predicates.clear ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlState::PddlState (const PddlState& _rState)\n";
		file << "{\n";
		file << "    s_Preamble = _rState.s_Preamble;\n";
		file << "\n";
		file << "    PddlPredicate_dq_t::const_iterator iter;\n";
		file << "    for (iter = _rState.dq_Predicates.begin(); iter != _rState.dq_Predicates.end(); ++iter)\n";
		file << "    {\n";
		file << "		const PddlPredicate* pFrom = *iter;\n";
		file << "		if (true == pFrom->b_IsFunction)\n";
		file << "			dq_Predicates.push_back (new PddlFunctionValuePredicate (*(PddlFunctionValuePredicate*)pFrom));\n";
		file << "		else\n";
		file << "			dq_Predicates.push_back (new PddlPredicate (*pFrom));\n";
		file << "    }\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlState::~PddlState (void)\n";
		file << "{\n";
		file << "	ITERATE (PddlPredicate_dq_t, dq_Predicates, ite)\n";
		file << "		delete *ite;\n";
		file << "	dq_Predicates.clear ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "long PddlState::calcEffectValue(const PddlEffect& _rEffect,\n";
		file << "                         const HashToPddlPredicate_hmp_t& _hmpPredicate)\n";
		file << "{\n";
		file << "    if (false == _rEffect.b_EffectValueIsPredicate)\n";
		file << "        return _rEffect.f_FunctionEffectValue;\n";
		file << "\n";
		file << "    else\n";
		file << "    {\n";
		file << "        String& hash = ((PddlPredicate&)_rEffect.o_FunctionEffectValue).BoundIdentityHash();\n";
		file << "        // PddlPredicate* pPred = ((HashToPddlPredicate_hmp_t&)_hmpPredicate)[hash];\n";
		file << "		HashToPddlPredicate_hmp_t::const_iterator	ite;\n";
		file << "		ite = _hmpPredicate.find (hash);\n";
		file << "		assert (_hmpPredicate.end () != ite);\n";
		file << "		const PddlPredicate* pPred = ite->second;\n";
		file << "\n";
		file << "        return pPred->l_Value;\n";
		file << "    }\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void PddlState::UpdateToNextState (const PddlAction& _rAction,\n";
		file << "								   PddlPredicate_dq_t& _rdqPredicates)\n";
		file << "{\n";
		file << "    // cout << _rAction << endl;\n";
		file << "    HashToPddlPredicate_hmp_t hmpOldPredicate (2 * dq_Predicates.size ());\n";
		file << "\n";
		file << "	CONST_ITERATE (PddlPredicate_dq_t, dq_Predicates, ite)\n";
		file << "    {\n";
		file << "		PddlPredicate* pPredicate = *ite;\n";
		file << "        String& hash = pPredicate->BoundIdentityHash();\n";
		file << "        // cout << hash << endl;\n";
		file << "        hmpOldPredicate.insert (make_pair (hash, pPredicate));\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // cout << \"applying effects : \" << _rAction.dq_Effects.size () << endl;\n";
		file << "	CONST_ITERATE (PddlEffect_dq_t, _rAction.dq_Effects, ite)\n";
		file << "    {\n";
		file << "		PddlPredicate& rPredicate = (PddlPredicate&) *ite;\n";
		file << "        String& hash = rPredicate.BoundIdentityHash();\n";
		file << "        // cout << *ite << endl;\n";
		file << "        // cout << hash << endl;\n";
		file << "        if (pe_assign == ite->e_Effect)\n";
		file << "        {\n";
		file << "            PddlPredicate *pPred = hmpOldPredicate [hash];\n";
		file << "            long value = long (calcEffectValue(*ite, hmpOldPredicate));\n";
		file << "            pPred->l_Value = value;\n";
		file << "			pPred->s_BoundIdentityHash = \"\";\n";
		file << "\n";
		file << "			PddlFunctionValuePredicate* pNewPred\n";
		file << "				= new PddlFunctionValuePredicate (*(PddlFunctionValuePredicate*)pPred);\n";
		file << "			_rdqPredicates.push_back (pNewPred);\n";
		file << "        }\n";
		file << "        else if (pe_increase == ite->e_Effect)\n";
		file << "        {\n";
		file << "            PddlPredicate *pPred = hmpOldPredicate [hash];\n";
		file << "            long inc = long (calcEffectValue(*ite, hmpOldPredicate));\n";
		file << "            pPred->l_Value += inc;\n";
		file << "			pPred->s_BoundIdentityHash = \"\";\n";
		file << "    		// cout << inc << \" \" << (pPred->l_Value) << endl;\n";
		file << "\n";
		file << "			PddlFunctionValuePredicate* pNewPred\n";
		file << "				= new PddlFunctionValuePredicate (*(PddlFunctionValuePredicate*)pPred);\n";
		file << "			_rdqPredicates.push_back (pNewPred);\n";
		file << "        }\n";
		file << "        else if (pe_decrease == ite->e_Effect)\n";
		file << "        {\n";
		file << "            PddlPredicate *pPred = hmpOldPredicate[hash];\n";
		file << "            long dec = long (calcEffectValue(*ite, hmpOldPredicate));\n";
		file << "            pPred->l_Value -= dec;\n";
		file << "			pPred->s_BoundIdentityHash = \"\";\n";
		file << "     		// cout << dec << \" \" << (pPred->l_Value) << endl;\n";
		file << "        }\n";
		file << "        else if (pe_predicate_set == ite->e_Effect)\n";
		file << "        {\n";
		file << "            if (hmpOldPredicate.end() == hmpOldPredicate.find(hash))\n";
		file << "            {\n";
		file << "                PddlPredicate& ref = (PddlPredicate&)*ite;\n";
		file << "                PddlPredicate *pPred = new PddlPredicate(ref);\n";
		file << "                hmpOldPredicate.insert (make_pair (hash, pPred));\n";
		file << "                pPred->l_Value = 1;\n";
		file << "				pPred->s_BoundIdentityHash = \"\";\n";
		file << "\n";
		file << "				dq_Predicates.push_back (pPred);\n";
		file << "				_rdqPredicates.push_back (new PddlPredicate (*pPred));\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                PddlPredicate *pPred = hmpOldPredicate[hash];\n";
		file << "                pPred->l_Value = 1;\n";
		file << "				pPred->s_BoundIdentityHash = \"\";\n";
		file << "				_rdqPredicates.push_back (new PddlPredicate (*pPred));\n";
		file << "            }\n";
		file << "        }\n";
		file << "        else if (pe_predicate_clear == ite->e_Effect)\n";
		file << "        {\n";
		file << "            if (hmpOldPredicate.end() == hmpOldPredicate.find(hash))\n";
		file << "            {\n";
		file << "                PddlPredicate& ref = (PddlPredicate&)*ite;\n";
		file << "                PddlPredicate *pPred = new PddlPredicate(ref);\n";
		file << "                hmpOldPredicate.insert (make_pair (hash, pPred));\n";
		file << "                pPred->l_Value = 0;\n";
		file << "				pPred->s_BoundIdentityHash = \"\";\n";
		file << "\n";
		file << "				dq_Predicates.push_back (pPred);\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                PddlPredicate *pPred = hmpOldPredicate [hash];\n";
		file << "                pPred->l_Value = 0;\n";
		file << "				pPred->s_BoundIdentityHash = \"\";\n";
		file << "            }\n";
		file << "        }\n";
		file << "        else\n";
		file << "        {\n";
		file << "            cerr << \"Unknown action effect type:\" << endl;\n";
		file << "            cerr << *ite << endl;\n";
		file << "            assert(false);\n";
		file << "        }\n";
		file << "    }\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlState* PddlState::ComputeNextState(const PddlAction& _rAction)\n";
		file << "{\n";
		file << "    // cout << _rAction << endl;\n";
		file << "    HashToPddlPredicate_hmp_t hmpOldPredicate (2 * dq_Predicates.size ());\n";
		file << "    HashToPddlPredicate_hmp_t hmpNewPredicate (2 * dq_Predicates.size ());\n";
		file << "\n";
		file << "\n";
		file << "	CONST_ITERATE (PddlPredicate_dq_t, dq_Predicates, ite)\n";
		file << "    {\n";
		file << "		PddlPredicate* pPredicate = *ite;\n";
		file << "\n";
		file << "        String& hash = pPredicate->BoundIdentityHash();\n";
		file << "        // cout << hash << endl;\n";
		file << "        hmpOldPredicate.insert (make_pair (hash, pPredicate));\n";
		file << "		if (true == pPredicate->b_IsFunction)\n";
		file << "			hmpNewPredicate.insert (make_pair (hash, new PddlFunctionValuePredicate (*(PddlFunctionValuePredicate*)pPredicate)));\n";
		file << "		else\n";
		file << "			hmpNewPredicate.insert (make_pair (hash, new PddlPredicate (*pPredicate)));\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // cout << \"applying effects : \" << _rAction.dq_Effects.size () << endl;\n";
		file << "	CONST_ITERATE (PddlEffect_dq_t, _rAction.dq_Effects, ite)\n";
		file << "    {\n";
		file << "		PddlPredicate& rPredicate = (PddlPredicate&) *ite;\n";
		file << "        String& hash = rPredicate.BoundIdentityHash();\n";
		file << "        // cout << *ite << endl;\n";
		file << "        // cout << hash << endl;\n";
		file << "        if (pe_assign == ite->e_Effect)\n";
		file << "        {\n";
		file << "            PddlPredicate *pPred = hmpNewPredicate[hash];\n";
		file << "            long value = long (calcEffectValue(*ite, hmpOldPredicate));\n";
		file << "            pPred->l_Value = value;\n";
		file << "			pPred->s_BoundIdentityHash = \"\";\n";
		file << "        }\n";
		file << "        else if (pe_increase == ite->e_Effect)\n";
		file << "        {\n";
		file << "            PddlPredicate *pPred = hmpNewPredicate[hash];\n";
		file << "            long inc = long (calcEffectValue(*ite, hmpOldPredicate));\n";
		file << "            pPred->l_Value += inc;\n";
		file << "			pPred->s_BoundIdentityHash = \"\";\n";
		file << "    		// cout << inc << \" \" << (pPred->l_Value) << endl;\n";
		file << "        }\n";
		file << "        else if (pe_decrease == ite->e_Effect)\n";
		file << "        {\n";
		file << "            PddlPredicate *pPred = hmpNewPredicate[hash];\n";
		file << "            long dec = long (calcEffectValue(*ite, hmpOldPredicate));\n";
		file << "            pPred->l_Value -= dec;\n";
		file << "			pPred->s_BoundIdentityHash = \"\";\n";
		file << "     		// cout << dec << \" \" << (pPred->l_Value) << endl;\n";
		file << "        }\n";
		file << "        else if (pe_predicate_set == ite->e_Effect)\n";
		file << "        {\n";
		file << "            if (hmpNewPredicate.end() == hmpNewPredicate.find(hash))\n";
		file << "            {\n";
		file << "                PddlPredicate& ref = (PddlPredicate&)*ite;\n";
		file << "                PddlPredicate *pPred = new PddlPredicate(ref);\n";
		file << "                hmpNewPredicate.insert(make_pair(hash, pPred));\n";
		file << "                pPred->l_Value = 1;\n";
		file << "				pPred->s_BoundIdentityHash = \"\";\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                PddlPredicate *pPred = hmpNewPredicate[hash];\n";
		file << "                pPred->l_Value = 1;\n";
		file << "				pPred->s_BoundIdentityHash = \"\";\n";
		file << "            }\n";
		file << "        }\n";
		file << "        else if (pe_predicate_clear == ite->e_Effect)\n";
		file << "        {\n";
		file << "            if (hmpNewPredicate.end() == hmpNewPredicate.find(hash))\n";
		file << "            {\n";
		file << "                PddlPredicate& ref = (PddlPredicate&)*ite;\n";
		file << "                PddlPredicate *pPred = new PddlPredicate(ref);\n";
		file << "                hmpNewPredicate.insert(make_pair(hash, pPred));\n";
		file << "                pPred->l_Value = 0;\n";
		file << "				pPred->s_BoundIdentityHash = \"\";\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                PddlPredicate *pPred = hmpNewPredicate[hash];\n";
		file << "                pPred->l_Value = 0;\n";
		file << "				pPred->s_BoundIdentityHash = \"\";\n";
		file << "            }\n";
		file << "        }\n";
		file << "        else\n";
		file << "        {\n";
		file << "            cerr << \"Unknown action effect type:\" << endl;\n";
		file << "            cerr << *ite << endl;\n";
		file << "            assert(false);\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    PddlState* state = new PddlState();\n";
		file << "    state->s_Preamble = s_Preamble;\n";
		file << "    ITERATE (HashToPddlPredicate_hmp_t, hmpNewPredicate, it)\n";
		file << "        state->dq_Predicates.push_back(it->second);\n";
		file << "\n";
		file << "\n";
		file << "    return state;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String PddlState::GetPddlString (void)\n";
		file << "{\n";
		file << "	String sPddl;\n";
		file << "	sPddl << \"(define \\n\"\n";
		file << "		  << s_Preamble\n";
		file << "		  << \"\\n\\n\"\n";
		file << "		  << \"(:init\\n\"\n";
		file << "		  << PddlState::GetPredicatePddlString ()\n";
		file << "		  << \"\\n)\\n)\";\n";
		file << "\n";
		file << "	return sPddl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String PddlState::GetPredicatePddlString (void)\n";
		file << "{\n";
		file << "	String_set_t setPredicates;\n";
		file << "	ITERATE (PddlPredicate_dq_t, dq_Predicates, ite)\n";
		file << "	{\n";
		file << "		PddlPredicate* pPredicate = *ite;\n";
		file << "		if (true == pPredicate->b_IsFunction)\n";
		file << "			setPredicates.insert (pPredicate->GetPddlString ());\n";
		file << "		else if (0 != pPredicate->l_Value)\n";
		file << "			setPredicates.insert (pPredicate->GetPddlString ());\n";
		file << "	}\n";
		file << "\n";
		file << "	String sPddl;\n";
		file << "	ITERATE (String_set_t, setPredicates, ite)\n";
		file << "		sPddl << *ite << '\\n';\n";
		file << "	return sPddl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool PddlState::operator== (const PddlState& _rRight) const\n";
		file << "{\n";
		file << "	if (s_Preamble != _rRight.s_Preamble)\n";
		file << "		return false;\n";
		file << "	size_t iPredicates = dq_Predicates.size ();\n";
		file << "	if (_rRight.dq_Predicates.size () != iPredicates)\n";
		file << "		return false;\n";
		file << "\n";
		file << "	String_set_t setLeft;\n";
		file << "	CONST_ITERATE (PddlPredicate_dq_t, dq_Predicates, ite)\n";
		file << "		setLeft.insert ((*ite)->GetPddlString ());\n";
		file << "\n";
		file << "	String_set_t setRight;\n";
		file << "	CONST_ITERATE (PddlPredicate_dq_t, _rRight.dq_Predicates, ite)\n";
		file << "		setRight.insert ((*ite)->GetPddlString ());\n";
		file << "\n";
		file << "	String_set_t::const_iterator	iteLeft = setLeft.begin ();\n";
		file << "	String_set_t::const_iterator	iteRight = setRight.begin ();\n";
		file << "	for (; iteLeft != setLeft.end (), iteRight != setRight.end ();\n";
		file << "		 ++ iteLeft, ++ iteRight)\n";
		file << "	{\n";
		file << "		if (*iteLeft != *iteRight)\n";
		file << "			return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String PddlProblem::GetPddlString (void)\n";
		file << "{\n";
		file << "	String sPddl;\n";
		file << "	sPddl << \"(define \\n\"\n";
		file << "		  << o_StartState.s_Preamble\n";
		file << "		  << \"\\n\\n\"\n";
		file << "		  << \"(:init\\n\"\n";
		file << "		  << o_StartState.GetPredicatePddlString ()\n";
		file << "		  << \"\\n)\"\n";
		file << "		  << \"(:goal\\n\"\n";
		file << "		  << o_PartialGoalState.GetPredicatePddlString ()\n";
		file << "		  << \"\\n)\\n)\";\n";
		file << "\n";
		file << "	return sPddl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlPlan::~PddlPlan (void)\n";
		file << "{\n";
		file << "	ITERATE (PddlAction_dq_t, dq_Actions, ite)\n";
		file << "		delete *ite;\n";
		file << "	dq_Actions.clear ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlParameter& _rParam)\n";
		file << "{\n";
		file << "	if (\"\" != _rParam.s_Type)\n";
		file << "		_rStream << _rParam.s_Type << ' ';\n";
		file << "	_rStream << _rParam.s_VariableName;\n";
		file << "	if ((NULL != _rParam.p_ResolvedValue) &&\n";
		file << "		(\"\" != *_rParam.p_ResolvedValue))\n";
		file << "		_rStream << \" = \" << *_rParam.p_ResolvedValue;\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlParameter_dq_t& _rdqParam)\n";
		file << "{\n";
		file << "	for (size_t i = 0; i < _rdqParam.size (); ++ i)\n";
		file << "	{\n";
		file << "		if (i > 0)\n";
		file << "			_rStream << ',';\n";
		file << "		const PddlParameter& rParam = _rdqParam [i];\n";
		file << "		_rStream << rParam;\n";
		file << "	}\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlPredicate& _rPredicate)\n";
		file << "{\n";
		file << "	_rStream << _rPredicate.s_Name;\n";
		file << "	if (true == _rPredicate.b_IsFunction)\n";
		file << "		_rStream << \"(\";\n";
		file << "	else\n";
		file << "		_rStream << \"<\";\n";
		file << "	_rStream << _rPredicate.dq_Parameters;\n";
		file << "	if (true == _rPredicate.b_IsFunction)\n";
		file << "		_rStream << \") = \" << _rPredicate.l_Value;\n";
		file << "	else\n";
		file << "		_rStream << \">\" << _rPredicate.l_Value;\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlFunctionValuePredicate& _rPredicate)\n";
		file << "{\n";
		file << "	_rStream << _rPredicate.s_Name << \"(\" << _rPredicate.dq_Parameters;\n";
		file << "	_rStream << \") \" << _rPredicate.c_Operator << ' ' << _rPredicate.l_Value;\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlEffect& _rEffect)\n";
		file << "{\n";
		file << "	if (pe_assign == _rEffect.e_Effect)\n";
		file << "		_rStream << \"[= \";\n";
		file << "	else if (pe_increase == _rEffect.e_Effect)\n";
		file << "		_rStream << \"[+ \";\n";
		file << "	else if (pe_decrease == _rEffect.e_Effect)\n";
		file << "		_rStream << \"[- \";\n";
		file << "\n";
		file << "	if ((pe_assign == _rEffect.e_Effect) ||\n";
		file << "		(pe_increase == _rEffect.e_Effect) ||\n";
		file << "		(pe_decrease == _rEffect.e_Effect))\n";
		file << "	{\n";
		file << "		if (true == _rEffect.b_EffectValueIsPredicate)\n";
		file << "			_rStream << _rEffect.o_FunctionEffectValue << \"] \";\n";
		file << "		else\n";
		file << "			_rStream << _rEffect.f_FunctionEffectValue << \"] \";\n";
		file << "	}\n";
		file << "\n";
		file << "	else if (pe_predicate_set == _rEffect.e_Effect)\n";
		file << "		_rStream << \"[1] \";\n";
		file << "	else if (pe_predicate_clear == _rEffect.e_Effect)\n";
		file << "		_rStream << \"[0] \";\n";
		file << "\n";
		file << "	_rStream << _rEffect.s_Name;\n";
		file << "	_rStream << '(' << _rEffect.dq_Parameters << ')';\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlAction& _rAction)\n";
		file << "{\n";
		file << "	_rStream << _rAction.s_Name << endl;\n";
		file << "	_rStream << \"[PARAMS]:\" << endl;\n";
		file << "	ITERATE (PddlParameter_dq_t, ((PddlAction&)_rAction).dq_Parameters, ite)\n";
		file << "		_rStream << \"   \" << *ite << endl;\n";
		file << "	_rStream << \"[EFFECTS]:\" << endl;\n";
		file << "	ITERATE (PddlEffect_dq_t, ((PddlAction&)_rAction).dq_Effects, ite)\n";
		file << "		_rStream << \"   \" << *ite << endl;\n";
		file << "\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlDomain& _rDomain)\n";
		file << "{\n";
		file << "	ITERATE (PddlPredicate_dq_t, ((PddlDomain&)_rDomain).dq_Predicates, ite)\n";
		file << "		_rStream << **ite << endl;\n";
		file << "	_rStream << endl;\n";
		file << "	ITERATE (NameToPddlAction_hmp_t, ((PddlDomain&)_rDomain).hmp_NameToActions, ite)\n";
		file << "		_rStream << *ite->second << endl;\n";
		file << "\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlState& _rProblem)\n";
		file << "{\n";
		file << "	_rStream << _rProblem.s_Preamble << endl << endl;\n";
		file << "	ITERATE (PddlPredicate_dq_t, ((PddlState&)_rProblem).dq_Predicates, ite)\n";
		file << "		_rStream << **ite << endl;\n";
		file << "\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "//\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlProblem& _rProblem)\n";
		file << "{\n";
		file << "	_rStream << _rProblem.o_StartState.s_Preamble << endl << endl;\n";
		file << "	_rStream << \"(:init \" << endl;\n";
		file << "	ITERATE (PddlPredicate_dq_t, ((PddlState&)_rProblem.o_StartState).dq_Predicates, ite)\n";
		file << "		_rStream << **ite << endl;\n";
		file << "	_rStream << \")\\n(:goal \" << endl;\n";
		file << "	ITERATE (PddlPredicate_dq_t, ((PddlState&)_rProblem.o_PartialGoalState).dq_Predicates, ite)\n";
		file << "		_rStream << **ite << endl;\n";
		file << "	_rStream << ')';\n";
		file << "\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("Pddl__.g", ios_base::out);
		file << "lexer grammar Pddl;\n";
		file << "options {\n";
		file << "  language=C;\n";
		file << "\n";
		file << "}\n";
		file << "\n";
		file << "T54 : '(' ;\n";
		file << "T55 : 'define' ;\n";
		file << "T56 : ')' ;\n";
		file << "T57 : 'domain' ;\n";
		file << "T58 : ':requirements' ;\n";
		file << "T59 : ':types' ;\n";
		file << "T60 : '-' ;\n";
		file << "T61 : 'either' ;\n";
		file << "T62 : ':functions' ;\n";
		file << "T63 : 'number' ;\n";
		file << "T64 : ':constants' ;\n";
		file << "T65 : ':predicates' ;\n";
		file << "T66 : ':constraints' ;\n";
		file << "T67 : ':action' ;\n";
		file << "T68 : ':parameters' ;\n";
		file << "T69 : ':precondition' ;\n";
		file << "T70 : ':effect' ;\n";
		file << "T71 : 'and' ;\n";
		file << "T72 : 'or' ;\n";
		file << "T73 : 'not' ;\n";
		file << "T74 : 'imply' ;\n";
		file << "T75 : 'exists' ;\n";
		file << "T76 : 'forall' ;\n";
		file << "T77 : ':durative-action' ;\n";
		file << "T78 : ':duration' ;\n";
		file << "T79 : ':condition' ;\n";
		file << "T80 : 'preference' ;\n";
		file << "T81 : 'at' ;\n";
		file << "T82 : 'over' ;\n";
		file << "T83 : 'start' ;\n";
		file << "T84 : 'end' ;\n";
		file << "T85 : 'all' ;\n";
		file << "T86 : ':derived' ;\n";
		file << "T87 : 'when' ;\n";
		file << "T88 : '*' ;\n";
		file << "T89 : '+' ;\n";
		file << "T90 : '/' ;\n";
		file << "T91 : '>' ;\n";
		file << "T92 : '<' ;\n";
		file << "T93 : '=' ;\n";
		file << "T94 : '>=' ;\n";
		file << "T95 : '<=' ;\n";
		file << "T96 : 'assign' ;\n";
		file << "T97 : 'scale-up' ;\n";
		file << "T98 : 'scale-down' ;\n";
		file << "T99 : 'increase' ;\n";
		file << "T100 : 'decrease' ;\n";
		file << "T101 : '?duration' ;\n";
		file << "T102 : 'problem' ;\n";
		file << "T103 : ':domain' ;\n";
		file << "T104 : ':objects' ;\n";
		file << "T105 : ':init' ;\n";
		file << "T106 : ':goal' ;\n";
		file << "T107 : ':metric' ;\n";
		file << "T108 : 'minimize' ;\n";
		file << "T109 : 'maximize' ;\n";
		file << "T110 : 'total-time' ;\n";
		file << "T111 : 'is-violated' ;\n";
		file << "T112 : 'always' ;\n";
		file << "T113 : 'sometime' ;\n";
		file << "T114 : 'within' ;\n";
		file << "T115 : 'at-most-once' ;\n";
		file << "T116 : 'sometime-after' ;\n";
		file << "T117 : 'sometime-before' ;\n";
		file << "T118 : 'always-within' ;\n";
		file << "T119 : 'hold-during' ;\n";
		file << "T120 : 'hold-after' ;\n";
		file << "\n";
		file << "// $ANTLR src \"Pddl.g\" 506\n";
		file << "/************* LEXER ****************************/\n";
		file << "\n";
		file << "\n";
		file << "REQUIRE_KEY\n";
		file << "    : ':strips'\n";
		file << "    | ':typing'\n";
		file << "    | ':negative-preconditions'\n";
		file << "    | ':disjunctive-preconditions'\n";
		file << "    | ':equality'\n";
		file << "    | ':existential-preconditions'\n";
		file << "    | ':universal-preconditions'\n";
		file << "    | ':quantified-preconditions'\n";
		file << "    | ':conditional-effects'\n";
		file << "    | ':fluents'\n";
		file << "    | ':adl'\n";
		file << "    | ':durative-actions'\n";
		file << "    | ':derived-predicates'\n";
		file << "    | ':timed-initial-literals'\n";
		file << "    | ':preferences'\n";
		file << "    | ':constraints'\n";
		file << "    ;\n";
		file << "\n";
		file << "\n";
		file << "// $ANTLR src \"Pddl.g\" 529\n";
		file << "NAME:    LETTER ANY_CHAR* ;\n";
		file << "\n";
		file << "// $ANTLR src \"Pddl.g\" 531\n";
		file << "fragment LETTER:	'a'..'z' | 'A'..'Z';\n";
		file << "\n";
		file << "// $ANTLR src \"Pddl.g\" 533\n";
		file << "fragment ANY_CHAR: LETTER | '0'..'9' | '-' | '_';\n";
		file << "\n";
		file << "// $ANTLR src \"Pddl.g\" 535\n";
		file << "VARIABLE : '?' LETTER ANY_CHAR* ;\n";
		file << "\n";
		file << "// $ANTLR src \"Pddl.g\" 537\n";
		file << "NUMBER : DIGIT+ ('.' DIGIT+)? ;\n";
		file << "\n";
		file << "// $ANTLR src \"Pddl.g\" 539\n";
		file << "fragment DIGIT: '0'..'9';\n";
		file << "\n";
		file << "// $ANTLR src \"Pddl.g\" 541\n";
		file << "LINE_COMMENT\n";
		file << "    : ';' ~('\\n'|'\\r')* '\\r'? '\\n' { $channel = HIDDEN; }\n";
		file << "    ;\n";
		file << "\n";
		file << "// $ANTLR src \"Pddl.g\" 545\n";
		file << "WHITESPACE\n";
		file << "    :   (   ' '\n";
		file << "        |   '\\t'\n";
		file << "        |   '\\r'\n";
		file << "        |   '\\n'\n";
		file << "        )+\n";
		file << "        { $channel = HIDDEN; }\n";
		file << "    ;\n";
		file.close ();
	}



	{
		ofstream file ("Pddl.g", ios_base::out);
		file << "/**\n";
		file << " * PDDL grammar for ANTLR v3\n";
		file << " * Zeyn Saigol\n";
		file << " * School of Computer Science\n";
		file << " * University of Birmingham\n";
		file << " *\n";
		file << " * $Id: Pddl.g 120 2008-10-02 14:59:50Z zas $\n";
		file << " */\n";
		file << "grammar Pddl;\n";
		file << "options {\n";
		file << "    language=C;\n";
		file << "    output=AST;\n";
		file << "    backtrack=true;\n";
		file << "    //k=4;\n";
		file << "}\n";
		file << "\n";
		file << "tokens {\n";
		file << "    DOMAIN;\n";
		file << "    DOMAIN_NAME;\n";
		file << "    REQUIREMENTS;\n";
		file << "    TYPES;\n";
		file << "    EITHER_TYPE;\n";
		file << "    CONSTANTS;\n";
		file << "    FUNCTIONS;\n";
		file << "    PREDICATES;\n";
		file << "    PARAMETERS;\n";
		file << "    ACTION;\n";
		file << "    DURATIVE_ACTION;\n";
		file << "    PROBLEM;\n";
		file << "    PROBLEM_NAME;\n";
		file << "    PROBLEM_DOMAIN;\n";
		file << "    OBJECTS;\n";
		file << "    INIT;\n";
		file << "    FUNC_HEAD;\n";
		file << "    PRECONDITION;\n";
		file << "    EFFECT;\n";
		file << "    AND_GD;\n";
		file << "    OR_GD;\n";
		file << "	NOT_GD;\n";
		file << "	IMPLY_GD;\n";
		file << "	EXISTS_GD;\n";
		file << "	FORALL_GD;\n";
		file << "	COMPARISON_GD;\n";
		file << "	AND_EFFECT;\n";
		file << "	FORALL_EFFECT;\n";
		file << "	WHEN_EFFECT;\n";
		file << "	ASSIGN_EFFECT;\n";
		file << "	NOT_EFFECT;\n";
		file << "	PRED_HEAD;\n";
		file << "	GOAL;\n";
		file << "	BINARY_OP;\n";
		file << "	UNARY_MINUS;\n";
		file << "	INIT_EQ;\n";
		file << "	INIT_AT;\n";
		file << "	NOT_PRED_INIT;\n";
		file << "	PRED_INST;\n";
		file << "	PROBLEM_CONSTRAINT;\n";
		file << "	PROBLEM_METRIC;\n";
		file << "}\n";
		file << "\n";
		file << "//prog: ( domain {print $domain.tree.toStringTree();} )+ ;\n";
		file << "\n";
		file << "\n";
		file << "getDomain: ( domain {return $domain.tree;} )+ ;\n";
		file << "getProblem: ( problem {return $problem.tree;} )+ ;\n";
		file << "\n";
		file << "\n";
		file << "//@parser::header {package uk.ac.bham.cs.zas.pddl.antlr;}\n";
		file << "\n";
		file << "// @parser::members {\n";
		file << "// private boolean wasError = false;\n";
		file << "// public void reportError(RecognitionException e) {\n";
		file << "// 	wasError = true;\n";
		file << "// 	super.reportError(e);\n";
		file << "// }\n";
		file << "// public boolean invalidGrammar() {\n";
		file << "// 	return wasError;\n";
		file << "// }\n";
		file << "// }\n";
		file << "\n";
		file << "// Standard way of disabling the default error handler, and throwing Exceptions instead:\n";
		file << "//@rulecatch { }\n";
		file << "//@members {\n";
		file << "// // raise exception, rather than recovering, on mismatched token within alt\n";
		file << "// protected void mismatch(IntStream input, int ttype, BitSet follow)\n";
		file << "//   throws RecognitionException\n";
		file << "// {\n";
		file << "//   throw new MismatchedTokenException(ttype, input);\n";
		file << "// }\n";
		file << "//}\n";
		file << "\n";
		file << "//@lexer::header {package uk.ac.bham.cs.zas.pddl.antlr;}\n";
		file << "\n";
		file << "\n";
		file << "/************* Start of grammar *******************/\n";
		file << "\n";
		file << "pddlDoc : domain | problem;\n";
		file << "\n";
		file << "/************* DOMAINS ****************************/\n";
		file << "\n";
		file << "domain\n";
		file << "    : '(' 'define' domainName\n";
		file << "      requireDef?\n";
		file << "      typesDef?\n";
		file << "      constantsDef?\n";
		file << "      predicatesDef?\n";
		file << "      functionsDef?\n";
		file << "      constraints?\n";
		file << "      structureDef*\n";
		file << "      ')'\n";
		file << "      -> ^(DOMAIN domainName requireDef? typesDef?\n";
		file << "                constantsDef? predicatesDef? functionsDef?\n";
		file << "                constraints? structureDef*)\n";
		file << "    ;\n";
		file << "\n";
		file << "domainName\n";
		file << "    : '(' 'domain' NAME ')'\n";
		file << "    	-> ^(DOMAIN_NAME NAME)\n";
		file << "    ;\n";
		file << "\n";
		file << "requireDef\n";
		file << "	: '(' ':requirements' REQUIRE_KEY+ ')'\n";
		file << "	-> ^(REQUIREMENTS REQUIRE_KEY+)\n";
		file << "	;\n";
		file << "\n";
		file << "typesDef\n";
		file << "	: '(' ':types' typedNameList ')'\n";
		file << "	  -> ^(TYPES typedNameList)\n";
		file << "	;\n";
		file << "\n";
		file << "// If have any typed names, they must come FIRST!\n";
		file << "typedNameList\n";
		file << "    : (NAME* | singleTypeNameList+ NAME*)\n";
		file << "    ;\n";
		file << "\n";
		file << "singleTypeNameList\n";
		file << "    : (NAME+ '-' t=type)\n";
		file << "	  -> ^(NAME $t)+\n";
		file << "	;\n";
		file << "\n";
		file << "type\n";
		file << "	: ( '(' 'either' primType+ ')' )\n";
		file << "	  -> ^(EITHER_TYPE primType+)\n";
		file << "	| primType\n";
		file << "	;\n";
		file << "\n";
		file << "primType : NAME ;\n";
		file << "\n";
		file << "functionsDef\n";
		file << "	: '(' ':functions' functionList ')'\n";
		file << "	-> ^(FUNCTIONS functionList)\n";
		file << "	;\n";
		file << "\n";
		file << "functionList\n";
		file << "	: (atomicFunctionSkeleton+ ('-' functionType)? )*\n";
		file << "	;\n";
		file << "\n";
		file << "atomicFunctionSkeleton\n";
		file << "	: '('! functionSymbol^ typedVariableList ')'!\n";
		file << "	;\n";
		file << "\n";
		file << "functionSymbol : NAME ;\n";
		file << "\n";
		file << "functionType : 'number' ; // Currently in PDDL only numeric functions are allowed\n";
		file << "\n";
		file << "constantsDef\n";
		file << "	: '(' ':constants' typedNameList ')'\n";
		file << "	-> ^(CONSTANTS typedNameList)\n";
		file << "	;\n";
		file << "\n";
		file << "predicatesDef\n";
		file << "	: '(' ':predicates' atomicFormulaSkeleton+ ')'\n";
		file << "	-> ^(PREDICATES atomicFormulaSkeleton+)\n";
		file << "	;\n";
		file << "\n";
		file << "atomicFormulaSkeleton\n";
		file << "	: '('! predicate^ typedVariableList ')'!\n";
		file << "	;\n";
		file << "\n";
		file << "predicate : NAME ;\n";
		file << "\n";
		file << "// If have any typed variables, they must come FIRST!\n";
		file << "typedVariableList\n";
		file << "    : (VARIABLE* | singleTypeVarList+ VARIABLE*)\n";
		file << "    ;\n";
		file << "\n";
		file << "singleTypeVarList\n";
		file << "    : (VARIABLE+ '-' t=type)\n";
		file << "      -> ^(VARIABLE $t)+\n";
		file << "    ;\n";
		file << "\n";
		file << "constraints\n";
		file << "	: '('! ':constraints'^ conGD ')'!\n";
		file << "	;\n";
		file << "\n";
		file << "structureDef\n";
		file << "	: actionDef\n";
		file << "	| durativeActionDef\n";
		file << "	| derivedDef\n";
		file << "	;\n";
		file << "\n";
		file << "\n";
		file << "/************* ACTIONS ****************************/\n";
		file << "\n";
		file << "actionDef\n";
		file << "	: '(' ':action' actionSymbol\n";
		file << "           actionDefBody ')'\n";
		file << "       -> ^(ACTION actionSymbol actionDefBody)\n";
		file << "    ;\n";
		file << "\n";
		file << "actionSymbol : NAME ;\n";
		file << "\n";
		file << "\n";
		file << "// Should allow preGD instead of goalDesc for preconditions -\n";
		file << "// but I can't get the LL(*) parsing to work\n";
		file << "// This means 'preference' preconditions cannot be used\n";
		file << "actionDefBody\n";
		file << "	: ( ':parameters' '(' typedVariableList ')')?\n";
		file << "      ( ':precondition' (('(' ')') | goalDesc))?\n";
		file << "	  ( ':effect' (('(' ')') | effect))?\n";
		file << "	  -> ^(PARAMETERS typedVariableList?) ^(PRECONDITION goalDesc?) ^(EFFECT effect?)\n";
		file << "	;\n";
		file << "\n";
		file << "//preGD\n";
		file << "//	: prefGD\n";
		file << "//	| '(' 'and' preGD* ')'\n";
		file << "//	| '(' 'forall' '(' typedVariableList ')' preGD ')'\n";
		file << "//	;\n";
		file << "//\n";
		file << "//prefGD\n";
		file << "//	: '(' 'preference' NAME? goalDesc ')'\n";
		file << "//	| goalDesc\n";
		file << "//	;\n";
		file << "\n";
		file << "goalDesc\n";
		file << "	: atomicTermFormula\n";
		file << "	| '(' 'and' goalDesc* ')'\n";
		file << "	          -> ^(AND_GD goalDesc*)\n";
		file << "	| '(' 'or' goalDesc* ')'\n";
		file << "	          -> ^(OR_GD goalDesc*)\n";
		file << "	| '(' 'not' goalDesc ')'\n";
		file << "	          -> ^(NOT_GD goalDesc)\n";
		file << "	| '(' 'imply' goalDesc goalDesc ')'\n";
		file << "	          -> ^(IMPLY_GD goalDesc goalDesc)\n";
		file << "	| '(' 'exists' '(' typedVariableList ')' goalDesc ')'\n";
		file << "	          -> ^(EXISTS_GD typedVariableList goalDesc)\n";
		file << "	| '(' 'forall' '(' typedVariableList ')' goalDesc ')'\n";
		file << "	          -> ^(FORALL_GD typedVariableList goalDesc)\n";
		file << "    | fComp\n";
		file << "              -> ^(COMPARISON_GD fComp)\n";
		file << "    ;\n";
		file << "\n";
		file << "fComp\n";
		file << "	: '('! binaryComp fExp fExp ')'!\n";
		file << "	;\n";
		file << "\n";
		file << "atomicTermFormula\n";
		file << "	: '(' predicate term* ')' -> ^(PRED_HEAD predicate term*)\n";
		file << "	;\n";
		file << "\n";
		file << "term : NAME | VARIABLE ;\n";
		file << "\n";
		file << "/************* DURATIVE ACTIONS ****************************/\n";
		file << "\n";
		file << "durativeActionDef\n";
		file << "	: '(' ':durative-action' actionSymbol\n";
		file << "	      ':parameters' '(' typedVariableList ')'\n";
		file << "           daDefBody ')'\n";
		file << "       -> ^(DURATIVE_ACTION actionSymbol typedVariableList daDefBody)\n";
		file << "    ;\n";
		file << "\n";
		file << "daDefBody\n";
		file << "	: ':duration' durationConstraint\n";
		file << "	| ':condition' (('(' ')') | daGD)\n";
		file << "    | ':effect' (('(' ')') | daEffect)\n";
		file << "    ;\n";
		file << "\n";
		file << "daGD\n";
		file << "	: prefTimedGD\n";
		file << "	| '(' 'and' daGD* ')'\n";
		file << "	| '(' 'forall' '(' typedVariableList ')' daGD ')'\n";
		file << "	;\n";
		file << "\n";
		file << "prefTimedGD\n";
		file << "	: timedGD\n";
		file << "	| '(' 'preference' NAME? timedGD ')'\n";
		file << "	;\n";
		file << "\n";
		file << "timedGD\n";
		file << "	: '(' 'at' timeSpecifier goalDesc ')'\n";
		file << "	| '(' 'over' interval goalDesc ')'\n";
		file << "	;\n";
		file << "\n";
		file << "timeSpecifier : 'start' | 'end' ;\n";
		file << "interval : 'all' ;\n";
		file << "\n";
		file << "/************* DERIVED DEFINITIONS ****************************/\n";
		file << "\n";
		file << "derivedDef\n";
		file << "	: '('! ':derived'^ typedVariableList goalDesc ')'!\n";
		file << "	;\n";
		file << "\n";
		file << "/************* EXPRESSIONS ****************************/\n";
		file << "\n";
		file << "fExp\n";
		file << "	: NUMBER\n";
		file << "	| '(' binaryOp fExp fExp2 ')' -> ^(BINARY_OP binaryOp fExp fExp2)\n";
		file << "	| '(' '-' fExp ')' -> ^(UNARY_MINUS fExp)\n";
		file << "	| fHead\n";
		file << "	| VARIABLE\n";
		file << "	;\n";
		file << "\n";
		file << "// This is purely a workaround for an ANTLR bug in tree construction\n";
		file << "// http://www.antlr.org/wiki/display/ANTLR3/multiple+occurences+of+a+token+mix+up+the+list+management+in+tree+rewrites\n";
		file << "fExp2 : fExp ;\n";
		file << "\n";
		file << "fHead\n";
		file << "	: '(' functionSymbol term* ')' -> ^(FUNC_HEAD functionSymbol term*)\n";
		file << "	| functionSymbol -> ^(FUNC_HEAD functionSymbol)\n";
		file << "	;\n";
		file << "\n";
		file << "effect\n";
		file << "	: '(' 'and' cEffect* ')' -> ^(AND_EFFECT cEffect*)\n";
		file << "	| cEffect\n";
		file << "	;\n";
		file << "\n";
		file << "cEffect\n";
		file << "	: '(' 'forall' '(' typedVariableList ')' effect ')'\n";
		file << "	  -> ^(FORALL_EFFECT typedVariableList effect)\n";
		file << "	| '(' 'when' goalDesc condEffect ')'\n";
		file << "	  -> ^(WHEN_EFFECT goalDesc condEffect)\n";
		file << "	| pEffect\n";
		file << "	;\n";
		file << "\n";
		file << "pEffect\n";
		file << "	: '(' assignOp fHead fExp ')'\n";
		file << "	  -> ^(ASSIGN_EFFECT assignOp fHead fExp)\n";
		file << "	| '(' 'not' atomicTermFormula ')'\n";
		file << "	  -> ^(NOT_EFFECT atomicTermFormula)\n";
		file << "	| atomicTermFormula\n";
		file << "	;\n";
		file << "\n";
		file << "\n";
		file << "// TODO: why is this different from the \"and cEffect\" above? Does it matter?\n";
		file << "condEffect\n";
		file << "	: '(' 'and' pEffect* ')' -> ^(AND_EFFECT pEffect*)\n";
		file << "	| pEffect\n";
		file << "	;\n";
		file << "\n";
		file << "// TODO: should these be uppercase & lexer section?\n";
		file << "binaryOp : '*' | '+' | '-' | '/' ;\n";
		file << "\n";
		file << "binaryComp : '>' | '<' | '=' | '>=' | '<=' ;\n";
		file << "\n";
		file << "assignOp : 'assign' | 'scale-up' | 'scale-down' | 'increase' | 'decrease' ;\n";
		file << "\n";
		file << "\n";
		file << "/************* DURATIONS  ****************************/\n";
		file << "\n";
		file << "durationConstraint\n";
		file << "	: '(' 'and' simpleDurationConstraint+ ')'\n";
		file << "	| '(' ')'\n";
		file << "	| simpleDurationConstraint\n";
		file << "	;\n";
		file << "\n";
		file << "simpleDurationConstraint\n";
		file << "	: '(' durOp '?duration' durValue ')'\n";
		file << "	| '(' 'at' timeSpecifier simpleDurationConstraint ')'\n";
		file << "	;\n";
		file << "\n";
		file << "durOp : '<=' | '>=' | '=' ;\n";
		file << "\n";
		file << "durValue : NUMBER | fExp ;\n";
		file << "\n";
		file << "daEffect\n";
		file << "	: '(' 'and' daEffect* ')'\n";
		file << "	| timedEffect\n";
		file << "	| '(' 'forall' '(' typedVariableList ')' daEffect ')'\n";
		file << "	| '(' 'when' daGD timedEffect ')'\n";
		file << "	| '(' assignOp fHead fExpDA ')'\n";
		file << "	;\n";
		file << "\n";
		file << "timedEffect\n";
		file << "	: '(' 'at' timeSpecifier daEffect ')'     // BNF has a-effect here, but not defined anywhere\n";
		file << "	| '(' 'at' timeSpecifier fAssignDA ')'\n";
		file << "	| '(' assignOp fHead fExp ')'         // BNF has assign-op-t and f-exp-t here, but not defined anywhere\n";
		file << "	;\n";
		file << "\n";
		file << "fAssignDA\n";
		file << "	: '(' assignOp fHead fExpDA ')'\n";
		file << "	;\n";
		file << "\n";
		file << "fExpDA\n";
		file << "	: '(' ((binaryOp fExpDA fExpDA) | ('-' fExpDA)) ')'\n";
		file << "	| '?duration'\n";
		file << "	| fExp\n";
		file << "	;\n";
		file << "\n";
		file << "/************* PROBLEMS ****************************/\n";
		file << "\n";
		file << "problem\n";
		file << "	: '(' 'define' problemDecl\n";
		file << "	  problemDomain\n";
		file << "      requireDef?\n";
		file << "      objectDecl?\n";
		file << "      init\n";
		file << "      goal\n";
		file << "      probConstraints?\n";
		file << "      metricSpec?\n";
		file << "      // lengthSpec? This is not defined anywhere in the BNF spec\n";
		file << "      ')'\n";
		file << "      -> ^(PROBLEM problemDecl problemDomain requireDef? objectDecl?\n";
		file << "      		init goal probConstraints? metricSpec?)\n";
		file << "    ;\n";
		file << "\n";
		file << "problemDecl\n";
		file << "    : '(' 'problem' NAME ')'\n";
		file << "    -> ^(PROBLEM_NAME NAME)\n";
		file << "    ;\n";
		file << "\n";
		file << "problemDomain\n";
		file << "	: '(' ':domain' NAME ')'\n";
		file << "	-> ^(PROBLEM_DOMAIN NAME)\n";
		file << "	;\n";
		file << "\n";
		file << "objectDecl\n";
		file << "	: '(' ':objects' typedNameList ')'\n";
		file << "	-> ^(OBJECTS typedNameList)\n";
		file << "	;\n";
		file << "\n";
		file << "init\n";
		file << "	: '(' ':init' initEl* ')'\n";
		file << "	-> ^(INIT initEl*)\n";
		file << "	;\n";
		file << "\n";
		file << "initEl\n";
		file << "	: nameLiteral\n";
		file << "	| '(' '=' fHead NUMBER ')'         -> ^(INIT_EQ fHead NUMBER)\n";
		file << "	| '(' 'at' NUMBER nameLiteral ')'  -> ^(INIT_AT NUMBER nameLiteral)\n";
		file << "	;\n";
		file << "\n";
		file << "nameLiteral\n";
		file << "	: atomicNameFormula\n";
		file << "	| '(' 'not' atomicNameFormula ')' -> ^(NOT_PRED_INIT atomicNameFormula)\n";
		file << "	;\n";
		file << "\n";
		file << "atomicNameFormula\n";
		file << "	: '(' predicate NAME* ')' -> ^(PRED_INST predicate NAME*)\n";
		file << "	;\n";
		file << "\n";
		file << "// Should allow preGD instead of goalDesc -\n";
		file << "// but I can't get the LL(*) parsing to work\n";
		file << "// This means 'preference' preconditions cannot be used\n";
		file << "//goal : '(' ':goal' preGD ')'  -> ^(GOAL preGD);\n";
		file << "goal : '(' ':goal' goalDesc ')' -> ^(GOAL goalDesc) ;\n";
		file << "\n";
		file << "probConstraints\n";
		file << "	: '(' ':constraints'  prefConGD ')'\n";
		file << "	  -> ^(PROBLEM_CONSTRAINT prefConGD)\n";
		file << "	;\n";
		file << "\n";
		file << "prefConGD\n";
		file << "	: '(' 'and' prefConGD* ')'\n";
		file << "	| '(' 'forall' '(' typedVariableList ')' prefConGD ')'\n";
		file << "	| '(' 'preference' NAME? conGD ')'\n";
		file << "	| conGD\n";
		file << "	;\n";
		file << "\n";
		file << "metricSpec\n";
		file << "	: '(' ':metric' optimization metricFExp ')'\n";
		file << "	  -> ^(PROBLEM_METRIC optimization metricFExp)\n";
		file << "	;\n";
		file << "\n";
		file << "optimization : 'minimize' | 'maximize' ;\n";
		file << "\n";
		file << "metricFExp\n";
		file << "	: '(' binaryOp metricFExp metricFExp ')'\n";
		file << "	| '(' ('*'|'/') metricFExp metricFExp+ ')'\n";
		file << "	| '(' '-' metricFExp ')'\n";
		file << "	| NUMBER\n";
		file << "	| '(' functionSymbol NAME* ')'\n";
		file << "	| functionSymbol\n";
		file << "    | 'total-time'\n";
		file << "	| '(' 'is-violated' NAME ')'\n";
		file << "	;\n";
		file << "\n";
		file << "/************* CONSTRAINTS ****************************/\n";
		file << "\n";
		file << "conGD\n";
		file << "	: '(' 'and' conGD* ')'\n";
		file << "	| '(' 'forall' '(' typedVariableList ')' conGD ')'\n";
		file << "	| '(' 'at' 'end' goalDesc ')'\n";
		file << "    | '(' 'always' goalDesc ')'\n";
		file << "	| '(' 'sometime' goalDesc ')'\n";
		file << " 	| '(' 'within' NUMBER goalDesc ')'\n";
		file << "	| '(' 'at-most-once' goalDesc ')'\n";
		file << "	| '(' 'sometime-after' goalDesc goalDesc ')'\n";
		file << "	| '(' 'sometime-before' goalDesc goalDesc ')'\n";
		file << "	| '(' 'always-within' NUMBER goalDesc goalDesc ')'\n";
		file << "	| '(' 'hold-during' NUMBER NUMBER goalDesc ')'\n";
		file << "	| '(' 'hold-after' NUMBER goalDesc ')'\n";
		file << "	;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "/************* LEXER ****************************/\n";
		file << "\n";
		file << "\n";
		file << "REQUIRE_KEY\n";
		file << "    : ':strips'\n";
		file << "    | ':typing'\n";
		file << "    | ':negative-preconditions'\n";
		file << "    | ':disjunctive-preconditions'\n";
		file << "    | ':equality'\n";
		file << "    | ':existential-preconditions'\n";
		file << "    | ':universal-preconditions'\n";
		file << "    | ':quantified-preconditions'\n";
		file << "    | ':conditional-effects'\n";
		file << "    | ':fluents'\n";
		file << "    | ':adl'\n";
		file << "    | ':durative-actions'\n";
		file << "    | ':derived-predicates'\n";
		file << "    | ':timed-initial-literals'\n";
		file << "    | ':preferences'\n";
		file << "    | ':constraints'\n";
		file << "    ;\n";
		file << "\n";
		file << "\n";
		file << "NAME:    LETTER ANY_CHAR* ;\n";
		file << "\n";
		file << "fragment LETTER:	'a'..'z' | 'A'..'Z';\n";
		file << "\n";
		file << "fragment ANY_CHAR: LETTER | '0'..'9' | '-' | '_';\n";
		file << "\n";
		file << "VARIABLE : '?' LETTER ANY_CHAR* ;\n";
		file << "\n";
		file << "NUMBER : DIGIT+ ('.' DIGIT+)? ;\n";
		file << "\n";
		file << "fragment DIGIT: '0'..'9';\n";
		file << "\n";
		file << "LINE_COMMENT\n";
		file << "    : ';' ~('\\n'|'\\r')* '\\r'? '\\n' { $channel = HIDDEN; }\n";
		file << "    ;\n";
		file << "\n";
		file << "WHITESPACE\n";
		file << "    :   (   ' '\n";
		file << "        |   '\\t'\n";
		file << "        |   '\\r'\n";
		file << "        |   '\\n'\n";
		file << "        )+\n";
		file << "        { $channel = HIDDEN; }\n";
		file << "    ;\n";
		file.close ();
	}



	{
		ofstream file ("Pddl.h", ios_base::out);
		file << "#ifndef __PDDL__\n";
		file << "#define __PDDL__\n";
		file << "\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <nlp_vector.h>\n";
		file << "#include <nlp_time.h>\n";
		file << "#include <deque>\n";
		file << "#include <hash_map>\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "\n";
		file << "class PddlParameter;\n";
		file << "class PddlPredicate;\n";
		file << "class PddlEffect;\n";
		file << "class PddlAction;\n";
		file << "typedef deque <PddlParameter>			PddlParameter_dq_t;\n";
		file << "typedef deque <PddlPredicate*>			PddlPredicate_dq_t;\n";
		file << "typedef deque <PddlEffect>				PddlEffect_dq_t;\n";
		file << "typedef deque <PddlAction*>				PddlAction_dq_t;\n";
		file << "typedef hash_map <String, PddlAction*>	NameToPddlAction_hmp_t;\n";
		file << "typedef hash_map <String, PddlPredicate*> HashToPddlPredicate_hmp_t;\n";
		file << "typedef Vector <int>					int_Vec_t;\n";
		file << "\n";
		file << "//\n";
		file << "class PddlParameter\n";
		file << "{\n";
		file << "	friend class PddlPredicate;\n";
		file << "\n";
		file << "	private:\n";
		file << "		String	s_Value;\n";
		file << "\n";
		file << "	public:\n";
		file << "		String	s_Type;\n";
		file << "		String	s_VariableName;\n";
		file << "		String*	p_ResolvedValue;\n";
		file << "\n";
		file << "		PddlParameter (void);\n";
		file << "		PddlParameter (const PddlParameter& _rParam);\n";
		file << "		void SetValue (String& _rValue);\n";
		file << "		String GetPddlString (void) const;\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlParameter& _rParam);\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlParameter_dq_t& _rdqParam);\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class PddlPredicate\n";
		file << "{\n";
		file << "	public:\n";
		file << "		int_Vec_t			vec_ParameterValueFeatureIndex;\n";
		file << "		PddlParameter_dq_t	dq_Parameters;\n";
		file << "		String				s_Name;\n";
		file << "		String				s_BoundIdentityHash;\n";
		file << "		long             	l_Value;\n";
		file << "\n";
		file << "		// index of predicate in subgoal candidate list\n";
		file << "		int					i_PredicateCandidateIndex;\n";
		file << "		// feature indices ...\n";
		file << "		int					i_PredicateIdentityFeatureIndex;\n";
		file << "		int					i_PredicateNameFeatureIndex;\n";
		file << "		int					i_PredicateCandidateWithoutNumber;\n";
		file << "\n";
		file << "		bool				b_IsFunction;\n";
		file << "\n";
		file << "        virtual String InstanceHash (void) const;\n";
		file << "		virtual String& BoundIdentityHash (void);\n";
		file << "		virtual String UnBoundIdentityHash (void);\n";
		file << "\n";
		file << "		PddlPredicate (void);\n";
		file << "		PddlPredicate (const PddlPredicate& _rPredicate);\n";
		file << "		virtual ~PddlPredicate (void) {}\n";
		file << "		virtual String GetPddlString (void) const;\n";
		file << "\n";
		file << "		virtual bool operator== (const PddlPredicate& _rRight) const;\n";
		file << "		virtual bool operator!= (const PddlPredicate& _rRight) const\n";
		file << "		{ return (false == operator==(_rRight)); };\n";
		file << "\n";
		file << "		virtual PddlPredicate* Clone (void)\n";
		file << "		{ return new PddlPredicate (*this); };\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlPredicate& _rPredicate);\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class PddlFunctionValuePredicate : public PddlPredicate\n";
		file << "{\n";
		file << "	public:\n";
		file << "		char	c_Operator;\n";
		file << "\n";
		file << "        virtual String InstanceHash (void) const;\n";
		file << "		virtual String& BoundIdentityHash (void);\n";
		file << "		virtual String UnBoundIdentityHash (void);\n";
		file << "\n";
		file << "		PddlFunctionValuePredicate (void) : PddlPredicate ()\n";
		file << "		{\n";
		file << "			b_IsFunction = true;\n";
		file << "			c_Operator = '*';\n";
		file << "		};\n";
		file << "\n";
		file << "		PddlFunctionValuePredicate (const PddlFunctionValuePredicate& _rPredicate);\n";
		file << "		virtual ~PddlFunctionValuePredicate (void) {}\n";
		file << "		virtual String GetPddlString (void) const;\n";
		file << "\n";
		file << "		virtual bool operator== (const PddlFunctionValuePredicate& _rRight) const;\n";
		file << "		virtual bool operator!= (const PddlFunctionValuePredicate& _rRight) const\n";
		file << "		{ return (false == operator==(_rRight)); };\n";
		file << "\n";
		file << "		virtual PddlPredicate* Clone (void)\n";
		file << "		{ return new PddlFunctionValuePredicate (*this); };\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlFunctionValuePredicate& _rPredicate);\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "enum PddlEffect_e\n";
		file << "{\n";
		file << "	pe_unknown,\n";
		file << "	pe_assign,\n";
		file << "	pe_increase,\n";
		file << "	pe_decrease,\n";
		file << "	pe_predicate_set,\n";
		file << "	pe_predicate_clear\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class PddlEffect : public PddlPredicate\n";
		file << "{\n";
		file << "	public:\n";
		file << "		PddlPredicate	o_FunctionEffectValue;\n";
		file << "		PddlEffect_e	e_Effect;\n";
		file << "		long			f_FunctionEffectValue;\n";
		file << "		bool			b_EffectValueIsPredicate;\n";
		file << "\n";
		file << "		PddlEffect (void) : PddlPredicate ()\n";
		file << "		{\n";
		file << "			e_Effect = pe_unknown;\n";
		file << "			f_FunctionEffectValue = 0;\n";
		file << "			b_EffectValueIsPredicate = false;\n";
		file << "		};\n";
		file << "\n";
		file << "		PddlEffect (const PddlEffect& _rEffect);\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlEffect& _rEffect);\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class PddlAction\n";
		file << "{\n";
		file << "	public:\n";
		file << "		PddlParameter_dq_t	dq_Parameters;\n";
		file << "		PddlEffect_dq_t		dq_Effects;\n";
		file << "		String				s_Name;\n";
		file << "\n";
		file << "        PddlAction (void) {};\n";
		file << "        PddlAction (const PddlAction& _rAction);\n";
		file << "		void LinkEffectsToParameters (void);\n";
		file << "\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlAction& _rAction);\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class PddlDomain\n";
		file << "{\n";
		file << "	public:\n";
		file << "		PddlPredicate_dq_t		dq_Predicates;\n";
		file << "		NameToPddlAction_hmp_t	hmp_NameToActions;\n";
		file << "\n";
		file << "		PddlDomain (void) {};\n";
		file << "		~PddlDomain (void);\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlDomain& _rDomain);\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class PddlState\n";
		file << "{\n";
		file << "    private:\n";
		file << "        long calcEffectValue (const PddlEffect& _rEffect,\n";
		file << "                        	   const HashToPddlPredicate_hmp_t& _hmpPredicate);\n";
		file << "\n";
		file << "	public:\n";
		file << "		PddlPredicate_dq_t	dq_Predicates;\n";
		file << "		String				s_Preamble;\n";
		file << "\n";
		file << "		PddlState (void) {};\n";
		file << "        PddlState (const PddlState& _rState);\n";
		file << "		~PddlState (void);\n";
		file << "\n";
		file << "        PddlState* ComputeNextState (const PddlAction& _rAction);\n";
		file << "        void UpdateToNextState (const PddlAction& _rAction,\n";
		file << "								PddlPredicate_dq_t& _rdqPredicates);\n";
		file << "		String GetPddlString (void);\n";
		file << "		String GetPredicatePddlString (void);\n";
		file << "\n";
		file << "		bool operator== (const PddlState& _rRight) const;\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator << (ostream& _rStream, const PddlState& _rState);\n";
		file << "\n";
		file << "//\n";
		file << "class PddlProblem\n";
		file << "{\n";
		file << "	public:\n";
		file << "		PddlState	o_StartState;\n";
		file << "		PddlState	o_PartialGoalState;\n";
		file << "\n";
		file << "		PddlProblem (void) {};\n";
		file << "		~PddlProblem (void) {};\n";
		file << "		String GetPddlString (void);\n";
		file << "};\n";
		file << "\n";
		file << "ostream& operator<< (ostream& _rStream, const PddlProblem& _rProblem);\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class PddlPlan\n";
		file << "{\n";
		file << "	public:\n";
		file << "		PddlAction_dq_t	dq_Actions;\n";
		file << "\n";
		file << "		PddlPlan (void) {};\n";
		file << "		~PddlPlan (void);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file.close ();
	}



	{
		ofstream file ("PddlInterface.cpp", ios_base::out);
		file << "#include \"PddlParser.h\"\n";
		file << "#include \"PddlLexer.h\"\n";
		file << "// [WARNING !!!]\n";
		file << "// PddlParser.h and PddlLexer.h have to be before\n";
		file << "// PddlInterface.h.  Otherwise we get weird errors.\n";
		file << "// [WARNING !!!]\n";
		file << "#include \"PddlInterface.h\"\n";
		file << "#include <nlp_config.h>\n";
		file << "#include <nlp_macros.h>\n";
		file << "#include <assert.h>\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void PddlInterface::ParsePddlParameters (ANTLR3_BASE_TREE* _pTree,\n";
		file << "										 PddlParameter_dq_t* _pdqParams,\n";
		file << "										 int _iStartingIndex)\n";
		file << "{\n";
		file << "	long iParameters = _pTree->getChildCount (_pTree);\n";
		file << "	for (int i = _iStartingIndex; i < iParameters; ++ i)\n";
		file << "	{\n";
		file << "		_pdqParams->push_back (PddlParameter ());\n";
		file << "		PddlParameter& rParam = _pdqParams->back ();\n";
		file << "\n";
		file << "		ANTLR3_BASE_TREE* pParam = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, i);\n";
		file << "		rParam.s_VariableName = ToString (pParam);\n";
		file << "		// cout << \"param variable name : \" << rParam.s_VariableName << endl;\n";
		file << "        if ('?' != rParam.s_VariableName.at (0))\n";
		file << "            rParam.p_ResolvedValue = &rParam.s_VariableName;\n";
		file << "\n";
		file << "		if (1 == pParam->getChildCount (pParam))\n";
		file << "		{\n";
		file << "			ANTLR3_BASE_TREE* pType = (ANTLR3_BASE_TREE*) pParam->getChild (pParam, 0);\n";
		file << "			rParam.s_Type = ToString (pType);\n";
		file << "			// cout << \"param variable type : \" << rParam.s_Type << endl;\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void PddlInterface::ParsePddlEffects (ANTLR3_BASE_TREE* _pTree,\n";
		file << "									  PddlEffect_dq_t* _pdqEffects)\n";
		file << "{\n";
		file << "	#ifndef NDEBUG\n";
		file << "	int iBase = _pTree->getChildCount (_pTree);\n";
		file << "	assert (1 == iBase);\n";
		file << "	#endif\n";
		file << "\n";
		file << "	ANTLR3_BASE_TREE* pEffectTree = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, 0);\n";
		file << "	int iEffects = pEffectTree->getChildCount (pEffectTree);\n";
		file << "\n";
		file << "	for (int i = 0; i < iEffects; ++ i)\n";
		file << "	{\n";
		file << "		_pdqEffects->push_back (PddlEffect ());\n";
		file << "		PddlEffect& rEffect = _pdqEffects->back ();\n";
		file << "\n";
		file << "		ANTLR3_BASE_TREE* pEffect = (ANTLR3_BASE_TREE*) pEffectTree->getChild (pEffectTree, i);\n";
		file << "		String sToken (ToString (pEffect));\n";
		file << "		// cout << \"effect type : \" << sToken << endl;\n";
		file << "		if (\"PRED_HEAD\" == sToken)\n";
		file << "		{\n";
		file << "			// predicate being set true...\n";
		file << "			int iEffectAttrs = pEffect->getChildCount (pEffect);\n";
		file << "			assert (iEffectAttrs > 0);\n";
		file << "			ANTLR3_BASE_TREE* pPredicateName\n";
		file << "				= (ANTLR3_BASE_TREE*) pEffect->getChild (pEffect, 0);\n";
		file << "			rEffect.s_Name = ToString (pPredicateName);\n";
		file << "			// cout << \"effect predicate : \" << rEffect.s_Name << endl;\n";
		file << "			rEffect.e_Effect = pe_predicate_set;\n";
		file << "\n";
		file << "			if (iEffectAttrs > 1)\n";
		file << "				ParsePddlParameters (pEffect, &rEffect.dq_Parameters, 1);\n";
		file << "		}\n";
		file << "		else if (\"NOT_EFFECT\" == sToken)\n";
		file << "		{\n";
		file << "			// predicate being set false ...\n";
		file << "			assert (1 == pEffect->getChildCount (pEffect));\n";
		file << "			ANTLR3_BASE_TREE* pChild\n";
		file << "				= (ANTLR3_BASE_TREE*) pEffect->getChild (pEffect, 0);\n";
		file << "\n";
		file << "			int iEffectAttrs = pChild->getChildCount (pChild);\n";
		file << "			assert (iEffectAttrs > 0);\n";
		file << "			ANTLR3_BASE_TREE* pPredicateName\n";
		file << "				= (ANTLR3_BASE_TREE*) pChild->getChild (pChild, 0);\n";
		file << "			rEffect.s_Name = ToString (pPredicateName);\n";
		file << "			// cout << \"effect not predicate : \" << rEffect.s_Name << endl;\n";
		file << "			rEffect.e_Effect = pe_predicate_clear;\n";
		file << "\n";
		file << "			if (iEffectAttrs > 1)\n";
		file << "				ParsePddlParameters (pChild, &rEffect.dq_Parameters, 1);\n";
		file << "		}\n";
		file << "		else if (\"ASSIGN_EFFECT\" == sToken)\n";
		file << "		{\n";
		file << "			// function ...\n";
		file << "			int iEffectAttrs = pEffect->getChildCount (pEffect);\n";
		file << "			assert (3 == iEffectAttrs);\n";
		file << "\n";
		file << "			// effect type ...\n";
		file << "			ANTLR3_BASE_TREE* pEffectType\n";
		file << "				= (ANTLR3_BASE_TREE*) pEffect->getChild (pEffect, 0);\n";
		file << "			String sEffectType (ToString (pEffectType));\n";
		file << "			// cout << \"function effect type : \" << sEffectType << endl;\n";
		file << "			if (\"assign\" == sEffectType)\n";
		file << "				rEffect.e_Effect = pe_assign;\n";
		file << "			else if (\"increase\" == sEffectType)\n";
		file << "				rEffect.e_Effect = pe_increase;\n";
		file << "			else if (\"decrease\" == sEffectType)\n";
		file << "				rEffect.e_Effect = pe_decrease;\n";
		file << "\n";
		file << "\n";
		file << "			// function name + params\n";
		file << "			ANTLR3_BASE_TREE* pFunction\n";
		file << "				= (ANTLR3_BASE_TREE*) pEffect->getChild (pEffect, 1);\n";
		file << "			// cout << \"function effect head : \" << ToString (pFunction) << endl;\n";
		file << "			assert (0 == strcmp (\"FUNC_HEAD\", ToString (pFunction)));\n";
		file << "\n";
		file << "			iEffectAttrs = pFunction->getChildCount (pFunction);\n";
		file << "			ANTLR3_BASE_TREE* pFunctionName\n";
		file << "				= (ANTLR3_BASE_TREE*) pFunction->getChild (pFunction, 0);\n";
		file << "			rEffect.s_Name = ToString (pFunctionName);\n";
		file << "			// cout << \"function effect name : \" << rEffect.s_Name << endl;\n";
		file << "\n";
		file << "			if (iEffectAttrs > 1)\n";
		file << "				ParsePddlParameters (pFunction, &rEffect.dq_Parameters, 1);\n";
		file << "\n";
		file << "\n";
		file << "			// effect value ...\n";
		file << "			ANTLR3_BASE_TREE* pEffectValue\n";
		file << "				= (ANTLR3_BASE_TREE*) pEffect->getChild (pEffect, 2);\n";
		file << "			String sEffectValue (ToString (pEffectValue));\n";
		file << "			// cout << \"function effect value : \" << sEffectValue << endl;\n";
		file << "			if (true == sEffectValue.IsDigit ())\n";
		file << "				rEffect.f_FunctionEffectValue = (double) sEffectValue;\n";
		file << "			else\n";
		file << "			{\n";
		file << "				assert (\"FUNC_HEAD\" == sEffectValue);\n";
		file << "				rEffect.b_EffectValueIsPredicate = true;\n";
		file << "\n";
		file << "				iEffectAttrs = pEffectValue->getChildCount (pEffectValue);\n";
		file << "				ANTLR3_BASE_TREE* pFunctionName\n";
		file << "					= (ANTLR3_BASE_TREE*) pEffectValue->getChild (pEffectValue, 0);\n";
		file << "				rEffect.o_FunctionEffectValue.s_Name = ToString (pFunctionName);\n";
		file << "				// cout << \"func effect value name : \" << rEffect.o_FunctionEffectValue.s_Name << endl;\n";
		file << "\n";
		file << "				if (iEffectAttrs > 1)\n";
		file << "					ParsePddlParameters (pEffectValue,\n";
		file << "										 &rEffect.o_FunctionEffectValue.dq_Parameters,\n";
		file << "										 1);\n";
		file << "			}\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlPredicate* PddlInterface::ParsePddlPredicate (ANTLR3_BASE_TREE* _pTree,\n";
		file << "												  bool _bIsFunction)\n";
		file << "{\n";
		file << "	PddlPredicate* pPredicate = NULL;\n";
		file << "	if (true == _bIsFunction)\n";
		file << "		pPredicate = new PddlFunctionValuePredicate;\n";
		file << "	else\n";
		file << "		pPredicate = new PddlPredicate;\n";
		file << "	pPredicate->b_IsFunction = _bIsFunction;\n";
		file << "	pPredicate->s_Name = ToString (_pTree);\n";
		file << "	// cout << \"predicate name : \" << pPredicate->s_Name << endl;\n";
		file << "\n";
		file << "	ParsePddlParameters (_pTree, &pPredicate->dq_Parameters);\n";
		file << "	return pPredicate;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlAction* PddlInterface::ParsePddlAction (ANTLR3_BASE_TREE* _pTree)\n";
		file << "{\n";
		file << "	PddlAction* pAction = new PddlAction;\n";
		file << "	long iChildren = _pTree->getChildCount (_pTree);\n";
		file << "	assert (iChildren > 1);\n";
		file << "\n";
		file << "	{ // Name\n";
		file << "		ANTLR3_BASE_TREE* pChild = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, 0);\n";
		file << "		pAction->s_Name = ToString (pChild);\n";
		file << "		// cout << \"action name : \" << pAction->s_Name << endl;\n";
		file << "	}\n";
		file << "\n";
		file << "	for (int i = 1; i < iChildren; ++ i)\n";
		file << "	{\n";
		file << "		ANTLR3_BASE_TREE* pChild = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, i);\n";
		file << "		String sToken (ToString (pChild));\n";
		file << "		// cout << \"action info : \" << sToken << endl;\n";
		file << "		if (\"PARAMETERS\" == sToken)\n";
		file << "		{\n";
		file << "			ParsePddlParameters (pChild, &pAction->dq_Parameters);\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "\n";
		file << "		if (\"EFFECT\" == sToken)\n";
		file << "		{\n";
		file << "			ParsePddlEffects (pChild, &pAction->dq_Effects);\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	return pAction;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlDomain* PddlInterface::ParseDomainPddl (String& _rDomain)\n";
		file << "{\n";
		file << "	size_t iLength = _rDomain.length ();\n";
		file << "	ANTLR3_UINT8* pText = ANTLR3_STRDUP (_rDomain);\n";
		file << "\n";
		file << "	ANTLR3_INPUT_STREAM* paisDomain;\n";
		file << "	paisDomain = antlr3NewAsciiStringInPlaceStream (pText, iLength, NULL);\n";
		file << "	PddlLexer* pLexer = PddlLexerNew (paisDomain);\n";
		file << "\n";
		file << "	ANTLR3_COMMON_TOKEN_STREAM* pTokenStream;\n";
		file << "	pTokenStream = antlr3CommonTokenStreamSourceNew (ANTLR3_SIZE_HINT, TOKENSOURCE(pLexer));\n";
		file << "\n";
		file << "	PddlParser* pParser = PddlParserNew (pTokenStream);\n";
		file << "	PddlParser_getDomain_return oAST = pParser->getDomain (pParser);\n";
		file << "\n";
		file << "	PddlDomain* pDomain = new PddlDomain;\n";
		file << "\n";
		file << "	long iChildren = oAST.tree->getChildCount (oAST.tree);\n";
		file << "	for (long c = 0; c < iChildren; ++ c)\n";
		file << "	{\n";
		file << "		ANTLR3_BASE_TREE* pChild = (ANTLR3_BASE_TREE*) oAST.tree->getChild (oAST.tree, c);\n";
		file << "		String sToken (ToString (pChild));\n";
		file << "		// cout << \"domain info : \" << sToken << endl;\n";
		file << "		if (\"TYPES\" == sToken)\n";
		file << "			continue;\n";
		file << "\n";
		file << "		bool bIsPredicate = (\"PREDICATES\" == sToken);\n";
		file << "		bool bIsFunction = (\"FUNCTIONS\" == sToken);\n";
		file << "		bool bIsAction = (\"ACTION\" == sToken);\n";
		file << "\n";
		file << "		if (bIsPredicate || bIsFunction)\n";
		file << "		{\n";
		file << "			long iGrandChildren = pChild->getChildCount (pChild);\n";
		file << "			for (long t = 0; t < iGrandChildren; ++ t)\n";
		file << "			{\n";
		file << "				ANTLR3_BASE_TREE* pPredicateTree\n";
		file << "					= (ANTLR3_BASE_TREE*) pChild->getChild (pChild, t);\n";
		file << "				PddlPredicate* pPredicate\n";
		file << "					= ParsePddlPredicate (pPredicateTree, bIsFunction);\n";
		file << "				pDomain->dq_Predicates.push_back (pPredicate);\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		if (bIsAction)\n";
		file << "		{\n";
		file << "			PddlAction* pAction = ParsePddlAction (pChild);\n";
		file << "			pAction->LinkEffectsToParameters ();\n";
		file << "			pDomain->hmp_NameToActions.insert (make_pair (pAction->s_Name, pAction));\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	pParser->free (pParser);\n";
		file << "	pLexer->free (pLexer);\n";
		file << "	pTokenStream->free (pTokenStream);\n";
		file << "	paisDomain->close (paisDomain);\n";
		file << "	ANTLR3_FREE (pText);\n";
		file << "\n";
		file << "	return pDomain;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlPredicate* PddlInterface::ParsePddlInit (ANTLR3_BASE_TREE* _pTree)\n";
		file << "{\n";
		file << "	String sType = ToString (_pTree);\n";
		file << "	PddlPredicate* pPredicate = NULL;\n";
		file << "	if (\"PRED_INST\" == sType)\n";
		file << "	{\n";
		file << "		pPredicate = new PddlPredicate;\n";
		file << "		int iPredicateAttr = _pTree->getChildCount (_pTree);\n";
		file << "		assert (iPredicateAttr > 0);\n";
		file << "\n";
		file << "		ANTLR3_BASE_TREE* pChild = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, 0);\n";
		file << "		pPredicate->s_Name = ToString (pChild);\n";
		file << "		pPredicate->l_Value = 1;\n";
		file << "\n";
		file << "		if (iPredicateAttr > 1)\n";
		file << "			ParsePddlParameters (_pTree, &pPredicate->dq_Parameters, 1);\n";
		file << "	}\n";
		file << "	else if (\"INIT_EQ\" == sType)\n";
		file << "	{\n";
		file << "		pPredicate = new PddlFunctionValuePredicate;\n";
		file << "		((PddlFunctionValuePredicate*)pPredicate)->c_Operator = '=';\n";
		file << "\n";
		file << "		#ifndef NDEBUG\n";
		file << "		int iFunctionAttr = _pTree->getChildCount (_pTree);\n";
		file << "		assert (iFunctionAttr > 0);\n";
		file << "		#endif\n";
		file << "\n";
		file << "		// function ...\n";
		file << "		ANTLR3_BASE_TREE* pChild = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, 0);\n";
		file << "		assert (0 == strcmp (\"FUNC_HEAD\", ToString (pChild)));\n";
		file << "\n";
		file << "		int iFunctionParams = pChild->getChildCount (pChild);\n";
		file << "		assert (iFunctionParams > 0);\n";
		file << "		ANTLR3_BASE_TREE* pFunction = (ANTLR3_BASE_TREE*) pChild->getChild (pChild, 0);\n";
		file << "		pPredicate->s_Name = ToString (pFunction);\n";
		file << "		pPredicate->b_IsFunction = true;\n";
		file << "\n";
		file << "		if (iFunctionParams > 1)\n";
		file << "			ParsePddlParameters (pChild, &pPredicate->dq_Parameters, 1);\n";
		file << "\n";
		file << "		// value ...\n";
		file << "		ANTLR3_BASE_TREE* pValue = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, 1);\n";
		file << "		String sValue = ToString (pValue);\n";
		file << "		pPredicate->l_Value = (long)sValue;\n";
		file << "        //cout << sValue << \"::\" << pPredicate->l_Value << endl;\n";
		file << "\n";
		file << "	}\n";
		file << "\n";
		file << "	return pPredicate;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlPredicate* PddlInterface::ParsePddlGoal (ANTLR3_BASE_TREE* _pTree)\n";
		file << "{\n";
		file << "	String sType = ToString (_pTree);\n";
		file << "	PddlPredicate* pPredicate = NULL;\n";
		file << "\n";
		file << "	if (\"PRED_HEAD\" == sType)\n";
		file << "	{\n";
		file << "		// (PRED_HEAD connect m4_4 m4_3)\n";
		file << "		pPredicate = new PddlPredicate;\n";
		file << "\n";
		file << "		int iPredicateAttr = _pTree->getChildCount (_pTree);\n";
		file << "		assert (iPredicateAttr > 1);\n";
		file << "\n";
		file << "		ANTLR3_BASE_TREE* pChild = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, 0);\n";
		file << "		pPredicate->s_Name = ToString (pChild);\n";
		file << "		pPredicate->l_Value = 1;\n";
		file << "\n";
		file << "		if (iPredicateAttr > 1)\n";
		file << "			ParsePddlParameters (_pTree, &pPredicate->dq_Parameters, 1);\n";
		file << "	}\n";
		file << "\n";
		file << "	else if (\"COMPARISON_GD\" == sType)\n";
		file << "	{\n";
		file << "		// (COMPARISON_GD > (FUNC_HEAD thing-available wood-pickaxe) 0)\n";
		file << "		pPredicate = new PddlFunctionValuePredicate;\n";
		file << "\n";
		file << "		#ifndef NDEBUG\n";
		file << "		int iFunctionAttr = _pTree->getChildCount (_pTree);\n";
		file << "		assert (iFunctionAttr > 0);\n";
		file << "		#endif\n";
		file << "\n";
		file << "		// function ...\n";
		file << "		ANTLR3_BASE_TREE* pChild = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, 0);\n";
		file << "		String sOperator = ToString (pChild);\n";
		file << "		if (1 != sOperator.length ())\n";
		file << "			abort ();\n";
		file << "		((PddlFunctionValuePredicate*)pPredicate)->c_Operator = sOperator [0];\n";
		file << "\n";
		file << "		ANTLR3_BASE_TREE* pFunction = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, 1);\n";
		file << "		int iFunctionParams = pFunction->getChildCount (pFunction);\n";
		file << "		// assert (iFunctionParams > 1);\n";
		file << "		assert (0 == strcmp (\"FUNC_HEAD\", ToString (pFunction)));\n";
		file << "\n";
		file << "		ANTLR3_BASE_TREE* pFunctionName = (ANTLR3_BASE_TREE*) pFunction->getChild (pFunction, 0);\n";
		file << "		pPredicate->s_Name = ToString (pFunctionName);\n";
		file << "		pPredicate->b_IsFunction = true;\n";
		file << "\n";
		file << "		if (iFunctionParams > 1)\n";
		file << "			ParsePddlParameters (pFunction, &pPredicate->dq_Parameters, 1);\n";
		file << "\n";
		file << "		// value ...\n";
		file << "		ANTLR3_BASE_TREE* pValue = (ANTLR3_BASE_TREE*) _pTree->getChild (_pTree, 2);\n";
		file << "		String sValue = ToString (pValue);\n";
		file << "		pPredicate->l_Value = (long)sValue;\n";
		file << "	}\n";
		file << "\n";
		file << "	return pPredicate;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlProblem* PddlInterface::ParseProblemPddl (String& _rProblem)\n";
		file << "{\n";
		file << "	size_t iLength = _rProblem.length ();\n";
		file << "	ANTLR3_UINT8* pText = ANTLR3_STRDUP (_rProblem);\n";
		file << "\n";
		file << "	ANTLR3_INPUT_STREAM* paisDomain;\n";
		file << "	paisDomain = antlr3NewAsciiStringInPlaceStream (pText, iLength, NULL);\n";
		file << "	PddlLexer* pLexer = PddlLexerNew (paisDomain);\n";
		file << "\n";
		file << "	ANTLR3_COMMON_TOKEN_STREAM* pTokenStream;\n";
		file << "	pTokenStream = antlr3CommonTokenStreamSourceNew (ANTLR3_SIZE_HINT, TOKENSOURCE(pLexer));\n";
		file << "\n";
		file << "	PddlParser* pParser = PddlParserNew (pTokenStream);\n";
		file << "	PddlParser_getProblem_return oAST = pParser->getProblem (pParser);\n";
		file << "\n";
		file << "	PddlProblem* pProblem = new PddlProblem;\n";
		file << "	long iChildren = oAST.tree->getChildCount (oAST.tree);\n";
		file << "	for (long c = 0; c < iChildren; ++ c)\n";
		file << "	{\n";
		file << "		ANTLR3_BASE_TREE* pChild = (ANTLR3_BASE_TREE*) oAST.tree->getChild (oAST.tree, c);\n";
		file << "		// cout << ToTree (pChild) << endl;\n";
		file << "		String sToken (ToString (pChild));\n";
		file << "\n";
		file << "		if (\"PROBLEM_NAME\" == sToken)\n";
		file << "		{\n";
		file << "			assert (1 == pChild->getChildCount (pChild));\n";
		file << "			ANTLR3_BASE_TREE* pGrandChild\n";
		file << "				= (ANTLR3_BASE_TREE*) pChild->getChild (pChild, 0);\n";
		file << "\n";
		file << "			pProblem->o_StartState.s_Preamble << \"(problem \"\n";
		file << "											  << ToString (pGrandChild)\n";
		file << "											  << \")\\n\";\n";
		file << "		}\n";
		file << "\n";
		file << "		else if (\"PROBLEM_DOMAIN\" == sToken)\n";
		file << "		{\n";
		file << "			assert (1 == pChild->getChildCount (pChild));\n";
		file << "			ANTLR3_BASE_TREE* pGrandChild\n";
		file << "				= (ANTLR3_BASE_TREE*) pChild->getChild (pChild, 0);\n";
		file << "\n";
		file << "			pProblem->o_StartState.s_Preamble << \"(:domain \"\n";
		file << "											  << ToString (pGrandChild)\n";
		file << "											  << \")\\n\";\n";
		file << "		}\n";
		file << "\n";
		file << "		else if (\"OBJECTS\" == sToken)\n";
		file << "		{\n";
		file << "			pProblem->o_StartState.s_Preamble << \"(:objects\\n\";\n";
		file << "\n";
		file << "			long iObjects = pChild->getChildCount (pChild);\n";
		file << "			for (long o = 0; o < iObjects; ++ o)\n";
		file << "			{\n";
		file << "				ANTLR3_BASE_TREE* pObject\n";
		file << "					= (ANTLR3_BASE_TREE*) pChild->getChild (pChild, o);\n";
		file << "				assert (1 == pObject->getChildCount (pObject));\n";
		file << "				ANTLR3_BASE_TREE* pObjectType\n";
		file << "					= (ANTLR3_BASE_TREE*) pObject->getChild (pObject, 0);\n";
		file << "\n";
		file << "				pProblem->o_StartState.s_Preamble << ToString (pObject)\n";
		file << "												  << \" - \"\n";
		file << "												  << ToString (pObjectType)\n";
		file << "												  << '\\n';\n";
		file << "			}\n";
		file << "\n";
		file << "			pProblem->o_StartState.s_Preamble << \")\\n\";\n";
		file << "		}\n";
		file << "\n";
		file << "		else if (\"INIT\" == sToken)\n";
		file << "		{\n";
		file << "			long iPredicates = pChild->getChildCount (pChild);\n";
		file << "			for (long t = 0; t < iPredicates; ++ t)\n";
		file << "			{\n";
		file << "				ANTLR3_BASE_TREE* pPredicateTree\n";
		file << "					= (ANTLR3_BASE_TREE*) pChild->getChild (pChild, t);\n";
		file << "				PddlPredicate* pPredicate = ParsePddlInit (pPredicateTree);\n";
		file << "				pProblem->o_StartState.dq_Predicates.push_back (pPredicate);\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		else if (\"GOAL\" == sToken)\n";
		file << "		{\n";
		file << "			assert (1 == pChild->getChildCount (pChild));\n";
		file << "			ANTLR3_BASE_TREE* pGoalTree = (ANTLR3_BASE_TREE*) pChild->getChild (pChild, 0);\n";
		file << "			String sToken (ToString (pGoalTree));\n";
		file << "			if (\"AND_GD\" != sToken)\n";
		file << "				pGoalTree = pChild;\n";
		file << "\n";
		file << "			long iPredicates = pGoalTree->getChildCount (pGoalTree);\n";
		file << "			for (long t = 0; t < iPredicates; ++ t)\n";
		file << "			{\n";
		file << "				ANTLR3_BASE_TREE* pPredicateTree\n";
		file << "					= (ANTLR3_BASE_TREE*) pChild->getChild (pGoalTree, t);\n";
		file << "				PddlPredicate* pPredicate = ParsePddlGoal (pPredicateTree);\n";
		file << "				pProblem->o_PartialGoalState.dq_Predicates.push_back (pPredicate);\n";
		file << "			}\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	pParser->free (pParser);\n";
		file << "	pLexer->free (pLexer);\n";
		file << "	pTokenStream->free (pTokenStream);\n";
		file << "	paisDomain->close (paisDomain);\n";
		file << "	ANTLR3_FREE (pText);\n";
		file << "\n";
		file << "\n";
		file << "	return pProblem;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlPlan* PddlInterface::ParsePlan (PddlDomain& _rDomain, String& _rPlan)\n";
		file << "{\n";
		file << "    PddlPlan* pPlan = new PddlPlan();\n";
		file << "    String_dq_t dqActionStrs;\n";
		file << "\n";
		file << "	String sPlan (_rPlan);\n";
		file << "	sPlan.LowerCase ();\n";
		file << "    sPlan.Split (dqActionStrs, '\\n');\n";
		file << "\n";
		file << "    ITERATE (String_dq_t, dqActionStrs, iter)\n";
		file << "    {\n";
		file << "        if (0 == iter->length())\n";
		file << "			continue;\n";
		file << "        String_dq_t dqTokens;\n";
		file << "        iter->Split(dqTokens, ' ');\n";
		file << "        String& sName = dqTokens[0];\n";
		file << "\n";
		file << "        if (_rDomain.hmp_NameToActions.find (sName) == _rDomain.hmp_NameToActions.end())\n";
		file << "        {\n";
		file << "            cerr << \"Could not find action \\\"\" << sName << \"\\\" in domain.\" << endl;\n";
		file << "\n";
		file << "            assert(false);\n";
		file << "        }\n";
		file << "        else\n";
		file << "        {\n";
		file << "            PddlAction* pAction = _rDomain.hmp_NameToActions[sName];\n";
		file << "            PddlAction* pBindAction = new PddlAction (*pAction);\n";
		file << "            if (dqTokens.size() != pBindAction->dq_Parameters.size() + 1)\n";
		file << "            {\n";
		file << "                cerr << \"Number of parameters doesn't match: \" << *iter;\n";
		file << "                assert(false);\n";
		file << "            }\n";
		file << "            for (size_t i = 1; i < dqTokens.size(); ++i)\n";
		file << "                pBindAction->dq_Parameters[i-1].SetValue (dqTokens[i]);\n";
		file << "\n";
		file << "            pPlan->dq_Actions.push_back(pBindAction);\n";
		file << "        }\n";
		file << "    }\n";
		file << "    return pPlan;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "/*\n";
		file << "PddlState* PddlInterface::ComputeEndState (PddlDomain& _rDomain,\n";
		file << "                                            PddlProblem& _rProblem,\n";
		file << "                                            PddlPlan& _rPlan)\n";
		file << "{\n";
		file << "    PddlState* pState = &_rProblem.o_StartState;\n";
		file << "	PddlState* pDeleteState = NULL;\n";
		file << "    ITERATE (PddlAction_dq_t, _rPlan.dq_Actions, iter)\n";
		file << "    {\n";
		file << "        PddlState* pNextState = pState->ComputeNextState (**iter);\n";
		file << "        pState = pNextState;\n";
		file << "		if (NULL != pDeleteState)\n";
		file << "			delete pDeleteState;\n";
		file << "		pDeleteState = pNextState;\n";
		file << "    }\n";
		file << "\n";
		file << "	#ifndef NDEBUG\n";
		file << "	PddlState* pTest = ComputeEndStateFast (_rDomain, _rProblem, _rPlan);\n";
		file << "	assert (*pTest == *pState);\n";
		file << "	#endif\n";
		file << "\n";
		file << "    return pState;\n";
		file << "}\n";
		file << "*/\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlState* PddlInterface::ComputeEndStateFast (const PddlProblem& _rProblem,\n";
		file << "                                               const PddlPlan& _rPlan,\n";
		file << "											   PddlPredicate_dq_t& _rdqPredicates)\n";
		file << "{\n";
		file << "	PddlState* pNewState = new PddlState (_rProblem.o_StartState);\n";
		file << "    CONST_ITERATE (PddlAction_dq_t, _rPlan.dq_Actions, iter)\n";
		file << "    {\n";
		file << "		PddlAction* pAction = *iter;\n";
		file << "        pNewState->UpdateToNextState (*pAction, _rdqPredicates);\n";
		file << "    }\n";
		file << "\n";
		file << "    return pNewState;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlState* PddlInterface::ComputeApproximateFutureInit (const PddlState& _rInit,\n";
		file << "														PddlPredicate_dq_t& _rdqPredicates)\n";
		file << "{\n";
		file << "    PddlState* pNewState = new PddlState (_rInit);\n";
		file << "    HashToPddlPredicate_hmp_t hmpPredicate (2 * pNewState->dq_Predicates.size ());\n";
		file << "\n";
		file << "    ITERATE (PddlPredicate_dq_t, pNewState->dq_Predicates, ite)\n";
		file << "    {\n";
		file << "        PddlPredicate* pPredicate = *ite;\n";
		file << "        String& hash = pPredicate->BoundIdentityHash ();\n";
		file << "        hmpPredicate.insert (make_pair (hash, pPredicate));\n";
		file << "    }\n";
		file << "\n";
		file << "    ITERATE (PddlPredicate_dq_t, _rdqPredicates, ite)\n";
		file << "    {\n";
		file << "        PddlPredicate* pPredicate = *ite;\n";
		file << "        String& hash = pPredicate->BoundIdentityHash ();\n";
		file << "\n";
		file << "        HashToPddlPredicate_hmp_t::iterator itFind = hmpPredicate.find (hash);\n";
		file << "        if (hmpPredicate.end () == itFind)\n";
		file << "        {\n";
		file << "            // Not sure if creating new instance is needed.\n";
		file << "            PddlPredicate * pNewPred = new PddlPredicate (*pPredicate);\n";
		file << "            pNewPred->s_BoundIdentityHash = \"\";\n";
		file << "\n";
		file << "            hmpPredicate.insert (make_pair (hash, pNewPred));\n";
		file << "            pNewState->dq_Predicates.push_back (pNewPred);\n";
		file << "        }\n";
		file << "        else\n";
		file << "        {\n";
		file << "            PddlPredicate *pStatePred = itFind->second;\n";
		file << "            // for boolean predicate, just change the value (True / False)\n";
		file << "            if (false == pStatePred->b_IsFunction)\n";
		file << "                pStatePred->l_Value = pPredicate->l_Value;\n";
		file << "\n";
		file << "            // for function predicate (e.g. thing-available), change value\n";
		file << "			// if it is increased.\n";
		file << "            else\n";
		file << "            {\n";
		file << "                if (pPredicate->l_Value > pStatePred->l_Value)\n";
		file << "                    pStatePred->l_Value = pPredicate->l_Value;\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "    return pNewState;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("PddlInterface.h", ios_base::out);
		file << "#ifndef __PDDL_INTERFACE__\n";
		file << "#define __PDDL_INTERFACE__\n";
		file << "\n";
		file << "#include <math.h>\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <hash_map>\n";
		file << "#include \"Pddl.h\"\n";
		file << "#include <antlr3.h>\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "//\n";
		file << "class PddlInterface\n";
		file << "{\n";
		file << "	private:\n";
		file << "		static const char* ToString (ANTLR3_BASE_TREE* _pTree)\n";
		file << "		{\n";
		file << "			ANTLR3_COMMON_TREE* pSuper = (ANTLR3_COMMON_TREE*)_pTree->super;\n";
		file << "			/*\n";
		file << "			if (NULL == pSuper)\n";
		file << "				return \"super is null\";\n";
		file << "			if (NULL == pSuper->token)\n";
		file << "				return \"super->token is null\";\n";
		file << "			if ((NULL == pSuper) ||\n";
		file << "				(NULL == pSuper->token))\n";
		file << "				return \"\";\n";
		file << "				*/\n";
		file << "\n";
		file << "			if (ANTLR3_TEXT_STRING == pSuper->token->textState)\n";
		file << "			{\n";
		file << "				// cout << \"string type is ANTLR3_TEXT_STRING\" << endl;\n";
		file << "				return (const char*)pSuper->token->tokText.text;\n";
		file << "			}\n";
		file << "			else if (ANTLR3_TEXT_CHARP == pSuper->token->textState)\n";
		file << "			{\n";
		file << "				// cout << \"string type is ANTLR3_TEXT_CHARP\" << endl;\n";
		file << "				// if (NULL == pSuper->token->tokText.chars)\n";
		file << "					// return \"super->token->toktext.chars is null\";\n";
		file << "				return (const char*) pSuper->token->tokText.chars;\n";
		file << "			}\n";
		file << "			else if (ANTLR3_TOKEN_EOF == pSuper->token->type)\n";
		file << "			{\n";
		file << "				// cout << \"string type is EOF\" << endl;\n";
		file << "				return \"\";\n";
		file << "			}\n";
		file << "			else if (NULL != pSuper->token->input)\n";
		file << "			{\n";
		file << "				// cout << \"string type is INPUT\" << endl;\n";
		file << "				ANTLR3_COMMON_TOKEN* pToken = pSuper->token;\n";
		file << "				ANTLR3_STRING* pString = pToken->input->substr (pToken->input,\n";
		file << "											  pToken->getStartIndex (pToken),\n";
		file << "											  pToken->getStopIndex (pToken));\n";
		file << "				return (const char*) pString->chars;\n";
		file << "			}\n";
		file << "\n";
		file << "			return \"\";\n";
		file << "\n";
		file << "			// ANTLR3_STRING* pString = _pTree->toString (_pTree);\n";
		file << "			// return (const char*) pString->chars;\n";
		file << "		}\n";
		file << "		static const char* ToTree (ANTLR3_BASE_TREE* _pTree)\n";
		file << "		{\n";
		file << "			ANTLR3_STRING* pString = _pTree->toStringTree (_pTree);\n";
		file << "			return (const char*) pString->chars;\n";
		file << "		}\n";
		file << "\n";
		file << "		static void ParsePddlParameters (ANTLR3_BASE_TREE* _pTree,\n";
		file << "										 PddlParameter_dq_t* _pdqParams,\n";
		file << "										 int _iStartingIndex = 0);\n";
		file << "		static void ParsePddlEffects (ANTLR3_BASE_TREE* _pTree,\n";
		file << "									  PddlEffect_dq_t* _pdqEffects);\n";
		file << "		static PddlPredicate* ParsePddlPredicate (ANTLR3_BASE_TREE* _pTree,\n";
		file << "												  bool _bIsFunction);\n";
		file << "		static PddlAction* ParsePddlAction (ANTLR3_BASE_TREE* _pTree);\n";
		file << "\n";
		file << "		static PddlPredicate* ParsePddlInit (ANTLR3_BASE_TREE* _pTree);\n";
		file << "		static PddlPredicate* ParsePddlGoal (ANTLR3_BASE_TREE* _pTree);\n";
		file << "\n";
		file << "	public:\n";
		file << "		static String ConstructProblemPddl (String& _rStartState,\n";
		file << "											String& _rTargetState);\n";
		file << "\n";
		file << "		//static PddlState* ComputeEndState (PddlDomain& _rDomain,\n";
		file << "		//									PddlProblem& _rProblem,\n";
		file << "		//									PddlPlan& _rPlan);\n";
		file << "		static PddlState* ComputeEndStateFast (const PddlProblem& _rProblem,\n";
		file << "											   const PddlPlan& _rPlan,\n";
		file << "											   PddlPredicate_dq_t& _rdqPredicates);\n";
		file << "\n";
		file << "		static PddlState* ComputeApproximateFutureInit (const PddlState& _rInit,\n";
		file << "													   PddlPredicate_dq_t& _rdqPredicates);\n";
		file << "\n";
		file << "\n";
		file << "		static PddlDomain* ParseDomainPddl (String& _rDomain);\n";
		file << "		static PddlProblem* ParseProblemPddl (String& _rProblem);\n";
		file << "		static PddlPlan* ParsePlan (PddlDomain& _rDomain, String& _rPlan);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file.close ();
	}



	{
		ofstream file ("PddlLexer.c", ios_base::out);
		file << "/** \\file\n";
		file << " *  This C source file was generated by $ANTLR version 3.1.3 Mar 17, 2009 19:23:44\n";
		file << " *\n";
		file << " *     -  From the grammar source file : ../../model/subgoal_learning/Pddl.g\n";
		file << " *     -                            On : 2011-12-04 10:25:06\n";
		file << " *     -                 for the lexer : PddlLexerLexer *\n";
		file << " * Editing it, at least manually, is not wise.\n";
		file << " *\n";
		file << " * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.\n";
		file << " *\n";
		file << " *\n";
		file << "*/\n";
		file << "// [The \"BSD licence\"]\n";
		file << "// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC\n";
		file << "// http://www.temporal-wave.com\n";
		file << "// http://www.linkedin.com/in/jimidle\n";
		file << "//\n";
		file << "// All rights reserved.\n";
		file << "//\n";
		file << "// Redistribution and use in source and binary forms, with or without\n";
		file << "// modification, are permitted provided that the following conditions\n";
		file << "// are met:\n";
		file << "// 1. Redistributions of source code must retain the above copyright\n";
		file << "//    notice, this list of conditions and the following disclaimer.\n";
		file << "// 2. Redistributions in binary form must reproduce the above copyright\n";
		file << "//    notice, this list of conditions and the following disclaimer in the\n";
		file << "//    documentation and/or other materials provided with the distribution.\n";
		file << "// 3. The name of the author may not be used to endorse or promote products\n";
		file << "//    derived from this software without specific prior written permission.\n";
		file << "//\n";
		file << "// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n";
		file << "// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n";
		file << "// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n";
		file << "// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n";
		file << "// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n";
		file << "// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n";
		file << "// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n";
		file << "// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n";
		file << "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n";
		file << "// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n";
		file << "\n";
		file << "/* -----------------------------------------\n";
		file << " * Include the ANTLR3 generated header file.\n";
		file << " */\n";
		file << "\n";
		file << "#pragma GCC diagnostic ignored \"-Wunused-variable\"\n";
		file << "\n";
		file << "#include    \"PddlLexer.h\"\n";
		file << "/* ----------------------------------------- */\n";
		file << "\n";
		file << "\n";
		file << "/** String literals used by PddlLexer that we must do things like MATCHS() with.\n";
		file << " *  C will normally just lay down 8 bit characters, and you can use L\"xxx\" to\n";
		file << " *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so\n";
		file << " *  we perform this little trick of defining the literals as arrays of UINT32\n";
		file << " *  and passing in the address of these.\n";
		file << " */\n";
		file << "static ANTLR3_UCHAR	lit_1[]  = { 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_2[]  = { 0x64, 0x6F, 0x6D, 0x61, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_3[]  = { 0x3A, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_4[]  = { 0x3A, 0x74, 0x79, 0x70, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_5[]  = { 0x65, 0x69, 0x74, 0x68, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_6[]  = { 0x3A, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_7[]  = { 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_8[]  = { 0x3A, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_9[]  = { 0x3A, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_10[]  = { 0x3A, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_11[]  = { 0x3A, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_12[]  = { 0x3A, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_13[]  = { 0x3A, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_14[]  = { 0x3A, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_15[]  = { 0x61, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_16[]  = { 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_17[]  = { 0x6E, 0x6F, 0x74,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_18[]  = { 0x69, 0x6D, 0x70, 0x6C, 0x79,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_19[]  = { 0x65, 0x78, 0x69, 0x73, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_20[]  = { 0x66, 0x6F, 0x72, 0x61, 0x6C, 0x6C,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_21[]  = { 0x3A, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_22[]  = { 0x3A, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_23[]  = { 0x3A, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_24[]  = { 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_25[]  = { 0x61, 0x74,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_26[]  = { 0x6F, 0x76, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_27[]  = { 0x73, 0x74, 0x61, 0x72, 0x74,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_28[]  = { 0x65, 0x6E, 0x64,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_29[]  = { 0x61, 0x6C, 0x6C,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_30[]  = { 0x3A, 0x64, 0x65, 0x72, 0x69, 0x76, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_31[]  = { 0x77, 0x68, 0x65, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_32[]  = { 0x3E, 0x3D,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_33[]  = { 0x3C, 0x3D,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_34[]  = { 0x61, 0x73, 0x73, 0x69, 0x67, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_35[]  = { 0x73, 0x63, 0x61, 0x6C, 0x65, 0x2D, 0x75, 0x70,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_36[]  = { 0x73, 0x63, 0x61, 0x6C, 0x65, 0x2D, 0x64, 0x6F, 0x77, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_37[]  = { 0x69, 0x6E, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_38[]  = { 0x64, 0x65, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_39[]  = { 0x3F, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_40[]  = { 0x70, 0x72, 0x6F, 0x62, 0x6C, 0x65, 0x6D,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_41[]  = { 0x3A, 0x64, 0x6F, 0x6D, 0x61, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_42[]  = { 0x3A, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_43[]  = { 0x3A, 0x69, 0x6E, 0x69, 0x74,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_44[]  = { 0x3A, 0x67, 0x6F, 0x61, 0x6C,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_45[]  = { 0x3A, 0x6D, 0x65, 0x74, 0x72, 0x69, 0x63,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_46[]  = { 0x6D, 0x69, 0x6E, 0x69, 0x6D, 0x69, 0x7A, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_47[]  = { 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x69, 0x7A, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_48[]  = { 0x74, 0x6F, 0x74, 0x61, 0x6C, 0x2D, 0x74, 0x69, 0x6D, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_49[]  = { 0x69, 0x73, 0x2D, 0x76, 0x69, 0x6F, 0x6C, 0x61, 0x74, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_50[]  = { 0x61, 0x6C, 0x77, 0x61, 0x79, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_51[]  = { 0x73, 0x6F, 0x6D, 0x65, 0x74, 0x69, 0x6D, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_52[]  = { 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_53[]  = { 0x61, 0x74, 0x2D, 0x6D, 0x6F, 0x73, 0x74, 0x2D, 0x6F, 0x6E, 0x63, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_54[]  = { 0x73, 0x6F, 0x6D, 0x65, 0x74, 0x69, 0x6D, 0x65, 0x2D, 0x61, 0x66, 0x74, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_55[]  = { 0x73, 0x6F, 0x6D, 0x65, 0x74, 0x69, 0x6D, 0x65, 0x2D, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_56[]  = { 0x61, 0x6C, 0x77, 0x61, 0x79, 0x73, 0x2D, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6E,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_57[]  = { 0x68, 0x6F, 0x6C, 0x64, 0x2D, 0x64, 0x75, 0x72, 0x69, 0x6E, 0x67,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_58[]  = { 0x68, 0x6F, 0x6C, 0x64, 0x2D, 0x61, 0x66, 0x74, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_59[]  = { 0x3A, 0x73, 0x74, 0x72, 0x69, 0x70, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_60[]  = { 0x3A, 0x74, 0x79, 0x70, 0x69, 0x6E, 0x67,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_61[]  = { 0x3A, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_62[]  = { 0x3A, 0x64, 0x69, 0x73, 0x6A, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_63[]  = { 0x3A, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x69, 0x74, 0x79,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_64[]  = { 0x3A, 0x65, 0x78, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x69, 0x61, 0x6C, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_65[]  = { 0x3A, 0x75, 0x6E, 0x69, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_66[]  = { 0x3A, 0x71, 0x75, 0x61, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2D, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_67[]  = { 0x3A, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x2D, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_68[]  = { 0x3A, 0x66, 0x6C, 0x75, 0x65, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_69[]  = { 0x3A, 0x61, 0x64, 0x6C,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_70[]  = { 0x3A, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2D, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_71[]  = { 0x3A, 0x64, 0x65, 0x72, 0x69, 0x76, 0x65, 0x64, 0x2D, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_72[]  = { 0x3A, 0x74, 0x69, 0x6D, 0x65, 0x64, 0x2D, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x2D, 0x6C, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6C, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "static ANTLR3_UCHAR	lit_73[]  = { 0x3A, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x73,  ANTLR3_STRING_TERMINATOR};\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "/* MACROS that hide the C interface implementations from the\n";
		file << " * generated code, which makes it a little more understandable to the human eye.\n";
		file << " * I am very much against using C pre-processor macros for function calls and bits\n";
		file << " * of code as you cannot see what is happening when single stepping in debuggers\n";
		file << " * and so on. The exception (in my book at least) is for generated code, where you are\n";
		file << " * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()\n";
		file << " * hides some indirect calls, but is always referring to the input stream. This is\n";
		file << " * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig\n";
		file << " * the runtime interfaces without changing the generated code too often, without\n";
		file << " * confusing the reader of the generated output, who may not wish to know the gory\n";
		file << " * details of the interface inheritance.\n";
		file << " */\n";
		file << "\n";
		file << "#define		CTX	ctx\n";
		file << "\n";
		file << "/* Aids in accessing scopes for grammar programmers\n";
		file << " */\n";
		file << "#undef	SCOPE_TYPE\n";
		file << "#undef	SCOPE_STACK\n";
		file << "#undef	SCOPE_TOP\n";
		file << "#define	SCOPE_TYPE(scope)   pPddlLexer_##scope##_SCOPE\n";
		file << "#define SCOPE_STACK(scope)  pPddlLexer_##scope##Stack\n";
		file << "#define	SCOPE_TOP(scope)    ctx->pPddlLexer_##scope##Top\n";
		file << "#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))\n";
		file << "#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))\n";
		file << "\n";
		file << "\n";
		file << "/* Macros for accessing things in a lexer\n";
		file << " */\n";
		file << "#undef	    LEXER\n";
		file << "#undef	    RECOGNIZER\n";
		file << "#undef	    RULEMEMO\n";
		file << "#undef	    GETCHARINDEX\n";
		file << "#undef	    GETLINE\n";
		file << "#undef	    GETCHARPOSITIONINLINE\n";
		file << "#undef	    EMIT\n";
		file << "#undef	    EMITNEW\n";
		file << "#undef	    MATCHC\n";
		file << "#undef	    MATCHS\n";
		file << "#undef	    MATCHRANGE\n";
		file << "#undef	    LTOKEN\n";
		file << "#undef	    HASFAILED\n";
		file << "#undef	    FAILEDFLAG\n";
		file << "#undef	    INPUT\n";
		file << "#undef	    STRSTREAM\n";
		file << "#undef	    LA\n";
		file << "#undef	    HASEXCEPTION\n";
		file << "#undef	    EXCEPTION\n";
		file << "#undef	    CONSTRUCTEX\n";
		file << "#undef	    CONSUME\n";
		file << "#undef	    LRECOVER\n";
		file << "#undef	    MARK\n";
		file << "#undef	    REWIND\n";
		file << "#undef	    REWINDLAST\n";
		file << "#undef	    BACKTRACKING\n";
		file << "#undef		MATCHANY\n";
		file << "#undef		MEMOIZE\n";
		file << "#undef		HAVEPARSEDRULE\n";
		file << "#undef		GETTEXT\n";
		file << "#undef		INDEX\n";
		file << "#undef		SEEK\n";
		file << "#undef		PUSHSTREAM\n";
		file << "#undef		POPSTREAM\n";
		file << "#undef		SETTEXT\n";
		file << "#undef		SETTEXT8\n";
		file << "\n";
		file << "#define	    LEXER					ctx->pLexer\n";
		file << "#define	    RECOGNIZER			    LEXER->rec\n";
		file << "#define		LEXSTATE				RECOGNIZER->state\n";
		file << "#define		TOKSOURCE				LEXSTATE->tokSource\n";
		file << "#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)\n";
		file << "#define	    GETLINE()				LEXER->getLine(LEXER)\n";
		file << "#define	    GETTEXT()				LEXER->getText(LEXER)\n";
		file << "#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)\n";
		file << "#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)\n";
		file << "#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)\n";
		file << "#define	    MATCHC(c)				LEXER->matchc(LEXER, c)\n";
		file << "#define	    MATCHS(s)				LEXER->matchs(LEXER, s)\n";
		file << "#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)\n";
		file << "#define	    MATCHANY()				LEXER->matchAny(LEXER)\n";
		file << "#define	    LTOKEN  				LEXSTATE->token\n";
		file << "#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)\n";
		file << "#define	    BACKTRACKING			LEXSTATE->backtracking\n";
		file << "#define	    FAILEDFLAG				LEXSTATE->failed\n";
		file << "#define	    INPUT					LEXER->input\n";
		file << "#define	    STRSTREAM				INPUT\n";
		file << "#define		ISTREAM					INPUT->istream\n";
		file << "#define		INDEX()					ISTREAM->index(ISTREAM)\n";
		file << "#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)\n";
		file << "#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)\n";
		file << "#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)\n";
		file << "#define	    EXCEPTION				LEXSTATE->exception\n";
		file << "#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)\n";
		file << "#define	    LRECOVER()				LEXER->recover(LEXER)\n";
		file << "#define	    MARK()					ISTREAM->mark(ISTREAM)\n";
		file << "#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)\n";
		file << "#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)\n";
		file << "#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)\n";
		file << "#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)\n";
		file << "#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)\n";
		file << "#define		POPSTREAM()				LEXER->popCharStream(LEXER)\n";
		file << "#define		SETTEXT(str)			LEXSTATE->text = str\n";
		file << "#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)\n";
		file << "#define		USER1					LEXSTATE->user1\n";
		file << "#define		USER2					LEXSTATE->user2\n";
		file << "#define		USER3					LEXSTATE->user3\n";
		file << "#define		CUSTOM					LEXSTATE->custom\n";
		file << "#define		RULEMEMO				LEXSTATE->ruleMemo\n";
		file << "#define		DBG						RECOGNIZER->debugger\n";
		file << "\n";
		file << "/* If we have been told we can rely on the standard 8 bit or 16 bit input\n";
		file << " * stream, then we can define our macros to use the direct pointers\n";
		file << " * in the input object, which is much faster than indirect calls. This\n";
		file << " * is really only significant to lexers with a lot of fragment rules (which\n";
		file << " * do not place LA(1) in a temporary at the moment) and even then\n";
		file << " * only if there is a lot of input (order of say 1M or so).\n";
		file << " */\n";
		file << "#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)\n";
		file << "\n";
		file << "# ifdef	ANTLR3_INLINE_INPUT_ASCII\n";
		file << "\n";
		file << "/* 8 bit \"ASCII\" (actually any 8 bit character set) */\n";
		file << "\n";
		file << "#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))\n";
		file << "#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))\n";
		file << "\n";
		file << "# else\n";
		file << "\n";
		file << "#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar))\n";
		file << "#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))\n";
		file << "\n";
		file << "# endif\n";
		file << "\n";
		file << "# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))\n";
		file << "# define	    CONSUME()											\\\n";
		file << "{																	\\\n";
		file << "    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))						\\\n";
		file << "    {																\\\n";
		file << "		INPUT->charPositionInLine++;								\\\n";
		file << "		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\\\n";
		file << "		{															\\\n";
		file << "			INPUT->line++;											\\\n";
		file << "			INPUT->charPositionInLine	= 0;						\\\n";
		file << "			INPUT->currentLine		= (void *)(NEXTCHAR + 1);		\\\n";
		file << "		}															\\\n";
		file << "		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\\\n";
		file << "    }																\\\n";
		file << "}\n";
		file << "\n";
		file << "#else\n";
		file << "\n";
		file << "// Pick up the input character by calling the input stream implementation.\n";
		file << "//\n";
		file << "#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)\n";
		file << "#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)\n";
		file << "\n";
		file << "#endif\n";
		file << "#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt\n";
		file << "\n";
		file << "/* The 4 tokens defined below may well clash with your own #defines or token types. If so\n";
		file << " * then for the present you must use different names for your defines as these are hard coded\n";
		file << " * in the code generator. It would be better not to use such names internally, and maybe\n";
		file << " * we can change this in a forthcoming release. I deliberately do not #undef these\n";
		file << " * here as this will at least give you a redefined error somewhere if they clash.\n";
		file << " */\n";
		file << "#define	    UP	    ANTLR3_TOKEN_UP\n";
		file << "#define	    DOWN    ANTLR3_TOKEN_DOWN\n";
		file << "#define	    EOR	    ANTLR3_TOKEN_EOR\n";
		file << "#define	    INVALID ANTLR3_TOKEN_INVALID\n";
		file << "\n";
		file << "\n";
		file << "/* =============================================================================\n";
		file << " * Functions to create and destroy scopes. First come the rule scopes, followed\n";
		file << " * by the global declared scopes.\n";
		file << " */\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "/* ============================================================================= */\n";
		file << "\n";
		file << "/* =============================================================================\n";
		file << " * Start of recognizer\n";
		file << " */\n";
		file << "\n";
		file << "\n";
		file << "/* Forward declare the locally static matching functions we have generated and any predicate functions.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE  void	mT__54    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__55    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__56    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__57    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__58    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__59    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__60    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__61    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__62    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__63    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__64    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__65    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__66    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__67    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__68    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__69    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__70    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__71    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__72    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__73    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__74    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__75    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__76    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__77    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__78    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__79    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__80    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__81    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__82    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__83    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__84    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__85    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__86    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__87    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__88    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__89    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__90    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__91    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__92    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__93    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__94    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__95    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__96    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__97    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__98    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__99    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__100    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__101    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__102    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__103    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__104    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__105    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__106    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__107    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__108    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__109    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__110    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__111    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__112    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__113    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__114    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__115    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__116    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__117    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__118    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__119    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mT__120    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mREQUIRE_KEY    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mNAME    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mLETTER    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mANY_CHAR    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mVARIABLE    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mNUMBER    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mDIGIT    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mLINE_COMMENT    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mWHITESPACE    (pPddlLexer ctx);\n";
		file << "static ANTLR3_INLINE  void	mTokens    (pPddlLexer ctx);\n";
		file << "static void	PddlLexerFree(pPddlLexer ctx);\n";
		file << "\n";
		file << "/* =========================================================================\n";
		file << " * Lexer matching rules end.\n";
		file << " * =========================================================================\n";
		file << " */\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "static void\n";
		file << "PddlLexerFree  (pPddlLexer ctx)\n";
		file << "{\n";
		file << "    LEXER->free(LEXER);\n";
		file << "\n";
		file << "    ANTLR3_FREE(ctx);\n";
		file << "}\n";
		file << "\n";
		file << "/** \\brief Name of the grammar file that generated this code\n";
		file << " */\n";
		file << "static const char fileName[] = \"Pddl.g\";\n";
		file << "\n";
		file << "/** \\brief Return the name of the grammar file that generated this code.\n";
		file << " */\n";
		file << "static const char * getGrammarFileName()\n";
		file << "{\n";
		file << "	return fileName;\n";
		file << "}\n";
		file << "\n";
		file << "/** \\brief Create a new lexer called PddlLexer\n";
		file << " *\n";
		file << " * \\param[in]    instream Pointer to an initialized input stream\n";
		file << " * \\return\n";
		file << " *     - Success pPddlLexer initialized for the lex start\n";
		file << " *     - Fail NULL\n";
		file << " */\n";
		file << "ANTLR3_API pPddlLexer PddlLexerNew\n";
		file << "(pANTLR3_INPUT_STREAM instream)\n";
		file << "{\n";
		file << "	// See if we can create a new lexer with the standard constructor\n";
		file << "	//\n";
		file << "	return PddlLexerNewSSD(instream, NULL);\n";
		file << "}\n";
		file << "\n";
		file << "/** \\brief Create a new lexer called PddlLexer\n";
		file << " *\n";
		file << " * \\param[in]    instream Pointer to an initialized input stream\n";
		file << " * \\param[state] state Previously created shared recognizer stat\n";
		file << " * \\return\n";
		file << " *     - Success pPddlLexer initialized for the lex start\n";
		file << " *     - Fail NULL\n";
		file << " */\n";
		file << "ANTLR3_API pPddlLexer PddlLexerNewSSD\n";
		file << "(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)\n";
		file << "{\n";
		file << "    pPddlLexer ctx; // Context structure we will build and return\n";
		file << "\n";
		file << "    ctx = (pPddlLexer) ANTLR3_CALLOC(1, sizeof(PddlLexer));\n";
		file << "\n";
		file << "    if  (ctx == NULL)\n";
		file << "    {\n";
		file << "        // Failed to allocate memory for lexer context\n";
		file << "        return  NULL;\n";
		file << "    }\n";
		file << "\n";
		file << "    /* -------------------------------------------------------------------\n";
		file << "     * Memory for basic structure is allocated, now to fill in\n";
		file << "     * in base ANTLR3 structures. We initialize the function pointers\n";
		file << "     * for the standard ANTLR3 lexer function set, but upon return\n";
		file << "     * from here, the programmer may set the pointers to provide custom\n";
		file << "     * implementations of each function.\n";
		file << "     *\n";
		file << "     * We don't use the macros defined in PddlLexer.h here so you can get a sense\n";
		file << "     * of what goes where.\n";
		file << "     */\n";
		file << "\n";
		file << "    /* Create a base lexer, using the supplied input stream\n";
		file << "     */\n";
		file << "    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);\n";
		file << "\n";
		file << "    /* Check that we allocated the memory correctly\n";
		file << "     */\n";
		file << "    if	(ctx->pLexer == NULL)\n";
		file << "    {\n";
		file << "		ANTLR3_FREE(ctx);\n";
		file << "		return  NULL;\n";
		file << "    }\n";
		file << "    /* Install the implementation of our PddlLexer interface\n";
		file << "     */\n";
		file << "    ctx->mT__54	= mT__54;\n";
		file << "    ctx->mT__55	= mT__55;\n";
		file << "    ctx->mT__56	= mT__56;\n";
		file << "    ctx->mT__57	= mT__57;\n";
		file << "    ctx->mT__58	= mT__58;\n";
		file << "    ctx->mT__59	= mT__59;\n";
		file << "    ctx->mT__60	= mT__60;\n";
		file << "    ctx->mT__61	= mT__61;\n";
		file << "    ctx->mT__62	= mT__62;\n";
		file << "    ctx->mT__63	= mT__63;\n";
		file << "    ctx->mT__64	= mT__64;\n";
		file << "    ctx->mT__65	= mT__65;\n";
		file << "    ctx->mT__66	= mT__66;\n";
		file << "    ctx->mT__67	= mT__67;\n";
		file << "    ctx->mT__68	= mT__68;\n";
		file << "    ctx->mT__69	= mT__69;\n";
		file << "    ctx->mT__70	= mT__70;\n";
		file << "    ctx->mT__71	= mT__71;\n";
		file << "    ctx->mT__72	= mT__72;\n";
		file << "    ctx->mT__73	= mT__73;\n";
		file << "    ctx->mT__74	= mT__74;\n";
		file << "    ctx->mT__75	= mT__75;\n";
		file << "    ctx->mT__76	= mT__76;\n";
		file << "    ctx->mT__77	= mT__77;\n";
		file << "    ctx->mT__78	= mT__78;\n";
		file << "    ctx->mT__79	= mT__79;\n";
		file << "    ctx->mT__80	= mT__80;\n";
		file << "    ctx->mT__81	= mT__81;\n";
		file << "    ctx->mT__82	= mT__82;\n";
		file << "    ctx->mT__83	= mT__83;\n";
		file << "    ctx->mT__84	= mT__84;\n";
		file << "    ctx->mT__85	= mT__85;\n";
		file << "    ctx->mT__86	= mT__86;\n";
		file << "    ctx->mT__87	= mT__87;\n";
		file << "    ctx->mT__88	= mT__88;\n";
		file << "    ctx->mT__89	= mT__89;\n";
		file << "    ctx->mT__90	= mT__90;\n";
		file << "    ctx->mT__91	= mT__91;\n";
		file << "    ctx->mT__92	= mT__92;\n";
		file << "    ctx->mT__93	= mT__93;\n";
		file << "    ctx->mT__94	= mT__94;\n";
		file << "    ctx->mT__95	= mT__95;\n";
		file << "    ctx->mT__96	= mT__96;\n";
		file << "    ctx->mT__97	= mT__97;\n";
		file << "    ctx->mT__98	= mT__98;\n";
		file << "    ctx->mT__99	= mT__99;\n";
		file << "    ctx->mT__100	= mT__100;\n";
		file << "    ctx->mT__101	= mT__101;\n";
		file << "    ctx->mT__102	= mT__102;\n";
		file << "    ctx->mT__103	= mT__103;\n";
		file << "    ctx->mT__104	= mT__104;\n";
		file << "    ctx->mT__105	= mT__105;\n";
		file << "    ctx->mT__106	= mT__106;\n";
		file << "    ctx->mT__107	= mT__107;\n";
		file << "    ctx->mT__108	= mT__108;\n";
		file << "    ctx->mT__109	= mT__109;\n";
		file << "    ctx->mT__110	= mT__110;\n";
		file << "    ctx->mT__111	= mT__111;\n";
		file << "    ctx->mT__112	= mT__112;\n";
		file << "    ctx->mT__113	= mT__113;\n";
		file << "    ctx->mT__114	= mT__114;\n";
		file << "    ctx->mT__115	= mT__115;\n";
		file << "    ctx->mT__116	= mT__116;\n";
		file << "    ctx->mT__117	= mT__117;\n";
		file << "    ctx->mT__118	= mT__118;\n";
		file << "    ctx->mT__119	= mT__119;\n";
		file << "    ctx->mT__120	= mT__120;\n";
		file << "    ctx->mREQUIRE_KEY	= mREQUIRE_KEY;\n";
		file << "    ctx->mNAME	= mNAME;\n";
		file << "    ctx->mLETTER	= mLETTER;\n";
		file << "    ctx->mANY_CHAR	= mANY_CHAR;\n";
		file << "    ctx->mVARIABLE	= mVARIABLE;\n";
		file << "    ctx->mNUMBER	= mNUMBER;\n";
		file << "    ctx->mDIGIT	= mDIGIT;\n";
		file << "    ctx->mLINE_COMMENT	= mLINE_COMMENT;\n";
		file << "    ctx->mWHITESPACE	= mWHITESPACE;\n";
		file << "    ctx->mTokens	= mTokens;\n";
		file << "\n";
		file << "    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE\n";
		file << "     *  it will call mTokens() in this generated code, and will pass it the ctx\n";
		file << "     * pointer of this lexer, not the context of the base lexer, so store that now.\n";
		file << "     */\n";
		file << "    ctx->pLexer->ctx	    = ctx;\n";
		file << "\n";
		file << "    /**Install the token matching function\n";
		file << "     */\n";
		file << "    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);\n";
		file << "\n";
		file << "    ctx->getGrammarFileName	= getGrammarFileName;\n";
		file << "    ctx->free		= PddlLexerFree;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    /* Return the newly built lexer to the caller\n";
		file << "     */\n";
		file << "    return  ctx;\n";
		file << "}\n";
		file << "\n";
		file << "/* =========================================================================\n";
		file << " * DFA tables for the lexer\n";
		file << " */\n";
		file << "/** Static dfa state tables for Cyclic dfa:\n";
		file << " *    506:1: REQUIRE_KEY : ( ':strips' | ':typing' | ':negative-preconditions' | ':disjunctive-preconditions' | ':equality' | ':existential-preconditions' | ':universal-preconditions' | ':quantified-preconditions' | ':conditional-effects' | ':fluents' | ':adl' | ':durative-actions' | ':derived-predicates' | ':timed-initial-literals' | ':preferences' | ':constraints' );\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 dfa1_eot[24] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa1_eof[24] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa1_min[24] =\n";
		file << "    {\n";
		file << "	58, 97, -1, 105, -1, 101, 113, -1, -1, 111, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, 110, 100, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa1_max[24] =\n";
		file << "    {\n";
		file << "	58, 117, -1, 121, -1, 117, 120, -1, -1, 111, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, 110, 115, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa1_accept[24] =\n";
		file << "    {\n";
		file << "	-1, -1, 1, -1, 3, -1, -1, 7, 8, -1, 10, 11, 15, 2, 14, 4, 12, 13, 5, 6,\n";
		file << "	-1, -1, 9, 16\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa1_special[24] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "\n";
		file << "/** Used when there is no transition table entry for a particular state */\n";
		file << "#define dfa1_T_empty	    NULL\n";
		file << "\n";
		file << "static const ANTLR3_INT32 dfa1_T0[] =\n";
		file << "    {\n";
		file << "	1\n";
		file << "    };static const ANTLR3_INT32 dfa1_T1[] =\n";
		file << "    {\n";
		file << "	22, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 23\n";
		file << "    };static const ANTLR3_INT32 dfa1_T2[] =\n";
		file << "    {\n";
		file << "	21\n";
		file << "    };static const ANTLR3_INT32 dfa1_T3[] =\n";
		file << "    {\n";
		file << "	18, -1, -1, -1, -1, -1, -1, 19\n";
		file << "    };static const ANTLR3_INT32 dfa1_T4[] =\n";
		file << "    {\n";
		file << "	20\n";
		file << "    };static const ANTLR3_INT32 dfa1_T5[] =\n";
		file << "    {\n";
		file << "	17, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16\n";
		file << "    };static const ANTLR3_INT32 dfa1_T6[] =\n";
		file << "    {\n";
		file << "	14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 13\n";
		file << "    };static const ANTLR3_INT32 dfa1_T7[] =\n";
		file << "    {\n";
		file << "	11, -1, 9, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, 4, -1, 12, 8, -1, 2, 3,\n";
		file << "	7\n";
		file << "    };\n";
		file << "\n";
		file << "/* Transition tables are a table of sub tables, with some tables\n";
		file << " * reused for efficiency.\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 * const dfa1_transitions[] =\n";
		file << "{\n";
		file << "    dfa1_T0, dfa1_T7, dfa1_T_empty, dfa1_T6, dfa1_T_empty, dfa1_T5, dfa1_T3,\n";
		file << "    dfa1_T_empty, dfa1_T_empty, dfa1_T4, dfa1_T_empty, dfa1_T_empty, dfa1_T_empty,\n";
		file << "    dfa1_T_empty, dfa1_T_empty, dfa1_T_empty, dfa1_T_empty, dfa1_T_empty,\n";
		file << "    dfa1_T_empty, dfa1_T_empty, dfa1_T2, dfa1_T1, dfa1_T_empty, dfa1_T_empty\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "/* Declare tracking structure for Cyclic DFA 1\n";
		file << " */\n";
		file << "static\n";
		file << "ANTLR3_CYCLIC_DFA cdfa1\n";
		file << "    =	{\n";
		file << "	    1,		    /* Decision number of this dfa	    */\n";
		file << "	    /* Which decision this represents:   */\n";
		file << "	    (const pANTLR3_UCHAR)\"506:1: REQUIRE_KEY : ( ':strips' | ':typing' | ':negative-preconditions' | ':disjunctive-preconditions' | ':equality' | ':existential-preconditions' | ':universal-preconditions' | ':quantified-preconditions' | ':conditional-effects' | ':fluents' | ':adl' | ':durative-actions' | ':derived-predicates' | ':timed-initial-literals' | ':preferences' | ':constraints' );\",\n";
		file << "	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/\n";
		file << "	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */\n";
		file << "	    antlr3dfapredict,			/* DFA simulator function is in the runtime */\n";
		file << "	    dfa1_eot,	    /* EOT table			    */\n";
		file << "	    dfa1_eof,	    /* EOF table			    */\n";
		file << "	    dfa1_min,	    /* Minimum tokens for each state    */\n";
		file << "	    dfa1_max,	    /* Maximum tokens for each state    */\n";
		file << "	    dfa1_accept,	/* Accept table			    */\n";
		file << "	    dfa1_special,	/* Special transition states	    */\n";
		file << "	    dfa1_transitions	/* Table of transition tables	    */\n";
		file << "\n";
		file << "	};\n";
		file << "/* End of Cyclic DFA 1\n";
		file << " * ---------------------\n";
		file << " *//** Static dfa state tables for Cyclic dfa:\n";
		file << " *    1:1: Tokens : ( T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | T__94 | T__95 | T__96 | T__97 | T__98 | T__99 | T__100 | T__101 | T__102 | T__103 | T__104 | T__105 | T__106 | T__107 | T__108 | T__109 | T__110 | T__111 | T__112 | T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | REQUIRE_KEY | NAME | VARIABLE | NUMBER | LINE_COMMENT | WHITESPACE );\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 dfa10_eot[336] =\n";
		file << "    {\n";
		file << "	-1, -1, 25, -1, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1,\n";
		file << "	66, 68, -1, -1, 25, 25, 25, -1, -1, -1, -1, 25, 25, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, 25, 25, 25, 25, 25, 25, 95, 25, 25, 99,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 70, -1, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, 25,\n";
		file << "	127, 25, 129, 130, 25, -1, 132, 25, 25, -1, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 70, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1,\n";
		file << "	25, 25, -1, 25, -1, -1, 25, -1, 25, 25, 168, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 178, 25, 70, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, 25, 25, 25, 25, 25, 25, -1, 198, 25, 25, 25, 25, 25, 204, 25, 25, -1,\n";
		file << "	25, 70, 25, 25, 25, 25, 214, 25, 216, -1, -1, -1, -1, 222, 223, 224, 25,\n";
		file << "	227, 228, -1, 25, 25, 231, 25, 25, -1, 25, 25, 237, 70, 25, 25, 25, 25,\n";
		file << "	25, -1, 25, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, 25, -1, -1, 25, 25,\n";
		file << "	-1, 25, 255, 25, 25, 25, -1, 70, 25, 25, 25, 25, 25, 265, -1, -1, -1, -1,\n";
		file << "	269, 25, 25, 272, 25, 25, -1, 275, 25, 278, 70, 280, 281, 25, 25, 25, -1,\n";
		file << "	-1, -1, -1, -1, 25, 25, -1, 25, 25, -1, 25, 25, -1, 295, -1, -1, 25, 25,\n";
		file << "	25, -1, 300, -1, 25, 25, 25, 305, 306, 25, 25, -1, 309, 25, 311, -1, -1,\n";
		file << "	-1, 25, 25, 316, -1, -1, 25, 25, -1, 319, -1, -1, -1, 322, 25, -1, 25,\n";
		file << "	25, -1, -1, -1, -1, 327, 25, 25, -1, -1, 331, 25, -1, -1, 334, 335, -1,\n";
		file << "	-1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa10_eof[336] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa10_min[336] =\n";
		file << "    {\n";
		file << "	9, -1, 101, -1, 97, -1, 105, 111, 108, 114, 109, 111, 114, 99, 104, -1,\n";
		file << "	-1, -1, 61, 61, -1, 65, 97, 111, 111, -1, -1, -1, -1, 99, 109, -1, 105,\n";
		file << "	108, 111, 97, 99, 102, 101, -1, -1, -1, -1, -1, 116, 105, 100, 109, 116,\n";
		file << "	100, 45, 108, 115, 45, 101, 112, 99, 45, 114, 101, 97, 97, 109, 101, 116,\n";
		file << "	-1, -1, -1, -1, 117, -1, 110, 120, 116, 108, 105, 114, 97, 112, -1, 110,\n";
		file << "	101, -1, -1, -1, 114, 114, -1, 104, 115, 45, 98, 45, 45, 109, -1, 45, 97,\n";
		file << "	105, -1, 114, 108, 114, 118, 97, 102, 98, 114, 108, 101, 110, 104, 114,\n";
		file << "	105, 105, 97, 100, 110, 101, 105, 101, 100, 99, 97, 105, 101, 116, -1,\n";
		file << "	101, -1, -1, 111, -1, 121, 103, 45, 121, 101, 105, 108, 101, 108, 116,\n";
		file << "	101, 116, 45, 105, 97, 109, 109, 108, 45, 101, 97, 110, -1, 116, 105, -1,\n";
		file << "	-1, 116, 118, 114, 115, 114, 115, 115, 110, -1, 45, 97, 111, 108, 114,\n";
		file << "	101, 45, 45, 105, -1, 110, 116, 105, 105, 45, 97, 45, 115, 45, 97, 116,\n";
		file << "	105, 101, 45, 45, 45, 116, 45, 45, -1, 115, 108, 45, 101, 109, -1, 100,\n";
		file << "	109, 45, 105, 122, 122, 116, 117, 102, -1, 101, -1, -1, 97, 105, 111, 100,\n";
		file << "	-1, -1, -1, 45, 119, -1, -1, 101, 97, -1, 110, 45, 112, 111, 101, -1, 111,\n";
		file << "	101, 101, 105, 114, 116, 45, 105, 111, 101, -1, 45, 111, 105, 45, 116,\n";
		file << "	99, -1, 45, 119, 45, 110, 45, 45, 109, 105, 101, -1, 110, 110, 45, -1,\n";
		file << "	110, 116, -1, 101, 101, -1, 110, 97, -1, 45, -1, -1, 101, 110, 114, 116,\n";
		file << "	97, 97, 99, 104, 100, 45, 45, 102, 101, -1, 45, 103, 45, 115, -1, 99, 101,\n";
		file << "	105, 45, -1, -1, 116, 102, -1, 45, -1, -1, 116, 45, 110, -1, 101, 111,\n";
		file << "	-1, -1, 105, -1, 45, 114, 114, 111, -1, 45, 101, 110, -1, 45, 115, -1,\n";
		file << "	-1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa10_max[336] =\n";
		file << "    {\n";
		file << "	122, -1, 111, -1, 117, -1, 120, 117, 116, 118, 115, 111, 114, 116, 105,\n";
		file << "	-1, -1, -1, 61, 61, -1, 122, 105, 111, 111, -1, -1, -1, -1, 102, 109, -1,\n";
		file << "	121, 117, 111, 114, 100, 120, 117, -1, -1, -1, -1, -1, 116, 105, 100, 109,\n";
		file << "	116, 100, 122, 119, 115, 122, 101, 112, 99, 45, 114, 111, 97, 97, 109,\n";
		file << "	101, 116, -1, -1, -1, -1, 117, -1, 110, 120, 116, 108, 105, 114, 97, 112,\n";
		file << "	-1, 110, 101, -1, -1, -1, 114, 114, -1, 104, 115, 122, 98, 122, 122, 109,\n";
		file << "	-1, 122, 97, 105, -1, 114, 108, 114, 118, 97, 102, 98, 114, 108, 101, 110,\n";
		file << "	104, 114, 105, 105, 97, 100, 110, 101, 105, 105, 115, 102, 97, 105, 101,\n";
		file << "	116, -1, 101, -1, -1, 111, -1, 121, 103, 122, 121, 101, 105, 108, 101,\n";
		file << "	108, 116, 101, 116, 122, 105, 97, 109, 109, 108, 45, 101, 97, 110, -1,\n";
		file << "	116, 105, -1, -1, 116, 118, 114, 115, 114, 115, 115, 110, -1, 122, 97,\n";
		file << "	111, 108, 114, 101, 122, 45, 105, -1, 110, 116, 105, 105, 45, 100, 122,\n";
		file << "	115, 122, 114, 116, 105, 101, 122, 122, 122, 116, 122, 122, -1, 115, 108,\n";
		file << "	122, 101, 109, -1, 117, 109, 122, 105, 122, 122, 116, 117, 102, -1, 101,\n";
		file << "	-1, -1, 97, 105, 118, 100, -1, -1, -1, 45, 119, -1, -1, 101, 97, -1, 110,\n";
		file << "	122, 112, 111, 101, -1, 111, 101, 101, 105, 114, 116, 122, 105, 111, 101,\n";
		file << "	-1, 45, 111, 105, 122, 116, 99, -1, 122, 119, 122, 110, 122, 122, 109,\n";
		file << "	105, 101, -1, 110, 110, 45, -1, 110, 116, -1, 101, 101, -1, 110, 98, -1,\n";
		file << "	122, -1, -1, 101, 110, 114, 116, 97, 97, 99, 104, 100, 122, 122, 102, 101,\n";
		file << "	-1, 122, 103, 122, 115, -1, 99, 101, 105, 122, -1, -1, 116, 102, -1, 122,\n";
		file << "	-1, -1, 116, 122, 110, -1, 101, 111, -1, -1, 105, -1, 122, 114, 114, 111,\n";
		file << "	-1, 122, 101, 110, -1, 122, 115, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa10_accept[336] =\n";
		file << "    {\n";
		file << "	-1, 1, -1, 3, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 35, 36, 37, -1,\n";
		file << "	-1, 40, -1, -1, -1, -1, 69, 71, 72, 73, -1, -1, 5, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, 51, 52, 53, 54, 68, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 41, 38, 42, 39, -1, 70, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, 9, -1, -1, 15, 14, 17, -1, -1, 50, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, 28, -1, -1, -1, 19, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	31, -1, 20, 18, -1, 32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, 12, 16, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, -1, -1, -1, 34, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 21,\n";
		file << "	-1, -1, -1, -1, -1, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 4, 11,\n";
		file << "	-1, -1, -1, -1, 8, 22, 10, -1, -1, 59, 43, -1, -1, 23, -1, -1, -1, -1,\n";
		file << "	-1, 61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 25, -1, -1, -1, -1, -1,\n";
		file << "	-1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, -1, -1, 33, -1, -1,\n";
		file << "	46, -1, -1, 44, -1, -1, 60, -1, 55, 56, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, 48, -1, -1, -1, -1, 26, -1, -1, -1, -1, 27, 45, -1,\n";
		file << "	-1, 57, -1, 67, 13, -1, -1, -1, 58, -1, -1, 66, 13, -1, 62, -1, -1, -1,\n";
		file << "	-1, 65, -1, -1, -1, 63, -1, -1, 64, 24\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa10_special[336] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "\n";
		file << "/** Used when there is no transition table entry for a particular state */\n";
		file << "#define dfa10_T_empty	    NULL\n";
		file << "\n";
		file << "static const ANTLR3_INT32 dfa10_T0[] =\n";
		file << "    {\n";
		file << "	114\n";
		file << "    };static const ANTLR3_INT32 dfa10_T1[] =\n";
		file << "    {\n";
		file << "	149\n";
		file << "    };static const ANTLR3_INT32 dfa10_T2[] =\n";
		file << "    {\n";
		file << "	182\n";
		file << "    };static const ANTLR3_INT32 dfa10_T3[] =\n";
		file << "    {\n";
		file << "	25, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 25, -1, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25\n";
		file << "    };static const ANTLR3_INT32 dfa10_T4[] =\n";
		file << "    {\n";
		file << "	65\n";
		file << "    };static const ANTLR3_INT32 dfa10_T5[] =\n";
		file << "    {\n";
		file << "	122\n";
		file << "    };static const ANTLR3_INT32 dfa10_T6[] =\n";
		file << "    {\n";
		file << "	48, -1, -1, -1, -1, -1, 47\n";
		file << "    };static const ANTLR3_INT32 dfa10_T7[] =\n";
		file << "    {\n";
		file << "	28, 28, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, 1, 3, 15, 16, -1, 5,\n";
		file << "	-1, 17, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 4, 27, 19, 20, 18, 21,\n";
		file << "	-1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1, -1, 8, 25, 25,\n";
		file << "	2, 6, 11, 25, 24, 10, 25, 25, 25, 22, 7, 9, 12, 25, 25, 13, 23, 25, 25,\n";
		file << "	14, 25, 25, 25\n";
		file << "    };static const ANTLR3_INT32 dfa10_T8[] =\n";
		file << "    {\n";
		file << "	147\n";
		file << "    };static const ANTLR3_INT32 dfa10_T9[] =\n";
		file << "    {\n";
		file << "	72, -1, -1, -1, -1, -1, -1, -1, 71\n";
		file << "    };static const ANTLR3_INT32 dfa10_T10[] =\n";
		file << "    {\n";
		file << "	210\n";
		file << "    };static const ANTLR3_INT32 dfa10_T11[] =\n";
		file << "    {\n";
		file << "	277, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 25, -1, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25\n";
		file << "    };static const ANTLR3_INT32 dfa10_T12[] =\n";
		file << "    {\n";
		file << "	240\n";
		file << "    };static const ANTLR3_INT32 dfa10_T13[] =\n";
		file << "    {\n";
		file << "	261\n";
		file << "    };static const ANTLR3_INT32 dfa10_T14[] =\n";
		file << "    {\n";
		file << "	159, 158, -1, 43\n";
		file << "    };static const ANTLR3_INT32 dfa10_T15[] =\n";
		file << "    {\n";
		file << "	209\n";
		file << "    };static const ANTLR3_INT32 dfa10_T16[] =\n";
		file << "    {\n";
		file << "	181\n";
		file << "    };static const ANTLR3_INT32 dfa10_T17[] =\n";
		file << "    {\n";
		file << "	260\n";
		file << "    };static const ANTLR3_INT32 dfa10_T18[] =\n";
		file << "    {\n";
		file << "	239\n";
		file << "    };static const ANTLR3_INT32 dfa10_T19[] =\n";
		file << "    {\n";
		file << "	148\n";
		file << "    };static const ANTLR3_INT32 dfa10_T20[] =\n";
		file << "    {\n";
		file << "	113\n";
		file << "    };static const ANTLR3_INT32 dfa10_T21[] =\n";
		file << "    {\n";
		file << "	188\n";
		file << "    };static const ANTLR3_INT32 dfa10_T22[] =\n";
		file << "    {\n";
		file << "	217, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 218\n";
		file << "    };static const ANTLR3_INT32 dfa10_T23[] =\n";
		file << "    {\n";
		file << "	226, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 25, -1, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25\n";
		file << "    };static const ANTLR3_INT32 dfa10_T24[] =\n";
		file << "    {\n";
		file << "	119\n";
		file << "    };static const ANTLR3_INT32 dfa10_T25[] =\n";
		file << "    {\n";
		file << "	146\n";
		file << "    };static const ANTLR3_INT32 dfa10_T26[] =\n";
		file << "    {\n";
		file << "	154\n";
		file << "    };static const ANTLR3_INT32 dfa10_T27[] =\n";
		file << "    {\n";
		file << "	179\n";
		file << "    };static const ANTLR3_INT32 dfa10_T28[] =\n";
		file << "    {\n";
		file << "	207\n";
		file << "    };static const ANTLR3_INT32 dfa10_T29[] =\n";
		file << "    {\n";
		file << "	77\n";
		file << "    };static const ANTLR3_INT32 dfa10_T30[] =\n";
		file << "    {\n";
		file << "	131\n";
		file << "    };static const ANTLR3_INT32 dfa10_T31[] =\n";
		file << "    {\n";
		file << "	155, -1, -1, -1, 43\n";
		file << "    };static const ANTLR3_INT32 dfa10_T32[] =\n";
		file << "    {\n";
		file << "	165\n";
		file << "    };static const ANTLR3_INT32 dfa10_T33[] =\n";
		file << "    {\n";
		file << "	76, -1, -1, 75\n";
		file << "    };static const ANTLR3_INT32 dfa10_T34[] =\n";
		file << "    {\n";
		file << "	195\n";
		file << "    };static const ANTLR3_INT32 dfa10_T35[] =\n";
		file << "    {\n";
		file << "	225\n";
		file << "    };static const ANTLR3_INT32 dfa10_T36[] =\n";
		file << "    {\n";
		file << "	250\n";
		file << "    };static const ANTLR3_INT32 dfa10_T37[] =\n";
		file << "    {\n";
		file << "	270\n";
		file << "    };static const ANTLR3_INT32 dfa10_T38[] =\n";
		file << "    {\n";
		file << "	187\n";
		file << "    };static const ANTLR3_INT32 dfa10_T39[] =\n";
		file << "    {\n";
		file << "	288\n";
		file << "    };static const ANTLR3_INT32 dfa10_T40[] =\n";
		file << "    {\n";
		file << "	36, -1, 34, 38, 37, 33, 41, -1, 40, -1, -1, -1, 42, 43, 39, 35, 43, 31,\n";
		file << "	43, 32, 43\n";
		file << "    };static const ANTLR3_INT32 dfa10_T41[] =\n";
		file << "    {\n";
		file << "	185\n";
		file << "    };static const ANTLR3_INT32 dfa10_T42[] =\n";
		file << "    {\n";
		file << "	152\n";
		file << "    };static const ANTLR3_INT32 dfa10_T43[] =\n";
		file << "    {\n";
		file << "	117\n";
		file << "    };static const ANTLR3_INT32 dfa10_T44[] =\n";
		file << "    {\n";
		file << "	111\n";
		file << "    };static const ANTLR3_INT32 dfa10_T45[] =\n";
		file << "    {\n";
		file << "	253\n";
		file << "    };static const ANTLR3_INT32 dfa10_T46[] =\n";
		file << "    {\n";
		file << "	273\n";
		file << "    };static const ANTLR3_INT32 dfa10_T47[] =\n";
		file << "    {\n";
		file << "	200\n";
		file << "    };static const ANTLR3_INT32 dfa10_T48[] =\n";
		file << "    {\n";
		file << "	230\n";
		file << "    };static const ANTLR3_INT32 dfa10_T49[] =\n";
		file << "    {\n";
		file << "	290\n";
		file << "    };static const ANTLR3_INT32 dfa10_T50[] =\n";
		file << "    {\n";
		file << "	304\n";
		file << "    };static const ANTLR3_INT32 dfa10_T51[] =\n";
		file << "    {\n";
		file << "	125\n";
		file << "    };static const ANTLR3_INT32 dfa10_T52[] =\n";
		file << "    {\n";
		file << "	162\n";
		file << "    };static const ANTLR3_INT32 dfa10_T53[] =\n";
		file << "    {\n";
		file << "	192\n";
		file << "    };static const ANTLR3_INT32 dfa10_T54[] =\n";
		file << "    {\n";
		file << "	88\n";
		file << "    };static const ANTLR3_INT32 dfa10_T55[] =\n";
		file << "    {\n";
		file << "	259\n";
		file << "    };static const ANTLR3_INT32 dfa10_T56[] =\n";
		file << "    {\n";
		file << "	73\n";
		file << "    };static const ANTLR3_INT32 dfa10_T57[] =\n";
		file << "    {\n";
		file << "	211\n";
		file << "    };static const ANTLR3_INT32 dfa10_T58[] =\n";
		file << "    {\n";
		file << "	238\n";
		file << "    };static const ANTLR3_INT32 dfa10_T59[] =\n";
		file << "    {\n";
		file << "	183\n";
		file << "    };static const ANTLR3_INT32 dfa10_T60[] =\n";
		file << "    {\n";
		file << "	150\n";
		file << "    };static const ANTLR3_INT32 dfa10_T61[] =\n";
		file << "    {\n";
		file << "	208\n";
		file << "    };static const ANTLR3_INT32 dfa10_T62[] =\n";
		file << "    {\n";
		file << "	115\n";
		file << "    };static const ANTLR3_INT32 dfa10_T63[] =\n";
		file << "    {\n";
		file << "	180\n";
		file << "    };static const ANTLR3_INT32 dfa10_T64[] =\n";
		file << "    {\n";
		file << "	296\n";
		file << "    };static const ANTLR3_INT32 dfa10_T65[] =\n";
		file << "    {\n";
		file << "	282\n";
		file << "    };static const ANTLR3_INT32 dfa10_T66[] =\n";
		file << "    {\n";
		file << "	262\n";
		file << "    };static const ANTLR3_INT32 dfa10_T67[] =\n";
		file << "    {\n";
		file << "	279\n";
		file << "    };static const ANTLR3_INT32 dfa10_T68[] =\n";
		file << "    {\n";
		file << "	241\n";
		file << "    };static const ANTLR3_INT32 dfa10_T69[] =\n";
		file << "    {\n";
		file << "	171\n";
		file << "    };static const ANTLR3_INT32 dfa10_T70[] =\n";
		file << "    {\n";
		file << "	138\n";
		file << "    };static const ANTLR3_INT32 dfa10_T71[] =\n";
		file << "    {\n";
		file << "	103\n";
		file << "    };static const ANTLR3_INT32 dfa10_T72[] =\n";
		file << "    {\n";
		file << "	256\n";
		file << "    };static const ANTLR3_INT32 dfa10_T73[] =\n";
		file << "    {\n";
		file << "	197\n";
		file << "    };static const ANTLR3_INT32 dfa10_T74[] =\n";
		file << "    {\n";
		file << "	167\n";
		file << "    };static const ANTLR3_INT32 dfa10_T75[] =\n";
		file << "    {\n";
		file << "	63, 64\n";
		file << "    };static const ANTLR3_INT32 dfa10_T76[] =\n";
		file << "    {\n";
		file << "	98\n";
		file << "    };static const ANTLR3_INT32 dfa10_T77[] =\n";
		file << "    {\n";
		file << "	134\n";
		file << "    };static const ANTLR3_INT32 dfa10_T78[] =\n";
		file << "    {\n";
		file << "	123\n";
		file << "    };static const ANTLR3_INT32 dfa10_T79[] =\n";
		file << "    {\n";
		file << "	112\n";
		file << "    };static const ANTLR3_INT32 dfa10_T80[] =\n";
		file << "    {\n";
		file << "	196\n";
		file << "    };static const ANTLR3_INT32 dfa10_T81[] =\n";
		file << "    {\n";
		file << "	160\n";
		file << "    };static const ANTLR3_INT32 dfa10_T82[] =\n";
		file << "    {\n";
		file << "	166\n";
		file << "    };static const ANTLR3_INT32 dfa10_T83[] =\n";
		file << "    {\n";
		file << "	220\n";
		file << "    };static const ANTLR3_INT32 dfa10_T84[] =\n";
		file << "    {\n";
		file << "	133\n";
		file << "    };static const ANTLR3_INT32 dfa10_T85[] =\n";
		file << "    {\n";
		file << "	190\n";
		file << "    };static const ANTLR3_INT32 dfa10_T86[] =\n";
		file << "    {\n";
		file << "	43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 78\n";
		file << "    };static const ANTLR3_INT32 dfa10_T87[] =\n";
		file << "    {\n";
		file << "	84, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 43, -1, -1, -1, -1, -1, -1,\n";
		file << "	43\n";
		file << "    };static const ANTLR3_INT32 dfa10_T88[] =\n";
		file << "    {\n";
		file << "	94, -1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, -1, -1, -1, -1, 25, -1, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n";
		file << "	25, 25, 25, 25, 25, 25\n";
		file << "    };static const ANTLR3_INT32 dfa10_T89[] =\n";
		file << "    {\n";
		file << "	145\n";
		file << "    };static const ANTLR3_INT32 dfa10_T90[] =\n";
		file << "    {\n";
		file << "	110\n";
		file << "    };static const ANTLR3_INT32 dfa10_T91[] =\n";
		file << "    {\n";
		file << "	74\n";
		file << "    };static const ANTLR3_INT32 dfa10_T92[] =\n";
		file << "    {\n";
		file << "	174\n";
		file << "    };static const ANTLR3_INT32 dfa10_T93[] =\n";
		file << "    {\n";
		file << "	141\n";
		file << "    };static const ANTLR3_INT32 dfa10_T94[] =\n";
		file << "    {\n";
		file << "	233\n";
		file << "    };static const ANTLR3_INT32 dfa10_T95[] =\n";
		file << "    {\n";
		file << "	203\n";
		file << "    };static const ANTLR3_INT32 dfa10_T96[] =\n";
		file << "    {\n";
		file << "	53, -1, -1, -1, 54\n";
		file << "    };static const ANTLR3_INT32 dfa10_T97[] =\n";
		file << "    {\n";
		file << "	118\n";
		file << "    };static const ANTLR3_INT32 dfa10_T98[] =\n";
		file << "    {\n";
		file << "	244\n";
		file << "    };static const ANTLR3_INT32 dfa10_T99[] =\n";
		file << "    {\n";
		file << "	51, -1, 49, -1, -1, -1, -1, 52, 50\n";
		file << "    };static const ANTLR3_INT32 dfa10_T100[] =\n";
		file << "    {\n";
		file << "	215\n";
		file << "    };static const ANTLR3_INT32 dfa10_T101[] =\n";
		file << "    {\n";
		file << "	186\n";
		file << "    };static const ANTLR3_INT32 dfa10_T102[] =\n";
		file << "    {\n";
		file << "	153\n";
		file << "    };static const ANTLR3_INT32 dfa10_T103[] =\n";
		file << "    {\n";
		file << "	229\n";
		file << "    };static const ANTLR3_INT32 dfa10_T104[] =\n";
		file << "    {\n";
		file << "	199\n";
		file << "    };static const ANTLR3_INT32 dfa10_T105[] =\n";
		file << "    {\n";
		file << "	170\n";
		file << "    };static const ANTLR3_INT32 dfa10_T106[] =\n";
		file << "    {\n";
		file << "	137\n";
		file << "    };static const ANTLR3_INT32 dfa10_T107[] =\n";
		file << "    {\n";
		file << "	252\n";
		file << "    };static const ANTLR3_INT32 dfa10_T108[] =\n";
		file << "    {\n";
		file << "	276\n";
		file << "    };static const ANTLR3_INT32 dfa10_T109[] =\n";
		file << "    {\n";
		file << "	292\n";
		file << "    };static const ANTLR3_INT32 dfa10_T110[] =\n";
		file << "    {\n";
		file << "	102\n";
		file << "    };static const ANTLR3_INT32 dfa10_T111[] =\n";
		file << "    {\n";
		file << "	96, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 97\n";
		file << "    };static const ANTLR3_INT32 dfa10_T112[] =\n";
		file << "    {\n";
		file << "	43, -1, -1, -1, -1, -1, -1, -1, -1, 79\n";
		file << "    };static const ANTLR3_INT32 dfa10_T113[] =\n";
		file << "    {\n";
		file << "	257\n";
		file << "    };static const ANTLR3_INT32 dfa10_T114[] =\n";
		file << "    {\n";
		file << "	92\n";
		file << "    };static const ANTLR3_INT32 dfa10_T115[] =\n";
		file << "    {\n";
		file << "	101\n";
		file << "    };static const ANTLR3_INT32 dfa10_T116[] =\n";
		file << "    {\n";
		file << "	312\n";
		file << "    };static const ANTLR3_INT32 dfa10_T117[] =\n";
		file << "    {\n";
		file << "	169\n";
		file << "    };static const ANTLR3_INT32 dfa10_T118[] =\n";
		file << "    {\n";
		file << "	136\n";
		file << "    };static const ANTLR3_INT32 dfa10_T119[] =\n";
		file << "    {\n";
		file << "	157, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 156\n";
		file << "    };static const ANTLR3_INT32 dfa10_T120[] =\n";
		file << "    {\n";
		file << "	299\n";
		file << "    };static const ANTLR3_INT32 dfa10_T121[] =\n";
		file << "    {\n";
		file << "	285\n";
		file << "    };static const ANTLR3_INT32 dfa10_T122[] =\n";
		file << "    {\n";
		file << "	266\n";
		file << "    };static const ANTLR3_INT32 dfa10_T123[] =\n";
		file << "    {\n";
		file << "	89\n";
		file << "    };static const ANTLR3_INT32 dfa10_T124[] =\n";
		file << "    {\n";
		file << "	126\n";
		file << "    };static const ANTLR3_INT32 dfa10_T125[] =\n";
		file << "    {\n";
		file << "	245\n";
		file << "    };static const ANTLR3_INT32 dfa10_T126[] =\n";
		file << "    {\n";
		file << "	163\n";
		file << "    };static const ANTLR3_INT32 dfa10_T127[] =\n";
		file << "    {\n";
		file << "	70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n";
		file << "	70, 70, 70, 70, 70, 70, 70, 70, -1, -1, -1, -1, -1, -1, 70, 70, 70, 69,\n";
		file << "	70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n";
		file << "	70, 70, 70, 70\n";
		file << "    };static const ANTLR3_INT32 dfa10_T128[] =\n";
		file << "    {\n";
		file << "	193\n";
		file << "    };static const ANTLR3_INT32 dfa10_T129[] =\n";
		file << "    {\n";
		file << "	104\n";
		file << "    };static const ANTLR3_INT32 dfa10_T130[] =\n";
		file << "    {\n";
		file << "	116\n";
		file << "    };static const ANTLR3_INT32 dfa10_T131[] =\n";
		file << "    {\n";
		file << "	139\n";
		file << "    };static const ANTLR3_INT32 dfa10_T132[] =\n";
		file << "    {\n";
		file << "	172\n";
		file << "    };static const ANTLR3_INT32 dfa10_T133[] =\n";
		file << "    {\n";
		file << "	201\n";
		file << "    };static const ANTLR3_INT32 dfa10_T134[] =\n";
		file << "    {\n";
		file << "	184\n";
		file << "    };static const ANTLR3_INT32 dfa10_T135[] =\n";
		file << "    {\n";
		file << "	151\n";
		file << "    };static const ANTLR3_INT32 dfa10_T136[] =\n";
		file << "    {\n";
		file << "	213, -1, -1, 212\n";
		file << "    };static const ANTLR3_INT32 dfa10_T137[] =\n";
		file << "    {\n";
		file << "	326\n";
		file << "    };static const ANTLR3_INT32 dfa10_T138[] =\n";
		file << "    {\n";
		file << "	330\n";
		file << "    };static const ANTLR3_INT32 dfa10_T139[] =\n";
		file << "    {\n";
		file << "	313\n";
		file << "    };static const ANTLR3_INT32 dfa10_T140[] =\n";
		file << "    {\n";
		file << "	321\n";
		file << "    };static const ANTLR3_INT32 dfa10_T141[] =\n";
		file << "    {\n";
		file << "	55, 56, -1, -1, -1, -1, 57\n";
		file << "    };static const ANTLR3_INT32 dfa10_T142[] =\n";
		file << "    {\n";
		file << "	287\n";
		file << "    };static const ANTLR3_INT32 dfa10_T143[] =\n";
		file << "    {\n";
		file << "	301\n";
		file << "    };static const ANTLR3_INT32 dfa10_T144[] =\n";
		file << "    {\n";
		file << "	44, -1, -1, -1, -1, 46, -1, -1, -1, -1, -1, -1, -1, -1, -1, 45\n";
		file << "    };static const ANTLR3_INT32 dfa10_T145[] =\n";
		file << "    {\n";
		file << "	286\n";
		file << "    };static const ANTLR3_INT32 dfa10_T146[] =\n";
		file << "    {\n";
		file << "	268\n";
		file << "    };static const ANTLR3_INT32 dfa10_T147[] =\n";
		file << "    {\n";
		file << "	246\n";
		file << "    };static const ANTLR3_INT32 dfa10_T148[] =\n";
		file << "    {\n";
		file << "	176\n";
		file << "    };static const ANTLR3_INT32 dfa10_T149[] =\n";
		file << "    {\n";
		file << "	121\n";
		file << "    };static const ANTLR3_INT32 dfa10_T150[] =\n";
		file << "    {\n";
		file << "	267\n";
		file << "    };static const ANTLR3_INT32 dfa10_T151[] =\n";
		file << "    {\n";
		file << "	143\n";
		file << "    };static const ANTLR3_INT32 dfa10_T152[] =\n";
		file << "    {\n";
		file << "	108\n";
		file << "    };static const ANTLR3_INT32 dfa10_T153[] =\n";
		file << "    {\n";
		file << "	80\n";
		file << "    };static const ANTLR3_INT32 dfa10_T154[] =\n";
		file << "    {\n";
		file << "	189\n";
		file << "    };static const ANTLR3_INT32 dfa10_T155[] =\n";
		file << "    {\n";
		file << "	219\n";
		file << "    };static const ANTLR3_INT32 dfa10_T156[] =\n";
		file << "    {\n";
		file << "	43\n";
		file << "    };static const ANTLR3_INT32 dfa10_T157[] =\n";
		file << "    {\n";
		file << "	235, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 234\n";
		file << "    };static const ANTLR3_INT32 dfa10_T158[] =\n";
		file << "    {\n";
		file << "	205\n";
		file << "    };static const ANTLR3_INT32 dfa10_T159[] =\n";
		file << "    {\n";
		file << "	59\n";
		file << "    };static const ANTLR3_INT32 dfa10_T160[] =\n";
		file << "    {\n";
		file << "	293, 294\n";
		file << "    };static const ANTLR3_INT32 dfa10_T161[] =\n";
		file << "    {\n";
		file << "	58\n";
		file << "    };static const ANTLR3_INT32 dfa10_T162[] =\n";
		file << "    {\n";
		file << "	173\n";
		file << "    };static const ANTLR3_INT32 dfa10_T163[] =\n";
		file << "    {\n";
		file << "	140\n";
		file << "    };static const ANTLR3_INT32 dfa10_T164[] =\n";
		file << "    {\n";
		file << "	291\n";
		file << "    };static const ANTLR3_INT32 dfa10_T165[] =\n";
		file << "    {\n";
		file << "	202\n";
		file << "    };static const ANTLR3_INT32 dfa10_T166[] =\n";
		file << "    {\n";
		file << "	232\n";
		file << "    };static const ANTLR3_INT32 dfa10_T167[] =\n";
		file << "    {\n";
		file << "	254\n";
		file << "    };static const ANTLR3_INT32 dfa10_T168[] =\n";
		file << "    {\n";
		file << "	274\n";
		file << "    };static const ANTLR3_INT32 dfa10_T169[] =\n";
		file << "    {\n";
		file << "	100\n";
		file << "    };static const ANTLR3_INT32 dfa10_T170[] =\n";
		file << "    {\n";
		file << "	83, 43\n";
		file << "    };static const ANTLR3_INT32 dfa10_T171[] =\n";
		file << "    {\n";
		file << "	142\n";
		file << "    };static const ANTLR3_INT32 dfa10_T172[] =\n";
		file << "    {\n";
		file << "	107\n";
		file << "    };static const ANTLR3_INT32 dfa10_T173[] =\n";
		file << "    {\n";
		file << "	135\n";
		file << "    };static const ANTLR3_INT32 dfa10_T174[] =\n";
		file << "    {\n";
		file << "	90\n";
		file << "    };static const ANTLR3_INT32 dfa10_T175[] =\n";
		file << "    {\n";
		file << "	86, -1, -1, -1, 43, -1, -1, -1, -1, -1, 87, -1, -1, -1, -1, -1, 85\n";
		file << "    };static const ANTLR3_INT32 dfa10_T176[] =\n";
		file << "    {\n";
		file << "	175\n";
		file << "    };static const ANTLR3_INT32 dfa10_T177[] =\n";
		file << "    {\n";
		file << "	105, -1, -1, -1, -1, -1, -1, -1, -1, -1, 106\n";
		file << "    };static const ANTLR3_INT32 dfa10_T178[] =\n";
		file << "    {\n";
		file << "	248, -1, -1, -1, -1, -1, -1, 247\n";
		file << "    };static const ANTLR3_INT32 dfa10_T179[] =\n";
		file << "    {\n";
		file << "	251\n";
		file << "    };static const ANTLR3_INT32 dfa10_T180[] =\n";
		file << "    {\n";
		file << "	191\n";
		file << "    };static const ANTLR3_INT32 dfa10_T181[] =\n";
		file << "    {\n";
		file << "	161\n";
		file << "    };static const ANTLR3_INT32 dfa10_T182[] =\n";
		file << "    {\n";
		file << "	124\n";
		file << "    };static const ANTLR3_INT32 dfa10_T183[] =\n";
		file << "    {\n";
		file << "	332\n";
		file << "    };static const ANTLR3_INT32 dfa10_T184[] =\n";
		file << "    {\n";
		file << "	325\n";
		file << "    };static const ANTLR3_INT32 dfa10_T185[] =\n";
		file << "    {\n";
		file << "	329\n";
		file << "    };static const ANTLR3_INT32 dfa10_T186[] =\n";
		file << "    {\n";
		file << "	249\n";
		file << "    };static const ANTLR3_INT32 dfa10_T187[] =\n";
		file << "    {\n";
		file << "	308\n";
		file << "    };static const ANTLR3_INT32 dfa10_T188[] =\n";
		file << "    {\n";
		file << "	318\n";
		file << "    };static const ANTLR3_INT32 dfa10_T189[] =\n";
		file << "    {\n";
		file << "	221\n";
		file << "    };static const ANTLR3_INT32 dfa10_T190[] =\n";
		file << "    {\n";
		file << "	263\n";
		file << "    };static const ANTLR3_INT32 dfa10_T191[] =\n";
		file << "    {\n";
		file << "	242\n";
		file << "    };static const ANTLR3_INT32 dfa10_T192[] =\n";
		file << "    {\n";
		file << "	109\n";
		file << "    };static const ANTLR3_INT32 dfa10_T193[] =\n";
		file << "    {\n";
		file << "	91\n";
		file << "    };static const ANTLR3_INT32 dfa10_T194[] =\n";
		file << "    {\n";
		file << "	144\n";
		file << "    };static const ANTLR3_INT32 dfa10_T195[] =\n";
		file << "    {\n";
		file << "	164\n";
		file << "    };static const ANTLR3_INT32 dfa10_T196[] =\n";
		file << "    {\n";
		file << "	177\n";
		file << "    };static const ANTLR3_INT32 dfa10_T197[] =\n";
		file << "    {\n";
		file << "	323\n";
		file << "    };static const ANTLR3_INT32 dfa10_T198[] =\n";
		file << "    {\n";
		file << "	128\n";
		file << "    };static const ANTLR3_INT32 dfa10_T199[] =\n";
		file << "    {\n";
		file << "	315\n";
		file << "    };static const ANTLR3_INT32 dfa10_T200[] =\n";
		file << "    {\n";
		file << "	303\n";
		file << "    };static const ANTLR3_INT32 dfa10_T201[] =\n";
		file << "    {\n";
		file << "	194\n";
		file << "    };static const ANTLR3_INT32 dfa10_T202[] =\n";
		file << "    {\n";
		file << "	289\n";
		file << "    };static const ANTLR3_INT32 dfa10_T203[] =\n";
		file << "    {\n";
		file << "	271\n";
		file << "    };static const ANTLR3_INT32 dfa10_T204[] =\n";
		file << "    {\n";
		file << "	206\n";
		file << "    };static const ANTLR3_INT32 dfa10_T205[] =\n";
		file << "    {\n";
		file << "	307\n";
		file << "    };static const ANTLR3_INT32 dfa10_T206[] =\n";
		file << "    {\n";
		file << "	29, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30\n";
		file << "    };static const ANTLR3_INT32 dfa10_T207[] =\n";
		file << "    {\n";
		file << "	302\n";
		file << "    };static const ANTLR3_INT32 dfa10_T208[] =\n";
		file << "    {\n";
		file << "	314\n";
		file << "    };static const ANTLR3_INT32 dfa10_T209[] =\n";
		file << "    {\n";
		file << "	324\n";
		file << "    };static const ANTLR3_INT32 dfa10_T210[] =\n";
		file << "    {\n";
		file << "	317\n";
		file << "    };static const ANTLR3_INT32 dfa10_T211[] =\n";
		file << "    {\n";
		file << "	328\n";
		file << "    };static const ANTLR3_INT32 dfa10_T212[] =\n";
		file << "    {\n";
		file << "	120\n";
		file << "    };static const ANTLR3_INT32 dfa10_T213[] =\n";
		file << "    {\n";
		file << "	70, -1, -1, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n";
		file << "	70, 70, 70, 70, 70, 70, 70, 70, 70, 70, -1, -1, -1, -1, 70, -1, 70, 70,\n";
		file << "	70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n";
		file << "	70, 70, 70, 70, 70, 70\n";
		file << "    };static const ANTLR3_INT32 dfa10_T214[] =\n";
		file << "    {\n";
		file << "	333\n";
		file << "    };static const ANTLR3_INT32 dfa10_T215[] =\n";
		file << "    {\n";
		file << "	258\n";
		file << "    };static const ANTLR3_INT32 dfa10_T216[] =\n";
		file << "    {\n";
		file << "	243\n";
		file << "    };static const ANTLR3_INT32 dfa10_T217[] =\n";
		file << "    {\n";
		file << "	264\n";
		file << "    };static const ANTLR3_INT32 dfa10_T218[] =\n";
		file << "    {\n";
		file << "	284\n";
		file << "    };static const ANTLR3_INT32 dfa10_T219[] =\n";
		file << "    {\n";
		file << "	298\n";
		file << "    };static const ANTLR3_INT32 dfa10_T220[] =\n";
		file << "    {\n";
		file << "	236\n";
		file << "    };static const ANTLR3_INT32 dfa10_T221[] =\n";
		file << "    {\n";
		file << "	283\n";
		file << "    };static const ANTLR3_INT32 dfa10_T222[] =\n";
		file << "    {\n";
		file << "	67\n";
		file << "    };static const ANTLR3_INT32 dfa10_T223[] =\n";
		file << "    {\n";
		file << "	297\n";
		file << "    };static const ANTLR3_INT32 dfa10_T224[] =\n";
		file << "    {\n";
		file << "	310\n";
		file << "    };static const ANTLR3_INT32 dfa10_T225[] =\n";
		file << "    {\n";
		file << "	82, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81\n";
		file << "    };static const ANTLR3_INT32 dfa10_T226[] =\n";
		file << "    {\n";
		file << "	61, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, -1, 60\n";
		file << "    };static const ANTLR3_INT32 dfa10_T227[] =\n";
		file << "    {\n";
		file << "	93\n";
		file << "    };\n";
		file << "\n";
		file << "/* Transition tables are a table of sub tables, with some tables\n";
		file << " * reused for efficiency.\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 * const dfa10_transitions[] =\n";
		file << "{\n";
		file << "    dfa10_T7, dfa10_T_empty, dfa10_T206, dfa10_T_empty, dfa10_T40, dfa10_T_empty,\n";
		file << "    dfa10_T144, dfa10_T6, dfa10_T99, dfa10_T96, dfa10_T141, dfa10_T161,\n";
		file << "    dfa10_T159, dfa10_T226, dfa10_T75, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty,\n";
		file << "    dfa10_T4, dfa10_T222, dfa10_T_empty, dfa10_T127, dfa10_T9, dfa10_T56,\n";
		file << "    dfa10_T91, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty,\n";
		file << "    dfa10_T33, dfa10_T29, dfa10_T_empty, dfa10_T86, dfa10_T112, dfa10_T153,\n";
		file << "    dfa10_T225, dfa10_T170, dfa10_T87, dfa10_T175, dfa10_T_empty, dfa10_T_empty,\n";
		file << "    dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T54, dfa10_T123,\n";
		file << "    dfa10_T174, dfa10_T193, dfa10_T114, dfa10_T227, dfa10_T88, dfa10_T111,\n";
		file << "    dfa10_T76, dfa10_T3, dfa10_T169, dfa10_T115, dfa10_T110, dfa10_T71,\n";
		file << "    dfa10_T129, dfa10_T177, dfa10_T172, dfa10_T152, dfa10_T192, dfa10_T90,\n";
		file << "    dfa10_T44, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty,\n";
		file << "    dfa10_T79, dfa10_T_empty, dfa10_T20, dfa10_T0, dfa10_T62, dfa10_T130,\n";
		file << "    dfa10_T43, dfa10_T97, dfa10_T24, dfa10_T212, dfa10_T_empty, dfa10_T149,\n";
		file << "    dfa10_T5, dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T78, dfa10_T182,\n";
		file << "    dfa10_T_empty, dfa10_T51, dfa10_T124, dfa10_T3, dfa10_T198, dfa10_T3,\n";
		file << "    dfa10_T3, dfa10_T30, dfa10_T_empty, dfa10_T3, dfa10_T84, dfa10_T77,\n";
		file << "    dfa10_T_empty, dfa10_T173, dfa10_T118, dfa10_T106, dfa10_T70, dfa10_T131,\n";
		file << "    dfa10_T163, dfa10_T93, dfa10_T171, dfa10_T151, dfa10_T194, dfa10_T89,\n";
		file << "    dfa10_T25, dfa10_T8, dfa10_T19, dfa10_T1, dfa10_T60, dfa10_T135, dfa10_T42,\n";
		file << "    dfa10_T102, dfa10_T26, dfa10_T31, dfa10_T119, dfa10_T14, dfa10_T81,\n";
		file << "    dfa10_T181, dfa10_T52, dfa10_T126, dfa10_T_empty, dfa10_T195, dfa10_T_empty,\n";
		file << "    dfa10_T_empty, dfa10_T32, dfa10_T_empty, dfa10_T82, dfa10_T74, dfa10_T3,\n";
		file << "    dfa10_T117, dfa10_T105, dfa10_T69, dfa10_T132, dfa10_T162, dfa10_T92,\n";
		file << "    dfa10_T176, dfa10_T148, dfa10_T196, dfa10_T3, dfa10_T27, dfa10_T63,\n";
		file << "    dfa10_T16, dfa10_T2, dfa10_T59, dfa10_T134, dfa10_T41, dfa10_T101, dfa10_T38,\n";
		file << "    dfa10_T_empty, dfa10_T21, dfa10_T154, dfa10_T_empty, dfa10_T_empty,\n";
		file << "    dfa10_T85, dfa10_T180, dfa10_T53, dfa10_T128, dfa10_T201, dfa10_T34,\n";
		file << "    dfa10_T80, dfa10_T73, dfa10_T_empty, dfa10_T3, dfa10_T104, dfa10_T47,\n";
		file << "    dfa10_T133, dfa10_T165, dfa10_T95, dfa10_T3, dfa10_T158, dfa10_T204,\n";
		file << "    dfa10_T_empty, dfa10_T28, dfa10_T61, dfa10_T15, dfa10_T10, dfa10_T57,\n";
		file << "    dfa10_T136, dfa10_T3, dfa10_T100, dfa10_T3, dfa10_T22, dfa10_T155, dfa10_T83,\n";
		file << "    dfa10_T189, dfa10_T3, dfa10_T3, dfa10_T3, dfa10_T35, dfa10_T23, dfa10_T3,\n";
		file << "    dfa10_T_empty, dfa10_T103, dfa10_T48, dfa10_T3, dfa10_T166, dfa10_T94,\n";
		file << "    dfa10_T_empty, dfa10_T157, dfa10_T220, dfa10_T3, dfa10_T58, dfa10_T18,\n";
		file << "    dfa10_T12, dfa10_T68, dfa10_T191, dfa10_T216, dfa10_T_empty, dfa10_T98,\n";
		file << "    dfa10_T_empty, dfa10_T_empty, dfa10_T125, dfa10_T147, dfa10_T178, dfa10_T186,\n";
		file << "    dfa10_T_empty, dfa10_T_empty, dfa10_T_empty, dfa10_T36, dfa10_T179,\n";
		file << "    dfa10_T_empty, dfa10_T_empty, dfa10_T107, dfa10_T45, dfa10_T_empty,\n";
		file << "    dfa10_T167, dfa10_T3, dfa10_T72, dfa10_T113, dfa10_T215, dfa10_T_empty,\n";
		file << "    dfa10_T55, dfa10_T17, dfa10_T13, dfa10_T66, dfa10_T190, dfa10_T217,\n";
		file << "    dfa10_T3, dfa10_T122, dfa10_T150, dfa10_T146, dfa10_T_empty, dfa10_T156,\n";
		file << "    dfa10_T37, dfa10_T203, dfa10_T3, dfa10_T46, dfa10_T168, dfa10_T_empty,\n";
		file << "    dfa10_T3, dfa10_T108, dfa10_T11, dfa10_T67, dfa10_T3, dfa10_T3, dfa10_T65,\n";
		file << "    dfa10_T221, dfa10_T218, dfa10_T_empty, dfa10_T121, dfa10_T145, dfa10_T142,\n";
		file << "    dfa10_T_empty, dfa10_T39, dfa10_T202, dfa10_T_empty, dfa10_T49, dfa10_T164,\n";
		file << "    dfa10_T_empty, dfa10_T109, dfa10_T160, dfa10_T_empty, dfa10_T213, dfa10_T_empty,\n";
		file << "    dfa10_T_empty, dfa10_T64, dfa10_T223, dfa10_T219, dfa10_T120, dfa10_T156,\n";
		file << "    dfa10_T143, dfa10_T207, dfa10_T200, dfa10_T50, dfa10_T3, dfa10_T3, dfa10_T205,\n";
		file << "    dfa10_T187, dfa10_T_empty, dfa10_T3, dfa10_T224, dfa10_T3, dfa10_T116,\n";
		file << "    dfa10_T_empty, dfa10_T139, dfa10_T208, dfa10_T199, dfa10_T3, dfa10_T_empty,\n";
		file << "    dfa10_T_empty, dfa10_T210, dfa10_T188, dfa10_T_empty, dfa10_T3, dfa10_T_empty,\n";
		file << "    dfa10_T_empty, dfa10_T140, dfa10_T3, dfa10_T197, dfa10_T_empty, dfa10_T209,\n";
		file << "    dfa10_T184, dfa10_T_empty, dfa10_T_empty, dfa10_T137, dfa10_T_empty,\n";
		file << "    dfa10_T3, dfa10_T211, dfa10_T185, dfa10_T138, dfa10_T_empty, dfa10_T3,\n";
		file << "    dfa10_T183, dfa10_T214, dfa10_T_empty, dfa10_T3, dfa10_T156, dfa10_T_empty,\n";
		file << "    dfa10_T_empty\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "/* Declare tracking structure for Cyclic DFA 10\n";
		file << " */\n";
		file << "static\n";
		file << "ANTLR3_CYCLIC_DFA cdfa10\n";
		file << "    =	{\n";
		file << "	    10,		    /* Decision number of this dfa	    */\n";
		file << "	    /* Which decision this represents:   */\n";
		file << "	    (const pANTLR3_UCHAR)\"1:1: Tokens : ( T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | T__94 | T__95 | T__96 | T__97 | T__98 | T__99 | T__100 | T__101 | T__102 | T__103 | T__104 | T__105 | T__106 | T__107 | T__108 | T__109 | T__110 | T__111 | T__112 | T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | REQUIRE_KEY | NAME | VARIABLE | NUMBER | LINE_COMMENT | WHITESPACE );\",\n";
		file << "	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/\n";
		file << "	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */\n";
		file << "	    antlr3dfapredict,			/* DFA simulator function is in the runtime */\n";
		file << "	    dfa10_eot,	    /* EOT table			    */\n";
		file << "	    dfa10_eof,	    /* EOF table			    */\n";
		file << "	    dfa10_min,	    /* Minimum tokens for each state    */\n";
		file << "	    dfa10_max,	    /* Maximum tokens for each state    */\n";
		file << "	    dfa10_accept,	/* Accept table			    */\n";
		file << "	    dfa10_special,	/* Special transition states	    */\n";
		file << "	    dfa10_transitions	/* Table of transition tables	    */\n";
		file << "\n";
		file << "	};\n";
		file << "/* End of Cyclic DFA 10\n";
		file << " * ---------------------\n";
		file << " */\n";
		file << "/* =========================================================================\n";
		file << " * End of DFA tables for the lexer\n";
		file << " */\n";
		file << "\n";
		file << "/* =========================================================================\n";
		file << " * Functions to match the lexer grammar defined tokens from the input stream\n";
		file << " */\n";
		file << "\n";
		file << "//   Comes from: 7:7: ( '(' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__54\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__54\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__54(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__54;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:7:7: ( '(' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:7:9: '('\n";
		file << "    {\n";
		file << "        MATCHC('(');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__54Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__54Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__54Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__54\n";
		file << "\n";
		file << "//   Comes from: 8:7: ( 'define' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__55\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__55\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__55(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__55;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:8:7: ( 'define' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:8:9: 'define'\n";
		file << "    {\n";
		file << "        MATCHS(lit_1);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__55Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__55Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__55Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__55\n";
		file << "\n";
		file << "//   Comes from: 9:7: ( ')' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__56\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__56\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__56(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__56;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:9:7: ( ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:9:9: ')'\n";
		file << "    {\n";
		file << "        MATCHC(')');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__56Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__56Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__56Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__56\n";
		file << "\n";
		file << "//   Comes from: 10:7: ( 'domain' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__57\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__57\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__57(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__57;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:10:7: ( 'domain' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:10:9: 'domain'\n";
		file << "    {\n";
		file << "        MATCHS(lit_2);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__57Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__57Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__57Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__57\n";
		file << "\n";
		file << "//   Comes from: 11:7: ( ':requirements' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__58\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__58\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__58(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__58;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:11:7: ( ':requirements' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:11:9: ':requirements'\n";
		file << "    {\n";
		file << "        MATCHS(lit_3);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__58Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__58Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__58Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__58\n";
		file << "\n";
		file << "//   Comes from: 12:7: ( ':types' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__59\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__59\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__59(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__59;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:12:7: ( ':types' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:12:9: ':types'\n";
		file << "    {\n";
		file << "        MATCHS(lit_4);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__59Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__59Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__59Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__59\n";
		file << "\n";
		file << "//   Comes from: 13:7: ( '-' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__60\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__60\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__60(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__60;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:13:7: ( '-' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:13:9: '-'\n";
		file << "    {\n";
		file << "        MATCHC('-');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__60Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__60Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__60Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__60\n";
		file << "\n";
		file << "//   Comes from: 14:7: ( 'either' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__61\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__61\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__61(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__61;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:14:7: ( 'either' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:14:9: 'either'\n";
		file << "    {\n";
		file << "        MATCHS(lit_5);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__61Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__61Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__61Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__61\n";
		file << "\n";
		file << "//   Comes from: 15:7: ( ':functions' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__62\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__62\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__62(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__62;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:15:7: ( ':functions' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:15:9: ':functions'\n";
		file << "    {\n";
		file << "        MATCHS(lit_6);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__62Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__62Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__62Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__62\n";
		file << "\n";
		file << "//   Comes from: 16:7: ( 'number' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__63\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__63\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__63(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__63;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:16:7: ( 'number' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:16:9: 'number'\n";
		file << "    {\n";
		file << "        MATCHS(lit_7);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__63Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__63Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__63Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__63\n";
		file << "\n";
		file << "//   Comes from: 17:7: ( ':constants' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__64\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__64\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__64(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__64;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:17:7: ( ':constants' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:17:9: ':constants'\n";
		file << "    {\n";
		file << "        MATCHS(lit_8);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__64Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__64Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__64Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__64\n";
		file << "\n";
		file << "//   Comes from: 18:7: ( ':predicates' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__65\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__65\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__65(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__65;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:18:7: ( ':predicates' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:18:9: ':predicates'\n";
		file << "    {\n";
		file << "        MATCHS(lit_9);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__65Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__65Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__65Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__65\n";
		file << "\n";
		file << "//   Comes from: 19:7: ( ':constraints' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__66\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__66\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__66(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__66;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:19:7: ( ':constraints' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:19:9: ':constraints'\n";
		file << "    {\n";
		file << "        MATCHS(lit_10);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__66Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__66Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__66Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__66\n";
		file << "\n";
		file << "//   Comes from: 20:7: ( ':action' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__67\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__67\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__67(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__67;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:20:7: ( ':action' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:20:9: ':action'\n";
		file << "    {\n";
		file << "        MATCHS(lit_11);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__67Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__67Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__67Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__67\n";
		file << "\n";
		file << "//   Comes from: 21:7: ( ':parameters' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__68\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__68\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__68(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__68;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:21:7: ( ':parameters' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:21:9: ':parameters'\n";
		file << "    {\n";
		file << "        MATCHS(lit_12);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__68Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__68Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__68Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__68\n";
		file << "\n";
		file << "//   Comes from: 22:7: ( ':precondition' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__69\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__69\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__69(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__69;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:22:7: ( ':precondition' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:22:9: ':precondition'\n";
		file << "    {\n";
		file << "        MATCHS(lit_13);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__69Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__69Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__69Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__69\n";
		file << "\n";
		file << "//   Comes from: 23:7: ( ':effect' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__70\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__70\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__70(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__70;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:23:7: ( ':effect' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:23:9: ':effect'\n";
		file << "    {\n";
		file << "        MATCHS(lit_14);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__70Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__70Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__70Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__70\n";
		file << "\n";
		file << "//   Comes from: 24:7: ( 'and' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__71\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__71\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__71(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__71;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:24:7: ( 'and' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:24:9: 'and'\n";
		file << "    {\n";
		file << "        MATCHS(lit_15);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__71Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__71Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__71Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__71\n";
		file << "\n";
		file << "//   Comes from: 25:7: ( 'or' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__72\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__72\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__72(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__72;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:25:7: ( 'or' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:25:9: 'or'\n";
		file << "    {\n";
		file << "        MATCHS(lit_16);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__72Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__72Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__72Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__72\n";
		file << "\n";
		file << "//   Comes from: 26:7: ( 'not' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__73\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__73\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__73(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__73;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:26:7: ( 'not' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:26:9: 'not'\n";
		file << "    {\n";
		file << "        MATCHS(lit_17);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__73Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__73Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__73Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__73\n";
		file << "\n";
		file << "//   Comes from: 27:7: ( 'imply' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__74\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__74\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__74(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__74;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:27:7: ( 'imply' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:27:9: 'imply'\n";
		file << "    {\n";
		file << "        MATCHS(lit_18);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__74Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__74Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__74Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__74\n";
		file << "\n";
		file << "//   Comes from: 28:7: ( 'exists' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__75\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__75\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__75(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__75;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:28:7: ( 'exists' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:28:9: 'exists'\n";
		file << "    {\n";
		file << "        MATCHS(lit_19);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__75Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__75Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__75Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__75\n";
		file << "\n";
		file << "//   Comes from: 29:7: ( 'forall' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__76\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__76\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__76(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__76;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:29:7: ( 'forall' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:29:9: 'forall'\n";
		file << "    {\n";
		file << "        MATCHS(lit_20);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__76Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__76Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__76Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__76\n";
		file << "\n";
		file << "//   Comes from: 30:7: ( ':durative-action' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__77\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__77\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__77(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__77;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:30:7: ( ':durative-action' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:30:9: ':durative-action'\n";
		file << "    {\n";
		file << "        MATCHS(lit_21);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__77Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__77Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__77Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__77\n";
		file << "\n";
		file << "//   Comes from: 31:7: ( ':duration' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__78\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__78\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__78(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__78;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:31:7: ( ':duration' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:31:9: ':duration'\n";
		file << "    {\n";
		file << "        MATCHS(lit_22);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__78Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__78Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__78Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__78\n";
		file << "\n";
		file << "//   Comes from: 32:7: ( ':condition' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__79\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__79\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__79(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__79;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:32:7: ( ':condition' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:32:9: ':condition'\n";
		file << "    {\n";
		file << "        MATCHS(lit_23);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__79Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__79Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__79Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__79\n";
		file << "\n";
		file << "//   Comes from: 33:7: ( 'preference' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__80\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__80\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__80(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__80;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:33:7: ( 'preference' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:33:9: 'preference'\n";
		file << "    {\n";
		file << "        MATCHS(lit_24);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__80Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__80Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__80Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__80\n";
		file << "\n";
		file << "//   Comes from: 34:7: ( 'at' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__81\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__81\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__81(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__81;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:34:7: ( 'at' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:34:9: 'at'\n";
		file << "    {\n";
		file << "        MATCHS(lit_25);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__81Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__81Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__81Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__81\n";
		file << "\n";
		file << "//   Comes from: 35:7: ( 'over' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__82\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__82\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__82(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__82;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:35:7: ( 'over' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:35:9: 'over'\n";
		file << "    {\n";
		file << "        MATCHS(lit_26);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__82Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__82Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__82Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__82\n";
		file << "\n";
		file << "//   Comes from: 36:7: ( 'start' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__83\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__83\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__83(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__83;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:36:7: ( 'start' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:36:9: 'start'\n";
		file << "    {\n";
		file << "        MATCHS(lit_27);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__83Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__83Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__83Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__83\n";
		file << "\n";
		file << "//   Comes from: 37:7: ( 'end' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__84\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__84\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__84(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__84;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:37:7: ( 'end' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:37:9: 'end'\n";
		file << "    {\n";
		file << "        MATCHS(lit_28);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__84Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__84Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__84Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__84\n";
		file << "\n";
		file << "//   Comes from: 38:7: ( 'all' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__85\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__85\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__85(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__85;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:38:7: ( 'all' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:38:9: 'all'\n";
		file << "    {\n";
		file << "        MATCHS(lit_29);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__85Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__85Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__85Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__85\n";
		file << "\n";
		file << "//   Comes from: 39:7: ( ':derived' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__86\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__86\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__86(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__86;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:39:7: ( ':derived' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:39:9: ':derived'\n";
		file << "    {\n";
		file << "        MATCHS(lit_30);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__86Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__86Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__86Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__86\n";
		file << "\n";
		file << "//   Comes from: 40:7: ( 'when' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__87\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__87\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__87(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__87;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:40:7: ( 'when' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:40:9: 'when'\n";
		file << "    {\n";
		file << "        MATCHS(lit_31);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__87Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__87Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__87Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__87\n";
		file << "\n";
		file << "//   Comes from: 41:7: ( '*' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__88\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__88\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__88(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__88;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:41:7: ( '*' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:41:9: '*'\n";
		file << "    {\n";
		file << "        MATCHC('*');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__88Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__88Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__88Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__88\n";
		file << "\n";
		file << "//   Comes from: 42:7: ( '+' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__89\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__89\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__89(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__89;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:42:7: ( '+' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:42:9: '+'\n";
		file << "    {\n";
		file << "        MATCHC('+');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__89Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__89Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__89Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__89\n";
		file << "\n";
		file << "//   Comes from: 43:7: ( '/' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__90\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__90\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__90(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__90;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:43:7: ( '/' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:43:9: '/'\n";
		file << "    {\n";
		file << "        MATCHC('/');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__90Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__90Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__90Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__90\n";
		file << "\n";
		file << "//   Comes from: 44:7: ( '>' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__91\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__91\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__91(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__91;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:44:7: ( '>' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:44:9: '>'\n";
		file << "    {\n";
		file << "        MATCHC('>');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__91Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__91Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__91Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__91\n";
		file << "\n";
		file << "//   Comes from: 45:7: ( '<' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__92\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__92\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__92(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__92;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:45:7: ( '<' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:45:9: '<'\n";
		file << "    {\n";
		file << "        MATCHC('<');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__92Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__92Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__92Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__92\n";
		file << "\n";
		file << "//   Comes from: 46:7: ( '=' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__93\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__93\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__93(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__93;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:46:7: ( '=' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:46:9: '='\n";
		file << "    {\n";
		file << "        MATCHC('=');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__93Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__93Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__93Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__93\n";
		file << "\n";
		file << "//   Comes from: 47:7: ( '>=' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__94\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__94\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__94(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__94;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:47:7: ( '>=' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:47:9: '>='\n";
		file << "    {\n";
		file << "        MATCHS(lit_32);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__94Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__94Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__94Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__94\n";
		file << "\n";
		file << "//   Comes from: 48:7: ( '<=' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__95\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__95\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__95(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__95;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:48:7: ( '<=' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:48:9: '<='\n";
		file << "    {\n";
		file << "        MATCHS(lit_33);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__95Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__95Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__95Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__95\n";
		file << "\n";
		file << "//   Comes from: 49:7: ( 'assign' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__96\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__96\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__96(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__96;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:49:7: ( 'assign' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:49:9: 'assign'\n";
		file << "    {\n";
		file << "        MATCHS(lit_34);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__96Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__96Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__96Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__96\n";
		file << "\n";
		file << "//   Comes from: 50:7: ( 'scale-up' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__97\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__97\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__97(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__97;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:50:7: ( 'scale-up' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:50:9: 'scale-up'\n";
		file << "    {\n";
		file << "        MATCHS(lit_35);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__97Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__97Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__97Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__97\n";
		file << "\n";
		file << "//   Comes from: 51:7: ( 'scale-down' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__98\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__98\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__98(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__98;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:51:7: ( 'scale-down' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:51:9: 'scale-down'\n";
		file << "    {\n";
		file << "        MATCHS(lit_36);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__98Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__98Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__98Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__98\n";
		file << "\n";
		file << "//   Comes from: 52:7: ( 'increase' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__99\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__99\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__99(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__99;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:52:7: ( 'increase' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:52:9: 'increase'\n";
		file << "    {\n";
		file << "        MATCHS(lit_37);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__99Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__99Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__99Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__99\n";
		file << "\n";
		file << "//   Comes from: 53:8: ( 'decrease' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__100\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__100\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__100(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__100;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:53:8: ( 'decrease' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:53:10: 'decrease'\n";
		file << "    {\n";
		file << "        MATCHS(lit_38);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__100Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__100Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__100Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__100\n";
		file << "\n";
		file << "//   Comes from: 54:8: ( '?duration' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__101\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__101\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__101(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__101;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:54:8: ( '?duration' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:54:10: '?duration'\n";
		file << "    {\n";
		file << "        MATCHS(lit_39);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__101Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__101Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__101Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__101\n";
		file << "\n";
		file << "//   Comes from: 55:8: ( 'problem' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__102\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__102\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__102(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__102;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:55:8: ( 'problem' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:55:10: 'problem'\n";
		file << "    {\n";
		file << "        MATCHS(lit_40);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__102Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__102Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__102Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__102\n";
		file << "\n";
		file << "//   Comes from: 56:8: ( ':domain' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__103\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__103\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__103(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__103;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:56:8: ( ':domain' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:56:10: ':domain'\n";
		file << "    {\n";
		file << "        MATCHS(lit_41);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__103Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__103Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__103Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__103\n";
		file << "\n";
		file << "//   Comes from: 57:8: ( ':objects' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__104\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__104\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__104(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__104;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:57:8: ( ':objects' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:57:10: ':objects'\n";
		file << "    {\n";
		file << "        MATCHS(lit_42);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__104Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__104Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__104Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__104\n";
		file << "\n";
		file << "//   Comes from: 58:8: ( ':init' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__105\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__105\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__105(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__105;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:58:8: ( ':init' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:58:10: ':init'\n";
		file << "    {\n";
		file << "        MATCHS(lit_43);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__105Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__105Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__105Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__105\n";
		file << "\n";
		file << "//   Comes from: 59:8: ( ':goal' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__106\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__106\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__106(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__106;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:59:8: ( ':goal' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:59:10: ':goal'\n";
		file << "    {\n";
		file << "        MATCHS(lit_44);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__106Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__106Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__106Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__106\n";
		file << "\n";
		file << "//   Comes from: 60:8: ( ':metric' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__107\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__107\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__107(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__107;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:60:8: ( ':metric' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:60:10: ':metric'\n";
		file << "    {\n";
		file << "        MATCHS(lit_45);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__107Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__107Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__107Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__107\n";
		file << "\n";
		file << "//   Comes from: 61:8: ( 'minimize' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__108\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__108\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__108(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__108;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:61:8: ( 'minimize' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:61:10: 'minimize'\n";
		file << "    {\n";
		file << "        MATCHS(lit_46);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__108Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__108Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__108Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__108\n";
		file << "\n";
		file << "//   Comes from: 62:8: ( 'maximize' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__109\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__109\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__109(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__109;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:62:8: ( 'maximize' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:62:10: 'maximize'\n";
		file << "    {\n";
		file << "        MATCHS(lit_47);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__109Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__109Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__109Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__109\n";
		file << "\n";
		file << "//   Comes from: 63:8: ( 'total-time' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__110\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__110\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__110(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__110;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:63:8: ( 'total-time' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:63:10: 'total-time'\n";
		file << "    {\n";
		file << "        MATCHS(lit_48);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__110Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__110Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__110Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__110\n";
		file << "\n";
		file << "//   Comes from: 64:8: ( 'is-violated' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__111\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__111\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__111(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__111;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:64:8: ( 'is-violated' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:64:10: 'is-violated'\n";
		file << "    {\n";
		file << "        MATCHS(lit_49);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__111Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__111Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__111Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__111\n";
		file << "\n";
		file << "//   Comes from: 65:8: ( 'always' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__112\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__112\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__112(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__112;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:65:8: ( 'always' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:65:10: 'always'\n";
		file << "    {\n";
		file << "        MATCHS(lit_50);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__112Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__112Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__112Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__112\n";
		file << "\n";
		file << "//   Comes from: 66:8: ( 'sometime' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__113\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__113\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__113(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__113;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:66:8: ( 'sometime' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:66:10: 'sometime'\n";
		file << "    {\n";
		file << "        MATCHS(lit_51);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__113Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__113Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__113Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__113\n";
		file << "\n";
		file << "//   Comes from: 67:8: ( 'within' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__114\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__114\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__114(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__114;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:67:8: ( 'within' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:67:10: 'within'\n";
		file << "    {\n";
		file << "        MATCHS(lit_52);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__114Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__114Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__114Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__114\n";
		file << "\n";
		file << "//   Comes from: 68:8: ( 'at-most-once' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__115\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__115\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__115(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__115;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:68:8: ( 'at-most-once' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:68:10: 'at-most-once'\n";
		file << "    {\n";
		file << "        MATCHS(lit_53);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__115Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__115Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__115Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__115\n";
		file << "\n";
		file << "//   Comes from: 69:8: ( 'sometime-after' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__116\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__116\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__116(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__116;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:69:8: ( 'sometime-after' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:69:10: 'sometime-after'\n";
		file << "    {\n";
		file << "        MATCHS(lit_54);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__116Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__116Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__116Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__116\n";
		file << "\n";
		file << "//   Comes from: 70:8: ( 'sometime-before' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__117\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__117\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__117(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__117;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:70:8: ( 'sometime-before' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:70:10: 'sometime-before'\n";
		file << "    {\n";
		file << "        MATCHS(lit_55);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__117Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__117Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__117Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__117\n";
		file << "\n";
		file << "//   Comes from: 71:8: ( 'always-within' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__118\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__118\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__118(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__118;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:71:8: ( 'always-within' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:71:10: 'always-within'\n";
		file << "    {\n";
		file << "        MATCHS(lit_56);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__118Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__118Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__118Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__118\n";
		file << "\n";
		file << "//   Comes from: 72:8: ( 'hold-during' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__119\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__119\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__119(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__119;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:72:8: ( 'hold-during' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:72:10: 'hold-during'\n";
		file << "    {\n";
		file << "        MATCHS(lit_57);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__119Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__119Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__119Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__119\n";
		file << "\n";
		file << "//   Comes from: 73:8: ( 'hold-after' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start T__120\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token T__120\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mT__120(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = T__120;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:73:8: ( 'hold-after' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:73:10: 'hold-after'\n";
		file << "    {\n";
		file << "        MATCHS(lit_58);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleT__120Ex;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleT__120Ex; /* Prevent compiler warnings */\n";
		file << "    ruleT__120Ex: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end T__120\n";
		file << "\n";
		file << "//   Comes from: 510:5: ( ':strips' | ':typing' | ':negative-preconditions' | ':disjunctive-preconditions' | ':equality' | ':existential-preconditions' | ':universal-preconditions' | ':quantified-preconditions' | ':conditional-effects' | ':fluents' | ':adl' | ':durative-actions' | ':derived-predicates' | ':timed-initial-literals' | ':preferences' | ':constraints' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start REQUIRE_KEY\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token REQUIRE_KEY\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mREQUIRE_KEY(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = REQUIRE_KEY;\n";
		file << "\n";
		file << "\n";
		file << "    {\n";
		file << "        //  ../../model/subgoal_learning/Pddl.g:510:5: ( ':strips' | ':typing' | ':negative-preconditions' | ':disjunctive-preconditions' | ':equality' | ':existential-preconditions' | ':universal-preconditions' | ':quantified-preconditions' | ':conditional-effects' | ':fluents' | ':adl' | ':durative-actions' | ':derived-predicates' | ':timed-initial-literals' | ':preferences' | ':constraints' )\n";
		file << "\n";
		file << "        ANTLR3_UINT32 alt1;\n";
		file << "\n";
		file << "        alt1=16;\n";
		file << "\n";
		file << "        alt1 = cdfa1.predict(ctx, RECOGNIZER, ISTREAM, &cdfa1);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleREQUIRE_KEYEx;\n";
		file << "        }\n";
		file << "\n";
		file << "        switch (alt1)\n";
		file << "        {\n";
		file << "    	case 1:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:510:7: ':strips'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_59);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 2:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:511:7: ':typing'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_60);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 3:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:512:7: ':negative-preconditions'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_61);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 4:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:513:7: ':disjunctive-preconditions'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_62);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 5:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:514:7: ':equality'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_63);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 6:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:515:7: ':existential-preconditions'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_64);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 7:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:516:7: ':universal-preconditions'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_65);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 8:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:517:7: ':quantified-preconditions'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_66);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 9:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:518:7: ':conditional-effects'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_67);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 10:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:519:7: ':fluents'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_68);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 11:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:520:7: ':adl'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_69);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 12:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:521:7: ':durative-actions'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_70);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 13:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:522:7: ':derived-predicates'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_71);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 14:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:523:7: ':timed-initial-literals'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_72);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 15:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:524:7: ':preferences'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_73);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 16:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:525:7: ':constraints'\n";
		file << "    	    {\n";
		file << "    	        MATCHS(lit_10);\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleREQUIRE_KEYEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "\n";
		file << "        }\n";
		file << "    }\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleREQUIRE_KEYEx; /* Prevent compiler warnings */\n";
		file << "    ruleREQUIRE_KEYEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end REQUIRE_KEY\n";
		file << "\n";
		file << "//   Comes from: 529:5: ( LETTER ( ANY_CHAR )* )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start NAME\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token NAME\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mNAME(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = NAME;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:529:5: ( LETTER ( ANY_CHAR )* )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:529:10: LETTER ( ANY_CHAR )*\n";
		file << "    {\n";
		file << "        /* 529:10: LETTER ( ANY_CHAR )* */\n";
		file << "        mLETTER(ctx );\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleNAMEEx;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:529:17: ( ANY_CHAR )*\n";
		file << "\n";
		file << "        for (;;)\n";
		file << "        {\n";
		file << "            int alt2=2;\n";
		file << "            {\n";
		file << "               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                */\n";
		file << "                int LA2_0 = LA(1);\n";
		file << "                if ( (LA2_0 == '-' || ((LA2_0 >= '0') && (LA2_0 <= '9')) || ((LA2_0 >= 'A') && (LA2_0 <= 'Z')) || LA2_0 == '_' || ((LA2_0 >= 'a') && (LA2_0 <= 'z'))) )\n";
		file << "                {\n";
		file << "                    alt2=1;\n";
		file << "                }\n";
		file << "\n";
		file << "            }\n";
		file << "            switch (alt2)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:529:17: ANY_CHAR\n";
		file << "        	    {\n";
		file << "        	        /* 529:17: ANY_CHAR */\n";
		file << "        	        mANY_CHAR(ctx );\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleNAMEEx;\n";
		file << "        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "        	default:\n";
		file << "        	    goto loop2;	/* break out of the loop */\n";
		file << "        	    break;\n";
		file << "            }\n";
		file << "        }\n";
		file << "        loop2: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleNAMEEx; /* Prevent compiler warnings */\n";
		file << "    ruleNAMEEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end NAME\n";
		file << "\n";
		file << "//   Comes from: 531:16: ( 'a' .. 'z' | 'A' .. 'Z' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start LETTER\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token LETTER\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mLETTER(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:531:16: ( 'a' .. 'z' | 'A' .. 'Z' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:\n";
		file << "    {\n";
		file << "        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || ((LA(1) >= 'a') && (LA(1) <= 'z')) )\n";
		file << "        {\n";
		file << "            CONSUME();\n";
		file << "\n";
		file << "        }\n";
		file << "        else\n";
		file << "        {\n";
		file << "            CONSTRUCTEX();\n";
		file << "            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "\n";
		file << "            LRECOVER();    goto ruleLETTEREx;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleLETTEREx; /* Prevent compiler warnings */\n";
		file << "    ruleLETTEREx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end LETTER\n";
		file << "\n";
		file << "//   Comes from: 533:18: ( LETTER | '0' .. '9' | '-' | '_' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start ANY_CHAR\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token ANY_CHAR\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mANY_CHAR(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:533:18: ( LETTER | '0' .. '9' | '-' | '_' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:\n";
		file << "    {\n";
		file << "        if ( LA(1) == '-' || ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )\n";
		file << "        {\n";
		file << "            CONSUME();\n";
		file << "\n";
		file << "        }\n";
		file << "        else\n";
		file << "        {\n";
		file << "            CONSTRUCTEX();\n";
		file << "            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "\n";
		file << "            LRECOVER();    goto ruleANY_CHAREx;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleANY_CHAREx; /* Prevent compiler warnings */\n";
		file << "    ruleANY_CHAREx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end ANY_CHAR\n";
		file << "\n";
		file << "//   Comes from: 535:10: ( '?' LETTER ( ANY_CHAR )* )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start VARIABLE\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token VARIABLE\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mVARIABLE(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = VARIABLE;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:535:10: ( '?' LETTER ( ANY_CHAR )* )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:535:12: '?' LETTER ( ANY_CHAR )*\n";
		file << "    {\n";
		file << "        MATCHC('?');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleVARIABLEEx;\n";
		file << "        }\n";
		file << "\n";
		file << "        /* 535:12: '?' LETTER ( ANY_CHAR )* */\n";
		file << "        mLETTER(ctx );\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleVARIABLEEx;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:535:23: ( ANY_CHAR )*\n";
		file << "\n";
		file << "        for (;;)\n";
		file << "        {\n";
		file << "            int alt3=2;\n";
		file << "            {\n";
		file << "               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                */\n";
		file << "                int LA3_0 = LA(1);\n";
		file << "                if ( (LA3_0 == '-' || ((LA3_0 >= '0') && (LA3_0 <= '9')) || ((LA3_0 >= 'A') && (LA3_0 <= 'Z')) || LA3_0 == '_' || ((LA3_0 >= 'a') && (LA3_0 <= 'z'))) )\n";
		file << "                {\n";
		file << "                    alt3=1;\n";
		file << "                }\n";
		file << "\n";
		file << "            }\n";
		file << "            switch (alt3)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:535:23: ANY_CHAR\n";
		file << "        	    {\n";
		file << "        	        /* 535:23: ANY_CHAR */\n";
		file << "        	        mANY_CHAR(ctx );\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleVARIABLEEx;\n";
		file << "        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "        	default:\n";
		file << "        	    goto loop3;	/* break out of the loop */\n";
		file << "        	    break;\n";
		file << "            }\n";
		file << "        }\n";
		file << "        loop3: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleVARIABLEEx; /* Prevent compiler warnings */\n";
		file << "    ruleVARIABLEEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end VARIABLE\n";
		file << "\n";
		file << "//   Comes from: 537:8: ( ( DIGIT )+ ( '.' ( DIGIT )+ )? )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start NUMBER\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token NUMBER\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mNUMBER(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = NUMBER;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:537:8: ( ( DIGIT )+ ( '.' ( DIGIT )+ )? )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:537:10: ( DIGIT )+ ( '.' ( DIGIT )+ )?\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:537:10: ( DIGIT )+\n";
		file << "        {\n";
		file << "            int cnt4=0;\n";
		file << "\n";
		file << "            for (;;)\n";
		file << "            {\n";
		file << "                int alt4=2;\n";
		file << "        	{\n";
		file << "        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	    */\n";
		file << "        	    int LA4_0 = LA(1);\n";
		file << "        	    if ( (((LA4_0 >= '0') && (LA4_0 <= '9'))) )\n";
		file << "        	    {\n";
		file << "        	        alt4=1;\n";
		file << "        	    }\n";
		file << "\n";
		file << "        	}\n";
		file << "        	switch (alt4)\n";
		file << "        	{\n";
		file << "        	    case 1:\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:537:10: DIGIT\n";
		file << "        	        {\n";
		file << "        	            /* 537:10: DIGIT */\n";
		file << "        	            mDIGIT(ctx );\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto ruleNUMBEREx;\n";
		file << "        	            }\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	        break;\n";
		file << "\n";
		file << "        	    default:\n";
		file << "\n";
		file << "        		if ( cnt4 >= 1 )\n";
		file << "        		{\n";
		file << "        		    goto loop4;\n";
		file << "        		}\n";
		file << "        		/* mismatchedSetEx()\n";
		file << "        		 */\n";
		file << "        		CONSTRUCTEX();\n";
		file << "        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "        		goto ruleNUMBEREx;\n";
		file << "        	}\n";
		file << "        	cnt4++;\n";
		file << "            }\n";
		file << "            loop4: ;	/* Jump to here if this rule does not match */\n";
		file << "        }\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:537:17: ( '.' ( DIGIT )+ )?\n";
		file << "        {\n";
		file << "            int alt6=2;\n";
		file << "            {\n";
		file << "                int LA6_0 = LA(1);\n";
		file << "                if ( (LA6_0 == '.') )\n";
		file << "                {\n";
		file << "                    alt6=1;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt6)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:537:18: '.' ( DIGIT )+\n";
		file << "        	    {\n";
		file << "        	        MATCHC('.');\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleNUMBEREx;\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:537:22: ( DIGIT )+\n";
		file << "        	        {\n";
		file << "        	            int cnt5=0;\n";
		file << "\n";
		file << "        	            for (;;)\n";
		file << "        	            {\n";
		file << "        	                int alt5=2;\n";
		file << "        	        	{\n";
		file << "        	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	        	    */\n";
		file << "        	        	    int LA5_0 = LA(1);\n";
		file << "        	        	    if ( (((LA5_0 >= '0') && (LA5_0 <= '9'))) )\n";
		file << "        	        	    {\n";
		file << "        	        	        alt5=1;\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "        	        	switch (alt5)\n";
		file << "        	        	{\n";
		file << "        	        	    case 1:\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:537:22: DIGIT\n";
		file << "        	        	        {\n";
		file << "        	        	            /* 537:22: DIGIT */\n";
		file << "        	        	            mDIGIT(ctx );\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto ruleNUMBEREx;\n";
		file << "        	        	            }\n";
		file << "\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "        	        	        break;\n";
		file << "\n";
		file << "        	        	    default:\n";
		file << "\n";
		file << "        	        		if ( cnt5 >= 1 )\n";
		file << "        	        		{\n";
		file << "        	        		    goto loop5;\n";
		file << "        	        		}\n";
		file << "        	        		/* mismatchedSetEx()\n";
		file << "        	        		 */\n";
		file << "        	        		CONSTRUCTEX();\n";
		file << "        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "        	        		goto ruleNUMBEREx;\n";
		file << "        	        	}\n";
		file << "        	        	cnt5++;\n";
		file << "        	            }\n";
		file << "        	            loop5: ;	/* Jump to here if this rule does not match */\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleNUMBEREx; /* Prevent compiler warnings */\n";
		file << "    ruleNUMBEREx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end NUMBER\n";
		file << "\n";
		file << "//   Comes from: 539:15: ( '0' .. '9' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start DIGIT\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token DIGIT\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mDIGIT(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:539:15: ( '0' .. '9' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:539:17: '0' .. '9'\n";
		file << "    {\n";
		file << "        MATCHRANGE('0', '9');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleDIGITEx;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleDIGITEx; /* Prevent compiler warnings */\n";
		file << "    ruleDIGITEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end DIGIT\n";
		file << "\n";
		file << "//   Comes from: 542:5: ( ';' (~ ( '\\\\n' | '\\\\r' ) )* ( '\\\\r' )? '\\\\n' )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start LINE_COMMENT\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token LINE_COMMENT\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mLINE_COMMENT(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = LINE_COMMENT;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:542:5: ( ';' (~ ( '\\\\n' | '\\\\r' ) )* ( '\\\\r' )? '\\\\n' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:542:7: ';' (~ ( '\\\\n' | '\\\\r' ) )* ( '\\\\r' )? '\\\\n'\n";
		file << "    {\n";
		file << "        MATCHC(';');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleLINE_COMMENTEx;\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:542:11: (~ ( '\\\\n' | '\\\\r' ) )*\n";
		file << "\n";
		file << "        for (;;)\n";
		file << "        {\n";
		file << "            int alt7=2;\n";
		file << "            {\n";
		file << "               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                */\n";
		file << "                int LA7_0 = LA(1);\n";
		file << "                if ( (((LA7_0 >= 0x0000) && (LA7_0 <= '\\t')) || ((LA7_0 >= 0x000B) && (LA7_0 <= '\\f')) || ((LA7_0 >= 0x000E) && (LA7_0 <= 0xFFFF))) )\n";
		file << "                {\n";
		file << "                    alt7=1;\n";
		file << "                }\n";
		file << "\n";
		file << "            }\n";
		file << "            switch (alt7)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:542:11: ~ ( '\\\\n' | '\\\\r' )\n";
		file << "        	    {\n";
		file << "        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )\n";
		file << "        	        {\n";
		file << "        	            CONSUME();\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	        else\n";
		file << "        	        {\n";
		file << "        	            CONSTRUCTEX();\n";
		file << "        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "\n";
		file << "        	            LRECOVER();    goto ruleLINE_COMMENTEx;\n";
		file << "        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "        	default:\n";
		file << "        	    goto loop7;	/* break out of the loop */\n";
		file << "        	    break;\n";
		file << "            }\n";
		file << "        }\n";
		file << "        loop7: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:542:25: ( '\\\\r' )?\n";
		file << "        {\n";
		file << "            int alt8=2;\n";
		file << "            {\n";
		file << "                int LA8_0 = LA(1);\n";
		file << "                if ( (LA8_0 == '\\r') )\n";
		file << "                {\n";
		file << "                    alt8=1;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt8)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:542:25: '\\\\r'\n";
		file << "        	    {\n";
		file << "        	        MATCHC('\\r');\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleLINE_COMMENTEx;\n";
		file << "        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "        MATCHC('\\n');\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleLINE_COMMENTEx;\n";
		file << "        }\n";
		file << "\n";
		file << "        {\n";
		file << "             LEXSTATE->channel = HIDDEN;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleLINE_COMMENTEx; /* Prevent compiler warnings */\n";
		file << "    ruleLINE_COMMENTEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end LINE_COMMENT\n";
		file << "\n";
		file << "//   Comes from: 546:5: ( ( ' ' | '\\\\t' | '\\\\r' | '\\\\n' )+ )\n";
		file << "/** \\brief Lexer rule generated by ANTLR3\n";
		file << " *\n";
		file << " * $ANTLR start WHITESPACE\n";
		file << " *\n";
		file << " * Looks to match the characters the constitute the token WHITESPACE\n";
		file << " * from the attached input stream.\n";
		file << " *\n";
		file << " *\n";
		file << " * \\remark\n";
		file << " *  - lexer->error == ANTLR3_TRUE if an exception was thrown.\n";
		file << " */\n";
		file << "static ANTLR3_INLINE\n";
		file << "void mWHITESPACE(pPddlLexer ctx)\n";
		file << "{\n";
		file << "	ANTLR3_UINT32	_type;\n";
		file << "\n";
		file << "    _type	    = WHITESPACE;\n";
		file << "\n";
		file << "\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:546:5: ( ( ' ' | '\\\\t' | '\\\\r' | '\\\\n' )+ )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:546:9: ( ' ' | '\\\\t' | '\\\\r' | '\\\\n' )+\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:546:9: ( ' ' | '\\\\t' | '\\\\r' | '\\\\n' )+\n";
		file << "        {\n";
		file << "            int cnt9=0;\n";
		file << "\n";
		file << "            for (;;)\n";
		file << "            {\n";
		file << "                int alt9=2;\n";
		file << "        	{\n";
		file << "        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	    */\n";
		file << "        	    int LA9_0 = LA(1);\n";
		file << "        	    if ( (((LA9_0 >= '\\t') && (LA9_0 <= '\\n')) || LA9_0 == '\\r' || LA9_0 == ' ') )\n";
		file << "        	    {\n";
		file << "        	        alt9=1;\n";
		file << "        	    }\n";
		file << "\n";
		file << "        	}\n";
		file << "        	switch (alt9)\n";
		file << "        	{\n";
		file << "        	    case 1:\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:\n";
		file << "        	        {\n";
		file << "        	            if ( ((LA(1) >= '\\t') && (LA(1) <= '\\n')) || LA(1) == '\\r' || LA(1) == ' ' )\n";
		file << "        	            {\n";
		file << "        	                CONSUME();\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            else\n";
		file << "        	            {\n";
		file << "        	                CONSTRUCTEX();\n";
		file << "        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "\n";
		file << "        	                LRECOVER();    goto ruleWHITESPACEEx;\n";
		file << "        	            }\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	        break;\n";
		file << "\n";
		file << "        	    default:\n";
		file << "\n";
		file << "        		if ( cnt9 >= 1 )\n";
		file << "        		{\n";
		file << "        		    goto loop9;\n";
		file << "        		}\n";
		file << "        		/* mismatchedSetEx()\n";
		file << "        		 */\n";
		file << "        		CONSTRUCTEX();\n";
		file << "        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "        		goto ruleWHITESPACEEx;\n";
		file << "        	}\n";
		file << "        	cnt9++;\n";
		file << "            }\n";
		file << "            loop9: ;	/* Jump to here if this rule does not match */\n";
		file << "        }\n";
		file << "        {\n";
		file << "             LEXSTATE->channel = HIDDEN;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "	LEXSTATE->type = _type;\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleWHITESPACEEx; /* Prevent compiler warnings */\n";
		file << "    ruleWHITESPACEEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end WHITESPACE\n";
		file << "\n";
		file << "/** This is the entry point in to the lexer from an object that\n";
		file << " *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM\n";
		file << " */\n";
		file << "static void\n";
		file << "mTokens(pPddlLexer ctx)\n";
		file << "{\n";
		file << "    {\n";
		file << "        //  ../../model/subgoal_learning/Pddl.g:1:8: ( T__54 | T__55 | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | T__81 | T__82 | T__83 | T__84 | T__85 | T__86 | T__87 | T__88 | T__89 | T__90 | T__91 | T__92 | T__93 | T__94 | T__95 | T__96 | T__97 | T__98 | T__99 | T__100 | T__101 | T__102 | T__103 | T__104 | T__105 | T__106 | T__107 | T__108 | T__109 | T__110 | T__111 | T__112 | T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | REQUIRE_KEY | NAME | VARIABLE | NUMBER | LINE_COMMENT | WHITESPACE )\n";
		file << "\n";
		file << "        ANTLR3_UINT32 alt10;\n";
		file << "\n";
		file << "        alt10=73;\n";
		file << "\n";
		file << "        alt10 = cdfa10.predict(ctx, RECOGNIZER, ISTREAM, &cdfa10);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto ruleTokensEx;\n";
		file << "        }\n";
		file << "\n";
		file << "        switch (alt10)\n";
		file << "        {\n";
		file << "    	case 1:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:10: T__54\n";
		file << "    	    {\n";
		file << "    	        /* 1:10: T__54 */\n";
		file << "    	        mT__54(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 2:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:16: T__55\n";
		file << "    	    {\n";
		file << "    	        /* 1:16: T__55 */\n";
		file << "    	        mT__55(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 3:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:22: T__56\n";
		file << "    	    {\n";
		file << "    	        /* 1:22: T__56 */\n";
		file << "    	        mT__56(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 4:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:28: T__57\n";
		file << "    	    {\n";
		file << "    	        /* 1:28: T__57 */\n";
		file << "    	        mT__57(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 5:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:34: T__58\n";
		file << "    	    {\n";
		file << "    	        /* 1:34: T__58 */\n";
		file << "    	        mT__58(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 6:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:40: T__59\n";
		file << "    	    {\n";
		file << "    	        /* 1:40: T__59 */\n";
		file << "    	        mT__59(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 7:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:46: T__60\n";
		file << "    	    {\n";
		file << "    	        /* 1:46: T__60 */\n";
		file << "    	        mT__60(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 8:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:52: T__61\n";
		file << "    	    {\n";
		file << "    	        /* 1:52: T__61 */\n";
		file << "    	        mT__61(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 9:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:58: T__62\n";
		file << "    	    {\n";
		file << "    	        /* 1:58: T__62 */\n";
		file << "    	        mT__62(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 10:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:64: T__63\n";
		file << "    	    {\n";
		file << "    	        /* 1:64: T__63 */\n";
		file << "    	        mT__63(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 11:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:70: T__64\n";
		file << "    	    {\n";
		file << "    	        /* 1:70: T__64 */\n";
		file << "    	        mT__64(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 12:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:76: T__65\n";
		file << "    	    {\n";
		file << "    	        /* 1:76: T__65 */\n";
		file << "    	        mT__65(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 13:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:82: T__66\n";
		file << "    	    {\n";
		file << "    	        /* 1:82: T__66 */\n";
		file << "    	        mT__66(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 14:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:88: T__67\n";
		file << "    	    {\n";
		file << "    	        /* 1:88: T__67 */\n";
		file << "    	        mT__67(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 15:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:94: T__68\n";
		file << "    	    {\n";
		file << "    	        /* 1:94: T__68 */\n";
		file << "    	        mT__68(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 16:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:100: T__69\n";
		file << "    	    {\n";
		file << "    	        /* 1:100: T__69 */\n";
		file << "    	        mT__69(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 17:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:106: T__70\n";
		file << "    	    {\n";
		file << "    	        /* 1:106: T__70 */\n";
		file << "    	        mT__70(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 18:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:112: T__71\n";
		file << "    	    {\n";
		file << "    	        /* 1:112: T__71 */\n";
		file << "    	        mT__71(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 19:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:118: T__72\n";
		file << "    	    {\n";
		file << "    	        /* 1:118: T__72 */\n";
		file << "    	        mT__72(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 20:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:124: T__73\n";
		file << "    	    {\n";
		file << "    	        /* 1:124: T__73 */\n";
		file << "    	        mT__73(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 21:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:130: T__74\n";
		file << "    	    {\n";
		file << "    	        /* 1:130: T__74 */\n";
		file << "    	        mT__74(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 22:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:136: T__75\n";
		file << "    	    {\n";
		file << "    	        /* 1:136: T__75 */\n";
		file << "    	        mT__75(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 23:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:142: T__76\n";
		file << "    	    {\n";
		file << "    	        /* 1:142: T__76 */\n";
		file << "    	        mT__76(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 24:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:148: T__77\n";
		file << "    	    {\n";
		file << "    	        /* 1:148: T__77 */\n";
		file << "    	        mT__77(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 25:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:154: T__78\n";
		file << "    	    {\n";
		file << "    	        /* 1:154: T__78 */\n";
		file << "    	        mT__78(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 26:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:160: T__79\n";
		file << "    	    {\n";
		file << "    	        /* 1:160: T__79 */\n";
		file << "    	        mT__79(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 27:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:166: T__80\n";
		file << "    	    {\n";
		file << "    	        /* 1:166: T__80 */\n";
		file << "    	        mT__80(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 28:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:172: T__81\n";
		file << "    	    {\n";
		file << "    	        /* 1:172: T__81 */\n";
		file << "    	        mT__81(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 29:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:178: T__82\n";
		file << "    	    {\n";
		file << "    	        /* 1:178: T__82 */\n";
		file << "    	        mT__82(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 30:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:184: T__83\n";
		file << "    	    {\n";
		file << "    	        /* 1:184: T__83 */\n";
		file << "    	        mT__83(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 31:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:190: T__84\n";
		file << "    	    {\n";
		file << "    	        /* 1:190: T__84 */\n";
		file << "    	        mT__84(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 32:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:196: T__85\n";
		file << "    	    {\n";
		file << "    	        /* 1:196: T__85 */\n";
		file << "    	        mT__85(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 33:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:202: T__86\n";
		file << "    	    {\n";
		file << "    	        /* 1:202: T__86 */\n";
		file << "    	        mT__86(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 34:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:208: T__87\n";
		file << "    	    {\n";
		file << "    	        /* 1:208: T__87 */\n";
		file << "    	        mT__87(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 35:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:214: T__88\n";
		file << "    	    {\n";
		file << "    	        /* 1:214: T__88 */\n";
		file << "    	        mT__88(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 36:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:220: T__89\n";
		file << "    	    {\n";
		file << "    	        /* 1:220: T__89 */\n";
		file << "    	        mT__89(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 37:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:226: T__90\n";
		file << "    	    {\n";
		file << "    	        /* 1:226: T__90 */\n";
		file << "    	        mT__90(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 38:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:232: T__91\n";
		file << "    	    {\n";
		file << "    	        /* 1:232: T__91 */\n";
		file << "    	        mT__91(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 39:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:238: T__92\n";
		file << "    	    {\n";
		file << "    	        /* 1:238: T__92 */\n";
		file << "    	        mT__92(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 40:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:244: T__93\n";
		file << "    	    {\n";
		file << "    	        /* 1:244: T__93 */\n";
		file << "    	        mT__93(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 41:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:250: T__94\n";
		file << "    	    {\n";
		file << "    	        /* 1:250: T__94 */\n";
		file << "    	        mT__94(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 42:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:256: T__95\n";
		file << "    	    {\n";
		file << "    	        /* 1:256: T__95 */\n";
		file << "    	        mT__95(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 43:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:262: T__96\n";
		file << "    	    {\n";
		file << "    	        /* 1:262: T__96 */\n";
		file << "    	        mT__96(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 44:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:268: T__97\n";
		file << "    	    {\n";
		file << "    	        /* 1:268: T__97 */\n";
		file << "    	        mT__97(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 45:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:274: T__98\n";
		file << "    	    {\n";
		file << "    	        /* 1:274: T__98 */\n";
		file << "    	        mT__98(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 46:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:280: T__99\n";
		file << "    	    {\n";
		file << "    	        /* 1:280: T__99 */\n";
		file << "    	        mT__99(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 47:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:286: T__100\n";
		file << "    	    {\n";
		file << "    	        /* 1:286: T__100 */\n";
		file << "    	        mT__100(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 48:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:293: T__101\n";
		file << "    	    {\n";
		file << "    	        /* 1:293: T__101 */\n";
		file << "    	        mT__101(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 49:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:300: T__102\n";
		file << "    	    {\n";
		file << "    	        /* 1:300: T__102 */\n";
		file << "    	        mT__102(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 50:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:307: T__103\n";
		file << "    	    {\n";
		file << "    	        /* 1:307: T__103 */\n";
		file << "    	        mT__103(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 51:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:314: T__104\n";
		file << "    	    {\n";
		file << "    	        /* 1:314: T__104 */\n";
		file << "    	        mT__104(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 52:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:321: T__105\n";
		file << "    	    {\n";
		file << "    	        /* 1:321: T__105 */\n";
		file << "    	        mT__105(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 53:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:328: T__106\n";
		file << "    	    {\n";
		file << "    	        /* 1:328: T__106 */\n";
		file << "    	        mT__106(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 54:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:335: T__107\n";
		file << "    	    {\n";
		file << "    	        /* 1:335: T__107 */\n";
		file << "    	        mT__107(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 55:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:342: T__108\n";
		file << "    	    {\n";
		file << "    	        /* 1:342: T__108 */\n";
		file << "    	        mT__108(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 56:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:349: T__109\n";
		file << "    	    {\n";
		file << "    	        /* 1:349: T__109 */\n";
		file << "    	        mT__109(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 57:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:356: T__110\n";
		file << "    	    {\n";
		file << "    	        /* 1:356: T__110 */\n";
		file << "    	        mT__110(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 58:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:363: T__111\n";
		file << "    	    {\n";
		file << "    	        /* 1:363: T__111 */\n";
		file << "    	        mT__111(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 59:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:370: T__112\n";
		file << "    	    {\n";
		file << "    	        /* 1:370: T__112 */\n";
		file << "    	        mT__112(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 60:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:377: T__113\n";
		file << "    	    {\n";
		file << "    	        /* 1:377: T__113 */\n";
		file << "    	        mT__113(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 61:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:384: T__114\n";
		file << "    	    {\n";
		file << "    	        /* 1:384: T__114 */\n";
		file << "    	        mT__114(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 62:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:391: T__115\n";
		file << "    	    {\n";
		file << "    	        /* 1:391: T__115 */\n";
		file << "    	        mT__115(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 63:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:398: T__116\n";
		file << "    	    {\n";
		file << "    	        /* 1:398: T__116 */\n";
		file << "    	        mT__116(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 64:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:405: T__117\n";
		file << "    	    {\n";
		file << "    	        /* 1:405: T__117 */\n";
		file << "    	        mT__117(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 65:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:412: T__118\n";
		file << "    	    {\n";
		file << "    	        /* 1:412: T__118 */\n";
		file << "    	        mT__118(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 66:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:419: T__119\n";
		file << "    	    {\n";
		file << "    	        /* 1:419: T__119 */\n";
		file << "    	        mT__119(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 67:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:426: T__120\n";
		file << "    	    {\n";
		file << "    	        /* 1:426: T__120 */\n";
		file << "    	        mT__120(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 68:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:433: REQUIRE_KEY\n";
		file << "    	    {\n";
		file << "    	        /* 1:433: REQUIRE_KEY */\n";
		file << "    	        mREQUIRE_KEY(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 69:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:445: NAME\n";
		file << "    	    {\n";
		file << "    	        /* 1:445: NAME */\n";
		file << "    	        mNAME(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 70:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:450: VARIABLE\n";
		file << "    	    {\n";
		file << "    	        /* 1:450: VARIABLE */\n";
		file << "    	        mVARIABLE(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 71:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:459: NUMBER\n";
		file << "    	    {\n";
		file << "    	        /* 1:459: NUMBER */\n";
		file << "    	        mNUMBER(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 72:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:466: LINE_COMMENT\n";
		file << "    	    {\n";
		file << "    	        /* 1:466: LINE_COMMENT */\n";
		file << "    	        mLINE_COMMENT(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "    	case 73:\n";
		file << "    	    // ../../model/subgoal_learning/Pddl.g:1:479: WHITESPACE\n";
		file << "    	    {\n";
		file << "    	        /* 1:479: WHITESPACE */\n";
		file << "    	        mWHITESPACE(ctx );\n";
		file << "    	        if  (HASEXCEPTION())\n";
		file << "    	        {\n";
		file << "    	            goto ruleTokensEx;\n";
		file << "    	        }\n";
		file << "\n";
		file << "\n";
		file << "    	    }\n";
		file << "    	    break;\n";
		file << "\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    goto ruleTokensEx; /* Prevent compiler warnings */\n";
		file << "ruleTokensEx: ;\n";
		file << "}\n";
		file << "\n";
		file << "/* =========================================================================\n";
		file << " * Lexer matching rules end.\n";
		file << " * =========================================================================\n";
		file << " */\n";
		file << "/* End of Lexer code\n";
		file << " * ================================================\n";
		file << " * ================================================\n";
		file << " */\n";
		file << "\n";
		file << "#pragma GCC diagnostic pop\n";
		file << "\n";
		file << "/* End of code\n";
		file << " * =============================================================================\n";
		file << " */\n";
		file.close ();
	}



	{
		ofstream file ("PddlLexer.h", ios_base::out);
		file << "/** \\file\n";
		file << " *  This C header file was generated by $ANTLR version 3.1.3 Mar 17, 2009 19:23:44\n";
		file << " *\n";
		file << " *     -  From the grammar source file : ../../model/subgoal_learning/Pddl.g\n";
		file << " *     -                            On : 2011-12-04 10:25:06\n";
		file << " *     -                 for the lexer : PddlLexerLexer *\n";
		file << " * Editing it, at least manually, is not wise.\n";
		file << " *\n";
		file << " * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.\n";
		file << " *\n";
		file << " *\n";
		file << " * The lexer PddlLexer has the callable functions (rules) shown below,\n";
		file << " * which will invoke the code for the associated rule in the source grammar\n";
		file << " * assuming that the input stream is pointing to a token/text stream that could begin\n";
		file << " * this rule.\n";
		file << " *\n";
		file << " * For instance if you call the first (topmost) rule in a parser grammar, you will\n";
		file << " * get the results of a full parse, but calling a rule half way through the grammar will\n";
		file << " * allow you to pass part of a full token stream to the parser, such as for syntax checking\n";
		file << " * in editors and so on.\n";
		file << " *\n";
		file << " * The parser entry points are called indirectly (by function pointer to function) via\n";
		file << " * a parser context typedef pPddlLexer, which is returned from a call to PddlLexerNew().\n";
		file << " *\n";
		file << " * As this is a generated lexer, it is unlikely you will call it 'manually'. However\n";
		file << " * the methods are provided anyway.\n";
		file << " * * The methods in pPddlLexer are  as follows:\n";
		file << " *\n";
		file << " *  -  void      pPddlLexer->T__54(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__55(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__56(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__57(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__58(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__59(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__60(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__61(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__62(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__63(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__64(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__65(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__66(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__67(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__68(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__69(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__70(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__71(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__72(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__73(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__74(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__75(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__76(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__77(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__78(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__79(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__80(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__81(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__82(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__83(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__84(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__85(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__86(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__87(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__88(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__89(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__90(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__91(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__92(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__93(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__94(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__95(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__96(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__97(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__98(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__99(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__100(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__101(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__102(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__103(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__104(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__105(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__106(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__107(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__108(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__109(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__110(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__111(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__112(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__113(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__114(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__115(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__116(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__117(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__118(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__119(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->T__120(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->REQUIRE_KEY(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->NAME(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->LETTER(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->ANY_CHAR(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->VARIABLE(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->NUMBER(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->DIGIT(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->LINE_COMMENT(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->WHITESPACE(pPddlLexer)\n";
		file << " *  -  void      pPddlLexer->Tokens(pPddlLexer)\n";
		file << " *\n";
		file << " * The return type for any particular rule is of course determined by the source\n";
		file << " * grammar file.\n";
		file << " */\n";
		file << "// [The \"BSD licence\"]\n";
		file << "// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC\n";
		file << "// http://www.temporal-wave.com\n";
		file << "// http://www.linkedin.com/in/jimidle\n";
		file << "//\n";
		file << "// All rights reserved.\n";
		file << "//\n";
		file << "// Redistribution and use in source and binary forms, with or without\n";
		file << "// modification, are permitted provided that the following conditions\n";
		file << "// are met:\n";
		file << "// 1. Redistributions of source code must retain the above copyright\n";
		file << "//    notice, this list of conditions and the following disclaimer.\n";
		file << "// 2. Redistributions in binary form must reproduce the above copyright\n";
		file << "//    notice, this list of conditions and the following disclaimer in the\n";
		file << "//    documentation and/or other materials provided with the distribution.\n";
		file << "// 3. The name of the author may not be used to endorse or promote products\n";
		file << "//    derived from this software without specific prior written permission.\n";
		file << "//\n";
		file << "// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n";
		file << "// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n";
		file << "// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n";
		file << "// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n";
		file << "// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n";
		file << "// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n";
		file << "// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n";
		file << "// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n";
		file << "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n";
		file << "// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n";
		file << "\n";
		file << "#ifndef	_PddlLexer_H\n";
		file << "#define _PddlLexer_H\n";
		file << "/* =============================================================================\n";
		file << " * Standard antlr3 C runtime definitions\n";
		file << " */\n";
		file << "#include    <antlr3.h>\n";
		file << "\n";
		file << "/* End of standard antlr 3 runtime definitions\n";
		file << " * =============================================================================\n";
		file << " */\n";
		file << "\n";
		file << "#ifdef __cplusplus\n";
		file << "extern \"C\" {\n";
		file << "#endif\n";
		file << "\n";
		file << "// Forward declare the context typedef so that we can use it before it is\n";
		file << "// properly defined. Delegators and delegates (from import statements) are\n";
		file << "// interdependent and their context structures contain pointers to each other\n";
		file << "// C only allows such things to be declared if you pre-declare the typedef.\n";
		file << "//\n";
		file << "typedef struct PddlLexer_Ctx_struct PddlLexer, * pPddlLexer;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "#ifdef	ANTLR3_WINDOWS\n";
		file << "// Disable: Unreferenced parameter,							- Rules with parameters that are not used\n";
		file << "//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)\n";
		file << "//          initialized but unused variable					- tree rewrite variables declared but not needed\n";
		file << "//          Unreferenced local variable						- lexer rule declares but does not always use _type\n";
		file << "//          potentially unitialized variable used			- retval always returned from a rule\n";
		file << "//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns\n";
		file << "//\n";
		file << "// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at\n";
		file << "// and the codegen must generate some of these warnings by necessity, apart from 4100, which is\n";
		file << "// usually generated when a parser rule is given a parameter that it does not use. Mostly though\n";
		file << "// this is a matter of orthogonality hence I disable that one.\n";
		file << "//\n";
		file << "#pragma warning( disable : 4100 )\n";
		file << "#pragma warning( disable : 4101 )\n";
		file << "#pragma warning( disable : 4127 )\n";
		file << "#pragma warning( disable : 4189 )\n";
		file << "#pragma warning( disable : 4505 )\n";
		file << "#pragma warning( disable : 4701 )\n";
		file << "#endif\n";
		file << "\n";
		file << "/** Context tracking structure for PddlLexer\n";
		file << " */\n";
		file << "struct PddlLexer_Ctx_struct\n";
		file << "{\n";
		file << "    /** Built in ANTLR3 context tracker contains all the generic elements\n";
		file << "     *  required for context tracking.\n";
		file << "     */\n";
		file << "    pANTLR3_LEXER    pLexer;\n";
		file << "\n";
		file << "\n";
		file << "     void (*mT__54)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__55)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__56)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__57)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__58)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__59)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__60)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__61)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__62)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__63)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__64)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__65)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__66)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__67)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__68)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__69)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__70)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__71)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__72)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__73)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__74)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__75)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__76)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__77)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__78)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__79)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__80)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__81)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__82)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__83)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__84)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__85)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__86)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__87)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__88)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__89)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__90)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__91)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__92)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__93)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__94)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__95)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__96)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__97)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__98)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__99)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__100)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__101)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__102)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__103)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__104)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__105)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__106)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__107)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__108)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__109)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__110)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__111)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__112)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__113)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__114)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__115)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__116)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__117)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__118)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__119)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mT__120)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mREQUIRE_KEY)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mNAME)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mLETTER)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mANY_CHAR)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mVARIABLE)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mNUMBER)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mDIGIT)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mLINE_COMMENT)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mWHITESPACE)	(struct PddlLexer_Ctx_struct * ctx);\n";
		file << "     void (*mTokens)	(struct PddlLexer_Ctx_struct * ctx);    const char * (*getGrammarFileName)();\n";
		file << "    void	    (*free)   (struct PddlLexer_Ctx_struct * ctx);\n";
		file << "\n";
		file << "};\n";
		file << "\n";
		file << "// Function protoypes for the constructor functions that external translation units\n";
		file << "// such as delegators and delegates may wish to call.\n";
		file << "//\n";
		file << "ANTLR3_API pPddlLexer PddlLexerNew         (pANTLR3_INPUT_STREAM instream);\n";
		file << "ANTLR3_API pPddlLexer PddlLexerNewSSD      (pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state);\n";
		file << "\n";
		file << "/** Symbolic definitions of all the tokens that the lexer will work with.\n";
		file << " * \\{\n";
		file << " *\n";
		file << " * Antlr will define EOF, but we can't use that as it it is too common in\n";
		file << " * in C header files and that would be confusing. There is no way to filter this out at the moment\n";
		file << " * so we just undef it here for now. That isn't the value we get back from C recognizers\n";
		file << " * anyway. We are looking for ANTLR3_TOKEN_EOF.\n";
		file << " */\n";
		file << "#ifdef	EOF\n";
		file << "#undef	EOF\n";
		file << "#endif\n";
		file << "#ifdef	Tokens\n";
		file << "#undef	Tokens\n";
		file << "#endif\n";
		file << "#define REQUIRE_KEY      46\n";
		file << "#define FUNCTIONS      10\n";
		file << "#define LETTER      49\n";
		file << "#define PRED_INST      42\n";
		file << "#define TYPES      7\n";
		file << "#define EXISTS_GD      27\n";
		file << "#define EOF      -1\n";
		file << "#define COMPARISON_GD      29\n";
		file << "#define ACTION      13\n";
		file << "#define T__93      93\n";
		file << "#define ANY_CHAR      50\n";
		file << "#define T__94      94\n";
		file << "#define NOT_EFFECT      34\n";
		file << "#define T__91      91\n";
		file << "#define NAME      45\n";
		file << "#define T__92      92\n";
		file << "#define T__90      90\n";
		file << "#define OBJECTS      18\n";
		file << "#define PROBLEM_DOMAIN      17\n";
		file << "#define ASSIGN_EFFECT      33\n";
		file << "#define T__99      99\n";
		file << "#define T__98      98\n";
		file << "#define T__97      97\n";
		file << "#define T__96      96\n";
		file << "#define T__95      95\n";
		file << "#define T__80      80\n";
		file << "#define T__81      81\n";
		file << "#define T__82      82\n";
		file << "#define T__83      83\n";
		file << "#define LINE_COMMENT      52\n";
		file << "#define PROBLEM      15\n";
		file << "#define NUMBER      48\n";
		file << "#define WHITESPACE      53\n";
		file << "#define UNARY_MINUS      38\n";
		file << "#define OR_GD      24\n";
		file << "#define T__85      85\n";
		file << "#define T__84      84\n";
		file << "#define T__87      87\n";
		file << "#define T__86      86\n";
		file << "#define T__89      89\n";
		file << "#define T__88      88\n";
		file << "#define DOMAIN_NAME      5\n";
		file << "#define PRED_HEAD      35\n";
		file << "#define T__71      71\n";
		file << "#define T__72      72\n";
		file << "#define PREDICATES      11\n";
		file << "#define VARIABLE      47\n";
		file << "#define T__70      70\n";
		file << "#define INIT_AT      40\n";
		file << "#define T__76      76\n";
		file << "#define T__75      75\n";
		file << "#define T__74      74\n";
		file << "#define INIT      19\n";
		file << "#define T__73      73\n";
		file << "#define T__79      79\n";
		file << "#define T__78      78\n";
		file << "#define T__77      77\n";
		file << "#define AND_GD      23\n";
		file << "#define T__68      68\n";
		file << "#define T__69      69\n";
		file << "#define T__66      66\n";
		file << "#define T__67      67\n";
		file << "#define T__64      64\n";
		file << "#define FUNC_HEAD      20\n";
		file << "#define T__65      65\n";
		file << "#define T__62      62\n";
		file << "#define T__63      63\n";
		file << "#define PARAMETERS      12\n";
		file << "#define NOT_GD      25\n";
		file << "#define PROBLEM_NAME      16\n";
		file << "#define T__118      118\n";
		file << "#define DURATIVE_ACTION      14\n";
		file << "#define T__119      119\n";
		file << "#define T__116      116\n";
		file << "#define T__117      117\n";
		file << "#define T__114      114\n";
		file << "#define T__115      115\n";
		file << "#define PROBLEM_METRIC      44\n";
		file << "#define T__120      120\n";
		file << "#define CONSTANTS      9\n";
		file << "#define T__61      61\n";
		file << "#define T__60      60\n";
		file << "#define T__55      55\n";
		file << "#define T__56      56\n";
		file << "#define T__57      57\n";
		file << "#define T__58      58\n";
		file << "#define T__54      54\n";
		file << "#define IMPLY_GD      26\n";
		file << "#define T__107      107\n";
		file << "#define T__108      108\n";
		file << "#define T__109      109\n";
		file << "#define T__103      103\n";
		file << "#define T__59      59\n";
		file << "#define T__104      104\n";
		file << "#define T__105      105\n";
		file << "#define T__106      106\n";
		file << "#define T__111      111\n";
		file << "#define T__110      110\n";
		file << "#define T__113      113\n";
		file << "#define T__112      112\n";
		file << "#define INIT_EQ      39\n";
		file << "#define DIGIT      51\n";
		file << "#define NOT_PRED_INIT      41\n";
		file << "#define GOAL      36\n";
		file << "#define BINARY_OP      37\n";
		file << "#define FORALL_GD      28\n";
		file << "#define T__102      102\n";
		file << "#define T__101      101\n";
		file << "#define T__100      100\n";
		file << "#define DOMAIN      4\n";
		file << "#define WHEN_EFFECT      32\n";
		file << "#define PRECONDITION      21\n";
		file << "#define EFFECT      22\n";
		file << "#define AND_EFFECT      30\n";
		file << "#define PROBLEM_CONSTRAINT      43\n";
		file << "#define EITHER_TYPE      8\n";
		file << "#define FORALL_EFFECT      31\n";
		file << "#define REQUIREMENTS      6\n";
		file << "#ifdef	EOF\n";
		file << "#undef	EOF\n";
		file << "#define	EOF	ANTLR3_TOKEN_EOF\n";
		file << "#endif\n";
		file << "\n";
		file << "#ifndef TOKENSOURCE\n";
		file << "#define TOKENSOURCE(lxr) lxr->pLexer->rec->state->tokSource\n";
		file << "#endif\n";
		file << "\n";
		file << "/* End of token definitions for PddlLexer\n";
		file << " * =============================================================================\n";
		file << " */\n";
		file << "/** \\} */\n";
		file << "\n";
		file << "#ifdef __cplusplus\n";
		file << "}\n";
		file << "#endif\n";
		file << "\n";
		file << "#endif\n";
		file << "\n";
		file << "/* END - Note:Keep extra line feed to satisfy UNIX systems */\n";
		file.close ();
	}



	{
		ofstream file ("PddlParser.c", ios_base::out);
		file << "/** \\file\n";
		file << " *  This C source file was generated by $ANTLR version 3.1.3 Mar 17, 2009 19:23:44\n";
		file << " *\n";
		file << " *     -  From the grammar source file : ../../model/subgoal_learning/Pddl.g\n";
		file << " *     -                            On : 2011-12-04 10:25:05\n";
		file << " *     -                for the parser : PddlParserParser *\n";
		file << " * Editing it, at least manually, is not wise.\n";
		file << " *\n";
		file << " * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.\n";
		file << " *\n";
		file << " *\n";
		file << "*/\n";
		file << "// [The \"BSD licence\"]\n";
		file << "// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC\n";
		file << "// http://www.temporal-wave.com\n";
		file << "// http://www.linkedin.com/in/jimidle\n";
		file << "//\n";
		file << "// All rights reserved.\n";
		file << "//\n";
		file << "// Redistribution and use in source and binary forms, with or without\n";
		file << "// modification, are permitted provided that the following conditions\n";
		file << "// are met:\n";
		file << "// 1. Redistributions of source code must retain the above copyright\n";
		file << "//    notice, this list of conditions and the following disclaimer.\n";
		file << "// 2. Redistributions in binary form must reproduce the above copyright\n";
		file << "//    notice, this list of conditions and the following disclaimer in the\n";
		file << "//    documentation and/or other materials provided with the distribution.\n";
		file << "// 3. The name of the author may not be used to endorse or promote products\n";
		file << "//    derived from this software without specific prior written permission.\n";
		file << "//\n";
		file << "// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n";
		file << "// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n";
		file << "// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n";
		file << "// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n";
		file << "// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n";
		file << "// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n";
		file << "// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n";
		file << "// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n";
		file << "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n";
		file << "// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n";
		file << "\n";
		file << "/* -----------------------------------------\n";
		file << " * Include the ANTLR3 generated header file.\n";
		file << " */\n";
		file << "\n";
		file << "#pragma GCC diagnostic ignored \"-Wunused-but-set-variable\"\n";
		file << "#pragma GCC diagnostic ignored \"-Wunused-variable\"\n";
		file << "#pragma GCC diagnostic ignored \"-Wunused-function\"\n";
		file << "\n";
		file << "#include    \"PddlParser.h\"\n";
		file << "/* ----------------------------------------- */\n";
		file << "\n";
		file << "/**\n";
		file << " * PDDL grammar for ANTLR v3\n";
		file << " * Zeyn Saigol\n";
		file << " * School of Computer Science\n";
		file << " * University of Birmingham\n";
		file << " *\n";
		file << " * $Id: Pddl.g 120 2008-10-02 14:59:50Z zas $\n";
		file << " */\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "/* MACROS that hide the C interface implementations from the\n";
		file << " * generated code, which makes it a little more understandable to the human eye.\n";
		file << " * I am very much against using C pre-processor macros for function calls and bits\n";
		file << " * of code as you cannot see what is happening when single stepping in debuggers\n";
		file << " * and so on. The exception (in my book at least) is for generated code, where you are\n";
		file << " * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()\n";
		file << " * hides some indirect calls, but is always referring to the input stream. This is\n";
		file << " * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig\n";
		file << " * the runtime interfaces without changing the generated code too often, without\n";
		file << " * confusing the reader of the generated output, who may not wish to know the gory\n";
		file << " * details of the interface inheritance.\n";
		file << " */\n";
		file << "\n";
		file << "#define		CTX	ctx\n";
		file << "\n";
		file << "/* Aids in accessing scopes for grammar programmers\n";
		file << " */\n";
		file << "#undef	SCOPE_TYPE\n";
		file << "#undef	SCOPE_STACK\n";
		file << "#undef	SCOPE_TOP\n";
		file << "#define	SCOPE_TYPE(scope)   pPddlParser_##scope##_SCOPE\n";
		file << "#define SCOPE_STACK(scope)  pPddlParser_##scope##Stack\n";
		file << "#define	SCOPE_TOP(scope)    ctx->pPddlParser_##scope##Top\n";
		file << "#define	SCOPE_SIZE(scope)			(ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope)))\n";
		file << "#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))\n";
		file << "\n";
		file << "/* Macros for accessing things in the parser\n";
		file << " */\n";
		file << "\n";
		file << "#undef	    PARSER\n";
		file << "#undef	    RECOGNIZER\n";
		file << "#undef	    HAVEPARSEDRULE\n";
		file << "#undef		MEMOIZE\n";
		file << "#undef	    INPUT\n";
		file << "#undef	    STRSTREAM\n";
		file << "#undef	    HASEXCEPTION\n";
		file << "#undef	    EXCEPTION\n";
		file << "#undef	    MATCHT\n";
		file << "#undef	    MATCHANYT\n";
		file << "#undef	    FOLLOWSTACK\n";
		file << "#undef	    FOLLOWPUSH\n";
		file << "#undef	    FOLLOWPOP\n";
		file << "#undef	    PRECOVER\n";
		file << "#undef	    PREPORTERROR\n";
		file << "#undef	    LA\n";
		file << "#undef	    LT\n";
		file << "#undef	    CONSTRUCTEX\n";
		file << "#undef	    CONSUME\n";
		file << "#undef	    MARK\n";
		file << "#undef	    REWIND\n";
		file << "#undef	    REWINDLAST\n";
		file << "#undef	    PERRORRECOVERY\n";
		file << "#undef	    HASFAILED\n";
		file << "#undef	    FAILEDFLAG\n";
		file << "#undef	    RECOVERFROMMISMATCHEDSET\n";
		file << "#undef	    RECOVERFROMMISMATCHEDELEMENT\n";
		file << "#undef		INDEX\n";
		file << "#undef      ADAPTOR\n";
		file << "#undef		SEEK\n";
		file << "#undef	    RULEMEMO\n";
		file << "#undef		DBG\n";
		file << "\n";
		file << "#define	    PARSER							ctx->pParser\n";
		file << "#define	    RECOGNIZER						PARSER->rec\n";
		file << "#define		PSRSTATE						RECOGNIZER->state\n";
		file << "#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)\n";
		file << "#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)\n";
		file << "#define	    INPUT							PARSER->tstream\n";
		file << "#define	    STRSTREAM						INPUT\n";
		file << "#define		ISTREAM							INPUT->istream\n";
		file << "#define		INDEX()							ISTREAM->index(INPUT->istream)\n";
		file << "#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)\n";
		file << "#define	    EXCEPTION						PSRSTATE->exception\n";
		file << "#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)\n";
		file << "#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)\n";
		file << "#define	    FOLLOWSTACK					    PSRSTATE->following\n";
		file << "#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)\n";
		file << "#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)\n";
		file << "#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)\n";
		file << "#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)\n";
		file << "#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)\n";
		file << "#define	    LT(n)							INPUT->_LT(INPUT, n)\n";
		file << "#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)\n";
		file << "#define	    CONSUME()						ISTREAM->consume(ISTREAM)\n";
		file << "#define	    MARK()							ISTREAM->mark(ISTREAM)\n";
		file << "#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)\n";
		file << "#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)\n";
		file << "#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)\n";
		file << "#define	    PERRORRECOVERY					PSRSTATE->errorRecovery\n";
		file << "#define	    FAILEDFLAG						PSRSTATE->failed\n";
		file << "#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)\n";
		file << "#define	    BACKTRACKING					PSRSTATE->backtracking\n";
		file << "#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)\n";
		file << "#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)\n";
		file << "#define     ADAPTOR                         ctx->adaptor\n";
		file << "#define		RULEMEMO						PSRSTATE->ruleMemo\n";
		file << "#define		DBG								RECOGNIZER->debugger\n";
		file << "\n";
		file << "#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt\n";
		file << "\n";
		file << "/* The 4 tokens defined below may well clash with your own #defines or token types. If so\n";
		file << " * then for the present you must use different names for your defines as these are hard coded\n";
		file << " * in the code generator. It would be better not to use such names internally, and maybe\n";
		file << " * we can change this in a forthcoming release. I deliberately do not #undef these\n";
		file << " * here as this will at least give you a redefined error somewhere if they clash.\n";
		file << " */\n";
		file << "#define	    UP	    ANTLR3_TOKEN_UP\n";
		file << "#define	    DOWN    ANTLR3_TOKEN_DOWN\n";
		file << "#define	    EOR	    ANTLR3_TOKEN_EOR\n";
		file << "#define	    INVALID ANTLR3_TOKEN_INVALID\n";
		file << "\n";
		file << "\n";
		file << "/* =============================================================================\n";
		file << " * Functions to create and destroy scopes. First come the rule scopes, followed\n";
		file << " * by the global declared scopes.\n";
		file << " */\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "/* ============================================================================= */\n";
		file << "\n";
		file << "/* =============================================================================\n";
		file << " * Start of recognizer\n";
		file << " */\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "/** \\brief Table of all token names in symbolic order, mainly used for\n";
		file << " *         error reporting.\n";
		file << " */\n";
		file << "pANTLR3_UINT8   PddlParserTokenNames[117+4]\n";
		file << "     = {\n";
		file << "        (pANTLR3_UINT8) \"<invalid>\",       /* String to print to indicate an invalid token */\n";
		file << "        (pANTLR3_UINT8) \"<EOR>\",\n";
		file << "        (pANTLR3_UINT8) \"<DOWN>\",\n";
		file << "        (pANTLR3_UINT8) \"<UP>\",\n";
		file << "        (pANTLR3_UINT8) \"DOMAIN\",\n";
		file << "        (pANTLR3_UINT8) \"DOMAIN_NAME\",\n";
		file << "        (pANTLR3_UINT8) \"REQUIREMENTS\",\n";
		file << "        (pANTLR3_UINT8) \"TYPES\",\n";
		file << "        (pANTLR3_UINT8) \"EITHER_TYPE\",\n";
		file << "        (pANTLR3_UINT8) \"CONSTANTS\",\n";
		file << "        (pANTLR3_UINT8) \"FUNCTIONS\",\n";
		file << "        (pANTLR3_UINT8) \"PREDICATES\",\n";
		file << "        (pANTLR3_UINT8) \"PARAMETERS\",\n";
		file << "        (pANTLR3_UINT8) \"ACTION\",\n";
		file << "        (pANTLR3_UINT8) \"DURATIVE_ACTION\",\n";
		file << "        (pANTLR3_UINT8) \"PROBLEM\",\n";
		file << "        (pANTLR3_UINT8) \"PROBLEM_NAME\",\n";
		file << "        (pANTLR3_UINT8) \"PROBLEM_DOMAIN\",\n";
		file << "        (pANTLR3_UINT8) \"OBJECTS\",\n";
		file << "        (pANTLR3_UINT8) \"INIT\",\n";
		file << "        (pANTLR3_UINT8) \"FUNC_HEAD\",\n";
		file << "        (pANTLR3_UINT8) \"PRECONDITION\",\n";
		file << "        (pANTLR3_UINT8) \"EFFECT\",\n";
		file << "        (pANTLR3_UINT8) \"AND_GD\",\n";
		file << "        (pANTLR3_UINT8) \"OR_GD\",\n";
		file << "        (pANTLR3_UINT8) \"NOT_GD\",\n";
		file << "        (pANTLR3_UINT8) \"IMPLY_GD\",\n";
		file << "        (pANTLR3_UINT8) \"EXISTS_GD\",\n";
		file << "        (pANTLR3_UINT8) \"FORALL_GD\",\n";
		file << "        (pANTLR3_UINT8) \"COMPARISON_GD\",\n";
		file << "        (pANTLR3_UINT8) \"AND_EFFECT\",\n";
		file << "        (pANTLR3_UINT8) \"FORALL_EFFECT\",\n";
		file << "        (pANTLR3_UINT8) \"WHEN_EFFECT\",\n";
		file << "        (pANTLR3_UINT8) \"ASSIGN_EFFECT\",\n";
		file << "        (pANTLR3_UINT8) \"NOT_EFFECT\",\n";
		file << "        (pANTLR3_UINT8) \"PRED_HEAD\",\n";
		file << "        (pANTLR3_UINT8) \"GOAL\",\n";
		file << "        (pANTLR3_UINT8) \"BINARY_OP\",\n";
		file << "        (pANTLR3_UINT8) \"UNARY_MINUS\",\n";
		file << "        (pANTLR3_UINT8) \"INIT_EQ\",\n";
		file << "        (pANTLR3_UINT8) \"INIT_AT\",\n";
		file << "        (pANTLR3_UINT8) \"NOT_PRED_INIT\",\n";
		file << "        (pANTLR3_UINT8) \"PRED_INST\",\n";
		file << "        (pANTLR3_UINT8) \"PROBLEM_CONSTRAINT\",\n";
		file << "        (pANTLR3_UINT8) \"PROBLEM_METRIC\",\n";
		file << "        (pANTLR3_UINT8) \"NAME\",\n";
		file << "        (pANTLR3_UINT8) \"REQUIRE_KEY\",\n";
		file << "        (pANTLR3_UINT8) \"VARIABLE\",\n";
		file << "        (pANTLR3_UINT8) \"NUMBER\",\n";
		file << "        (pANTLR3_UINT8) \"LETTER\",\n";
		file << "        (pANTLR3_UINT8) \"ANY_CHAR\",\n";
		file << "        (pANTLR3_UINT8) \"DIGIT\",\n";
		file << "        (pANTLR3_UINT8) \"LINE_COMMENT\",\n";
		file << "        (pANTLR3_UINT8) \"WHITESPACE\",\n";
		file << "        (pANTLR3_UINT8) \"'('\",\n";
		file << "        (pANTLR3_UINT8) \"'define'\",\n";
		file << "        (pANTLR3_UINT8) \"')'\",\n";
		file << "        (pANTLR3_UINT8) \"'domain'\",\n";
		file << "        (pANTLR3_UINT8) \"':requirements'\",\n";
		file << "        (pANTLR3_UINT8) \"':types'\",\n";
		file << "        (pANTLR3_UINT8) \"'-'\",\n";
		file << "        (pANTLR3_UINT8) \"'either'\",\n";
		file << "        (pANTLR3_UINT8) \"':functions'\",\n";
		file << "        (pANTLR3_UINT8) \"'number'\",\n";
		file << "        (pANTLR3_UINT8) \"':constants'\",\n";
		file << "        (pANTLR3_UINT8) \"':predicates'\",\n";
		file << "        (pANTLR3_UINT8) \"':constraints'\",\n";
		file << "        (pANTLR3_UINT8) \"':action'\",\n";
		file << "        (pANTLR3_UINT8) \"':parameters'\",\n";
		file << "        (pANTLR3_UINT8) \"':precondition'\",\n";
		file << "        (pANTLR3_UINT8) \"':effect'\",\n";
		file << "        (pANTLR3_UINT8) \"'and'\",\n";
		file << "        (pANTLR3_UINT8) \"'or'\",\n";
		file << "        (pANTLR3_UINT8) \"'not'\",\n";
		file << "        (pANTLR3_UINT8) \"'imply'\",\n";
		file << "        (pANTLR3_UINT8) \"'exists'\",\n";
		file << "        (pANTLR3_UINT8) \"'forall'\",\n";
		file << "        (pANTLR3_UINT8) \"':durative-action'\",\n";
		file << "        (pANTLR3_UINT8) \"':duration'\",\n";
		file << "        (pANTLR3_UINT8) \"':condition'\",\n";
		file << "        (pANTLR3_UINT8) \"'preference'\",\n";
		file << "        (pANTLR3_UINT8) \"'at'\",\n";
		file << "        (pANTLR3_UINT8) \"'over'\",\n";
		file << "        (pANTLR3_UINT8) \"'start'\",\n";
		file << "        (pANTLR3_UINT8) \"'end'\",\n";
		file << "        (pANTLR3_UINT8) \"'all'\",\n";
		file << "        (pANTLR3_UINT8) \"':derived'\",\n";
		file << "        (pANTLR3_UINT8) \"'when'\",\n";
		file << "        (pANTLR3_UINT8) \"'*'\",\n";
		file << "        (pANTLR3_UINT8) \"'+'\",\n";
		file << "        (pANTLR3_UINT8) \"'/'\",\n";
		file << "        (pANTLR3_UINT8) \"'>'\",\n";
		file << "        (pANTLR3_UINT8) \"'<'\",\n";
		file << "        (pANTLR3_UINT8) \"'='\",\n";
		file << "        (pANTLR3_UINT8) \"'>='\",\n";
		file << "        (pANTLR3_UINT8) \"'<='\",\n";
		file << "        (pANTLR3_UINT8) \"'assign'\",\n";
		file << "        (pANTLR3_UINT8) \"'scale-up'\",\n";
		file << "        (pANTLR3_UINT8) \"'scale-down'\",\n";
		file << "        (pANTLR3_UINT8) \"'increase'\",\n";
		file << "        (pANTLR3_UINT8) \"'decrease'\",\n";
		file << "        (pANTLR3_UINT8) \"'?duration'\",\n";
		file << "        (pANTLR3_UINT8) \"'problem'\",\n";
		file << "        (pANTLR3_UINT8) \"':domain'\",\n";
		file << "        (pANTLR3_UINT8) \"':objects'\",\n";
		file << "        (pANTLR3_UINT8) \"':init'\",\n";
		file << "        (pANTLR3_UINT8) \"':goal'\",\n";
		file << "        (pANTLR3_UINT8) \"':metric'\",\n";
		file << "        (pANTLR3_UINT8) \"'minimize'\",\n";
		file << "        (pANTLR3_UINT8) \"'maximize'\",\n";
		file << "        (pANTLR3_UINT8) \"'total-time'\",\n";
		file << "        (pANTLR3_UINT8) \"'is-violated'\",\n";
		file << "        (pANTLR3_UINT8) \"'always'\",\n";
		file << "        (pANTLR3_UINT8) \"'sometime'\",\n";
		file << "        (pANTLR3_UINT8) \"'within'\",\n";
		file << "        (pANTLR3_UINT8) \"'at-most-once'\",\n";
		file << "        (pANTLR3_UINT8) \"'sometime-after'\",\n";
		file << "        (pANTLR3_UINT8) \"'sometime-before'\",\n";
		file << "        (pANTLR3_UINT8) \"'always-within'\",\n";
		file << "        (pANTLR3_UINT8) \"'hold-during'\",\n";
		file << "        (pANTLR3_UINT8) \"'hold-after'\"\n";
		file << "       };\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "// Forward declare the locally static matching functions we have generated.\n";
		file << "//\n";
		file << "static PddlParser_getDomain_return	getDomain    (pPddlParser ctx);\n";
		file << "static PddlParser_getProblem_return	getProblem    (pPddlParser ctx);\n";
		file << "static PddlParser_pddlDoc_return	pddlDoc    (pPddlParser ctx);\n";
		file << "static PddlParser_domain_return	domain    (pPddlParser ctx);\n";
		file << "static PddlParser_domainName_return	domainName    (pPddlParser ctx);\n";
		file << "static PddlParser_requireDef_return	requireDef    (pPddlParser ctx);\n";
		file << "static PddlParser_typesDef_return	typesDef    (pPddlParser ctx);\n";
		file << "static PddlParser_typedNameList_return	typedNameList    (pPddlParser ctx);\n";
		file << "static PddlParser_singleTypeNameList_return	singleTypeNameList    (pPddlParser ctx);\n";
		file << "static PddlParser_type_return	type    (pPddlParser ctx);\n";
		file << "static PddlParser_primType_return	primType    (pPddlParser ctx);\n";
		file << "static PddlParser_functionsDef_return	functionsDef    (pPddlParser ctx);\n";
		file << "static PddlParser_functionList_return	functionList    (pPddlParser ctx);\n";
		file << "static PddlParser_atomicFunctionSkeleton_return	atomicFunctionSkeleton    (pPddlParser ctx);\n";
		file << "static PddlParser_functionSymbol_return	functionSymbol    (pPddlParser ctx);\n";
		file << "static PddlParser_functionType_return	functionType    (pPddlParser ctx);\n";
		file << "static PddlParser_constantsDef_return	constantsDef    (pPddlParser ctx);\n";
		file << "static PddlParser_predicatesDef_return	predicatesDef    (pPddlParser ctx);\n";
		file << "static PddlParser_atomicFormulaSkeleton_return	atomicFormulaSkeleton    (pPddlParser ctx);\n";
		file << "static PddlParser_predicate_return	predicate    (pPddlParser ctx);\n";
		file << "static PddlParser_typedVariableList_return	typedVariableList    (pPddlParser ctx);\n";
		file << "static PddlParser_singleTypeVarList_return	singleTypeVarList    (pPddlParser ctx);\n";
		file << "static PddlParser_constraints_return	constraints    (pPddlParser ctx);\n";
		file << "static PddlParser_structureDef_return	structureDef    (pPddlParser ctx);\n";
		file << "static PddlParser_actionDef_return	actionDef    (pPddlParser ctx);\n";
		file << "static PddlParser_actionSymbol_return	actionSymbol    (pPddlParser ctx);\n";
		file << "static PddlParser_actionDefBody_return	actionDefBody    (pPddlParser ctx);\n";
		file << "static PddlParser_goalDesc_return	goalDesc    (pPddlParser ctx);\n";
		file << "static PddlParser_fComp_return	fComp    (pPddlParser ctx);\n";
		file << "static PddlParser_atomicTermFormula_return	atomicTermFormula    (pPddlParser ctx);\n";
		file << "static PddlParser_term_return	term    (pPddlParser ctx);\n";
		file << "static PddlParser_durativeActionDef_return	durativeActionDef    (pPddlParser ctx);\n";
		file << "static PddlParser_daDefBody_return	daDefBody    (pPddlParser ctx);\n";
		file << "static PddlParser_daGD_return	daGD    (pPddlParser ctx);\n";
		file << "static PddlParser_prefTimedGD_return	prefTimedGD    (pPddlParser ctx);\n";
		file << "static PddlParser_timedGD_return	timedGD    (pPddlParser ctx);\n";
		file << "static PddlParser_timeSpecifier_return	timeSpecifier    (pPddlParser ctx);\n";
		file << "static PddlParser_interval_return	interval    (pPddlParser ctx);\n";
		file << "static PddlParser_derivedDef_return	derivedDef    (pPddlParser ctx);\n";
		file << "static PddlParser_fExp_return	fExp    (pPddlParser ctx);\n";
		file << "static PddlParser_fExp2_return	fExp2    (pPddlParser ctx);\n";
		file << "static PddlParser_fHead_return	fHead    (pPddlParser ctx);\n";
		file << "static PddlParser_effect_return	effect    (pPddlParser ctx);\n";
		file << "static PddlParser_cEffect_return	cEffect    (pPddlParser ctx);\n";
		file << "static PddlParser_pEffect_return	pEffect    (pPddlParser ctx);\n";
		file << "static PddlParser_condEffect_return	condEffect    (pPddlParser ctx);\n";
		file << "static PddlParser_binaryOp_return	binaryOp    (pPddlParser ctx);\n";
		file << "static PddlParser_binaryComp_return	binaryComp    (pPddlParser ctx);\n";
		file << "static PddlParser_assignOp_return	assignOp    (pPddlParser ctx);\n";
		file << "static PddlParser_durationConstraint_return	durationConstraint    (pPddlParser ctx);\n";
		file << "static PddlParser_simpleDurationConstraint_return	simpleDurationConstraint    (pPddlParser ctx);\n";
		file << "static PddlParser_durOp_return	durOp    (pPddlParser ctx);\n";
		file << "static PddlParser_durValue_return	durValue    (pPddlParser ctx);\n";
		file << "static PddlParser_daEffect_return	daEffect    (pPddlParser ctx);\n";
		file << "static PddlParser_timedEffect_return	timedEffect    (pPddlParser ctx);\n";
		file << "static PddlParser_fAssignDA_return	fAssignDA    (pPddlParser ctx);\n";
		file << "static PddlParser_fExpDA_return	fExpDA    (pPddlParser ctx);\n";
		file << "static PddlParser_problem_return	problem    (pPddlParser ctx);\n";
		file << "static PddlParser_problemDecl_return	problemDecl    (pPddlParser ctx);\n";
		file << "static PddlParser_problemDomain_return	problemDomain    (pPddlParser ctx);\n";
		file << "static PddlParser_objectDecl_return	objectDecl    (pPddlParser ctx);\n";
		file << "static PddlParser_init_return	init    (pPddlParser ctx);\n";
		file << "static PddlParser_initEl_return	initEl    (pPddlParser ctx);\n";
		file << "static PddlParser_nameLiteral_return	nameLiteral    (pPddlParser ctx);\n";
		file << "static PddlParser_atomicNameFormula_return	atomicNameFormula    (pPddlParser ctx);\n";
		file << "static PddlParser_goal_return	goal    (pPddlParser ctx);\n";
		file << "static PddlParser_probConstraints_return	probConstraints    (pPddlParser ctx);\n";
		file << "static PddlParser_prefConGD_return	prefConGD    (pPddlParser ctx);\n";
		file << "static PddlParser_metricSpec_return	metricSpec    (pPddlParser ctx);\n";
		file << "static PddlParser_optimization_return	optimization    (pPddlParser ctx);\n";
		file << "static PddlParser_metricFExp_return	metricFExp    (pPddlParser ctx);\n";
		file << "static PddlParser_conGD_return	conGD    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred19_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred58_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred59_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred60_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred88_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred90_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred91_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred92_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred93_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred94_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred95_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred96_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred97_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred109_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred110_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred112_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred114_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred117_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred118_Pddl    (pPddlParser ctx);\n";
		file << "static ANTLR3_BOOLEAN	synpred121_Pddl    (pPddlParser ctx);\n";
		file << "static void	PddlParserFree(pPddlParser ctx);\n";
		file << "/* For use in tree output where we are accumulating rule labels via label += ruleRef\n";
		file << " * we need a function that knows how to free a return scope when the list is destroyed.\n";
		file << " * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.\n";
		file << " */\n";
		file << "static	void ANTLR3_CDECL freeScope(void * scope)\n";
		file << "{\n";
		file << "    ANTLR3_FREE(scope);\n";
		file << "}\n";
		file << "\n";
		file << "/** \\brief Name of the grammar file that generated this code\n";
		file << " */\n";
		file << "static const char fileName[] = \"Pddl.g\";\n";
		file << "\n";
		file << "/** \\brief Return the name of the grammar file that generated this code.\n";
		file << " */\n";
		file << "static const char * getGrammarFileName()\n";
		file << "{\n";
		file << "	return fileName;\n";
		file << "}\n";
		file << "/** \\brief Create a new PddlParser parser and return a context for it.\n";
		file << " *\n";
		file << " * \\param[in] instream Pointer to an input stream interface.\n";
		file << " *\n";
		file << " * \\return Pointer to new parser context upon success.\n";
		file << " */\n";
		file << "ANTLR3_API pPddlParser\n";
		file << "PddlParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)\n";
		file << "{\n";
		file << "	// See if we can create a new parser with the standard constructor\n";
		file << "	//\n";
		file << "	return PddlParserNewSSD(instream, NULL);\n";
		file << "}\n";
		file << "\n";
		file << "/** \\brief Create a new PddlParser parser and return a context for it.\n";
		file << " *\n";
		file << " * \\param[in] instream Pointer to an input stream interface.\n";
		file << " *\n";
		file << " * \\return Pointer to new parser context upon success.\n";
		file << " */\n";
		file << "ANTLR3_API pPddlParser\n";
		file << "PddlParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)\n";
		file << "{\n";
		file << "    pPddlParser ctx;	    /* Context structure we will build and return   */\n";
		file << "\n";
		file << "    ctx	= (pPddlParser) ANTLR3_CALLOC(1, sizeof(PddlParser));\n";
		file << "\n";
		file << "    if	(ctx == NULL)\n";
		file << "    {\n";
		file << "		// Failed to allocate memory for parser context\n";
		file << "		//\n";
		file << "        return  NULL;\n";
		file << "    }\n";
		file << "\n";
		file << "    /* -------------------------------------------------------------------\n";
		file << "     * Memory for basic structure is allocated, now to fill in\n";
		file << "     * the base ANTLR3 structures. We initialize the function pointers\n";
		file << "     * for the standard ANTLR3 parser function set, but upon return\n";
		file << "     * from here, the programmer may set the pointers to provide custom\n";
		file << "     * implementations of each function.\n";
		file << "     *\n";
		file << "     * We don't use the macros defined in PddlParser.h here, in order that you can get a sense\n";
		file << "     * of what goes where.\n";
		file << "     */\n";
		file << "\n";
		file << "    /* Create a base parser/recognizer, using the supplied token stream\n";
		file << "     */\n";
		file << "    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);\n";
		file << "    /* Install the implementation of our PddlParser interface\n";
		file << "     */\n";
		file << "    ctx->getDomain	= getDomain;\n";
		file << "    ctx->getProblem	= getProblem;\n";
		file << "    ctx->pddlDoc	= pddlDoc;\n";
		file << "    ctx->domain	= domain;\n";
		file << "    ctx->domainName	= domainName;\n";
		file << "    ctx->requireDef	= requireDef;\n";
		file << "    ctx->typesDef	= typesDef;\n";
		file << "    ctx->typedNameList	= typedNameList;\n";
		file << "    ctx->singleTypeNameList	= singleTypeNameList;\n";
		file << "    ctx->type	= type;\n";
		file << "    ctx->primType	= primType;\n";
		file << "    ctx->functionsDef	= functionsDef;\n";
		file << "    ctx->functionList	= functionList;\n";
		file << "    ctx->atomicFunctionSkeleton	= atomicFunctionSkeleton;\n";
		file << "    ctx->functionSymbol	= functionSymbol;\n";
		file << "    ctx->functionType	= functionType;\n";
		file << "    ctx->constantsDef	= constantsDef;\n";
		file << "    ctx->predicatesDef	= predicatesDef;\n";
		file << "    ctx->atomicFormulaSkeleton	= atomicFormulaSkeleton;\n";
		file << "    ctx->predicate	= predicate;\n";
		file << "    ctx->typedVariableList	= typedVariableList;\n";
		file << "    ctx->singleTypeVarList	= singleTypeVarList;\n";
		file << "    ctx->constraints	= constraints;\n";
		file << "    ctx->structureDef	= structureDef;\n";
		file << "    ctx->actionDef	= actionDef;\n";
		file << "    ctx->actionSymbol	= actionSymbol;\n";
		file << "    ctx->actionDefBody	= actionDefBody;\n";
		file << "    ctx->goalDesc	= goalDesc;\n";
		file << "    ctx->fComp	= fComp;\n";
		file << "    ctx->atomicTermFormula	= atomicTermFormula;\n";
		file << "    ctx->term	= term;\n";
		file << "    ctx->durativeActionDef	= durativeActionDef;\n";
		file << "    ctx->daDefBody	= daDefBody;\n";
		file << "    ctx->daGD	= daGD;\n";
		file << "    ctx->prefTimedGD	= prefTimedGD;\n";
		file << "    ctx->timedGD	= timedGD;\n";
		file << "    ctx->timeSpecifier	= timeSpecifier;\n";
		file << "    ctx->interval	= interval;\n";
		file << "    ctx->derivedDef	= derivedDef;\n";
		file << "    ctx->fExp	= fExp;\n";
		file << "    ctx->fExp2	= fExp2;\n";
		file << "    ctx->fHead	= fHead;\n";
		file << "    ctx->effect	= effect;\n";
		file << "    ctx->cEffect	= cEffect;\n";
		file << "    ctx->pEffect	= pEffect;\n";
		file << "    ctx->condEffect	= condEffect;\n";
		file << "    ctx->binaryOp	= binaryOp;\n";
		file << "    ctx->binaryComp	= binaryComp;\n";
		file << "    ctx->assignOp	= assignOp;\n";
		file << "    ctx->durationConstraint	= durationConstraint;\n";
		file << "    ctx->simpleDurationConstraint	= simpleDurationConstraint;\n";
		file << "    ctx->durOp	= durOp;\n";
		file << "    ctx->durValue	= durValue;\n";
		file << "    ctx->daEffect	= daEffect;\n";
		file << "    ctx->timedEffect	= timedEffect;\n";
		file << "    ctx->fAssignDA	= fAssignDA;\n";
		file << "    ctx->fExpDA	= fExpDA;\n";
		file << "    ctx->problem	= problem;\n";
		file << "    ctx->problemDecl	= problemDecl;\n";
		file << "    ctx->problemDomain	= problemDomain;\n";
		file << "    ctx->objectDecl	= objectDecl;\n";
		file << "    ctx->init	= init;\n";
		file << "    ctx->initEl	= initEl;\n";
		file << "    ctx->nameLiteral	= nameLiteral;\n";
		file << "    ctx->atomicNameFormula	= atomicNameFormula;\n";
		file << "    ctx->goal	= goal;\n";
		file << "    ctx->probConstraints	= probConstraints;\n";
		file << "    ctx->prefConGD	= prefConGD;\n";
		file << "    ctx->metricSpec	= metricSpec;\n";
		file << "    ctx->optimization	= optimization;\n";
		file << "    ctx->metricFExp	= metricFExp;\n";
		file << "    ctx->conGD	= conGD;\n";
		file << "    ctx->synpred19_Pddl	= synpred19_Pddl;\n";
		file << "    ctx->synpred58_Pddl	= synpred58_Pddl;\n";
		file << "    ctx->synpred59_Pddl	= synpred59_Pddl;\n";
		file << "    ctx->synpred60_Pddl	= synpred60_Pddl;\n";
		file << "    ctx->synpred88_Pddl	= synpred88_Pddl;\n";
		file << "    ctx->synpred90_Pddl	= synpred90_Pddl;\n";
		file << "    ctx->synpred91_Pddl	= synpred91_Pddl;\n";
		file << "    ctx->synpred92_Pddl	= synpred92_Pddl;\n";
		file << "    ctx->synpred93_Pddl	= synpred93_Pddl;\n";
		file << "    ctx->synpred94_Pddl	= synpred94_Pddl;\n";
		file << "    ctx->synpred95_Pddl	= synpred95_Pddl;\n";
		file << "    ctx->synpred96_Pddl	= synpred96_Pddl;\n";
		file << "    ctx->synpred97_Pddl	= synpred97_Pddl;\n";
		file << "    ctx->synpred109_Pddl	= synpred109_Pddl;\n";
		file << "    ctx->synpred110_Pddl	= synpred110_Pddl;\n";
		file << "    ctx->synpred112_Pddl	= synpred112_Pddl;\n";
		file << "    ctx->synpred114_Pddl	= synpred114_Pddl;\n";
		file << "    ctx->synpred117_Pddl	= synpred117_Pddl;\n";
		file << "    ctx->synpred118_Pddl	= synpred118_Pddl;\n";
		file << "    ctx->synpred121_Pddl	= synpred121_Pddl;\n";
		file << "    ctx->free			= PddlParserFree;\n";
		file << "    ctx->getGrammarFileName	= getGrammarFileName;\n";
		file << "\n";
		file << "    /* Install the scope pushing methods.\n";
		file << "     */\n";
		file << "    ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);\n";
		file << "    ctx->vectors	= antlr3VectorFactoryNew(0);\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    /* Install the token table\n";
		file << "     */\n";
		file << "    PSRSTATE->tokenNames   = PddlParserTokenNames;\n";
		file << "\n";
		file << "\n";
		file << "    /* Return the newly built parser to the caller\n";
		file << "     */\n";
		file << "    return  ctx;\n";
		file << "}\n";
		file << "\n";
		file << "/** Free the parser resources\n";
		file << " */\n";
		file << " static void\n";
		file << " PddlParserFree(pPddlParser ctx)\n";
		file << " {\n";
		file << "    /* Free any scope memory\n";
		file << "     */\n";
		file << "\n";
		file << "    ctx->vectors->close(ctx->vectors);\n";
		file << "    /* We created the adaptor so we must free it\n";
		file << "     */\n";
		file << "    ADAPTOR->free(ADAPTOR);\n";
		file << "	// Free this parser\n";
		file << "	//\n";
		file << "    ctx->pParser->free(ctx->pParser);\n";
		file << "    ANTLR3_FREE(ctx);\n";
		file << "\n";
		file << "    /* Everything is released, so we can return\n";
		file << "     */\n";
		file << "    return;\n";
		file << " }\n";
		file << "\n";
		file << "/** Return token names used by this parser\n";
		file << " *\n";
		file << " * The returned pointer is used as an index into the token names table (using the token\n";
		file << " * number as the index).\n";
		file << " *\n";
		file << " * \\return Pointer to first char * in the table.\n";
		file << " */\n";
		file << "static pANTLR3_UINT8    *getTokenNames()\n";
		file << "{\n";
		file << "        return PddlParserTokenNames;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "/* Declare the bitsets\n";
		file << " */\n";
		file << "\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_domain_in_getDomain284  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_domain_in_getDomain284_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_domain_in_getDomain284	= { FOLLOW_domain_in_getDomain284_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_problem_in_getProblem298  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_problem_in_getProblem298_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_problem_in_getProblem298	= { FOLLOW_problem_in_getProblem298_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_domain_in_pddlDoc343  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_domain_in_pddlDoc343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_domain_in_pddlDoc343	= { FOLLOW_domain_in_pddlDoc343_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_problem_in_pddlDoc347  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_problem_in_pddlDoc347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_problem_in_pddlDoc347	= { FOLLOW_problem_in_pddlDoc347_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_domain362  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_domain362_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_domain362	= { FOLLOW_54_in_domain362_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_domain364  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_55_in_domain364_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_55_in_domain364	= { FOLLOW_55_in_domain364_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_domainName_in_domain366  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_domainName_in_domain366_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_domainName_in_domain366	= { FOLLOW_domainName_in_domain366_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_requireDef_in_domain374  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_requireDef_in_domain374_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_requireDef_in_domain374	= { FOLLOW_requireDef_in_domain374_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typesDef_in_domain383  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typesDef_in_domain383_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typesDef_in_domain383	= { FOLLOW_typesDef_in_domain383_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_constantsDef_in_domain392  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_constantsDef_in_domain392_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_constantsDef_in_domain392	= { FOLLOW_constantsDef_in_domain392_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicatesDef_in_domain401  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_predicatesDef_in_domain401_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_predicatesDef_in_domain401	= { FOLLOW_predicatesDef_in_domain401_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionsDef_in_domain410  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_functionsDef_in_domain410_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_functionsDef_in_domain410	= { FOLLOW_functionsDef_in_domain410_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_constraints_in_domain419  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_constraints_in_domain419_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_constraints_in_domain419	= { FOLLOW_constraints_in_domain419_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_structureDef_in_domain428  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_structureDef_in_domain428_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_structureDef_in_domain428	= { FOLLOW_structureDef_in_domain428_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_domain437  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_domain437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_domain437	= { FOLLOW_56_in_domain437_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_domainName521  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_domainName521_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_domainName521	= { FOLLOW_54_in_domainName521_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_57_in_domainName523  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_57_in_domainName523_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_57_in_domainName523	= { FOLLOW_57_in_domainName523_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_domainName525  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_domainName525_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_domainName525	= { FOLLOW_NAME_in_domainName525_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_domainName527  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_domainName527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_domainName527	= { FOLLOW_56_in_domainName527_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_requireDef554  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_requireDef554_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_requireDef554	= { FOLLOW_54_in_requireDef554_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_requireDef556  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_58_in_requireDef556_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_58_in_requireDef556	= { FOLLOW_58_in_requireDef556_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_REQUIRE_KEY_in_requireDef558  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_REQUIRE_KEY_in_requireDef558_bits[]	= { ANTLR3_UINT64_LIT(0x0100400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_REQUIRE_KEY_in_requireDef558	= { FOLLOW_REQUIRE_KEY_in_requireDef558_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_requireDef561  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_requireDef561_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_requireDef561	= { FOLLOW_56_in_requireDef561_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_typesDef582  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_typesDef582_bits[]	= { ANTLR3_UINT64_LIT(0x0800000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_typesDef582	= { FOLLOW_54_in_typesDef582_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_typesDef584  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_59_in_typesDef584_bits[]	= { ANTLR3_UINT64_LIT(0x0100200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_59_in_typesDef584	= { FOLLOW_59_in_typesDef584_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedNameList_in_typesDef586  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedNameList_in_typesDef586_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedNameList_in_typesDef586	= { FOLLOW_typedNameList_in_typesDef586_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_typesDef588  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_typesDef588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_typesDef588	= { FOLLOW_56_in_typesDef588_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_typedNameList615  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_typedNameList615_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_typedNameList615	= { FOLLOW_NAME_in_typedNameList615_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_singleTypeNameList_in_typedNameList620  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_singleTypeNameList_in_typedNameList620_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_singleTypeNameList_in_typedNameList620	= { FOLLOW_singleTypeNameList_in_typedNameList620_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_typedNameList623  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_typedNameList623_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_typedNameList623	= { FOLLOW_NAME_in_typedNameList623_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_singleTypeNameList643  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_singleTypeNameList643_bits[]	= { ANTLR3_UINT64_LIT(0x1000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_singleTypeNameList643	= { FOLLOW_NAME_in_singleTypeNameList643_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_singleTypeNameList646  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_60_in_singleTypeNameList646_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_60_in_singleTypeNameList646	= { FOLLOW_60_in_singleTypeNameList646_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_singleTypeNameList650  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_type_in_singleTypeNameList650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_type_in_singleTypeNameList650	= { FOLLOW_type_in_singleTypeNameList650_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_type677  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_type677_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_type677	= { FOLLOW_54_in_type677_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_61_in_type679  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_61_in_type679_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_61_in_type679	= { FOLLOW_61_in_type679_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_primType_in_type681  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_primType_in_type681_bits[]	= { ANTLR3_UINT64_LIT(0x0140200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_primType_in_type681	= { FOLLOW_primType_in_type681_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_type684  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_type684_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_type684	= { FOLLOW_56_in_type684_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_primType_in_type703  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_primType_in_type703_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_primType_in_type703	= { FOLLOW_primType_in_type703_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_primType713  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_primType713_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_primType713	= { FOLLOW_NAME_in_primType713_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_functionsDef723  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_functionsDef723_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_functionsDef723	= { FOLLOW_54_in_functionsDef723_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_62_in_functionsDef725  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_62_in_functionsDef725_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_62_in_functionsDef725	= { FOLLOW_62_in_functionsDef725_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionList_in_functionsDef727  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_functionList_in_functionsDef727_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_functionList_in_functionsDef727	= { FOLLOW_functionList_in_functionsDef727_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_functionsDef729  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_functionsDef729_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_functionsDef729	= { FOLLOW_56_in_functionsDef729_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicFunctionSkeleton_in_functionList750  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_atomicFunctionSkeleton_in_functionList750_bits[]	= { ANTLR3_UINT64_LIT(0x1040000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_atomicFunctionSkeleton_in_functionList750	= { FOLLOW_atomicFunctionSkeleton_in_functionList750_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_functionList754  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_60_in_functionList754_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_60_in_functionList754	= { FOLLOW_60_in_functionList754_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionType_in_functionList756  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_functionType_in_functionList756_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_functionType_in_functionList756	= { FOLLOW_functionType_in_functionList756_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_atomicFunctionSkeleton772  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_atomicFunctionSkeleton772_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_atomicFunctionSkeleton772	= { FOLLOW_54_in_atomicFunctionSkeleton772_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionSymbol_in_atomicFunctionSkeleton775  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_functionSymbol_in_atomicFunctionSkeleton775_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_functionSymbol_in_atomicFunctionSkeleton775	= { FOLLOW_functionSymbol_in_atomicFunctionSkeleton775_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_atomicFunctionSkeleton778  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_atomicFunctionSkeleton778_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_atomicFunctionSkeleton778	= { FOLLOW_typedVariableList_in_atomicFunctionSkeleton778_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_atomicFunctionSkeleton780  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_atomicFunctionSkeleton780_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_atomicFunctionSkeleton780	= { FOLLOW_56_in_atomicFunctionSkeleton780_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_functionSymbol791  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_functionSymbol791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_functionSymbol791	= { FOLLOW_NAME_in_functionSymbol791_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_63_in_functionType800  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_63_in_functionType800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_63_in_functionType800	= { FOLLOW_63_in_functionType800_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_constantsDef811  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_constantsDef811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_constantsDef811	= { FOLLOW_54_in_constantsDef811_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_64_in_constantsDef813  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_64_in_constantsDef813_bits[]	= { ANTLR3_UINT64_LIT(0x0100200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_64_in_constantsDef813	= { FOLLOW_64_in_constantsDef813_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedNameList_in_constantsDef815  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedNameList_in_constantsDef815_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedNameList_in_constantsDef815	= { FOLLOW_typedNameList_in_constantsDef815_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_constantsDef817  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_constantsDef817_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_constantsDef817	= { FOLLOW_56_in_constantsDef817_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_predicatesDef837  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_predicatesDef837_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_predicatesDef837	= { FOLLOW_54_in_predicatesDef837_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_65_in_predicatesDef839  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_65_in_predicatesDef839_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_65_in_predicatesDef839	= { FOLLOW_65_in_predicatesDef839_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicFormulaSkeleton_in_predicatesDef841  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_atomicFormulaSkeleton_in_predicatesDef841_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_atomicFormulaSkeleton_in_predicatesDef841	= { FOLLOW_atomicFormulaSkeleton_in_predicatesDef841_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_predicatesDef844  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_predicatesDef844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_predicatesDef844	= { FOLLOW_56_in_predicatesDef844_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_atomicFormulaSkeleton865  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_atomicFormulaSkeleton865_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_atomicFormulaSkeleton865	= { FOLLOW_54_in_atomicFormulaSkeleton865_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicate_in_atomicFormulaSkeleton868  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_predicate_in_atomicFormulaSkeleton868_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_predicate_in_atomicFormulaSkeleton868	= { FOLLOW_predicate_in_atomicFormulaSkeleton868_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_atomicFormulaSkeleton871  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_atomicFormulaSkeleton871_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_atomicFormulaSkeleton871	= { FOLLOW_typedVariableList_in_atomicFormulaSkeleton871_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_atomicFormulaSkeleton873  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_atomicFormulaSkeleton873_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_atomicFormulaSkeleton873	= { FOLLOW_56_in_atomicFormulaSkeleton873_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_predicate884  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_predicate884_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_predicate884	= { FOLLOW_NAME_in_predicate884_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_typedVariableList899  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_typedVariableList899_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_typedVariableList899	= { FOLLOW_VARIABLE_in_typedVariableList899_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_singleTypeVarList_in_typedVariableList904  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_singleTypeVarList_in_typedVariableList904_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_singleTypeVarList_in_typedVariableList904	= { FOLLOW_singleTypeVarList_in_typedVariableList904_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_typedVariableList907  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_typedVariableList907_bits[]	= { ANTLR3_UINT64_LIT(0x0000800000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_typedVariableList907	= { FOLLOW_VARIABLE_in_typedVariableList907_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_singleTypeVarList927  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_singleTypeVarList927_bits[]	= { ANTLR3_UINT64_LIT(0x1000800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_singleTypeVarList927	= { FOLLOW_VARIABLE_in_singleTypeVarList927_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_singleTypeVarList930  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_60_in_singleTypeVarList930_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_60_in_singleTypeVarList930	= { FOLLOW_60_in_singleTypeVarList930_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_type_in_singleTypeVarList934  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_type_in_singleTypeVarList934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_type_in_singleTypeVarList934	= { FOLLOW_type_in_singleTypeVarList934_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_constraints965  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_constraints965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_constraints965	= { FOLLOW_54_in_constraints965_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_66_in_constraints968  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_66_in_constraints968_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_66_in_constraints968	= { FOLLOW_66_in_constraints968_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_conGD_in_constraints971  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_conGD_in_constraints971_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_conGD_in_constraints971	= { FOLLOW_conGD_in_constraints971_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_constraints973  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_constraints973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_constraints973	= { FOLLOW_56_in_constraints973_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_actionDef_in_structureDef985  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_actionDef_in_structureDef985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_actionDef_in_structureDef985	= { FOLLOW_actionDef_in_structureDef985_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_durativeActionDef_in_structureDef990  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_durativeActionDef_in_structureDef990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_durativeActionDef_in_structureDef990	= { FOLLOW_durativeActionDef_in_structureDef990_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_derivedDef_in_structureDef995  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_derivedDef_in_structureDef995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_derivedDef_in_structureDef995	= { FOLLOW_derivedDef_in_structureDef995_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_actionDef1010  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_actionDef1010_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_actionDef1010	= { FOLLOW_54_in_actionDef1010_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_67_in_actionDef1012  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_67_in_actionDef1012_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_67_in_actionDef1012	= { FOLLOW_67_in_actionDef1012_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_actionSymbol_in_actionDef1014  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_actionSymbol_in_actionDef1014_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000), ANTLR3_UINT64_LIT(0x0000000000000070) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_actionSymbol_in_actionDef1014	= { FOLLOW_actionSymbol_in_actionDef1014_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_actionDefBody_in_actionDef1027  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_actionDefBody_in_actionDef1027_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_actionDefBody_in_actionDef1027	= { FOLLOW_actionDefBody_in_actionDef1027_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_actionDef1029  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_actionDef1029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_actionDef1029	= { FOLLOW_56_in_actionDef1029_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_actionSymbol1059  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_actionSymbol1059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_actionSymbol1059	= { FOLLOW_NAME_in_actionSymbol1059_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_68_in_actionDefBody1075  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_68_in_actionDefBody1075_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_68_in_actionDefBody1075	= { FOLLOW_68_in_actionDefBody1075_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_actionDefBody1077  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_actionDefBody1077_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_actionDefBody1077	= { FOLLOW_54_in_actionDefBody1077_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_actionDefBody1079  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_actionDefBody1079_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_actionDefBody1079	= { FOLLOW_typedVariableList_in_actionDefBody1079_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_actionDefBody1081  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_actionDefBody1081_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000060) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_actionDefBody1081	= { FOLLOW_56_in_actionDefBody1081_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_69_in_actionDefBody1093  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_69_in_actionDefBody1093_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_69_in_actionDefBody1093	= { FOLLOW_69_in_actionDefBody1093_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_actionDefBody1097  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_actionDefBody1097_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_actionDefBody1097	= { FOLLOW_54_in_actionDefBody1097_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_actionDefBody1099  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_actionDefBody1099_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000040) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_actionDefBody1099	= { FOLLOW_56_in_actionDefBody1099_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_actionDefBody1104  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_actionDefBody1104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000040) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_actionDefBody1104	= { FOLLOW_goalDesc_in_actionDefBody1104_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_70_in_actionDefBody1114  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_70_in_actionDefBody1114_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_70_in_actionDefBody1114	= { FOLLOW_70_in_actionDefBody1114_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_actionDefBody1118  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_actionDefBody1118_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_actionDefBody1118	= { FOLLOW_54_in_actionDefBody1118_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_actionDefBody1120  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_actionDefBody1120_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_actionDefBody1120	= { FOLLOW_56_in_actionDefBody1120_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_effect_in_actionDefBody1125  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_effect_in_actionDefBody1125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_effect_in_actionDefBody1125	= { FOLLOW_effect_in_actionDefBody1125_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicTermFormula_in_goalDesc1176  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_atomicTermFormula_in_goalDesc1176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_atomicTermFormula_in_goalDesc1176	= { FOLLOW_atomicTermFormula_in_goalDesc1176_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_goalDesc1181  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_goalDesc1181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_goalDesc1181	= { FOLLOW_54_in_goalDesc1181_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_goalDesc1183  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_goalDesc1183_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_goalDesc1183	= { FOLLOW_71_in_goalDesc1183_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_goalDesc1185  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_goalDesc1185_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_goalDesc1185	= { FOLLOW_goalDesc_in_goalDesc1185_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_goalDesc1188  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_goalDesc1188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_goalDesc1188	= { FOLLOW_56_in_goalDesc1188_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_goalDesc1213  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_goalDesc1213_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_goalDesc1213	= { FOLLOW_54_in_goalDesc1213_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_goalDesc1215  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_72_in_goalDesc1215_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_72_in_goalDesc1215	= { FOLLOW_72_in_goalDesc1215_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_goalDesc1217  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_goalDesc1217_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_goalDesc1217	= { FOLLOW_goalDesc_in_goalDesc1217_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_goalDesc1220  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_goalDesc1220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_goalDesc1220	= { FOLLOW_56_in_goalDesc1220_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_goalDesc1245  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_goalDesc1245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_goalDesc1245	= { FOLLOW_54_in_goalDesc1245_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_goalDesc1247  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_73_in_goalDesc1247_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_73_in_goalDesc1247	= { FOLLOW_73_in_goalDesc1247_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_goalDesc1249  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_goalDesc1249_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_goalDesc1249	= { FOLLOW_goalDesc_in_goalDesc1249_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_goalDesc1251  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_goalDesc1251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_goalDesc1251	= { FOLLOW_56_in_goalDesc1251_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_goalDesc1275  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_goalDesc1275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000400) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_goalDesc1275	= { FOLLOW_54_in_goalDesc1275_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_74_in_goalDesc1277  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_74_in_goalDesc1277_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_74_in_goalDesc1277	= { FOLLOW_74_in_goalDesc1277_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_goalDesc1279  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_goalDesc1279_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_goalDesc1279	= { FOLLOW_goalDesc_in_goalDesc1279_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_goalDesc1281  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_goalDesc1281_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_goalDesc1281	= { FOLLOW_goalDesc_in_goalDesc1281_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_goalDesc1283  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_goalDesc1283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_goalDesc1283	= { FOLLOW_56_in_goalDesc1283_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_goalDesc1309  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_goalDesc1309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_goalDesc1309	= { FOLLOW_54_in_goalDesc1309_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_75_in_goalDesc1311  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_75_in_goalDesc1311_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_75_in_goalDesc1311	= { FOLLOW_75_in_goalDesc1311_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_goalDesc1313  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_goalDesc1313_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_goalDesc1313	= { FOLLOW_54_in_goalDesc1313_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_goalDesc1315  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_goalDesc1315_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_goalDesc1315	= { FOLLOW_typedVariableList_in_goalDesc1315_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_goalDesc1317  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_goalDesc1317_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_goalDesc1317	= { FOLLOW_56_in_goalDesc1317_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_goalDesc1319  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_goalDesc1319_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_goalDesc1319	= { FOLLOW_goalDesc_in_goalDesc1319_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_goalDesc1321  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_goalDesc1321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_goalDesc1321	= { FOLLOW_56_in_goalDesc1321_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_goalDesc1347  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_goalDesc1347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_goalDesc1347	= { FOLLOW_54_in_goalDesc1347_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_goalDesc1349  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_76_in_goalDesc1349_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_76_in_goalDesc1349	= { FOLLOW_76_in_goalDesc1349_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_goalDesc1351  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_goalDesc1351_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_goalDesc1351	= { FOLLOW_54_in_goalDesc1351_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_goalDesc1353  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_goalDesc1353_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_goalDesc1353	= { FOLLOW_typedVariableList_in_goalDesc1353_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_goalDesc1355  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_goalDesc1355_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_goalDesc1355	= { FOLLOW_56_in_goalDesc1355_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_goalDesc1357  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_goalDesc1357_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_goalDesc1357	= { FOLLOW_goalDesc_in_goalDesc1357_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_goalDesc1359  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_goalDesc1359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_goalDesc1359	= { FOLLOW_56_in_goalDesc1359_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fComp_in_goalDesc1388  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fComp_in_goalDesc1388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fComp_in_goalDesc1388	= { FOLLOW_fComp_in_goalDesc1388_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_fComp1424  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_fComp1424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x00000000F8000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_fComp1424	= { FOLLOW_54_in_fComp1424_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryComp_in_fComp1427  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_binaryComp_in_fComp1427_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_binaryComp_in_fComp1427	= { FOLLOW_binaryComp_in_fComp1427_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_fComp1429  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_fComp1429_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_fComp1429	= { FOLLOW_fExp_in_fComp1429_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_fComp1431  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_fComp1431_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_fComp1431	= { FOLLOW_fExp_in_fComp1431_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_fComp1433  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_fComp1433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_fComp1433	= { FOLLOW_56_in_fComp1433_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_atomicTermFormula1445  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_atomicTermFormula1445_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_atomicTermFormula1445	= { FOLLOW_54_in_atomicTermFormula1445_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicate_in_atomicTermFormula1447  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_predicate_in_atomicTermFormula1447_bits[]	= { ANTLR3_UINT64_LIT(0x0100A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_predicate_in_atomicTermFormula1447	= { FOLLOW_predicate_in_atomicTermFormula1447_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_atomicTermFormula1449  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_term_in_atomicTermFormula1449_bits[]	= { ANTLR3_UINT64_LIT(0x0100A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_term_in_atomicTermFormula1449	= { FOLLOW_term_in_atomicTermFormula1449_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_atomicTermFormula1452  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_atomicTermFormula1452_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_atomicTermFormula1452	= { FOLLOW_56_in_atomicTermFormula1452_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_term0  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_set_in_term0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_set_in_term0	= { FOLLOW_set_in_term0_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_durativeActionDef1490  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_durativeActionDef1490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000002000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_durativeActionDef1490	= { FOLLOW_54_in_durativeActionDef1490_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_77_in_durativeActionDef1492  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_77_in_durativeActionDef1492_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_77_in_durativeActionDef1492	= { FOLLOW_77_in_durativeActionDef1492_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_actionSymbol_in_durativeActionDef1494  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_actionSymbol_in_durativeActionDef1494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_actionSymbol_in_durativeActionDef1494	= { FOLLOW_actionSymbol_in_durativeActionDef1494_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_68_in_durativeActionDef1503  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_68_in_durativeActionDef1503_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_68_in_durativeActionDef1503	= { FOLLOW_68_in_durativeActionDef1503_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_durativeActionDef1505  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_durativeActionDef1505_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_durativeActionDef1505	= { FOLLOW_54_in_durativeActionDef1505_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_durativeActionDef1507  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_durativeActionDef1507_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_durativeActionDef1507	= { FOLLOW_typedVariableList_in_durativeActionDef1507_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_durativeActionDef1509  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_durativeActionDef1509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x000000000000C040) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_durativeActionDef1509	= { FOLLOW_56_in_durativeActionDef1509_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daDefBody_in_durativeActionDef1522  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daDefBody_in_durativeActionDef1522_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daDefBody_in_durativeActionDef1522	= { FOLLOW_daDefBody_in_durativeActionDef1522_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_durativeActionDef1524  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_durativeActionDef1524_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_durativeActionDef1524	= { FOLLOW_56_in_durativeActionDef1524_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_78_in_daDefBody1557  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_78_in_daDefBody1557_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_78_in_daDefBody1557	= { FOLLOW_78_in_daDefBody1557_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_durationConstraint_in_daDefBody1559  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_durationConstraint_in_daDefBody1559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_durationConstraint_in_daDefBody1559	= { FOLLOW_durationConstraint_in_daDefBody1559_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_79_in_daDefBody1564  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_79_in_daDefBody1564_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_79_in_daDefBody1564	= { FOLLOW_79_in_daDefBody1564_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daDefBody1568  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daDefBody1568_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daDefBody1568	= { FOLLOW_54_in_daDefBody1568_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daDefBody1570  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daDefBody1570_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daDefBody1570	= { FOLLOW_56_in_daDefBody1570_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daGD_in_daDefBody1575  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daGD_in_daDefBody1575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daGD_in_daDefBody1575	= { FOLLOW_daGD_in_daDefBody1575_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_70_in_daDefBody1584  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_70_in_daDefBody1584_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_70_in_daDefBody1584	= { FOLLOW_70_in_daDefBody1584_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daDefBody1588  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daDefBody1588_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daDefBody1588	= { FOLLOW_54_in_daDefBody1588_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daDefBody1590  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daDefBody1590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daDefBody1590	= { FOLLOW_56_in_daDefBody1590_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daEffect_in_daDefBody1595  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daEffect_in_daDefBody1595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daEffect_in_daDefBody1595	= { FOLLOW_daEffect_in_daDefBody1595_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_prefTimedGD_in_daGD1610  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_prefTimedGD_in_daGD1610_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_prefTimedGD_in_daGD1610	= { FOLLOW_prefTimedGD_in_daGD1610_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daGD1615  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daGD1615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daGD1615	= { FOLLOW_54_in_daGD1615_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_daGD1617  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_daGD1617_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_daGD1617	= { FOLLOW_71_in_daGD1617_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daGD_in_daGD1619  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daGD_in_daGD1619_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daGD_in_daGD1619	= { FOLLOW_daGD_in_daGD1619_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daGD1622  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daGD1622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daGD1622	= { FOLLOW_56_in_daGD1622_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daGD1627  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daGD1627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daGD1627	= { FOLLOW_54_in_daGD1627_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_daGD1629  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_76_in_daGD1629_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_76_in_daGD1629	= { FOLLOW_76_in_daGD1629_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daGD1631  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daGD1631_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daGD1631	= { FOLLOW_54_in_daGD1631_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_daGD1633  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_daGD1633_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_daGD1633	= { FOLLOW_typedVariableList_in_daGD1633_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daGD1635  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daGD1635_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daGD1635	= { FOLLOW_56_in_daGD1635_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daGD_in_daGD1637  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daGD_in_daGD1637_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daGD_in_daGD1637	= { FOLLOW_daGD_in_daGD1637_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daGD1639  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daGD1639_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daGD1639	= { FOLLOW_56_in_daGD1639_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timedGD_in_prefTimedGD1650  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timedGD_in_prefTimedGD1650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timedGD_in_prefTimedGD1650	= { FOLLOW_timedGD_in_prefTimedGD1650_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_prefTimedGD1655  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_prefTimedGD1655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_prefTimedGD1655	= { FOLLOW_54_in_prefTimedGD1655_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_prefTimedGD1657  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_80_in_prefTimedGD1657_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_80_in_prefTimedGD1657	= { FOLLOW_80_in_prefTimedGD1657_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_prefTimedGD1659  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_prefTimedGD1659_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_prefTimedGD1659	= { FOLLOW_NAME_in_prefTimedGD1659_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timedGD_in_prefTimedGD1662  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timedGD_in_prefTimedGD1662_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timedGD_in_prefTimedGD1662	= { FOLLOW_timedGD_in_prefTimedGD1662_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_prefTimedGD1664  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_prefTimedGD1664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_prefTimedGD1664	= { FOLLOW_56_in_prefTimedGD1664_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_timedGD1675  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_timedGD1675_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_timedGD1675	= { FOLLOW_54_in_timedGD1675_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_timedGD1677  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_81_in_timedGD1677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000180000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_81_in_timedGD1677	= { FOLLOW_81_in_timedGD1677_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timeSpecifier_in_timedGD1679  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timeSpecifier_in_timedGD1679_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timeSpecifier_in_timedGD1679	= { FOLLOW_timeSpecifier_in_timedGD1679_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_timedGD1681  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_timedGD1681_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_timedGD1681	= { FOLLOW_goalDesc_in_timedGD1681_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_timedGD1683  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_timedGD1683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_timedGD1683	= { FOLLOW_56_in_timedGD1683_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_timedGD1688  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_timedGD1688_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_timedGD1688	= { FOLLOW_54_in_timedGD1688_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_82_in_timedGD1690  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_82_in_timedGD1690_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_82_in_timedGD1690	= { FOLLOW_82_in_timedGD1690_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_timedGD1692  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_interval_in_timedGD1692_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_interval_in_timedGD1692	= { FOLLOW_interval_in_timedGD1692_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_timedGD1694  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_timedGD1694_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_timedGD1694	= { FOLLOW_goalDesc_in_timedGD1694_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_timedGD1696  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_timedGD1696_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_timedGD1696	= { FOLLOW_56_in_timedGD1696_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_timeSpecifier0  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_set_in_timeSpecifier0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_set_in_timeSpecifier0	= { FOLLOW_set_in_timeSpecifier0_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_85_in_interval1718  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_85_in_interval1718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_85_in_interval1718	= { FOLLOW_85_in_interval1718_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_derivedDef1731  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_derivedDef1731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000400000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_derivedDef1731	= { FOLLOW_54_in_derivedDef1731_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_86_in_derivedDef1734  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_86_in_derivedDef1734_bits[]	= { ANTLR3_UINT64_LIT(0x0040800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_86_in_derivedDef1734	= { FOLLOW_86_in_derivedDef1734_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_derivedDef1737  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_derivedDef1737_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_derivedDef1737	= { FOLLOW_typedVariableList_in_derivedDef1737_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_derivedDef1739  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_derivedDef1739_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_derivedDef1739	= { FOLLOW_goalDesc_in_derivedDef1739_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_derivedDef1741  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_derivedDef1741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_derivedDef1741	= { FOLLOW_56_in_derivedDef1741_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_fExp1756  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_fExp1756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_fExp1756	= { FOLLOW_NUMBER_in_fExp1756_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_fExp1761  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_fExp1761_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000), ANTLR3_UINT64_LIT(0x0000000007000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_fExp1761	= { FOLLOW_54_in_fExp1761_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryOp_in_fExp1763  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_binaryOp_in_fExp1763_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_binaryOp_in_fExp1763	= { FOLLOW_binaryOp_in_fExp1763_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_fExp1765  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_fExp1765_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_fExp1765	= { FOLLOW_fExp_in_fExp1765_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp2_in_fExp1767  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp2_in_fExp1767_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp2_in_fExp1767	= { FOLLOW_fExp2_in_fExp1767_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_fExp1769  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_fExp1769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_fExp1769	= { FOLLOW_56_in_fExp1769_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_fExp1786  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_fExp1786_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_fExp1786	= { FOLLOW_54_in_fExp1786_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_fExp1788  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_60_in_fExp1788_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_60_in_fExp1788	= { FOLLOW_60_in_fExp1788_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_fExp1790  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_fExp1790_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_fExp1790	= { FOLLOW_fExp_in_fExp1790_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_fExp1792  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_fExp1792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_fExp1792	= { FOLLOW_56_in_fExp1792_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fHead_in_fExp1805  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fHead_in_fExp1805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fHead_in_fExp1805	= { FOLLOW_fHead_in_fExp1805_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_VARIABLE_in_fExp1810  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_VARIABLE_in_fExp1810_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_VARIABLE_in_fExp1810	= { FOLLOW_VARIABLE_in_fExp1810_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_fExp21822  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_fExp21822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_fExp21822	= { FOLLOW_fExp_in_fExp21822_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_fHead1832  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_fHead1832_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_fHead1832	= { FOLLOW_54_in_fHead1832_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionSymbol_in_fHead1834  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_functionSymbol_in_fHead1834_bits[]	= { ANTLR3_UINT64_LIT(0x0100A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_functionSymbol_in_fHead1834	= { FOLLOW_functionSymbol_in_fHead1834_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_term_in_fHead1836  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_term_in_fHead1836_bits[]	= { ANTLR3_UINT64_LIT(0x0100A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_term_in_fHead1836	= { FOLLOW_term_in_fHead1836_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_fHead1839  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_fHead1839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_fHead1839	= { FOLLOW_56_in_fHead1839_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionSymbol_in_fHead1855  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_functionSymbol_in_fHead1855_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_functionSymbol_in_fHead1855	= { FOLLOW_functionSymbol_in_fHead1855_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_effect1874  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_effect1874_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_effect1874	= { FOLLOW_54_in_effect1874_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_effect1876  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_effect1876_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_effect1876	= { FOLLOW_71_in_effect1876_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_cEffect_in_effect1878  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_cEffect_in_effect1878_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_cEffect_in_effect1878	= { FOLLOW_cEffect_in_effect1878_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_effect1881  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_effect1881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_effect1881	= { FOLLOW_56_in_effect1881_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_cEffect_in_effect1895  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_cEffect_in_effect1895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_cEffect_in_effect1895	= { FOLLOW_cEffect_in_effect1895_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_cEffect1906  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_cEffect1906_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_cEffect1906	= { FOLLOW_54_in_cEffect1906_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_cEffect1908  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_76_in_cEffect1908_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_76_in_cEffect1908	= { FOLLOW_76_in_cEffect1908_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_cEffect1910  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_cEffect1910_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_cEffect1910	= { FOLLOW_54_in_cEffect1910_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_cEffect1912  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_cEffect1912_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_cEffect1912	= { FOLLOW_typedVariableList_in_cEffect1912_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_cEffect1914  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_cEffect1914_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_cEffect1914	= { FOLLOW_56_in_cEffect1914_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_effect_in_cEffect1916  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_effect_in_cEffect1916_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_effect_in_cEffect1916	= { FOLLOW_effect_in_cEffect1916_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_cEffect1918  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_cEffect1918_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_cEffect1918	= { FOLLOW_56_in_cEffect1918_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_cEffect1936  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_cEffect1936_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_cEffect1936	= { FOLLOW_54_in_cEffect1936_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_87_in_cEffect1938  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_87_in_cEffect1938_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_87_in_cEffect1938	= { FOLLOW_87_in_cEffect1938_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_cEffect1940  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_cEffect1940_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_cEffect1940	= { FOLLOW_goalDesc_in_cEffect1940_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_condEffect_in_cEffect1942  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_condEffect_in_cEffect1942_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_condEffect_in_cEffect1942	= { FOLLOW_condEffect_in_cEffect1942_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_cEffect1944  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_cEffect1944_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_cEffect1944	= { FOLLOW_56_in_cEffect1944_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_pEffect_in_cEffect1962  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_pEffect_in_cEffect1962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_pEffect_in_cEffect1962	= { FOLLOW_pEffect_in_cEffect1962_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_pEffect1973  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_pEffect1973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001F00000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_pEffect1973	= { FOLLOW_54_in_pEffect1973_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignOp_in_pEffect1975  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_assignOp_in_pEffect1975_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_assignOp_in_pEffect1975	= { FOLLOW_assignOp_in_pEffect1975_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fHead_in_pEffect1977  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fHead_in_pEffect1977_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fHead_in_pEffect1977	= { FOLLOW_fHead_in_pEffect1977_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_pEffect1979  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_pEffect1979_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_pEffect1979	= { FOLLOW_fExp_in_pEffect1979_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_pEffect1981  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_pEffect1981_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_pEffect1981	= { FOLLOW_56_in_pEffect1981_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_pEffect2001  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_pEffect2001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_pEffect2001	= { FOLLOW_54_in_pEffect2001_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_pEffect2003  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_73_in_pEffect2003_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_73_in_pEffect2003	= { FOLLOW_73_in_pEffect2003_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicTermFormula_in_pEffect2005  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_atomicTermFormula_in_pEffect2005_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_atomicTermFormula_in_pEffect2005	= { FOLLOW_atomicTermFormula_in_pEffect2005_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_pEffect2007  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_pEffect2007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_pEffect2007	= { FOLLOW_56_in_pEffect2007_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicTermFormula_in_pEffect2023  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_atomicTermFormula_in_pEffect2023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_atomicTermFormula_in_pEffect2023	= { FOLLOW_atomicTermFormula_in_pEffect2023_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_condEffect2036  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_condEffect2036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_condEffect2036	= { FOLLOW_54_in_condEffect2036_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_condEffect2038  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_condEffect2038_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_condEffect2038	= { FOLLOW_71_in_condEffect2038_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_pEffect_in_condEffect2040  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_pEffect_in_condEffect2040_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_pEffect_in_condEffect2040	= { FOLLOW_pEffect_in_condEffect2040_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_condEffect2043  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_condEffect2043_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_condEffect2043	= { FOLLOW_56_in_condEffect2043_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_pEffect_in_condEffect2057  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_pEffect_in_condEffect2057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_pEffect_in_condEffect2057	= { FOLLOW_pEffect_in_condEffect2057_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_binaryOp0  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_set_in_binaryOp0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_set_in_binaryOp0	= { FOLLOW_set_in_binaryOp0_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_binaryComp0  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_set_in_binaryComp0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_set_in_binaryComp0	= { FOLLOW_set_in_binaryComp0_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_assignOp0  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_set_in_assignOp0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_set_in_assignOp0	= { FOLLOW_set_in_assignOp0_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_durationConstraint2144  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_durationConstraint2144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_durationConstraint2144	= { FOLLOW_54_in_durationConstraint2144_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_durationConstraint2146  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_durationConstraint2146_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_durationConstraint2146	= { FOLLOW_71_in_durationConstraint2146_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleDurationConstraint_in_durationConstraint2148  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_simpleDurationConstraint_in_durationConstraint2148_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_simpleDurationConstraint_in_durationConstraint2148	= { FOLLOW_simpleDurationConstraint_in_durationConstraint2148_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_durationConstraint2151  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_durationConstraint2151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_durationConstraint2151	= { FOLLOW_56_in_durationConstraint2151_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_durationConstraint2156  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_durationConstraint2156_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_durationConstraint2156	= { FOLLOW_54_in_durationConstraint2156_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_durationConstraint2158  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_durationConstraint2158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_durationConstraint2158	= { FOLLOW_56_in_durationConstraint2158_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleDurationConstraint_in_durationConstraint2163  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_simpleDurationConstraint_in_durationConstraint2163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_simpleDurationConstraint_in_durationConstraint2163	= { FOLLOW_simpleDurationConstraint_in_durationConstraint2163_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_simpleDurationConstraint2174  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_simpleDurationConstraint2174_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x00000000E0000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_simpleDurationConstraint2174	= { FOLLOW_54_in_simpleDurationConstraint2174_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_durOp_in_simpleDurationConstraint2176  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_durOp_in_simpleDurationConstraint2176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_durOp_in_simpleDurationConstraint2176	= { FOLLOW_durOp_in_simpleDurationConstraint2176_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_101_in_simpleDurationConstraint2178  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_101_in_simpleDurationConstraint2178_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_101_in_simpleDurationConstraint2178	= { FOLLOW_101_in_simpleDurationConstraint2178_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_durValue_in_simpleDurationConstraint2180  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_durValue_in_simpleDurationConstraint2180_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_durValue_in_simpleDurationConstraint2180	= { FOLLOW_durValue_in_simpleDurationConstraint2180_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_simpleDurationConstraint2182  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_simpleDurationConstraint2182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_simpleDurationConstraint2182	= { FOLLOW_56_in_simpleDurationConstraint2182_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_simpleDurationConstraint2187  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_simpleDurationConstraint2187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_simpleDurationConstraint2187	= { FOLLOW_54_in_simpleDurationConstraint2187_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_simpleDurationConstraint2189  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_81_in_simpleDurationConstraint2189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000180000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_81_in_simpleDurationConstraint2189	= { FOLLOW_81_in_simpleDurationConstraint2189_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timeSpecifier_in_simpleDurationConstraint2191  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timeSpecifier_in_simpleDurationConstraint2191_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timeSpecifier_in_simpleDurationConstraint2191	= { FOLLOW_timeSpecifier_in_simpleDurationConstraint2191_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_simpleDurationConstraint_in_simpleDurationConstraint2193  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_simpleDurationConstraint_in_simpleDurationConstraint2193_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_simpleDurationConstraint_in_simpleDurationConstraint2193	= { FOLLOW_simpleDurationConstraint_in_simpleDurationConstraint2193_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_simpleDurationConstraint2195  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_simpleDurationConstraint2195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_simpleDurationConstraint2195	= { FOLLOW_56_in_simpleDurationConstraint2195_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_durOp0  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_set_in_durOp0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_set_in_durOp0	= { FOLLOW_set_in_durOp0_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_durValue2222  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_durValue2222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_durValue2222	= { FOLLOW_NUMBER_in_durValue2222_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_durValue2226  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_durValue2226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_durValue2226	= { FOLLOW_fExp_in_durValue2226_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daEffect2236  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daEffect2236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daEffect2236	= { FOLLOW_54_in_daEffect2236_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_daEffect2238  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_daEffect2238_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_daEffect2238	= { FOLLOW_71_in_daEffect2238_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daEffect_in_daEffect2240  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daEffect_in_daEffect2240_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daEffect_in_daEffect2240	= { FOLLOW_daEffect_in_daEffect2240_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daEffect2243  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daEffect2243_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daEffect2243	= { FOLLOW_56_in_daEffect2243_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timedEffect_in_daEffect2248  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timedEffect_in_daEffect2248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timedEffect_in_daEffect2248	= { FOLLOW_timedEffect_in_daEffect2248_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daEffect2253  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daEffect2253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daEffect2253	= { FOLLOW_54_in_daEffect2253_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_daEffect2255  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_76_in_daEffect2255_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_76_in_daEffect2255	= { FOLLOW_76_in_daEffect2255_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daEffect2257  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daEffect2257_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daEffect2257	= { FOLLOW_54_in_daEffect2257_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_daEffect2259  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_daEffect2259_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_daEffect2259	= { FOLLOW_typedVariableList_in_daEffect2259_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daEffect2261  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daEffect2261_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daEffect2261	= { FOLLOW_56_in_daEffect2261_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daEffect_in_daEffect2263  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daEffect_in_daEffect2263_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daEffect_in_daEffect2263	= { FOLLOW_daEffect_in_daEffect2263_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daEffect2265  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daEffect2265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daEffect2265	= { FOLLOW_56_in_daEffect2265_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daEffect2270  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daEffect2270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daEffect2270	= { FOLLOW_54_in_daEffect2270_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_87_in_daEffect2272  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_87_in_daEffect2272_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_87_in_daEffect2272	= { FOLLOW_87_in_daEffect2272_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daGD_in_daEffect2274  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daGD_in_daEffect2274_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daGD_in_daEffect2274	= { FOLLOW_daGD_in_daEffect2274_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timedEffect_in_daEffect2276  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timedEffect_in_daEffect2276_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timedEffect_in_daEffect2276	= { FOLLOW_timedEffect_in_daEffect2276_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daEffect2278  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daEffect2278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daEffect2278	= { FOLLOW_56_in_daEffect2278_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_daEffect2283  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_daEffect2283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001F00000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_daEffect2283	= { FOLLOW_54_in_daEffect2283_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignOp_in_daEffect2285  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_assignOp_in_daEffect2285_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_assignOp_in_daEffect2285	= { FOLLOW_assignOp_in_daEffect2285_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fHead_in_daEffect2287  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fHead_in_daEffect2287_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fHead_in_daEffect2287	= { FOLLOW_fHead_in_daEffect2287_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_daEffect2289  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_daEffect2289_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_daEffect2289	= { FOLLOW_fExpDA_in_daEffect2289_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_daEffect2291  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_daEffect2291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_daEffect2291	= { FOLLOW_56_in_daEffect2291_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_timedEffect2302  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_timedEffect2302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_timedEffect2302	= { FOLLOW_54_in_timedEffect2302_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_timedEffect2304  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_81_in_timedEffect2304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000180000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_81_in_timedEffect2304	= { FOLLOW_81_in_timedEffect2304_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timeSpecifier_in_timedEffect2306  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timeSpecifier_in_timedEffect2306_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timeSpecifier_in_timedEffect2306	= { FOLLOW_timeSpecifier_in_timedEffect2306_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daEffect_in_timedEffect2308  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daEffect_in_timedEffect2308_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daEffect_in_timedEffect2308	= { FOLLOW_daEffect_in_timedEffect2308_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_timedEffect2310  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_timedEffect2310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_timedEffect2310	= { FOLLOW_56_in_timedEffect2310_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_timedEffect2320  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_timedEffect2320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_timedEffect2320	= { FOLLOW_54_in_timedEffect2320_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_timedEffect2322  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_81_in_timedEffect2322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000180000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_81_in_timedEffect2322	= { FOLLOW_81_in_timedEffect2322_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timeSpecifier_in_timedEffect2324  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timeSpecifier_in_timedEffect2324_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timeSpecifier_in_timedEffect2324	= { FOLLOW_timeSpecifier_in_timedEffect2324_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fAssignDA_in_timedEffect2326  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fAssignDA_in_timedEffect2326_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fAssignDA_in_timedEffect2326	= { FOLLOW_fAssignDA_in_timedEffect2326_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_timedEffect2328  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_timedEffect2328_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_timedEffect2328	= { FOLLOW_56_in_timedEffect2328_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_timedEffect2333  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_timedEffect2333_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001F00000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_timedEffect2333	= { FOLLOW_54_in_timedEffect2333_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignOp_in_timedEffect2335  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_assignOp_in_timedEffect2335_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_assignOp_in_timedEffect2335	= { FOLLOW_assignOp_in_timedEffect2335_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fHead_in_timedEffect2337  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fHead_in_timedEffect2337_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fHead_in_timedEffect2337	= { FOLLOW_fHead_in_timedEffect2337_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_timedEffect2339  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_timedEffect2339_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_timedEffect2339	= { FOLLOW_fExp_in_timedEffect2339_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_timedEffect2341  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_timedEffect2341_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_timedEffect2341	= { FOLLOW_56_in_timedEffect2341_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_fAssignDA2361  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_fAssignDA2361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001F00000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_fAssignDA2361	= { FOLLOW_54_in_fAssignDA2361_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_assignOp_in_fAssignDA2363  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_assignOp_in_fAssignDA2363_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_assignOp_in_fAssignDA2363	= { FOLLOW_assignOp_in_fAssignDA2363_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fHead_in_fAssignDA2365  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fHead_in_fAssignDA2365_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fHead_in_fAssignDA2365	= { FOLLOW_fHead_in_fAssignDA2365_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_fAssignDA2367  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_fAssignDA2367_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_fAssignDA2367	= { FOLLOW_fExpDA_in_fAssignDA2367_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_fAssignDA2369  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_fAssignDA2369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_fAssignDA2369	= { FOLLOW_56_in_fAssignDA2369_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_fExpDA2380  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_fExpDA2380_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000), ANTLR3_UINT64_LIT(0x0000000007000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_fExpDA2380	= { FOLLOW_54_in_fExpDA2380_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryOp_in_fExpDA2384  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_binaryOp_in_fExpDA2384_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_binaryOp_in_fExpDA2384	= { FOLLOW_binaryOp_in_fExpDA2384_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_fExpDA2386  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_fExpDA2386_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_fExpDA2386	= { FOLLOW_fExpDA_in_fExpDA2386_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_fExpDA2388  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_fExpDA2388_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_fExpDA2388	= { FOLLOW_fExpDA_in_fExpDA2388_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_fExpDA2394  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_60_in_fExpDA2394_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_60_in_fExpDA2394	= { FOLLOW_60_in_fExpDA2394_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_fExpDA2396  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_fExpDA2396_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_fExpDA2396	= { FOLLOW_fExpDA_in_fExpDA2396_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_fExpDA2400  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_fExpDA2400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_fExpDA2400	= { FOLLOW_56_in_fExpDA2400_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_101_in_fExpDA2405  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_101_in_fExpDA2405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_101_in_fExpDA2405	= { FOLLOW_101_in_fExpDA2405_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_fExpDA2410  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_fExpDA2410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_fExpDA2410	= { FOLLOW_fExp_in_fExpDA2410_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_problem2424  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_problem2424_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_problem2424	= { FOLLOW_54_in_problem2424_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_55_in_problem2426  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_55_in_problem2426_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_55_in_problem2426	= { FOLLOW_55_in_problem2426_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_problemDecl_in_problem2428  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_problemDecl_in_problem2428_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_problemDecl_in_problem2428	= { FOLLOW_problemDecl_in_problem2428_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_problemDomain_in_problem2433  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_problemDomain_in_problem2433_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_problemDomain_in_problem2433	= { FOLLOW_problemDomain_in_problem2433_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_requireDef_in_problem2441  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_requireDef_in_problem2441_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_requireDef_in_problem2441	= { FOLLOW_requireDef_in_problem2441_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_objectDecl_in_problem2450  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_objectDecl_in_problem2450_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_objectDecl_in_problem2450	= { FOLLOW_objectDecl_in_problem2450_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_init_in_problem2459  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_init_in_problem2459_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_init_in_problem2459	= { FOLLOW_init_in_problem2459_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goal_in_problem2467  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goal_in_problem2467_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goal_in_problem2467	= { FOLLOW_goal_in_problem2467_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_probConstraints_in_problem2475  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_probConstraints_in_problem2475_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_probConstraints_in_problem2475	= { FOLLOW_probConstraints_in_problem2475_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricSpec_in_problem2484  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricSpec_in_problem2484_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricSpec_in_problem2484	= { FOLLOW_metricSpec_in_problem2484_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_problem2500  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_problem2500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_problem2500	= { FOLLOW_56_in_problem2500_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_problemDecl2557  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_problemDecl2557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_problemDecl2557	= { FOLLOW_54_in_problemDecl2557_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_102_in_problemDecl2559  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_102_in_problemDecl2559_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_102_in_problemDecl2559	= { FOLLOW_102_in_problemDecl2559_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_problemDecl2561  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_problemDecl2561_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_problemDecl2561	= { FOLLOW_NAME_in_problemDecl2561_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_problemDecl2563  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_problemDecl2563_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_problemDecl2563	= { FOLLOW_56_in_problemDecl2563_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_problemDomain2589  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_problemDomain2589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_problemDomain2589	= { FOLLOW_54_in_problemDomain2589_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_103_in_problemDomain2591  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_103_in_problemDomain2591_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_103_in_problemDomain2591	= { FOLLOW_103_in_problemDomain2591_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_problemDomain2593  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_problemDomain2593_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_problemDomain2593	= { FOLLOW_NAME_in_problemDomain2593_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_problemDomain2595  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_problemDomain2595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_problemDomain2595	= { FOLLOW_56_in_problemDomain2595_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_objectDecl2615  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_objectDecl2615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_objectDecl2615	= { FOLLOW_54_in_objectDecl2615_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_104_in_objectDecl2617  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_104_in_objectDecl2617_bits[]	= { ANTLR3_UINT64_LIT(0x0100200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_104_in_objectDecl2617	= { FOLLOW_104_in_objectDecl2617_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedNameList_in_objectDecl2619  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedNameList_in_objectDecl2619_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedNameList_in_objectDecl2619	= { FOLLOW_typedNameList_in_objectDecl2619_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_objectDecl2621  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_objectDecl2621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_objectDecl2621	= { FOLLOW_56_in_objectDecl2621_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_init2641  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_init2641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_init2641	= { FOLLOW_54_in_init2641_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_105_in_init2643  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_105_in_init2643_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_105_in_init2643	= { FOLLOW_105_in_init2643_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_initEl_in_init2645  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_initEl_in_init2645_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_initEl_in_init2645	= { FOLLOW_initEl_in_init2645_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_init2648  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_init2648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_init2648	= { FOLLOW_56_in_init2648_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameLiteral_in_initEl2669  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_nameLiteral_in_initEl2669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_nameLiteral_in_initEl2669	= { FOLLOW_nameLiteral_in_initEl2669_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_initEl2674  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_initEl2674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000020000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_initEl2674	= { FOLLOW_54_in_initEl2674_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_93_in_initEl2676  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_93_in_initEl2676_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_93_in_initEl2676	= { FOLLOW_93_in_initEl2676_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fHead_in_initEl2678  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fHead_in_initEl2678_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fHead_in_initEl2678	= { FOLLOW_fHead_in_initEl2678_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_initEl2680  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_initEl2680_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_initEl2680	= { FOLLOW_NUMBER_in_initEl2680_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_initEl2682  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_initEl2682_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_initEl2682	= { FOLLOW_56_in_initEl2682_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_initEl2705  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_initEl2705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_initEl2705	= { FOLLOW_54_in_initEl2705_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_initEl2707  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_81_in_initEl2707_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_81_in_initEl2707	= { FOLLOW_81_in_initEl2707_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_initEl2709  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_initEl2709_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_initEl2709	= { FOLLOW_NUMBER_in_initEl2709_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameLiteral_in_initEl2711  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_nameLiteral_in_initEl2711_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_nameLiteral_in_initEl2711	= { FOLLOW_nameLiteral_in_initEl2711_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_initEl2713  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_initEl2713_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_initEl2713	= { FOLLOW_56_in_initEl2713_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicNameFormula_in_nameLiteral2735  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_atomicNameFormula_in_nameLiteral2735_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_atomicNameFormula_in_nameLiteral2735	= { FOLLOW_atomicNameFormula_in_nameLiteral2735_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_nameLiteral2740  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_nameLiteral2740_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_nameLiteral2740	= { FOLLOW_54_in_nameLiteral2740_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_73_in_nameLiteral2742  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_73_in_nameLiteral2742_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_73_in_nameLiteral2742	= { FOLLOW_73_in_nameLiteral2742_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicNameFormula_in_nameLiteral2744  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_atomicNameFormula_in_nameLiteral2744_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_atomicNameFormula_in_nameLiteral2744	= { FOLLOW_atomicNameFormula_in_nameLiteral2744_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_nameLiteral2746  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_nameLiteral2746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_nameLiteral2746	= { FOLLOW_56_in_nameLiteral2746_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_atomicNameFormula2765  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_atomicNameFormula2765_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_atomicNameFormula2765	= { FOLLOW_54_in_atomicNameFormula2765_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_predicate_in_atomicNameFormula2767  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_predicate_in_atomicNameFormula2767_bits[]	= { ANTLR3_UINT64_LIT(0x0100200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_predicate_in_atomicNameFormula2767	= { FOLLOW_predicate_in_atomicNameFormula2767_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_atomicNameFormula2769  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_atomicNameFormula2769_bits[]	= { ANTLR3_UINT64_LIT(0x0100200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_atomicNameFormula2769	= { FOLLOW_NAME_in_atomicNameFormula2769_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_atomicNameFormula2772  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_atomicNameFormula2772_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_atomicNameFormula2772	= { FOLLOW_56_in_atomicNameFormula2772_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_goal2797  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_goal2797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000040000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_goal2797	= { FOLLOW_54_in_goal2797_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_106_in_goal2799  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_106_in_goal2799_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_106_in_goal2799	= { FOLLOW_106_in_goal2799_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_goal2801  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_goal2801_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_goal2801	= { FOLLOW_goalDesc_in_goal2801_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_goal2803  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_goal2803_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_goal2803	= { FOLLOW_56_in_goal2803_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_probConstraints2821  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_probConstraints2821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_probConstraints2821	= { FOLLOW_54_in_probConstraints2821_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_66_in_probConstraints2823  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_66_in_probConstraints2823_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_66_in_probConstraints2823	= { FOLLOW_66_in_probConstraints2823_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_prefConGD_in_probConstraints2826  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_prefConGD_in_probConstraints2826_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_prefConGD_in_probConstraints2826	= { FOLLOW_prefConGD_in_probConstraints2826_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_probConstraints2828  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_probConstraints2828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_probConstraints2828	= { FOLLOW_56_in_probConstraints2828_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_prefConGD2850  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_prefConGD2850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_prefConGD2850	= { FOLLOW_54_in_prefConGD2850_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_prefConGD2852  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_prefConGD2852_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_prefConGD2852	= { FOLLOW_71_in_prefConGD2852_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_prefConGD_in_prefConGD2854  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_prefConGD_in_prefConGD2854_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_prefConGD_in_prefConGD2854	= { FOLLOW_prefConGD_in_prefConGD2854_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_prefConGD2857  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_prefConGD2857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_prefConGD2857	= { FOLLOW_56_in_prefConGD2857_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_prefConGD2862  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_prefConGD2862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_prefConGD2862	= { FOLLOW_54_in_prefConGD2862_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_prefConGD2864  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_76_in_prefConGD2864_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_76_in_prefConGD2864	= { FOLLOW_76_in_prefConGD2864_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_prefConGD2866  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_prefConGD2866_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_prefConGD2866	= { FOLLOW_54_in_prefConGD2866_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_prefConGD2868  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_prefConGD2868_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_prefConGD2868	= { FOLLOW_typedVariableList_in_prefConGD2868_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_prefConGD2870  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_prefConGD2870_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_prefConGD2870	= { FOLLOW_56_in_prefConGD2870_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_prefConGD_in_prefConGD2872  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_prefConGD_in_prefConGD2872_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_prefConGD_in_prefConGD2872	= { FOLLOW_prefConGD_in_prefConGD2872_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_prefConGD2874  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_prefConGD2874_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_prefConGD2874	= { FOLLOW_56_in_prefConGD2874_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_prefConGD2879  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_prefConGD2879_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_prefConGD2879	= { FOLLOW_54_in_prefConGD2879_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_prefConGD2881  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_80_in_prefConGD2881_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_80_in_prefConGD2881	= { FOLLOW_80_in_prefConGD2881_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_prefConGD2883  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_prefConGD2883_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_prefConGD2883	= { FOLLOW_NAME_in_prefConGD2883_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_conGD_in_prefConGD2886  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_conGD_in_prefConGD2886_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_conGD_in_prefConGD2886	= { FOLLOW_conGD_in_prefConGD2886_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_prefConGD2888  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_prefConGD2888_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_prefConGD2888	= { FOLLOW_56_in_prefConGD2888_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_conGD_in_prefConGD2893  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_conGD_in_prefConGD2893_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_conGD_in_prefConGD2893	= { FOLLOW_conGD_in_prefConGD2893_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_metricSpec2904  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_metricSpec2904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000080000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_metricSpec2904	= { FOLLOW_54_in_metricSpec2904_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_107_in_metricSpec2906  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_107_in_metricSpec2906_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000300000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_107_in_metricSpec2906	= { FOLLOW_107_in_metricSpec2906_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_optimization_in_metricSpec2908  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_optimization_in_metricSpec2908_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_optimization_in_metricSpec2908	= { FOLLOW_optimization_in_metricSpec2908_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_metricSpec2910  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_metricSpec2910_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_metricSpec2910	= { FOLLOW_metricFExp_in_metricSpec2910_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_metricSpec2912  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_metricSpec2912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_metricSpec2912	= { FOLLOW_56_in_metricSpec2912_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_optimization0  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_set_in_optimization0_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_set_in_optimization0	= { FOLLOW_set_in_optimization0_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_metricFExp2949  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_metricFExp2949_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000), ANTLR3_UINT64_LIT(0x0000000007000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_metricFExp2949	= { FOLLOW_54_in_metricFExp2949_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryOp_in_metricFExp2951  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_binaryOp_in_metricFExp2951_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_binaryOp_in_metricFExp2951	= { FOLLOW_binaryOp_in_metricFExp2951_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_metricFExp2953  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_metricFExp2953_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_metricFExp2953	= { FOLLOW_metricFExp_in_metricFExp2953_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_metricFExp2955  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_metricFExp2955_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_metricFExp2955	= { FOLLOW_metricFExp_in_metricFExp2955_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_metricFExp2957  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_metricFExp2957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_metricFExp2957	= { FOLLOW_56_in_metricFExp2957_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_metricFExp2962  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_metricFExp2962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000005000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_metricFExp2962	= { FOLLOW_54_in_metricFExp2962_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_metricFExp2964  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_set_in_metricFExp2964_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_set_in_metricFExp2964	= { FOLLOW_set_in_metricFExp2964_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_metricFExp2970  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_metricFExp2970_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_metricFExp2970	= { FOLLOW_metricFExp_in_metricFExp2970_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_metricFExp2972  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_metricFExp2972_bits[]	= { ANTLR3_UINT64_LIT(0x0141200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_metricFExp2972	= { FOLLOW_metricFExp_in_metricFExp2972_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_metricFExp2975  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_metricFExp2975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_metricFExp2975	= { FOLLOW_56_in_metricFExp2975_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_metricFExp2980  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_metricFExp2980_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_metricFExp2980	= { FOLLOW_54_in_metricFExp2980_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_metricFExp2982  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_60_in_metricFExp2982_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_60_in_metricFExp2982	= { FOLLOW_60_in_metricFExp2982_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_metricFExp2984  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_metricFExp2984_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_metricFExp2984	= { FOLLOW_metricFExp_in_metricFExp2984_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_metricFExp2986  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_metricFExp2986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_metricFExp2986	= { FOLLOW_56_in_metricFExp2986_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_metricFExp2991  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_metricFExp2991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_metricFExp2991	= { FOLLOW_NUMBER_in_metricFExp2991_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_metricFExp2996  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_metricFExp2996_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_metricFExp2996	= { FOLLOW_54_in_metricFExp2996_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionSymbol_in_metricFExp2998  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_functionSymbol_in_metricFExp2998_bits[]	= { ANTLR3_UINT64_LIT(0x0100200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_functionSymbol_in_metricFExp2998	= { FOLLOW_functionSymbol_in_metricFExp2998_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_metricFExp3000  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_metricFExp3000_bits[]	= { ANTLR3_UINT64_LIT(0x0100200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_metricFExp3000	= { FOLLOW_NAME_in_metricFExp3000_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_metricFExp3003  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_metricFExp3003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_metricFExp3003	= { FOLLOW_56_in_metricFExp3003_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionSymbol_in_metricFExp3008  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_functionSymbol_in_metricFExp3008_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_functionSymbol_in_metricFExp3008	= { FOLLOW_functionSymbol_in_metricFExp3008_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_110_in_metricFExp3016  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_110_in_metricFExp3016_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_110_in_metricFExp3016	= { FOLLOW_110_in_metricFExp3016_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_metricFExp3021  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_metricFExp3021_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_metricFExp3021	= { FOLLOW_54_in_metricFExp3021_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_111_in_metricFExp3023  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_111_in_metricFExp3023_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_111_in_metricFExp3023	= { FOLLOW_111_in_metricFExp3023_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_metricFExp3025  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_metricFExp3025_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_metricFExp3025	= { FOLLOW_NAME_in_metricFExp3025_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_metricFExp3027  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_metricFExp3027_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_metricFExp3027	= { FOLLOW_56_in_metricFExp3027_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3041  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3041	= { FOLLOW_54_in_conGD3041_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_conGD3043  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_conGD3043_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_conGD3043	= { FOLLOW_71_in_conGD3043_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_conGD_in_conGD3045  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_conGD_in_conGD3045_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_conGD_in_conGD3045	= { FOLLOW_conGD_in_conGD3045_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3048  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3048	= { FOLLOW_56_in_conGD3048_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3053  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3053	= { FOLLOW_54_in_conGD3053_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_conGD3055  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_76_in_conGD3055_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_76_in_conGD3055	= { FOLLOW_76_in_conGD3055_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3057  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3057_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3057	= { FOLLOW_54_in_conGD3057_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_conGD3059  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_conGD3059_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_conGD3059	= { FOLLOW_typedVariableList_in_conGD3059_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3061  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3061_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3061	= { FOLLOW_56_in_conGD3061_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_conGD_in_conGD3063  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_conGD_in_conGD3063_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_conGD_in_conGD3063	= { FOLLOW_conGD_in_conGD3063_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3065  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3065	= { FOLLOW_56_in_conGD3065_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3070  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3070_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3070	= { FOLLOW_54_in_conGD3070_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_conGD3072  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_81_in_conGD3072_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_81_in_conGD3072	= { FOLLOW_81_in_conGD3072_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_84_in_conGD3074  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_84_in_conGD3074_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_84_in_conGD3074	= { FOLLOW_84_in_conGD3074_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3076  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3076_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3076	= { FOLLOW_goalDesc_in_conGD3076_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3078  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3078_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3078	= { FOLLOW_56_in_conGD3078_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3086  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3086_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0001000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3086	= { FOLLOW_54_in_conGD3086_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_112_in_conGD3088  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_112_in_conGD3088_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_112_in_conGD3088	= { FOLLOW_112_in_conGD3088_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3090  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3090_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3090	= { FOLLOW_goalDesc_in_conGD3090_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3092  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3092_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3092	= { FOLLOW_56_in_conGD3092_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3097  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3097_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3097	= { FOLLOW_54_in_conGD3097_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_113_in_conGD3099  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_113_in_conGD3099_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_113_in_conGD3099	= { FOLLOW_113_in_conGD3099_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3101  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3101_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3101	= { FOLLOW_goalDesc_in_conGD3101_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3103  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3103	= { FOLLOW_56_in_conGD3103_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3109  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0004000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3109	= { FOLLOW_54_in_conGD3109_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_114_in_conGD3111  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_114_in_conGD3111_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_114_in_conGD3111	= { FOLLOW_114_in_conGD3111_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_conGD3113  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_conGD3113_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_conGD3113	= { FOLLOW_NUMBER_in_conGD3113_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3115  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3115_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3115	= { FOLLOW_goalDesc_in_conGD3115_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3117  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3117	= { FOLLOW_56_in_conGD3117_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3122  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0008000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3122	= { FOLLOW_54_in_conGD3122_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_115_in_conGD3124  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_115_in_conGD3124_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_115_in_conGD3124	= { FOLLOW_115_in_conGD3124_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3126  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3126_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3126	= { FOLLOW_goalDesc_in_conGD3126_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3128  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3128	= { FOLLOW_56_in_conGD3128_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3133  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3133	= { FOLLOW_54_in_conGD3133_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_116_in_conGD3135  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_116_in_conGD3135_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_116_in_conGD3135	= { FOLLOW_116_in_conGD3135_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3137  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3137_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3137	= { FOLLOW_goalDesc_in_conGD3137_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3139  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3139_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3139	= { FOLLOW_goalDesc_in_conGD3139_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3141  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3141	= { FOLLOW_56_in_conGD3141_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3146  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0020000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3146	= { FOLLOW_54_in_conGD3146_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_117_in_conGD3148  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_117_in_conGD3148_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_117_in_conGD3148	= { FOLLOW_117_in_conGD3148_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3150  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3150_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3150	= { FOLLOW_goalDesc_in_conGD3150_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3152  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3152_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3152	= { FOLLOW_goalDesc_in_conGD3152_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3154  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3154_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3154	= { FOLLOW_56_in_conGD3154_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3159  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3159_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3159	= { FOLLOW_54_in_conGD3159_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_118_in_conGD3161  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_118_in_conGD3161_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_118_in_conGD3161	= { FOLLOW_118_in_conGD3161_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_conGD3163  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_conGD3163_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_conGD3163	= { FOLLOW_NUMBER_in_conGD3163_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3165  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3165_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3165	= { FOLLOW_goalDesc_in_conGD3165_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3167  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3167_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3167	= { FOLLOW_goalDesc_in_conGD3167_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3169  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3169	= { FOLLOW_56_in_conGD3169_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3174  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3174_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0080000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3174	= { FOLLOW_54_in_conGD3174_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_119_in_conGD3176  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_119_in_conGD3176_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_119_in_conGD3176	= { FOLLOW_119_in_conGD3176_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_conGD3178  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_conGD3178_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_conGD3178	= { FOLLOW_NUMBER_in_conGD3178_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_conGD3180  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_conGD3180_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_conGD3180	= { FOLLOW_NUMBER_in_conGD3180_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3182  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3182_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3182	= { FOLLOW_goalDesc_in_conGD3182_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3184  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3184	= { FOLLOW_56_in_conGD3184_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_conGD3189  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_conGD3189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_conGD3189	= { FOLLOW_54_in_conGD3189_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_120_in_conGD3191  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_120_in_conGD3191_bits[]	= { ANTLR3_UINT64_LIT(0x0001000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_120_in_conGD3191	= { FOLLOW_120_in_conGD3191_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_conGD3193  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_conGD3193_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_conGD3193	= { FOLLOW_NUMBER_in_conGD3193_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_goalDesc_in_conGD3195  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_goalDesc_in_conGD3195_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_goalDesc_in_conGD3195	= { FOLLOW_goalDesc_in_conGD3195_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_conGD3197  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_conGD3197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_conGD3197	= { FOLLOW_56_in_conGD3197_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_atomicFunctionSkeleton_in_synpred19_Pddl750  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_atomicFunctionSkeleton_in_synpred19_Pddl750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_atomicFunctionSkeleton_in_synpred19_Pddl750	= { FOLLOW_atomicFunctionSkeleton_in_synpred19_Pddl750_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred58_Pddl1761  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred58_Pddl1761_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000), ANTLR3_UINT64_LIT(0x0000000007000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred58_Pddl1761	= { FOLLOW_54_in_synpred58_Pddl1761_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryOp_in_synpred58_Pddl1763  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_binaryOp_in_synpred58_Pddl1763_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_binaryOp_in_synpred58_Pddl1763	= { FOLLOW_binaryOp_in_synpred58_Pddl1763_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_synpred58_Pddl1765  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_synpred58_Pddl1765_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_synpred58_Pddl1765	= { FOLLOW_fExp_in_synpred58_Pddl1765_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp2_in_synpred58_Pddl1767  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp2_in_synpred58_Pddl1767_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp2_in_synpred58_Pddl1767	= { FOLLOW_fExp2_in_synpred58_Pddl1767_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred58_Pddl1769  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred58_Pddl1769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred58_Pddl1769	= { FOLLOW_56_in_synpred58_Pddl1769_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred59_Pddl1786  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred59_Pddl1786_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred59_Pddl1786	= { FOLLOW_54_in_synpred59_Pddl1786_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_synpred59_Pddl1788  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_60_in_synpred59_Pddl1788_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_60_in_synpred59_Pddl1788	= { FOLLOW_60_in_synpred59_Pddl1788_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExp_in_synpred59_Pddl1790  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExp_in_synpred59_Pddl1790_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExp_in_synpred59_Pddl1790	= { FOLLOW_fExp_in_synpred59_Pddl1790_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred59_Pddl1792  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred59_Pddl1792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred59_Pddl1792	= { FOLLOW_56_in_synpred59_Pddl1792_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fHead_in_synpred60_Pddl1805  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fHead_in_synpred60_Pddl1805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fHead_in_synpred60_Pddl1805	= { FOLLOW_fHead_in_synpred60_Pddl1805_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_synpred88_Pddl2222  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NUMBER_in_synpred88_Pddl2222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_synpred88_Pddl2222	= { FOLLOW_NUMBER_in_synpred88_Pddl2222_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred90_Pddl2236  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred90_Pddl2236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred90_Pddl2236	= { FOLLOW_54_in_synpred90_Pddl2236_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_synpred90_Pddl2238  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_synpred90_Pddl2238_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_synpred90_Pddl2238	= { FOLLOW_71_in_synpred90_Pddl2238_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daEffect_in_synpred90_Pddl2240  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daEffect_in_synpred90_Pddl2240_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daEffect_in_synpred90_Pddl2240	= { FOLLOW_daEffect_in_synpred90_Pddl2240_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred90_Pddl2243  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred90_Pddl2243_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred90_Pddl2243	= { FOLLOW_56_in_synpred90_Pddl2243_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timedEffect_in_synpred91_Pddl2248  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timedEffect_in_synpred91_Pddl2248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timedEffect_in_synpred91_Pddl2248	= { FOLLOW_timedEffect_in_synpred91_Pddl2248_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred92_Pddl2253  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred92_Pddl2253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred92_Pddl2253	= { FOLLOW_54_in_synpred92_Pddl2253_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_synpred92_Pddl2255  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_76_in_synpred92_Pddl2255_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_76_in_synpred92_Pddl2255	= { FOLLOW_76_in_synpred92_Pddl2255_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred92_Pddl2257  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred92_Pddl2257_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred92_Pddl2257	= { FOLLOW_54_in_synpred92_Pddl2257_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_synpred92_Pddl2259  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_synpred92_Pddl2259_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_synpred92_Pddl2259	= { FOLLOW_typedVariableList_in_synpred92_Pddl2259_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred92_Pddl2261  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred92_Pddl2261_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred92_Pddl2261	= { FOLLOW_56_in_synpred92_Pddl2261_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daEffect_in_synpred92_Pddl2263  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daEffect_in_synpred92_Pddl2263_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daEffect_in_synpred92_Pddl2263	= { FOLLOW_daEffect_in_synpred92_Pddl2263_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred92_Pddl2265  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred92_Pddl2265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred92_Pddl2265	= { FOLLOW_56_in_synpred92_Pddl2265_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred93_Pddl2270  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred93_Pddl2270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred93_Pddl2270	= { FOLLOW_54_in_synpred93_Pddl2270_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_87_in_synpred93_Pddl2272  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_87_in_synpred93_Pddl2272_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_87_in_synpred93_Pddl2272	= { FOLLOW_87_in_synpred93_Pddl2272_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daGD_in_synpred93_Pddl2274  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daGD_in_synpred93_Pddl2274_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daGD_in_synpred93_Pddl2274	= { FOLLOW_daGD_in_synpred93_Pddl2274_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timedEffect_in_synpred93_Pddl2276  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timedEffect_in_synpred93_Pddl2276_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timedEffect_in_synpred93_Pddl2276	= { FOLLOW_timedEffect_in_synpred93_Pddl2276_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred93_Pddl2278  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred93_Pddl2278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred93_Pddl2278	= { FOLLOW_56_in_synpred93_Pddl2278_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred94_Pddl2302  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred94_Pddl2302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred94_Pddl2302	= { FOLLOW_54_in_synpred94_Pddl2302_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_synpred94_Pddl2304  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_81_in_synpred94_Pddl2304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000180000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_81_in_synpred94_Pddl2304	= { FOLLOW_81_in_synpred94_Pddl2304_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timeSpecifier_in_synpred94_Pddl2306  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timeSpecifier_in_synpred94_Pddl2306_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timeSpecifier_in_synpred94_Pddl2306	= { FOLLOW_timeSpecifier_in_synpred94_Pddl2306_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_daEffect_in_synpred94_Pddl2308  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_daEffect_in_synpred94_Pddl2308_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_daEffect_in_synpred94_Pddl2308	= { FOLLOW_daEffect_in_synpred94_Pddl2308_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred94_Pddl2310  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred94_Pddl2310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred94_Pddl2310	= { FOLLOW_56_in_synpred94_Pddl2310_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred95_Pddl2320  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred95_Pddl2320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred95_Pddl2320	= { FOLLOW_54_in_synpred95_Pddl2320_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_81_in_synpred95_Pddl2322  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_81_in_synpred95_Pddl2322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000180000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_81_in_synpred95_Pddl2322	= { FOLLOW_81_in_synpred95_Pddl2322_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_timeSpecifier_in_synpred95_Pddl2324  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_timeSpecifier_in_synpred95_Pddl2324_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_timeSpecifier_in_synpred95_Pddl2324	= { FOLLOW_timeSpecifier_in_synpred95_Pddl2324_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fAssignDA_in_synpred95_Pddl2326  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fAssignDA_in_synpred95_Pddl2326_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fAssignDA_in_synpred95_Pddl2326	= { FOLLOW_fAssignDA_in_synpred95_Pddl2326_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred95_Pddl2328  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred95_Pddl2328_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred95_Pddl2328	= { FOLLOW_56_in_synpred95_Pddl2328_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryOp_in_synpred96_Pddl2384  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_binaryOp_in_synpred96_Pddl2384_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_binaryOp_in_synpred96_Pddl2384	= { FOLLOW_binaryOp_in_synpred96_Pddl2384_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_synpred96_Pddl2386  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_synpred96_Pddl2386_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_synpred96_Pddl2386	= { FOLLOW_fExpDA_in_synpred96_Pddl2386_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_synpred96_Pddl2388  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_synpred96_Pddl2388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_synpred96_Pddl2388	= { FOLLOW_fExpDA_in_synpred96_Pddl2388_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred97_Pddl2380  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred97_Pddl2380_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000), ANTLR3_UINT64_LIT(0x0000000007000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred97_Pddl2380	= { FOLLOW_54_in_synpred97_Pddl2380_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryOp_in_synpred97_Pddl2384  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_binaryOp_in_synpred97_Pddl2384_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_binaryOp_in_synpred97_Pddl2384	= { FOLLOW_binaryOp_in_synpred97_Pddl2384_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_synpred97_Pddl2386  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_synpred97_Pddl2386_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_synpred97_Pddl2386	= { FOLLOW_fExpDA_in_synpred97_Pddl2386_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_synpred97_Pddl2388  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_synpred97_Pddl2388_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_synpred97_Pddl2388	= { FOLLOW_fExpDA_in_synpred97_Pddl2388_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_synpred97_Pddl2394  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_60_in_synpred97_Pddl2394_bits[]	= { ANTLR3_UINT64_LIT(0x0041A00000000000), ANTLR3_UINT64_LIT(0x0000002000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_60_in_synpred97_Pddl2394	= { FOLLOW_60_in_synpred97_Pddl2394_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_fExpDA_in_synpred97_Pddl2396  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_fExpDA_in_synpred97_Pddl2396_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_fExpDA_in_synpred97_Pddl2396	= { FOLLOW_fExpDA_in_synpred97_Pddl2396_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred97_Pddl2400  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred97_Pddl2400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred97_Pddl2400	= { FOLLOW_56_in_synpred97_Pddl2400_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred109_Pddl2850  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred109_Pddl2850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred109_Pddl2850	= { FOLLOW_54_in_synpred109_Pddl2850_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_synpred109_Pddl2852  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_71_in_synpred109_Pddl2852_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_71_in_synpred109_Pddl2852	= { FOLLOW_71_in_synpred109_Pddl2852_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_prefConGD_in_synpred109_Pddl2854  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_prefConGD_in_synpred109_Pddl2854_bits[]	= { ANTLR3_UINT64_LIT(0x0140000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_prefConGD_in_synpred109_Pddl2854	= { FOLLOW_prefConGD_in_synpred109_Pddl2854_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred109_Pddl2857  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred109_Pddl2857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred109_Pddl2857	= { FOLLOW_56_in_synpred109_Pddl2857_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred110_Pddl2862  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred110_Pddl2862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred110_Pddl2862	= { FOLLOW_54_in_synpred110_Pddl2862_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_76_in_synpred110_Pddl2864  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_76_in_synpred110_Pddl2864_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_76_in_synpred110_Pddl2864	= { FOLLOW_76_in_synpred110_Pddl2864_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred110_Pddl2866  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred110_Pddl2866_bits[]	= { ANTLR3_UINT64_LIT(0x0100800000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred110_Pddl2866	= { FOLLOW_54_in_synpred110_Pddl2866_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_typedVariableList_in_synpred110_Pddl2868  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_typedVariableList_in_synpred110_Pddl2868_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_typedVariableList_in_synpred110_Pddl2868	= { FOLLOW_typedVariableList_in_synpred110_Pddl2868_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred110_Pddl2870  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred110_Pddl2870_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred110_Pddl2870	= { FOLLOW_56_in_synpred110_Pddl2870_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_prefConGD_in_synpred110_Pddl2872  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_prefConGD_in_synpred110_Pddl2872_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_prefConGD_in_synpred110_Pddl2872	= { FOLLOW_prefConGD_in_synpred110_Pddl2872_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred110_Pddl2874  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred110_Pddl2874_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred110_Pddl2874	= { FOLLOW_56_in_synpred110_Pddl2874_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred112_Pddl2879  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred112_Pddl2879_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred112_Pddl2879	= { FOLLOW_54_in_synpred112_Pddl2879_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_80_in_synpred112_Pddl2881  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_80_in_synpred112_Pddl2881_bits[]	= { ANTLR3_UINT64_LIT(0x0040200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_80_in_synpred112_Pddl2881	= { FOLLOW_80_in_synpred112_Pddl2881_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_synpred112_Pddl2883  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_synpred112_Pddl2883_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_synpred112_Pddl2883	= { FOLLOW_NAME_in_synpred112_Pddl2883_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_conGD_in_synpred112_Pddl2886  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_conGD_in_synpred112_Pddl2886_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_conGD_in_synpred112_Pddl2886	= { FOLLOW_conGD_in_synpred112_Pddl2886_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred112_Pddl2888  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred112_Pddl2888_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred112_Pddl2888	= { FOLLOW_56_in_synpred112_Pddl2888_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred114_Pddl2949  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred114_Pddl2949_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000), ANTLR3_UINT64_LIT(0x0000000007000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred114_Pddl2949	= { FOLLOW_54_in_synpred114_Pddl2949_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_binaryOp_in_synpred114_Pddl2951  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_binaryOp_in_synpred114_Pddl2951_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_binaryOp_in_synpred114_Pddl2951	= { FOLLOW_binaryOp_in_synpred114_Pddl2951_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_synpred114_Pddl2953  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_synpred114_Pddl2953_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_synpred114_Pddl2953	= { FOLLOW_metricFExp_in_synpred114_Pddl2953_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_synpred114_Pddl2955  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_synpred114_Pddl2955_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_synpred114_Pddl2955	= { FOLLOW_metricFExp_in_synpred114_Pddl2955_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred114_Pddl2957  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred114_Pddl2957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred114_Pddl2957	= { FOLLOW_56_in_synpred114_Pddl2957_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred117_Pddl2962  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred117_Pddl2962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000005000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred117_Pddl2962	= { FOLLOW_54_in_synpred117_Pddl2962_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_synpred117_Pddl2964  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_set_in_synpred117_Pddl2964_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_set_in_synpred117_Pddl2964	= { FOLLOW_set_in_synpred117_Pddl2964_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_synpred117_Pddl2970  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_synpred117_Pddl2970_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_synpred117_Pddl2970	= { FOLLOW_metricFExp_in_synpred117_Pddl2970_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_synpred117_Pddl2972  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_synpred117_Pddl2972_bits[]	= { ANTLR3_UINT64_LIT(0x0141200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_synpred117_Pddl2972	= { FOLLOW_metricFExp_in_synpred117_Pddl2972_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred117_Pddl2975  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred117_Pddl2975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred117_Pddl2975	= { FOLLOW_56_in_synpred117_Pddl2975_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred118_Pddl2980  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred118_Pddl2980_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred118_Pddl2980	= { FOLLOW_54_in_synpred118_Pddl2980_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_synpred118_Pddl2982  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_60_in_synpred118_Pddl2982_bits[]	= { ANTLR3_UINT64_LIT(0x0041200000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_60_in_synpred118_Pddl2982	= { FOLLOW_60_in_synpred118_Pddl2982_bits, 2	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_metricFExp_in_synpred118_Pddl2984  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_metricFExp_in_synpred118_Pddl2984_bits[]	= { ANTLR3_UINT64_LIT(0x0100000000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_metricFExp_in_synpred118_Pddl2984	= { FOLLOW_metricFExp_in_synpred118_Pddl2984_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred118_Pddl2986  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred118_Pddl2986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred118_Pddl2986	= { FOLLOW_56_in_synpred118_Pddl2986_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_54_in_synpred121_Pddl2996  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_54_in_synpred121_Pddl2996_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_54_in_synpred121_Pddl2996	= { FOLLOW_54_in_synpred121_Pddl2996_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionSymbol_in_synpred121_Pddl2998  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_functionSymbol_in_synpred121_Pddl2998_bits[]	= { ANTLR3_UINT64_LIT(0x0100200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_functionSymbol_in_synpred121_Pddl2998	= { FOLLOW_functionSymbol_in_synpred121_Pddl2998_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAME_in_synpred121_Pddl3000  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_NAME_in_synpred121_Pddl3000_bits[]	= { ANTLR3_UINT64_LIT(0x0100200000000000) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_NAME_in_synpred121_Pddl3000	= { FOLLOW_NAME_in_synpred121_Pddl3000_bits, 1	};\n";
		file << "/** Bitset defining follow set for error recovery in rule state: FOLLOW_56_in_synpred121_Pddl3003  */\n";
		file << "static	ANTLR3_BITWORD FOLLOW_56_in_synpred121_Pddl3003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };\n";
		file << "static  ANTLR3_BITSET_LIST FOLLOW_56_in_synpred121_Pddl3003	= { FOLLOW_56_in_synpred121_Pddl3003_bits, 1	};\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "/* =========================================================================\n";
		file << " * DFA tables for the parser\n";
		file << " */\n";
		file << "/** Static dfa state tables for Cyclic dfa:\n";
		file << " *    133:7: ( ( NAME )* | ( singleTypeNameList )+ ( NAME )* )\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 dfa15_eot[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa15_eof[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa15_min[4] =\n";
		file << "    {\n";
		file << "	45, 45, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa15_max[4] =\n";
		file << "    {\n";
		file << "	56, 60, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa15_accept[4] =\n";
		file << "    {\n";
		file << "	-1, -1, 1, 2\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa15_special[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "\n";
		file << "/** Used when there is no transition table entry for a particular state */\n";
		file << "#define dfa15_T_empty	    NULL\n";
		file << "\n";
		file << "static const ANTLR3_INT32 dfa15_T0[] =\n";
		file << "    {\n";
		file << "	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2\n";
		file << "    };static const ANTLR3_INT32 dfa15_T1[] =\n";
		file << "    {\n";
		file << "	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, 3\n";
		file << "    };\n";
		file << "\n";
		file << "/* Transition tables are a table of sub tables, with some tables\n";
		file << " * reused for efficiency.\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 * const dfa15_transitions[] =\n";
		file << "{\n";
		file << "    dfa15_T0, dfa15_T1, dfa15_T_empty, dfa15_T_empty\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "/* Declare tracking structure for Cyclic DFA 15\n";
		file << " */\n";
		file << "static\n";
		file << "ANTLR3_CYCLIC_DFA cdfa15\n";
		file << "    =	{\n";
		file << "	    15,		    /* Decision number of this dfa	    */\n";
		file << "	    /* Which decision this represents:   */\n";
		file << "	    (const pANTLR3_UCHAR)\"133:7: ( ( NAME )* | ( singleTypeNameList )+ ( NAME )* )\",\n";
		file << "	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/\n";
		file << "	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */\n";
		file << "	    antlr3dfapredict,			/* DFA simulator function is in the runtime */\n";
		file << "	    dfa15_eot,	    /* EOT table			    */\n";
		file << "	    dfa15_eof,	    /* EOF table			    */\n";
		file << "	    dfa15_min,	    /* Minimum tokens for each state    */\n";
		file << "	    dfa15_max,	    /* Maximum tokens for each state    */\n";
		file << "	    dfa15_accept,	/* Accept table			    */\n";
		file << "	    dfa15_special,	/* Special transition states	    */\n";
		file << "	    dfa15_transitions	/* Table of transition tables	    */\n";
		file << "\n";
		file << "	};\n";
		file << "/* End of Cyclic DFA 15\n";
		file << " * ---------------------\n";
		file << " *//** Static dfa state tables for Cyclic dfa:\n";
		file << " *    ()+ loopback of 133:16: ( singleTypeNameList )+\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 dfa13_eot[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa13_eof[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa13_min[4] =\n";
		file << "    {\n";
		file << "	45, 45, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa13_max[4] =\n";
		file << "    {\n";
		file << "	56, 60, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa13_accept[4] =\n";
		file << "    {\n";
		file << "	-1, -1, 2, 1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa13_special[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "\n";
		file << "/** Used when there is no transition table entry for a particular state */\n";
		file << "#define dfa13_T_empty	    NULL\n";
		file << "\n";
		file << "static const ANTLR3_INT32 dfa13_T0[] =\n";
		file << "    {\n";
		file << "	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, 3\n";
		file << "    };static const ANTLR3_INT32 dfa13_T1[] =\n";
		file << "    {\n";
		file << "	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2\n";
		file << "    };\n";
		file << "\n";
		file << "/* Transition tables are a table of sub tables, with some tables\n";
		file << " * reused for efficiency.\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 * const dfa13_transitions[] =\n";
		file << "{\n";
		file << "    dfa13_T1, dfa13_T0, dfa13_T_empty, dfa13_T_empty\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "/* Declare tracking structure for Cyclic DFA 13\n";
		file << " */\n";
		file << "static\n";
		file << "ANTLR3_CYCLIC_DFA cdfa13\n";
		file << "    =	{\n";
		file << "	    13,		    /* Decision number of this dfa	    */\n";
		file << "	    /* Which decision this represents:   */\n";
		file << "	    (const pANTLR3_UCHAR)\"()+ loopback of 133:16: ( singleTypeNameList )+\",\n";
		file << "	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/\n";
		file << "	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */\n";
		file << "	    antlr3dfapredict,			/* DFA simulator function is in the runtime */\n";
		file << "	    dfa13_eot,	    /* EOT table			    */\n";
		file << "	    dfa13_eof,	    /* EOF table			    */\n";
		file << "	    dfa13_min,	    /* Minimum tokens for each state    */\n";
		file << "	    dfa13_max,	    /* Maximum tokens for each state    */\n";
		file << "	    dfa13_accept,	/* Accept table			    */\n";
		file << "	    dfa13_special,	/* Special transition states	    */\n";
		file << "	    dfa13_transitions	/* Table of transition tables	    */\n";
		file << "\n";
		file << "	};\n";
		file << "/* End of Cyclic DFA 13\n";
		file << " * ---------------------\n";
		file << " *//** Static dfa state tables for Cyclic dfa:\n";
		file << " *    184:7: ( ( VARIABLE )* | ( singleTypeVarList )+ ( VARIABLE )* )\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 dfa26_eot[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa26_eof[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa26_min[4] =\n";
		file << "    {\n";
		file << "	47, 47, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa26_max[4] =\n";
		file << "    {\n";
		file << "	56, 60, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa26_accept[4] =\n";
		file << "    {\n";
		file << "	-1, -1, 1, 2\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa26_special[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "\n";
		file << "/** Used when there is no transition table entry for a particular state */\n";
		file << "#define dfa26_T_empty	    NULL\n";
		file << "\n";
		file << "static const ANTLR3_INT32 dfa26_T0[] =\n";
		file << "    {\n";
		file << "	1, -1, -1, -1, -1, -1, -1, 2, -1, 2, -1, -1, -1, 3\n";
		file << "    };static const ANTLR3_INT32 dfa26_T1[] =\n";
		file << "    {\n";
		file << "	1, -1, -1, -1, -1, -1, -1, 2, -1, 2\n";
		file << "    };\n";
		file << "\n";
		file << "/* Transition tables are a table of sub tables, with some tables\n";
		file << " * reused for efficiency.\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 * const dfa26_transitions[] =\n";
		file << "{\n";
		file << "    dfa26_T1, dfa26_T0, dfa26_T_empty, dfa26_T_empty\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "/* Declare tracking structure for Cyclic DFA 26\n";
		file << " */\n";
		file << "static\n";
		file << "ANTLR3_CYCLIC_DFA cdfa26\n";
		file << "    =	{\n";
		file << "	    26,		    /* Decision number of this dfa	    */\n";
		file << "	    /* Which decision this represents:   */\n";
		file << "	    (const pANTLR3_UCHAR)\"184:7: ( ( VARIABLE )* | ( singleTypeVarList )+ ( VARIABLE )* )\",\n";
		file << "	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/\n";
		file << "	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */\n";
		file << "	    antlr3dfapredict,			/* DFA simulator function is in the runtime */\n";
		file << "	    dfa26_eot,	    /* EOT table			    */\n";
		file << "	    dfa26_eof,	    /* EOF table			    */\n";
		file << "	    dfa26_min,	    /* Minimum tokens for each state    */\n";
		file << "	    dfa26_max,	    /* Maximum tokens for each state    */\n";
		file << "	    dfa26_accept,	/* Accept table			    */\n";
		file << "	    dfa26_special,	/* Special transition states	    */\n";
		file << "	    dfa26_transitions	/* Table of transition tables	    */\n";
		file << "\n";
		file << "	};\n";
		file << "/* End of Cyclic DFA 26\n";
		file << " * ---------------------\n";
		file << " *//** Static dfa state tables for Cyclic dfa:\n";
		file << " *    ()+ loopback of 184:20: ( singleTypeVarList )+\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 dfa24_eot[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa24_eof[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa24_min[4] =\n";
		file << "    {\n";
		file << "	47, 47, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa24_max[4] =\n";
		file << "    {\n";
		file << "	56, 60, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa24_accept[4] =\n";
		file << "    {\n";
		file << "	-1, -1, 2, 1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa24_special[4] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1\n";
		file << "    };\n";
		file << "\n";
		file << "/** Used when there is no transition table entry for a particular state */\n";
		file << "#define dfa24_T_empty	    NULL\n";
		file << "\n";
		file << "static const ANTLR3_INT32 dfa24_T0[] =\n";
		file << "    {\n";
		file << "	1, -1, -1, -1, -1, -1, -1, 2, -1, 2\n";
		file << "    };static const ANTLR3_INT32 dfa24_T1[] =\n";
		file << "    {\n";
		file << "	1, -1, -1, -1, -1, -1, -1, 2, -1, 2, -1, -1, -1, 3\n";
		file << "    };\n";
		file << "\n";
		file << "/* Transition tables are a table of sub tables, with some tables\n";
		file << " * reused for efficiency.\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 * const dfa24_transitions[] =\n";
		file << "{\n";
		file << "    dfa24_T0, dfa24_T1, dfa24_T_empty, dfa24_T_empty\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "/* Declare tracking structure for Cyclic DFA 24\n";
		file << " */\n";
		file << "static\n";
		file << "ANTLR3_CYCLIC_DFA cdfa24\n";
		file << "    =	{\n";
		file << "	    24,		    /* Decision number of this dfa	    */\n";
		file << "	    /* Which decision this represents:   */\n";
		file << "	    (const pANTLR3_UCHAR)\"()+ loopback of 184:20: ( singleTypeVarList )+\",\n";
		file << "	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/\n";
		file << "	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */\n";
		file << "	    antlr3dfapredict,			/* DFA simulator function is in the runtime */\n";
		file << "	    dfa24_eot,	    /* EOT table			    */\n";
		file << "	    dfa24_eof,	    /* EOF table			    */\n";
		file << "	    dfa24_min,	    /* Minimum tokens for each state    */\n";
		file << "	    dfa24_max,	    /* Maximum tokens for each state    */\n";
		file << "	    dfa24_accept,	/* Accept table			    */\n";
		file << "	    dfa24_special,	/* Special transition states	    */\n";
		file << "	    dfa24_transitions	/* Table of transition tables	    */\n";
		file << "\n";
		file << "	};\n";
		file << "/* End of Cyclic DFA 24\n";
		file << " * ---------------------\n";
		file << " *//** Static dfa state tables for Cyclic dfa:\n";
		file << " *    235:1: goalDesc : ( atomicTermFormula | '(' 'and' ( goalDesc )* ')' -> ^( AND_GD ( goalDesc )* ) | '(' 'or' ( goalDesc )* ')' -> ^( OR_GD ( goalDesc )* ) | '(' 'not' goalDesc ')' -> ^( NOT_GD goalDesc ) | '(' 'imply' goalDesc goalDesc ')' -> ^( IMPLY_GD goalDesc goalDesc ) | '(' 'exists' '(' typedVariableList ')' goalDesc ')' -> ^( EXISTS_GD typedVariableList goalDesc ) | '(' 'forall' '(' typedVariableList ')' goalDesc ')' -> ^( FORALL_GD typedVariableList goalDesc ) | fComp -> ^( COMPARISON_GD fComp ) );\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 dfa36_eot[10] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa36_eof[10] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa36_min[10] =\n";
		file << "    {\n";
		file << "	54, 45, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa36_max[10] =\n";
		file << "    {\n";
		file << "	54, 95, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa36_accept[10] =\n";
		file << "    {\n";
		file << "	-1, -1, 2, 3, 4, 5, 6, 7, 1, 8\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa36_special[10] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "\n";
		file << "/** Used when there is no transition table entry for a particular state */\n";
		file << "#define dfa36_T_empty	    NULL\n";
		file << "\n";
		file << "static const ANTLR3_INT32 dfa36_T0[] =\n";
		file << "    {\n";
		file << "	1\n";
		file << "    };static const ANTLR3_INT32 dfa36_T1[] =\n";
		file << "    {\n";
		file << "	8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9\n";
		file << "    };\n";
		file << "\n";
		file << "/* Transition tables are a table of sub tables, with some tables\n";
		file << " * reused for efficiency.\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 * const dfa36_transitions[] =\n";
		file << "{\n";
		file << "    dfa36_T0, dfa36_T1, dfa36_T_empty, dfa36_T_empty, dfa36_T_empty, dfa36_T_empty,\n";
		file << "    dfa36_T_empty, dfa36_T_empty, dfa36_T_empty, dfa36_T_empty\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "/* Declare tracking structure for Cyclic DFA 36\n";
		file << " */\n";
		file << "static\n";
		file << "ANTLR3_CYCLIC_DFA cdfa36\n";
		file << "    =	{\n";
		file << "	    36,		    /* Decision number of this dfa	    */\n";
		file << "	    /* Which decision this represents:   */\n";
		file << "	    (const pANTLR3_UCHAR)\"235:1: goalDesc : ( atomicTermFormula | '(' 'and' ( goalDesc )* ')' -> ^( AND_GD ( goalDesc )* ) | '(' 'or' ( goalDesc )* ')' -> ^( OR_GD ( goalDesc )* ) | '(' 'not' goalDesc ')' -> ^( NOT_GD goalDesc ) | '(' 'imply' goalDesc goalDesc ')' -> ^( IMPLY_GD goalDesc goalDesc ) | '(' 'exists' '(' typedVariableList ')' goalDesc ')' -> ^( EXISTS_GD typedVariableList goalDesc ) | '(' 'forall' '(' typedVariableList ')' goalDesc ')' -> ^( FORALL_GD typedVariableList goalDesc ) | fComp -> ^( COMPARISON_GD fComp ) );\",\n";
		file << "	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/\n";
		file << "	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */\n";
		file << "	    antlr3dfapredict,			/* DFA simulator function is in the runtime */\n";
		file << "	    dfa36_eot,	    /* EOT table			    */\n";
		file << "	    dfa36_eof,	    /* EOF table			    */\n";
		file << "	    dfa36_min,	    /* Minimum tokens for each state    */\n";
		file << "	    dfa36_max,	    /* Maximum tokens for each state    */\n";
		file << "	    dfa36_accept,	/* Accept table			    */\n";
		file << "	    dfa36_special,	/* Special transition states	    */\n";
		file << "	    dfa36_transitions	/* Table of transition tables	    */\n";
		file << "\n";
		file << "	};\n";
		file << "/* End of Cyclic DFA 36\n";
		file << " * ---------------------\n";
		file << " *//** Static dfa state tables for Cyclic dfa:\n";
		file << " *    476:1: metricFExp : ( '(' binaryOp metricFExp metricFExp ')' | '(' ( '*' | '/' ) metricFExp ( metricFExp )+ ')' | '(' '-' metricFExp ')' | NUMBER | '(' functionSymbol ( NAME )* ')' | functionSymbol | 'total-time' | '(' 'is-violated' NAME ')' );\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 dfa77_eot[10] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa77_eof[10] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa77_min[10] =\n";
		file << "    {\n";
		file << "	45, 0, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa77_max[10] =\n";
		file << "    {\n";
		file << "	110, 0, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa77_accept[10] =\n";
		file << "    {\n";
		file << "	-1, -1, 4, 6, 7, 1, 2, 3, 5, 8\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa77_special[10] =\n";
		file << "    {\n";
		file << "	-1, 0, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "\n";
		file << "/** Used when there is no transition table entry for a particular state */\n";
		file << "#define dfa77_T_empty	    NULL\n";
		file << "\n";
		file << "static const ANTLR3_INT32 dfa77_T0[] =\n";
		file << "    {\n";
		file << "	3, -1, -1, 2, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4\n";
		file << "    };static const ANTLR3_INT32 dfa77_T1[] =\n";
		file << "    {\n";
		file << "	-1\n";
		file << "    };\n";
		file << "\n";
		file << "/* Transition tables are a table of sub tables, with some tables\n";
		file << " * reused for efficiency.\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 * const dfa77_transitions[] =\n";
		file << "{\n";
		file << "    dfa77_T0, dfa77_T1, dfa77_T_empty, dfa77_T_empty, dfa77_T_empty, dfa77_T_empty,\n";
		file << "    dfa77_T_empty, dfa77_T_empty, dfa77_T_empty, dfa77_T_empty\n";
		file << "};\n";
		file << "\n";
		file << "static ANTLR3_INT32 dfa77_sst(pPddlParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)\n";
		file << "{\n";
		file << "    ANTLR3_INT32    _s;\n";
		file << "\n";
		file << "    _s	    = s;\n";
		file << "    switch  (s)\n";
		file << "    {\n";
		file << "        case 0:\n";
		file << "\n";
		file << "    	{\n";
		file << "    	    ANTLR3_UINT32 LA77_1;\n";
		file << "\n";
		file << "    	    ANTLR3_MARKER index77_1;\n";
		file << "\n";
		file << "\n";
		file << "    		LA77_1 = LA(1);\n";
		file << "\n";
		file << "\n";
		file << "    	    index77_1 = INDEX();\n";
		file << "\n";
		file << "    	    REWINDLAST();\n";
		file << "\n";
		file << "    	    s = -1;\n";
		file << "    	    if ( (synpred114_Pddl(ctx)) )\n";
		file << "    	    {\n";
		file << "    	        s = 5;\n";
		file << "    	    }\n";
		file << "\n";
		file << "    	    else if ( (synpred117_Pddl(ctx)) )\n";
		file << "    	    {\n";
		file << "    	        s = 6;\n";
		file << "    	    }\n";
		file << "\n";
		file << "    	    else if ( (synpred118_Pddl(ctx)) )\n";
		file << "    	    {\n";
		file << "    	        s = 7;\n";
		file << "    	    }\n";
		file << "\n";
		file << "    	    else if ( (synpred121_Pddl(ctx)) )\n";
		file << "    	    {\n";
		file << "    	        s = 8;\n";
		file << "    	    }\n";
		file << "\n";
		file << "    	    else if ( (ANTLR3_TRUE) )\n";
		file << "    	    {\n";
		file << "    	        s = 9;\n";
		file << "    	    }\n";
		file << "\n";
		file << "\n";
		file << "    		SEEK(index77_1);\n";
		file << "\n";
		file << "    	    if ( s>=0 )\n";
		file << "    	    {\n";
		file << "    		return s;\n";
		file << "    	    }\n";
		file << "    	}\n";
		file << "    	break;\n";
		file << "    }\n";
		file << "    if (BACKTRACKING > 0)\n";
		file << "    {\n";
		file << "	FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "	return	-1;\n";
		file << "    }\n";
		file << "    CONSTRUCTEX();\n";
		file << "    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "    EXCEPTION->message      = (void *)\"476:1: metricFExp : ( '(' binaryOp metricFExp metricFExp ')' | '(' ( '*' | '/' ) metricFExp ( metricFExp )+ ')' | '(' '-' metricFExp ')' | NUMBER | '(' functionSymbol ( NAME )* ')' | functionSymbol | 'total-time' | '(' 'is-violated' NAME ')' );\";\n";
		file << "    EXCEPTION->decisionNum  = 77;\n";
		file << "    EXCEPTION->state        = _s;\n";
		file << "    return -1;\n";
		file << "}\n";
		file << "\n";
		file << "/* Declare tracking structure for Cyclic DFA 77\n";
		file << " */\n";
		file << "static\n";
		file << "ANTLR3_CYCLIC_DFA cdfa77\n";
		file << "    =	{\n";
		file << "	    77,		    /* Decision number of this dfa	    */\n";
		file << "	    /* Which decision this represents:   */\n";
		file << "	    (const pANTLR3_UCHAR)\"476:1: metricFExp : ( '(' binaryOp metricFExp metricFExp ')' | '(' ( '*' | '/' ) metricFExp ( metricFExp )+ ')' | '(' '-' metricFExp ')' | NUMBER | '(' functionSymbol ( NAME )* ')' | functionSymbol | 'total-time' | '(' 'is-violated' NAME ')' );\",\n";
		file << "	    (CDFA_SPECIAL_FUNC) dfa77_sst,\n";
		file << "	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */\n";
		file << "	    antlr3dfapredict,			/* DFA simulator function is in the runtime */\n";
		file << "	    dfa77_eot,	    /* EOT table			    */\n";
		file << "	    dfa77_eof,	    /* EOF table			    */\n";
		file << "	    dfa77_min,	    /* Minimum tokens for each state    */\n";
		file << "	    dfa77_max,	    /* Maximum tokens for each state    */\n";
		file << "	    dfa77_accept,	/* Accept table			    */\n";
		file << "	    dfa77_special,	/* Special transition states	    */\n";
		file << "	    dfa77_transitions	/* Table of transition tables	    */\n";
		file << "\n";
		file << "	};\n";
		file << "/* End of Cyclic DFA 77\n";
		file << " * ---------------------\n";
		file << " *//** Static dfa state tables for Cyclic dfa:\n";
		file << " *    487:1: conGD : ( '(' 'and' ( conGD )* ')' | '(' 'forall' '(' typedVariableList ')' conGD ')' | '(' 'at' 'end' goalDesc ')' | '(' 'always' goalDesc ')' | '(' 'sometime' goalDesc ')' | '(' 'within' NUMBER goalDesc ')' | '(' 'at-most-once' goalDesc ')' | '(' 'sometime-after' goalDesc goalDesc ')' | '(' 'sometime-before' goalDesc goalDesc ')' | '(' 'always-within' NUMBER goalDesc goalDesc ')' | '(' 'hold-during' NUMBER NUMBER goalDesc ')' | '(' 'hold-after' NUMBER goalDesc ')' );\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 dfa79_eot[14] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa79_eof[14] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa79_min[14] =\n";
		file << "    {\n";
		file << "	54, 71, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa79_max[14] =\n";
		file << "    {\n";
		file << "	54, 120, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa79_accept[14] =\n";
		file << "    {\n";
		file << "	-1, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n";
		file << "    };\n";
		file << "static const ANTLR3_INT32 dfa79_special[14] =\n";
		file << "    {\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n";
		file << "    };\n";
		file << "\n";
		file << "/** Used when there is no transition table entry for a particular state */\n";
		file << "#define dfa79_T_empty	    NULL\n";
		file << "\n";
		file << "static const ANTLR3_INT32 dfa79_T0[] =\n";
		file << "    {\n";
		file << "	1\n";
		file << "    };static const ANTLR3_INT32 dfa79_T1[] =\n";
		file << "    {\n";
		file << "	2, -1, -1, -1, -1, 3, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n";
		file << "	-1, -1, -1, -1, 5, 6, 7, 8, 9, 10, 11, 12, 13\n";
		file << "    };\n";
		file << "\n";
		file << "/* Transition tables are a table of sub tables, with some tables\n";
		file << " * reused for efficiency.\n";
		file << " */\n";
		file << "static const ANTLR3_INT32 * const dfa79_transitions[] =\n";
		file << "{\n";
		file << "    dfa79_T0, dfa79_T1, dfa79_T_empty, dfa79_T_empty, dfa79_T_empty, dfa79_T_empty,\n";
		file << "    dfa79_T_empty, dfa79_T_empty, dfa79_T_empty, dfa79_T_empty, dfa79_T_empty,\n";
		file << "    dfa79_T_empty, dfa79_T_empty, dfa79_T_empty\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "/* Declare tracking structure for Cyclic DFA 79\n";
		file << " */\n";
		file << "static\n";
		file << "ANTLR3_CYCLIC_DFA cdfa79\n";
		file << "    =	{\n";
		file << "	    79,		    /* Decision number of this dfa	    */\n";
		file << "	    /* Which decision this represents:   */\n";
		file << "	    (const pANTLR3_UCHAR)\"487:1: conGD : ( '(' 'and' ( conGD )* ')' | '(' 'forall' '(' typedVariableList ')' conGD ')' | '(' 'at' 'end' goalDesc ')' | '(' 'always' goalDesc ')' | '(' 'sometime' goalDesc ')' | '(' 'within' NUMBER goalDesc ')' | '(' 'at-most-once' goalDesc ')' | '(' 'sometime-after' goalDesc goalDesc ')' | '(' 'sometime-before' goalDesc goalDesc ')' | '(' 'always-within' NUMBER goalDesc goalDesc ')' | '(' 'hold-during' NUMBER NUMBER goalDesc ')' | '(' 'hold-after' NUMBER goalDesc ')' );\",\n";
		file << "	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/\n";
		file << "	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */\n";
		file << "	    antlr3dfapredict,			/* DFA simulator function is in the runtime */\n";
		file << "	    dfa79_eot,	    /* EOT table			    */\n";
		file << "	    dfa79_eof,	    /* EOF table			    */\n";
		file << "	    dfa79_min,	    /* Minimum tokens for each state    */\n";
		file << "	    dfa79_max,	    /* Maximum tokens for each state    */\n";
		file << "	    dfa79_accept,	/* Accept table			    */\n";
		file << "	    dfa79_special,	/* Special transition states	    */\n";
		file << "	    dfa79_transitions	/* Table of transition tables	    */\n";
		file << "\n";
		file << "	};\n";
		file << "/* End of Cyclic DFA 79\n";
		file << " * ---------------------\n";
		file << " */\n";
		file << "/* =========================================================================\n";
		file << " * End of DFA tables for the parser\n";
		file << " */\n";
		file << "\n";
		file << "/* ==============================================\n";
		file << " * Parsing rules\n";
		file << " */\n";
		file << "/**\n";
		file << " * $ANTLR start getDomain\n";
		file << " * ../../model/subgoal_learning/Pddl.g:64:1: getDomain : ( domain )+ ;\n";
		file << " */\n";
		file << "static PddlParser_getDomain_return\n";
		file << "getDomain(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_getDomain_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    PddlParser_domain_return domain1;\n";
		file << "    #undef	RETURN_TYPE_domain1\n";
		file << "    #define	RETURN_TYPE_domain1 PddlParser_domain_return\n";
		file << "\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    domain1.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:64:10: ( ( domain )+ )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:64:12: ( domain )+\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:64:12: ( domain )+\n";
		file << "            {\n";
		file << "                int cnt1=0;\n";
		file << "\n";
		file << "                for (;;)\n";
		file << "                {\n";
		file << "                    int alt1=2;\n";
		file << "            	{\n";
		file << "            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	    */\n";
		file << "            	    int LA1_0 = LA(1);\n";
		file << "            	    if ( (LA1_0 == 54) )\n";
		file << "            	    {\n";
		file << "            	        alt1=1;\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "            	switch (alt1)\n";
		file << "            	{\n";
		file << "            	    case 1:\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:64:14: domain\n";
		file << "            	        {\n";
		file << "            	            FOLLOWPUSH(FOLLOW_domain_in_getDomain284);\n";
		file << "            	            domain1=domain(ctx);\n";
		file << "\n";
		file << "            	            FOLLOWPOP();\n";
		file << "            	            if  (HASEXCEPTION())\n";
		file << "            	            {\n";
		file << "            	                goto rulegetDomainEx;\n";
		file << "            	            }\n";
		file << "            	            if (HASFAILED())\n";
		file << "            	            {\n";
		file << "            	                return retval;\n";
		file << "            	            }\n";
		file << "            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, domain1.tree);\n";
		file << "            	            if ( BACKTRACKING==0 )\n";
		file << "            	            {\n";
		file << "            	                //[SB] return (domain1.tree);\n";
		file << "\n";
		file << "								//[SB-INSERT]\n";
		file << "								retval.tree = domain1.tree;\n";
		file << "								return retval;\n";
		file << "								//[SB-INSERT-END]\n";
		file << "            	            }\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        break;\n";
		file << "\n";
		file << "            	    default:\n";
		file << "\n";
		file << "            		if ( cnt1 >= 1 )\n";
		file << "            		{\n";
		file << "            		    goto loop1;\n";
		file << "            		}\n";
		file << "            		if (BACKTRACKING>0)\n";
		file << "            		{\n";
		file << "            		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            		    return retval;\n";
		file << "            		}\n";
		file << "            		/* mismatchedSetEx()\n";
		file << "            		 */\n";
		file << "            		CONSTRUCTEX();\n";
		file << "            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "            		goto rulegetDomainEx;\n";
		file << "            	}\n";
		file << "            	cnt1++;\n";
		file << "                }\n";
		file << "                loop1: ;	/* Jump to here if this rule does not match */\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulegetDomainEx; /* Prevent compiler warnings */\n";
		file << "    rulegetDomainEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end getDomain */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start getProblem\n";
		file << " * ../../model/subgoal_learning/Pddl.g:65:1: getProblem : ( problem )+ ;\n";
		file << " */\n";
		file << "static PddlParser_getProblem_return\n";
		file << "getProblem(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_getProblem_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    PddlParser_problem_return problem2;\n";
		file << "    #undef	RETURN_TYPE_problem2\n";
		file << "    #define	RETURN_TYPE_problem2 PddlParser_problem_return\n";
		file << "\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    problem2.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:65:11: ( ( problem )+ )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:65:13: ( problem )+\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:65:13: ( problem )+\n";
		file << "            {\n";
		file << "                int cnt2=0;\n";
		file << "\n";
		file << "                for (;;)\n";
		file << "                {\n";
		file << "                    int alt2=2;\n";
		file << "            	{\n";
		file << "            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	    */\n";
		file << "            	    int LA2_0 = LA(1);\n";
		file << "            	    if ( (LA2_0 == 54) )\n";
		file << "            	    {\n";
		file << "            	        alt2=1;\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "            	switch (alt2)\n";
		file << "            	{\n";
		file << "            	    case 1:\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:65:15: problem\n";
		file << "            	        {\n";
		file << "            	            FOLLOWPUSH(FOLLOW_problem_in_getProblem298);\n";
		file << "            	            problem2=problem(ctx);\n";
		file << "\n";
		file << "            	            FOLLOWPOP();\n";
		file << "            	            if  (HASEXCEPTION())\n";
		file << "            	            {\n";
		file << "            	                goto rulegetProblemEx;\n";
		file << "            	            }\n";
		file << "            	            if (HASFAILED())\n";
		file << "            	            {\n";
		file << "            	                return retval;\n";
		file << "            	            }\n";
		file << "            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, problem2.tree);\n";
		file << "            	            if ( BACKTRACKING==0 )\n";
		file << "            	            {\n";
		file << "            	                //[SB] return (problem2.tree);\n";
		file << "								//[SB-INSERT]\n";
		file << "								retval.tree = problem2.tree;\n";
		file << "								return retval;\n";
		file << "								//[SB-INSERT-END]\n";
		file << "            	            }\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        break;\n";
		file << "\n";
		file << "            	    default:\n";
		file << "\n";
		file << "            		if ( cnt2 >= 1 )\n";
		file << "            		{\n";
		file << "            		    goto loop2;\n";
		file << "            		}\n";
		file << "            		if (BACKTRACKING>0)\n";
		file << "            		{\n";
		file << "            		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            		    return retval;\n";
		file << "            		}\n";
		file << "            		/* mismatchedSetEx()\n";
		file << "            		 */\n";
		file << "            		CONSTRUCTEX();\n";
		file << "            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "            		goto rulegetProblemEx;\n";
		file << "            	}\n";
		file << "            	cnt2++;\n";
		file << "                }\n";
		file << "                loop2: ;	/* Jump to here if this rule does not match */\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulegetProblemEx; /* Prevent compiler warnings */\n";
		file << "    rulegetProblemEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end getProblem */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start pddlDoc\n";
		file << " * ../../model/subgoal_learning/Pddl.g:95:1: pddlDoc : ( domain | problem );\n";
		file << " */\n";
		file << "static PddlParser_pddlDoc_return\n";
		file << "pddlDoc(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_pddlDoc_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    PddlParser_domain_return domain3;\n";
		file << "    #undef	RETURN_TYPE_domain3\n";
		file << "    #define	RETURN_TYPE_domain3 PddlParser_domain_return\n";
		file << "\n";
		file << "    PddlParser_problem_return problem4;\n";
		file << "    #undef	RETURN_TYPE_problem4\n";
		file << "    #define	RETURN_TYPE_problem4 PddlParser_problem_return\n";
		file << "\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    domain3.tree = NULL;\n";
		file << "\n";
		file << "    problem4.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:97:9: ( domain | problem )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt3;\n";
		file << "\n";
		file << "            alt3=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA3_0 = LA(1);\n";
		file << "                if ( (LA3_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA3_1 = LA(2);\n";
		file << "                        if ( (LA3_1 == 55) )\n";
		file << "                        {\n";
		file << "\n";
		file << "                            {\n";
		file << "                                int LA3_2 = LA(3);\n";
		file << "                                if ( (LA3_2 == 54) )\n";
		file << "                                {\n";
		file << "\n";
		file << "                                    {\n";
		file << "                                        int LA3_3 = LA(4);\n";
		file << "                                        if ( (LA3_3 == 102) )\n";
		file << "                                        {\n";
		file << "                                            alt3=2;\n";
		file << "                                        }\n";
		file << "                                        else if ( (LA3_3 == 57) )\n";
		file << "                                        {\n";
		file << "                                            alt3=1;\n";
		file << "                                        }\n";
		file << "                                        else\n";
		file << "                                        {\n";
		file << "                                            if (BACKTRACKING>0)\n";
		file << "                                            {\n";
		file << "                                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                                return retval;\n";
		file << "                                            }\n";
		file << "\n";
		file << "                                            CONSTRUCTEX();\n";
		file << "                                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                                            EXCEPTION->decisionNum  = 3;\n";
		file << "                                            EXCEPTION->state        = 3;\n";
		file << "\n";
		file << "\n";
		file << "                                            goto rulepddlDocEx;\n";
		file << "                                        }\n";
		file << "                                    }\n";
		file << "                                }\n";
		file << "                                else\n";
		file << "                                {\n";
		file << "                                    if (BACKTRACKING>0)\n";
		file << "                                    {\n";
		file << "                                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                        return retval;\n";
		file << "                                    }\n";
		file << "\n";
		file << "                                    CONSTRUCTEX();\n";
		file << "                                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                                    EXCEPTION->decisionNum  = 3;\n";
		file << "                                    EXCEPTION->state        = 2;\n";
		file << "\n";
		file << "\n";
		file << "                                    goto rulepddlDocEx;\n";
		file << "                                }\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 3;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto rulepddlDocEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 3;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto rulepddlDocEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt3)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:97:11: domain\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_domain_in_pddlDoc343);\n";
		file << "        	        domain3=domain(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepddlDocEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, domain3.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:97:20: problem\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_problem_in_pddlDoc347);\n";
		file << "        	        problem4=problem(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepddlDocEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, problem4.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulepddlDocEx; /* Prevent compiler warnings */\n";
		file << "    rulepddlDocEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end pddlDoc */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start domain\n";
		file << " * ../../model/subgoal_learning/Pddl.g:99:1: domain : '(' 'define' domainName ( requireDef )? ( typesDef )? ( constantsDef )? ( predicatesDef )? ( functionsDef )? ( constraints )? ( structureDef )* ')' -> ^( DOMAIN domainName ( requireDef )? ( typesDef )? ( constantsDef )? ( predicatesDef )? ( functionsDef )? ( constraints )? ( structureDef )* ) ;\n";
		file << " */\n";
		file << "static PddlParser_domain_return\n";
		file << "domain(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_domain_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal5;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal6;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal15;\n";
		file << "    PddlParser_domainName_return domainName7;\n";
		file << "    #undef	RETURN_TYPE_domainName7\n";
		file << "    #define	RETURN_TYPE_domainName7 PddlParser_domainName_return\n";
		file << "\n";
		file << "    PddlParser_requireDef_return requireDef8;\n";
		file << "    #undef	RETURN_TYPE_requireDef8\n";
		file << "    #define	RETURN_TYPE_requireDef8 PddlParser_requireDef_return\n";
		file << "\n";
		file << "    PddlParser_typesDef_return typesDef9;\n";
		file << "    #undef	RETURN_TYPE_typesDef9\n";
		file << "    #define	RETURN_TYPE_typesDef9 PddlParser_typesDef_return\n";
		file << "\n";
		file << "    PddlParser_constantsDef_return constantsDef10;\n";
		file << "    #undef	RETURN_TYPE_constantsDef10\n";
		file << "    #define	RETURN_TYPE_constantsDef10 PddlParser_constantsDef_return\n";
		file << "\n";
		file << "    PddlParser_predicatesDef_return predicatesDef11;\n";
		file << "    #undef	RETURN_TYPE_predicatesDef11\n";
		file << "    #define	RETURN_TYPE_predicatesDef11 PddlParser_predicatesDef_return\n";
		file << "\n";
		file << "    PddlParser_functionsDef_return functionsDef12;\n";
		file << "    #undef	RETURN_TYPE_functionsDef12\n";
		file << "    #define	RETURN_TYPE_functionsDef12 PddlParser_functionsDef_return\n";
		file << "\n";
		file << "    PddlParser_constraints_return constraints13;\n";
		file << "    #undef	RETURN_TYPE_constraints13\n";
		file << "    #define	RETURN_TYPE_constraints13 PddlParser_constraints_return\n";
		file << "\n";
		file << "    PddlParser_structureDef_return structureDef14;\n";
		file << "    #undef	RETURN_TYPE_structureDef14\n";
		file << "    #define	RETURN_TYPE_structureDef14 PddlParser_structureDef_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal5_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal6_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal15_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_55;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_constantsDef;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_requireDef;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_predicatesDef;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_constraints;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_structureDef;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_domainName;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_functionsDef;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typesDef;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal5       = NULL;\n";
		file << "    string_literal6       = NULL;\n";
		file << "    char_literal15       = NULL;\n";
		file << "    domainName7.tree = NULL;\n";
		file << "\n";
		file << "    requireDef8.tree = NULL;\n";
		file << "\n";
		file << "    typesDef9.tree = NULL;\n";
		file << "\n";
		file << "    constantsDef10.tree = NULL;\n";
		file << "\n";
		file << "    predicatesDef11.tree = NULL;\n";
		file << "\n";
		file << "    functionsDef12.tree = NULL;\n";
		file << "\n";
		file << "    constraints13.tree = NULL;\n";
		file << "\n";
		file << "    structureDef14.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal5_tree   = NULL;\n";
		file << "    string_literal6_tree   = NULL;\n";
		file << "    char_literal15_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_55   = NULL;\n";
		file << "    #define CREATE_stream_55  if (stream_55 == NULL) {stream_55 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 55\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_constantsDef   = NULL;\n";
		file << "    #define CREATE_stream_constantsDef  if (stream_constantsDef == NULL) {stream_constantsDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule constantsDef\"); }\n";
		file << "    stream_requireDef   = NULL;\n";
		file << "    #define CREATE_stream_requireDef  if (stream_requireDef == NULL) {stream_requireDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule requireDef\"); }\n";
		file << "    stream_predicatesDef   = NULL;\n";
		file << "    #define CREATE_stream_predicatesDef  if (stream_predicatesDef == NULL) {stream_predicatesDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule predicatesDef\"); }\n";
		file << "    stream_constraints   = NULL;\n";
		file << "    #define CREATE_stream_constraints  if (stream_constraints == NULL) {stream_constraints = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule constraints\"); }\n";
		file << "    stream_structureDef   = NULL;\n";
		file << "    #define CREATE_stream_structureDef  if (stream_structureDef == NULL) {stream_structureDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule structureDef\"); }\n";
		file << "    stream_domainName   = NULL;\n";
		file << "    #define CREATE_stream_domainName  if (stream_domainName == NULL) {stream_domainName = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule domainName\"); }\n";
		file << "    stream_functionsDef   = NULL;\n";
		file << "    #define CREATE_stream_functionsDef  if (stream_functionsDef == NULL) {stream_functionsDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule functionsDef\"); }\n";
		file << "    stream_typesDef   = NULL;\n";
		file << "    #define CREATE_stream_typesDef  if (stream_typesDef == NULL) {stream_typesDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule typesDef\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:102:5: ( '(' 'define' domainName ( requireDef )? ( typesDef )? ( constantsDef )? ( predicatesDef )? ( functionsDef )? ( constraints )? ( structureDef )* ')' -> ^( DOMAIN domainName ( requireDef )? ( typesDef )? ( constantsDef )? ( predicatesDef )? ( functionsDef )? ( constraints )? ( structureDef )* ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:102:7: '(' 'define' domainName ( requireDef )? ( typesDef )? ( constantsDef )? ( predicatesDef )? ( functionsDef )? ( constraints )? ( structureDef )* ')'\n";
		file << "        {\n";
		file << "            char_literal5 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_domain362);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledomainEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal5, NULL); }\n";
		file << "\n";
		file << "            string_literal6 = (pANTLR3_COMMON_TOKEN) MATCHT(55, &FOLLOW_55_in_domain364);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledomainEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_55; stream_55->add(stream_55, string_literal6, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_domainName_in_domain366);\n";
		file << "            domainName7=domainName(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledomainEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_domainName; stream_domainName->add(stream_domainName, domainName7.tree, NULL); }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:103:7: ( requireDef )?\n";
		file << "            {\n";
		file << "                int alt4=2;\n";
		file << "                {\n";
		file << "                    int LA4_0 = LA(1);\n";
		file << "                    if ( (LA4_0 == 54) )\n";
		file << "                    {\n";
		file << "                        {\n";
		file << "                            int LA4_1 = LA(2);\n";
		file << "                            if ( (LA4_1 == 58) )\n";
		file << "                            {\n";
		file << "                                alt4=1;\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt4)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: requireDef\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_requireDef_in_domain374);\n";
		file << "            	        requireDef8=requireDef(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruledomainEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_requireDef; stream_requireDef->add(stream_requireDef, requireDef8.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:104:7: ( typesDef )?\n";
		file << "            {\n";
		file << "                int alt5=2;\n";
		file << "                {\n";
		file << "                    int LA5_0 = LA(1);\n";
		file << "                    if ( (LA5_0 == 54) )\n";
		file << "                    {\n";
		file << "                        {\n";
		file << "                            int LA5_1 = LA(2);\n";
		file << "                            if ( (LA5_1 == 59) )\n";
		file << "                            {\n";
		file << "                                alt5=1;\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt5)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: typesDef\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_typesDef_in_domain383);\n";
		file << "            	        typesDef9=typesDef(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruledomainEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_typesDef; stream_typesDef->add(stream_typesDef, typesDef9.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:105:7: ( constantsDef )?\n";
		file << "            {\n";
		file << "                int alt6=2;\n";
		file << "                {\n";
		file << "                    int LA6_0 = LA(1);\n";
		file << "                    if ( (LA6_0 == 54) )\n";
		file << "                    {\n";
		file << "                        {\n";
		file << "                            int LA6_1 = LA(2);\n";
		file << "                            if ( (LA6_1 == 64) )\n";
		file << "                            {\n";
		file << "                                alt6=1;\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt6)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: constantsDef\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_constantsDef_in_domain392);\n";
		file << "            	        constantsDef10=constantsDef(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruledomainEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_constantsDef; stream_constantsDef->add(stream_constantsDef, constantsDef10.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:106:7: ( predicatesDef )?\n";
		file << "            {\n";
		file << "                int alt7=2;\n";
		file << "                {\n";
		file << "                    int LA7_0 = LA(1);\n";
		file << "                    if ( (LA7_0 == 54) )\n";
		file << "                    {\n";
		file << "                        {\n";
		file << "                            int LA7_1 = LA(2);\n";
		file << "                            if ( (LA7_1 == 65) )\n";
		file << "                            {\n";
		file << "                                alt7=1;\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt7)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: predicatesDef\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_predicatesDef_in_domain401);\n";
		file << "            	        predicatesDef11=predicatesDef(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruledomainEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_predicatesDef; stream_predicatesDef->add(stream_predicatesDef, predicatesDef11.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:107:7: ( functionsDef )?\n";
		file << "            {\n";
		file << "                int alt8=2;\n";
		file << "                {\n";
		file << "                    int LA8_0 = LA(1);\n";
		file << "                    if ( (LA8_0 == 54) )\n";
		file << "                    {\n";
		file << "                        {\n";
		file << "                            int LA8_1 = LA(2);\n";
		file << "                            if ( (LA8_1 == 62) )\n";
		file << "                            {\n";
		file << "                                alt8=1;\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt8)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: functionsDef\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_functionsDef_in_domain410);\n";
		file << "            	        functionsDef12=functionsDef(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruledomainEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_functionsDef; stream_functionsDef->add(stream_functionsDef, functionsDef12.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:108:7: ( constraints )?\n";
		file << "            {\n";
		file << "                int alt9=2;\n";
		file << "                {\n";
		file << "                    int LA9_0 = LA(1);\n";
		file << "                    if ( (LA9_0 == 54) )\n";
		file << "                    {\n";
		file << "                        {\n";
		file << "                            int LA9_1 = LA(2);\n";
		file << "                            if ( (LA9_1 == 66) )\n";
		file << "                            {\n";
		file << "                                alt9=1;\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt9)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: constraints\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_constraints_in_domain419);\n";
		file << "            	        constraints13=constraints(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruledomainEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_constraints; stream_constraints->add(stream_constraints, constraints13.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:109:7: ( structureDef )*\n";
		file << "\n";
		file << "            for (;;)\n";
		file << "            {\n";
		file << "                int alt10=2;\n";
		file << "                {\n";
		file << "                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                    */\n";
		file << "                    int LA10_0 = LA(1);\n";
		file << "                    if ( (LA10_0 == 54) )\n";
		file << "                    {\n";
		file << "                        alt10=1;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                switch (alt10)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: structureDef\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_structureDef_in_domain428);\n";
		file << "            	        structureDef14=structureDef(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruledomainEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_structureDef; stream_structureDef->add(stream_structureDef, structureDef14.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "            	default:\n";
		file << "            	    goto loop10;	/* break out of the loop */\n";
		file << "            	    break;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            loop10: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "            char_literal15 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_domain437);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledomainEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal15, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : functionsDef, requireDef, structureDef, constraints, predicatesDef, domainName, typesDef, constantsDef\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 111:7: -> ^( DOMAIN domainName ( requireDef )? ( typesDef )? ( constantsDef )? ( predicatesDef )? ( functionsDef )? ( constraints )? ( structureDef )* )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:111:10: ^( DOMAIN domainName ( requireDef )? ( typesDef )? ( constantsDef )? ( predicatesDef )? ( functionsDef )? ( constraints )? ( structureDef )* )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DOMAIN, (pANTLR3_UINT8)\"DOMAIN\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_domainName == NULL ? NULL : stream_domainName->nextTree(stream_domainName));\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:111:30: ( requireDef )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_requireDef != NULL && stream_requireDef->hasNext(stream_requireDef))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_requireDef == NULL ? NULL : stream_requireDef->nextTree(stream_requireDef));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_requireDef != NULL) stream_requireDef->reset(stream_requireDef);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:111:42: ( typesDef )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_typesDef != NULL && stream_typesDef->hasNext(stream_typesDef))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_typesDef == NULL ? NULL : stream_typesDef->nextTree(stream_typesDef));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_typesDef != NULL) stream_typesDef->reset(stream_typesDef);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:112:17: ( constantsDef )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_constantsDef != NULL && stream_constantsDef->hasNext(stream_constantsDef))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_constantsDef == NULL ? NULL : stream_constantsDef->nextTree(stream_constantsDef));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_constantsDef != NULL) stream_constantsDef->reset(stream_constantsDef);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:112:31: ( predicatesDef )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_predicatesDef != NULL && stream_predicatesDef->hasNext(stream_predicatesDef))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_predicatesDef == NULL ? NULL : stream_predicatesDef->nextTree(stream_predicatesDef));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_predicatesDef != NULL) stream_predicatesDef->reset(stream_predicatesDef);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:112:46: ( functionsDef )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_functionsDef != NULL && stream_functionsDef->hasNext(stream_functionsDef))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_functionsDef == NULL ? NULL : stream_functionsDef->nextTree(stream_functionsDef));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_functionsDef != NULL) stream_functionsDef->reset(stream_functionsDef);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:113:17: ( constraints )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_constraints != NULL && stream_constraints->hasNext(stream_constraints))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_constraints == NULL ? NULL : stream_constraints->nextTree(stream_constraints));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_constraints != NULL) stream_constraints->reset(stream_constraints);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:113:30: ( structureDef )*\n";
		file << "            	        {\n";
		file << "            	        	while ( (stream_structureDef != NULL && stream_structureDef->hasNext(stream_structureDef))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_structureDef == NULL ? NULL : stream_structureDef->nextTree(stream_structureDef));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if (stream_structureDef != NULL) stream_structureDef->reset(stream_structureDef);\n";
		file << "\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruledomainEx; /* Prevent compiler warnings */\n";
		file << "    ruledomainEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_55 != NULL) stream_55->free(stream_55);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_constantsDef != NULL) stream_constantsDef->free(stream_constantsDef);\n";
		file << "        if (stream_requireDef != NULL) stream_requireDef->free(stream_requireDef);\n";
		file << "        if (stream_predicatesDef != NULL) stream_predicatesDef->free(stream_predicatesDef);\n";
		file << "        if (stream_constraints != NULL) stream_constraints->free(stream_constraints);\n";
		file << "        if (stream_structureDef != NULL) stream_structureDef->free(stream_structureDef);\n";
		file << "        if (stream_domainName != NULL) stream_domainName->free(stream_domainName);\n";
		file << "        if (stream_functionsDef != NULL) stream_functionsDef->free(stream_functionsDef);\n";
		file << "        if (stream_typesDef != NULL) stream_typesDef->free(stream_typesDef);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end domain */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start domainName\n";
		file << " * ../../model/subgoal_learning/Pddl.g:116:1: domainName : '(' 'domain' NAME ')' -> ^( DOMAIN_NAME NAME ) ;\n";
		file << " */\n";
		file << "static PddlParser_domainName_return\n";
		file << "domainName(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_domainName_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal16;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal17;\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME18;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal19;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal16_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal17_tree;\n";
		file << "    pANTLR3_BASE_TREE NAME18_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal19_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NAME;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_57;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal16       = NULL;\n";
		file << "    string_literal17       = NULL;\n";
		file << "    NAME18       = NULL;\n";
		file << "    char_literal19       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal16_tree   = NULL;\n";
		file << "    string_literal17_tree   = NULL;\n";
		file << "    NAME18_tree   = NULL;\n";
		file << "    char_literal19_tree   = NULL;\n";
		file << "\n";
		file << "    stream_NAME   = NULL;\n";
		file << "    #define CREATE_stream_NAME  if (stream_NAME == NULL) {stream_NAME = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token NAME\"); }\n";
		file << "    stream_57   = NULL;\n";
		file << "    #define CREATE_stream_57  if (stream_57 == NULL) {stream_57 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 57\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:117:5: ( '(' 'domain' NAME ')' -> ^( DOMAIN_NAME NAME ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:117:7: '(' 'domain' NAME ')'\n";
		file << "        {\n";
		file << "            char_literal16 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_domainName521);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledomainNameEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal16, NULL); }\n";
		file << "\n";
		file << "            string_literal17 = (pANTLR3_COMMON_TOKEN) MATCHT(57, &FOLLOW_57_in_domainName523);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledomainNameEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_57; stream_57->add(stream_57, string_literal17, NULL); }\n";
		file << "\n";
		file << "            NAME18 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_domainName525);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledomainNameEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_NAME; stream_NAME->add(stream_NAME, NAME18, NULL); }\n";
		file << "\n";
		file << "            char_literal19 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_domainName527);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledomainNameEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal19, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : NAME\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 118:6: -> ^( DOMAIN_NAME NAME )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:118:9: ^( DOMAIN_NAME NAME )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DOMAIN_NAME, (pANTLR3_UINT8)\"DOMAIN_NAME\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_NAME == NULL ? NULL : stream_NAME->nextNode(stream_NAME));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruledomainNameEx; /* Prevent compiler warnings */\n";
		file << "    ruledomainNameEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_NAME != NULL) stream_NAME->free(stream_NAME);\n";
		file << "        if (stream_57 != NULL) stream_57->free(stream_57);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end domainName */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start requireDef\n";
		file << " * ../../model/subgoal_learning/Pddl.g:121:1: requireDef : '(' ':requirements' ( REQUIRE_KEY )+ ')' -> ^( REQUIREMENTS ( REQUIRE_KEY )+ ) ;\n";
		file << " */\n";
		file << "static PddlParser_requireDef_return\n";
		file << "requireDef(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_requireDef_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal20;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal21;\n";
		file << "    pANTLR3_COMMON_TOKEN    REQUIRE_KEY22;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal23;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal20_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal21_tree;\n";
		file << "    pANTLR3_BASE_TREE REQUIRE_KEY22_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal23_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_REQUIRE_KEY;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_58;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal20       = NULL;\n";
		file << "    string_literal21       = NULL;\n";
		file << "    REQUIRE_KEY22       = NULL;\n";
		file << "    char_literal23       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal20_tree   = NULL;\n";
		file << "    string_literal21_tree   = NULL;\n";
		file << "    REQUIRE_KEY22_tree   = NULL;\n";
		file << "    char_literal23_tree   = NULL;\n";
		file << "\n";
		file << "    stream_REQUIRE_KEY   = NULL;\n";
		file << "    #define CREATE_stream_REQUIRE_KEY  if (stream_REQUIRE_KEY == NULL) {stream_REQUIRE_KEY = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token REQUIRE_KEY\"); }\n";
		file << "    stream_58   = NULL;\n";
		file << "    #define CREATE_stream_58  if (stream_58 == NULL) {stream_58 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 58\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:122:2: ( '(' ':requirements' ( REQUIRE_KEY )+ ')' -> ^( REQUIREMENTS ( REQUIRE_KEY )+ ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:122:4: '(' ':requirements' ( REQUIRE_KEY )+ ')'\n";
		file << "        {\n";
		file << "            char_literal20 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_requireDef554);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulerequireDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal20, NULL); }\n";
		file << "\n";
		file << "            string_literal21 = (pANTLR3_COMMON_TOKEN) MATCHT(58, &FOLLOW_58_in_requireDef556);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulerequireDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_58; stream_58->add(stream_58, string_literal21, NULL); }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:122:24: ( REQUIRE_KEY )+\n";
		file << "            {\n";
		file << "                int cnt11=0;\n";
		file << "\n";
		file << "                for (;;)\n";
		file << "                {\n";
		file << "                    int alt11=2;\n";
		file << "            	{\n";
		file << "            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	    */\n";
		file << "            	    int LA11_0 = LA(1);\n";
		file << "            	    if ( (LA11_0 == REQUIRE_KEY) )\n";
		file << "            	    {\n";
		file << "            	        alt11=1;\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "            	switch (alt11)\n";
		file << "            	{\n";
		file << "            	    case 1:\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:0:0: REQUIRE_KEY\n";
		file << "            	        {\n";
		file << "            	            REQUIRE_KEY22 = (pANTLR3_COMMON_TOKEN) MATCHT(REQUIRE_KEY, &FOLLOW_REQUIRE_KEY_in_requireDef558);\n";
		file << "            	            if  (HASEXCEPTION())\n";
		file << "            	            {\n";
		file << "            	                goto rulerequireDefEx;\n";
		file << "            	            }\n";
		file << "            	            if (HASFAILED())\n";
		file << "            	            {\n";
		file << "            	                return retval;\n";
		file << "            	            }\n";
		file << "            	            if ( BACKTRACKING==0 ) { CREATE_stream_REQUIRE_KEY; stream_REQUIRE_KEY->add(stream_REQUIRE_KEY, REQUIRE_KEY22, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        break;\n";
		file << "\n";
		file << "            	    default:\n";
		file << "\n";
		file << "            		if ( cnt11 >= 1 )\n";
		file << "            		{\n";
		file << "            		    goto loop11;\n";
		file << "            		}\n";
		file << "            		if (BACKTRACKING>0)\n";
		file << "            		{\n";
		file << "            		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            		    return retval;\n";
		file << "            		}\n";
		file << "            		/* mismatchedSetEx()\n";
		file << "            		 */\n";
		file << "            		CONSTRUCTEX();\n";
		file << "            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "            		goto rulerequireDefEx;\n";
		file << "            	}\n";
		file << "            	cnt11++;\n";
		file << "                }\n";
		file << "                loop11: ;	/* Jump to here if this rule does not match */\n";
		file << "            }\n";
		file << "            char_literal23 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_requireDef561);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulerequireDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal23, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : REQUIRE_KEY\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 123:2: -> ^( REQUIREMENTS ( REQUIRE_KEY )+ )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:123:5: ^( REQUIREMENTS ( REQUIRE_KEY )+ )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, REQUIREMENTS, (pANTLR3_UINT8)\"REQUIREMENTS\"), root_1));\n";
		file << "\n";
		file << "            	        if ((stream_REQUIRE_KEY == NULL || !stream_REQUIRE_KEY->hasNext(stream_REQUIRE_KEY))  )\n";
		file << "            	        {\n";
		file << "            	            CONSTRUCTEX();\n";
		file << "            	            EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;\n";
		file << "            	            EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;\n";
		file << "            	        }\n";
		file << "            	        else\n";
		file << "            	        {\n";
		file << "            	        	while ( (stream_REQUIRE_KEY->hasNext(stream_REQUIRE_KEY))  ) {\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_REQUIRE_KEY == NULL ? NULL : stream_REQUIRE_KEY->nextNode(stream_REQUIRE_KEY));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	stream_REQUIRE_KEY->reset(stream_REQUIRE_KEY);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulerequireDefEx; /* Prevent compiler warnings */\n";
		file << "    rulerequireDefEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_REQUIRE_KEY != NULL) stream_REQUIRE_KEY->free(stream_REQUIRE_KEY);\n";
		file << "        if (stream_58 != NULL) stream_58->free(stream_58);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end requireDef */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start typesDef\n";
		file << " * ../../model/subgoal_learning/Pddl.g:126:1: typesDef : '(' ':types' typedNameList ')' -> ^( TYPES typedNameList ) ;\n";
		file << " */\n";
		file << "static PddlParser_typesDef_return\n";
		file << "typesDef(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_typesDef_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal24;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal25;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal27;\n";
		file << "    PddlParser_typedNameList_return typedNameList26;\n";
		file << "    #undef	RETURN_TYPE_typedNameList26\n";
		file << "    #define	RETURN_TYPE_typedNameList26 PddlParser_typedNameList_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal24_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal25_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal27_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_59;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typedNameList;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal24       = NULL;\n";
		file << "    string_literal25       = NULL;\n";
		file << "    char_literal27       = NULL;\n";
		file << "    typedNameList26.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal24_tree   = NULL;\n";
		file << "    string_literal25_tree   = NULL;\n";
		file << "    char_literal27_tree   = NULL;\n";
		file << "\n";
		file << "    stream_59   = NULL;\n";
		file << "    #define CREATE_stream_59  if (stream_59 == NULL) {stream_59 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 59\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_typedNameList   = NULL;\n";
		file << "    #define CREATE_stream_typedNameList  if (stream_typedNameList == NULL) {stream_typedNameList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule typedNameList\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:127:2: ( '(' ':types' typedNameList ')' -> ^( TYPES typedNameList ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:127:4: '(' ':types' typedNameList ')'\n";
		file << "        {\n";
		file << "            char_literal24 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_typesDef582);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruletypesDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal24, NULL); }\n";
		file << "\n";
		file << "            string_literal25 = (pANTLR3_COMMON_TOKEN) MATCHT(59, &FOLLOW_59_in_typesDef584);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruletypesDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_59; stream_59->add(stream_59, string_literal25, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_typedNameList_in_typesDef586);\n";
		file << "            typedNameList26=typedNameList(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruletypesDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_typedNameList; stream_typedNameList->add(stream_typedNameList, typedNameList26.tree, NULL); }\n";
		file << "            char_literal27 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_typesDef588);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruletypesDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal27, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : typedNameList\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 128:4: -> ^( TYPES typedNameList )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:128:7: ^( TYPES typedNameList )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, TYPES, (pANTLR3_UINT8)\"TYPES\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_typedNameList == NULL ? NULL : stream_typedNameList->nextTree(stream_typedNameList));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruletypesDefEx; /* Prevent compiler warnings */\n";
		file << "    ruletypesDefEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_59 != NULL) stream_59->free(stream_59);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_typedNameList != NULL) stream_typedNameList->free(stream_typedNameList);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end typesDef */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start typedNameList\n";
		file << " * ../../model/subgoal_learning/Pddl.g:132:1: typedNameList : ( ( NAME )* | ( singleTypeNameList )+ ( NAME )* ) ;\n";
		file << " */\n";
		file << "static PddlParser_typedNameList_return\n";
		file << "typedNameList(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_typedNameList_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME28;\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME30;\n";
		file << "    PddlParser_singleTypeNameList_return singleTypeNameList29;\n";
		file << "    #undef	RETURN_TYPE_singleTypeNameList29\n";
		file << "    #define	RETURN_TYPE_singleTypeNameList29 PddlParser_singleTypeNameList_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE NAME28_tree;\n";
		file << "    pANTLR3_BASE_TREE NAME30_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    NAME28       = NULL;\n";
		file << "    NAME30       = NULL;\n";
		file << "    singleTypeNameList29.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    NAME28_tree   = NULL;\n";
		file << "    NAME30_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:133:5: ( ( ( NAME )* | ( singleTypeNameList )+ ( NAME )* ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:133:7: ( ( NAME )* | ( singleTypeNameList )+ ( NAME )* )\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:133:7: ( ( NAME )* | ( singleTypeNameList )+ ( NAME )* )\n";
		file << "            {\n";
		file << "                int alt15=2;\n";
		file << "                alt15 = cdfa15.predict(ctx, RECOGNIZER, ISTREAM, &cdfa15);\n";
		file << "                if  (HASEXCEPTION())\n";
		file << "                {\n";
		file << "                    goto ruletypedNameListEx;\n";
		file << "                }\n";
		file << "                if (HASFAILED())\n";
		file << "                {\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                switch (alt15)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:133:8: ( NAME )*\n";
		file << "            	    {\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:133:8: ( NAME )*\n";
		file << "\n";
		file << "            	        for (;;)\n";
		file << "            	        {\n";
		file << "            	            int alt12=2;\n";
		file << "            	            {\n";
		file << "            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	                */\n";
		file << "            	                int LA12_0 = LA(1);\n";
		file << "            	                if ( (LA12_0 == NAME) )\n";
		file << "            	                {\n";
		file << "            	                    alt12=1;\n";
		file << "            	                }\n";
		file << "\n";
		file << "            	            }\n";
		file << "            	            switch (alt12)\n";
		file << "            	            {\n";
		file << "            	        	case 1:\n";
		file << "            	        	    // ../../model/subgoal_learning/Pddl.g:0:0: NAME\n";
		file << "            	        	    {\n";
		file << "            	        	        NAME28 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_typedNameList615);\n";
		file << "            	        	        if  (HASEXCEPTION())\n";
		file << "            	        	        {\n";
		file << "            	        	            goto ruletypedNameListEx;\n";
		file << "            	        	        }\n";
		file << "            	        	        if (HASFAILED())\n";
		file << "            	        	        {\n";
		file << "            	        	            return retval;\n";
		file << "            	        	        }\n";
		file << "            	        	        if ( BACKTRACKING==0 ) {\n";
		file << "            	        	        NAME28_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME28));\n";
		file << "            	        	        ADAPTOR->addChild(ADAPTOR, root_0, NAME28_tree);\n";
		file << "            	        	        }\n";
		file << "\n";
		file << "            	        	    }\n";
		file << "            	        	    break;\n";
		file << "\n";
		file << "            	        	default:\n";
		file << "            	        	    goto loop12;	/* break out of the loop */\n";
		file << "            	        	    break;\n";
		file << "            	            }\n";
		file << "            	        }\n";
		file << "            	        loop12: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "            	case 2:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:133:16: ( singleTypeNameList )+ ( NAME )*\n";
		file << "            	    {\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:133:16: ( singleTypeNameList )+\n";
		file << "            	        {\n";
		file << "            	            int cnt13=0;\n";
		file << "\n";
		file << "            	            for (;;)\n";
		file << "            	            {\n";
		file << "            	                int alt13=2;\n";
		file << "            	        	alt13 = cdfa13.predict(ctx, RECOGNIZER, ISTREAM, &cdfa13);\n";
		file << "            	        	if  (HASEXCEPTION())\n";
		file << "            	        	{\n";
		file << "            	        	    goto ruletypedNameListEx;\n";
		file << "            	        	}\n";
		file << "            	        	if (HASFAILED())\n";
		file << "            	        	{\n";
		file << "            	        	    return retval;\n";
		file << "            	        	}\n";
		file << "            	        	switch (alt13)\n";
		file << "            	        	{\n";
		file << "            	        	    case 1:\n";
		file << "            	        	        // ../../model/subgoal_learning/Pddl.g:0:0: singleTypeNameList\n";
		file << "            	        	        {\n";
		file << "            	        	            FOLLOWPUSH(FOLLOW_singleTypeNameList_in_typedNameList620);\n";
		file << "            	        	            singleTypeNameList29=singleTypeNameList(ctx);\n";
		file << "\n";
		file << "            	        	            FOLLOWPOP();\n";
		file << "            	        	            if  (HASEXCEPTION())\n";
		file << "            	        	            {\n";
		file << "            	        	                goto ruletypedNameListEx;\n";
		file << "            	        	            }\n";
		file << "            	        	            if (HASFAILED())\n";
		file << "            	        	            {\n";
		file << "            	        	                return retval;\n";
		file << "            	        	            }\n";
		file << "            	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, singleTypeNameList29.tree);\n";
		file << "\n";
		file << "            	        	        }\n";
		file << "            	        	        break;\n";
		file << "\n";
		file << "            	        	    default:\n";
		file << "\n";
		file << "            	        		if ( cnt13 >= 1 )\n";
		file << "            	        		{\n";
		file << "            	        		    goto loop13;\n";
		file << "            	        		}\n";
		file << "            	        		if (BACKTRACKING>0)\n";
		file << "            	        		{\n";
		file << "            	        		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            	        		    return retval;\n";
		file << "            	        		}\n";
		file << "            	        		/* mismatchedSetEx()\n";
		file << "            	        		 */\n";
		file << "            	        		CONSTRUCTEX();\n";
		file << "            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "            	        		goto ruletypedNameListEx;\n";
		file << "            	        	}\n";
		file << "            	        	cnt13++;\n";
		file << "            	            }\n";
		file << "            	            loop13: ;	/* Jump to here if this rule does not match */\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:133:36: ( NAME )*\n";
		file << "\n";
		file << "            	        for (;;)\n";
		file << "            	        {\n";
		file << "            	            int alt14=2;\n";
		file << "            	            {\n";
		file << "            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	                */\n";
		file << "            	                int LA14_0 = LA(1);\n";
		file << "            	                if ( (LA14_0 == NAME) )\n";
		file << "            	                {\n";
		file << "            	                    alt14=1;\n";
		file << "            	                }\n";
		file << "\n";
		file << "            	            }\n";
		file << "            	            switch (alt14)\n";
		file << "            	            {\n";
		file << "            	        	case 1:\n";
		file << "            	        	    // ../../model/subgoal_learning/Pddl.g:0:0: NAME\n";
		file << "            	        	    {\n";
		file << "            	        	        NAME30 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_typedNameList623);\n";
		file << "            	        	        if  (HASEXCEPTION())\n";
		file << "            	        	        {\n";
		file << "            	        	            goto ruletypedNameListEx;\n";
		file << "            	        	        }\n";
		file << "            	        	        if (HASFAILED())\n";
		file << "            	        	        {\n";
		file << "            	        	            return retval;\n";
		file << "            	        	        }\n";
		file << "            	        	        if ( BACKTRACKING==0 ) {\n";
		file << "            	        	        NAME30_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME30));\n";
		file << "            	        	        ADAPTOR->addChild(ADAPTOR, root_0, NAME30_tree);\n";
		file << "            	        	        }\n";
		file << "\n";
		file << "            	        	    }\n";
		file << "            	        	    break;\n";
		file << "\n";
		file << "            	        	default:\n";
		file << "            	        	    goto loop14;	/* break out of the loop */\n";
		file << "            	        	    break;\n";
		file << "            	            }\n";
		file << "            	        }\n";
		file << "            	        loop14: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruletypedNameListEx; /* Prevent compiler warnings */\n";
		file << "    ruletypedNameListEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end typedNameList */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start singleTypeNameList\n";
		file << " * ../../model/subgoal_learning/Pddl.g:136:1: singleTypeNameList : ( ( NAME )+ '-' t= type ) -> ( ^( NAME $t) )+ ;\n";
		file << " */\n";
		file << "static PddlParser_singleTypeNameList_return\n";
		file << "singleTypeNameList(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_singleTypeNameList_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME31;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal32;\n";
		file << "    PddlParser_type_return t;\n";
		file << "    #undef	RETURN_TYPE_t\n";
		file << "    #define	RETURN_TYPE_t PddlParser_type_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE NAME31_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal32_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NAME;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_60;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_type;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    NAME31       = NULL;\n";
		file << "    char_literal32       = NULL;\n";
		file << "    t.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    NAME31_tree   = NULL;\n";
		file << "    char_literal32_tree   = NULL;\n";
		file << "\n";
		file << "    stream_NAME   = NULL;\n";
		file << "    #define CREATE_stream_NAME  if (stream_NAME == NULL) {stream_NAME = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token NAME\"); }\n";
		file << "    stream_60   = NULL;\n";
		file << "    #define CREATE_stream_60  if (stream_60 == NULL) {stream_60 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 60\"); }\n";
		file << "    stream_type   = NULL;\n";
		file << "    #define CREATE_stream_type  if (stream_type == NULL) {stream_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule type\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:137:5: ( ( ( NAME )+ '-' t= type ) -> ( ^( NAME $t) )+ )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:137:7: ( ( NAME )+ '-' t= type )\n";
		file << "        {\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:137:7: ( ( NAME )+ '-' t= type )\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:137:8: ( NAME )+ '-' t= type\n";
		file << "            {\n";
		file << "                // ../../model/subgoal_learning/Pddl.g:137:8: ( NAME )+\n";
		file << "                {\n";
		file << "                    int cnt16=0;\n";
		file << "\n";
		file << "                    for (;;)\n";
		file << "                    {\n";
		file << "                        int alt16=2;\n";
		file << "                	{\n";
		file << "                	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                	    */\n";
		file << "                	    int LA16_0 = LA(1);\n";
		file << "                	    if ( (LA16_0 == NAME) )\n";
		file << "                	    {\n";
		file << "                	        alt16=1;\n";
		file << "                	    }\n";
		file << "\n";
		file << "                	}\n";
		file << "                	switch (alt16)\n";
		file << "                	{\n";
		file << "                	    case 1:\n";
		file << "                	        // ../../model/subgoal_learning/Pddl.g:0:0: NAME\n";
		file << "                	        {\n";
		file << "                	            NAME31 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_singleTypeNameList643);\n";
		file << "                	            if  (HASEXCEPTION())\n";
		file << "                	            {\n";
		file << "                	                goto rulesingleTypeNameListEx;\n";
		file << "                	            }\n";
		file << "                	            if (HASFAILED())\n";
		file << "                	            {\n";
		file << "                	                return retval;\n";
		file << "                	            }\n";
		file << "                	            if ( BACKTRACKING==0 ) { CREATE_stream_NAME; stream_NAME->add(stream_NAME, NAME31, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "                	        }\n";
		file << "                	        break;\n";
		file << "\n";
		file << "                	    default:\n";
		file << "\n";
		file << "                		if ( cnt16 >= 1 )\n";
		file << "                		{\n";
		file << "                		    goto loop16;\n";
		file << "                		}\n";
		file << "                		if (BACKTRACKING>0)\n";
		file << "                		{\n";
		file << "                		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                		    return retval;\n";
		file << "                		}\n";
		file << "                		/* mismatchedSetEx()\n";
		file << "                		 */\n";
		file << "                		CONSTRUCTEX();\n";
		file << "                		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "                		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "                		goto rulesingleTypeNameListEx;\n";
		file << "                	}\n";
		file << "                	cnt16++;\n";
		file << "                    }\n";
		file << "                    loop16: ;	/* Jump to here if this rule does not match */\n";
		file << "                }\n";
		file << "                char_literal32 = (pANTLR3_COMMON_TOKEN) MATCHT(60, &FOLLOW_60_in_singleTypeNameList646);\n";
		file << "                if  (HASEXCEPTION())\n";
		file << "                {\n";
		file << "                    goto rulesingleTypeNameListEx;\n";
		file << "                }\n";
		file << "                if (HASFAILED())\n";
		file << "                {\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                if ( BACKTRACKING==0 ) { CREATE_stream_60; stream_60->add(stream_60, char_literal32, NULL); }\n";
		file << "\n";
		file << "                FOLLOWPUSH(FOLLOW_type_in_singleTypeNameList650);\n";
		file << "                t=type(ctx);\n";
		file << "\n";
		file << "                FOLLOWPOP();\n";
		file << "                if  (HASEXCEPTION())\n";
		file << "                {\n";
		file << "                    goto rulesingleTypeNameListEx;\n";
		file << "                }\n";
		file << "                if (HASFAILED())\n";
		file << "                {\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                if ( BACKTRACKING==0 ) { CREATE_stream_type; stream_type->add(stream_type, t.tree, NULL); }\n";
		file << "\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : t, NAME\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval, t\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_t;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "            	stream_t=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token t\", t.tree != NULL ? t.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 138:4: -> ( ^( NAME $t) )+\n";
		file << "            	{\n";
		file << "            	    if ((stream_t == NULL || !stream_t->hasNext(stream_t)) || (stream_NAME == NULL || !stream_NAME->hasNext(stream_NAME))  )\n";
		file << "            	    {\n";
		file << "            	        CONSTRUCTEX();\n";
		file << "            	        EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;\n";
		file << "            	        EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;\n";
		file << "            	    }\n";
		file << "            	    else\n";
		file << "            	    {\n";
		file << "            	    	while ( (stream_t->hasNext(stream_t)) || (stream_NAME->hasNext(stream_NAME))  ) {\n";
		file << "            	    		// ../../model/subgoal_learning/Pddl.g:138:7: ^( NAME $t)\n";
		file << "            	    		{\n";
		file << "            	    		    pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	    		    root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_NAME == NULL ? NULL : stream_NAME->nextNode(stream_NAME), root_1));\n";
		file << "\n";
		file << "            	    		    ADAPTOR->addChild(ADAPTOR, root_1, stream_t == NULL ? NULL : stream_t->nextTree(stream_t));\n";
		file << "\n";
		file << "            	    		    ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    		}\n";
		file << "\n";
		file << "            	    	}\n";
		file << "            	    	stream_t->reset(stream_t);\n";
		file << "            	    	stream_NAME->reset(stream_NAME);\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "            	if (stream_t != NULL) stream_t->free(stream_t);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulesingleTypeNameListEx; /* Prevent compiler warnings */\n";
		file << "    rulesingleTypeNameListEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_NAME != NULL) stream_NAME->free(stream_NAME);\n";
		file << "        if (stream_60 != NULL) stream_60->free(stream_60);\n";
		file << "        if (stream_type != NULL) stream_type->free(stream_type);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end singleTypeNameList */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start type\n";
		file << " * ../../model/subgoal_learning/Pddl.g:141:1: type : ( ( '(' 'either' ( primType )+ ')' ) -> ^( EITHER_TYPE ( primType )+ ) | primType );\n";
		file << " */\n";
		file << "static PddlParser_type_return\n";
		file << "type(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_type_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal33;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal34;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal36;\n";
		file << "    PddlParser_primType_return primType35;\n";
		file << "    #undef	RETURN_TYPE_primType35\n";
		file << "    #define	RETURN_TYPE_primType35 PddlParser_primType_return\n";
		file << "\n";
		file << "    PddlParser_primType_return primType37;\n";
		file << "    #undef	RETURN_TYPE_primType37\n";
		file << "    #define	RETURN_TYPE_primType37 PddlParser_primType_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal33_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal34_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal36_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_61;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_primType;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal33       = NULL;\n";
		file << "    string_literal34       = NULL;\n";
		file << "    char_literal36       = NULL;\n";
		file << "    primType35.tree = NULL;\n";
		file << "\n";
		file << "    primType37.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal33_tree   = NULL;\n";
		file << "    string_literal34_tree   = NULL;\n";
		file << "    char_literal36_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_61   = NULL;\n";
		file << "    #define CREATE_stream_61  if (stream_61 == NULL) {stream_61 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 61\"); }\n";
		file << "    stream_primType   = NULL;\n";
		file << "    #define CREATE_stream_primType  if (stream_primType == NULL) {stream_primType = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule primType\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:142:2: ( ( '(' 'either' ( primType )+ ')' ) -> ^( EITHER_TYPE ( primType )+ ) | primType )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt18;\n";
		file << "\n";
		file << "            alt18=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA18_0 = LA(1);\n";
		file << "                if ( (LA18_0 == 54) )\n";
		file << "                {\n";
		file << "                    alt18=1;\n";
		file << "                }\n";
		file << "                else if ( (LA18_0 == NAME) )\n";
		file << "                {\n";
		file << "                    alt18=2;\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 18;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruletypeEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt18)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:142:4: ( '(' 'either' ( primType )+ ')' )\n";
		file << "        	    {\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:142:4: ( '(' 'either' ( primType )+ ')' )\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:142:6: '(' 'either' ( primType )+ ')'\n";
		file << "        	        {\n";
		file << "        	            char_literal33 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_type677);\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto ruletypeEx;\n";
		file << "        	            }\n";
		file << "        	            if (HASFAILED())\n";
		file << "        	            {\n";
		file << "        	                return retval;\n";
		file << "        	            }\n";
		file << "        	            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal33, NULL); }\n";
		file << "\n";
		file << "        	            string_literal34 = (pANTLR3_COMMON_TOKEN) MATCHT(61, &FOLLOW_61_in_type679);\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto ruletypeEx;\n";
		file << "        	            }\n";
		file << "        	            if (HASFAILED())\n";
		file << "        	            {\n";
		file << "        	                return retval;\n";
		file << "        	            }\n";
		file << "        	            if ( BACKTRACKING==0 ) { CREATE_stream_61; stream_61->add(stream_61, string_literal34, NULL); }\n";
		file << "\n";
		file << "        	            // ../../model/subgoal_learning/Pddl.g:142:19: ( primType )+\n";
		file << "        	            {\n";
		file << "        	                int cnt17=0;\n";
		file << "\n";
		file << "        	                for (;;)\n";
		file << "        	                {\n";
		file << "        	                    int alt17=2;\n";
		file << "        	            	{\n";
		file << "        	            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	            	    */\n";
		file << "        	            	    int LA17_0 = LA(1);\n";
		file << "        	            	    if ( (LA17_0 == NAME) )\n";
		file << "        	            	    {\n";
		file << "        	            	        alt17=1;\n";
		file << "        	            	    }\n";
		file << "\n";
		file << "        	            	}\n";
		file << "        	            	switch (alt17)\n";
		file << "        	            	{\n";
		file << "        	            	    case 1:\n";
		file << "        	            	        // ../../model/subgoal_learning/Pddl.g:0:0: primType\n";
		file << "        	            	        {\n";
		file << "        	            	            FOLLOWPUSH(FOLLOW_primType_in_type681);\n";
		file << "        	            	            primType35=primType(ctx);\n";
		file << "\n";
		file << "        	            	            FOLLOWPOP();\n";
		file << "        	            	            if  (HASEXCEPTION())\n";
		file << "        	            	            {\n";
		file << "        	            	                goto ruletypeEx;\n";
		file << "        	            	            }\n";
		file << "        	            	            if (HASFAILED())\n";
		file << "        	            	            {\n";
		file << "        	            	                return retval;\n";
		file << "        	            	            }\n";
		file << "        	            	            if ( BACKTRACKING==0 ) { CREATE_stream_primType; stream_primType->add(stream_primType, primType35.tree, NULL); }\n";
		file << "\n";
		file << "        	            	        }\n";
		file << "        	            	        break;\n";
		file << "\n";
		file << "        	            	    default:\n";
		file << "\n";
		file << "        	            		if ( cnt17 >= 1 )\n";
		file << "        	            		{\n";
		file << "        	            		    goto loop17;\n";
		file << "        	            		}\n";
		file << "        	            		if (BACKTRACKING>0)\n";
		file << "        	            		{\n";
		file << "        	            		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	            		    return retval;\n";
		file << "        	            		}\n";
		file << "        	            		/* mismatchedSetEx()\n";
		file << "        	            		 */\n";
		file << "        	            		CONSTRUCTEX();\n";
		file << "        	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "        	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "        	            		goto ruletypeEx;\n";
		file << "        	            	}\n";
		file << "        	            	cnt17++;\n";
		file << "        	                }\n";
		file << "        	                loop17: ;	/* Jump to here if this rule does not match */\n";
		file << "        	            }\n";
		file << "        	            char_literal36 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_type684);\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto ruletypeEx;\n";
		file << "        	            }\n";
		file << "        	            if (HASFAILED())\n";
		file << "        	            {\n";
		file << "        	                return retval;\n";
		file << "        	            }\n";
		file << "        	            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal36, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : primType\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 143:4: -> ^( EITHER_TYPE ( primType )+ )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:143:7: ^( EITHER_TYPE ( primType )+ )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, EITHER_TYPE, (pANTLR3_UINT8)\"EITHER_TYPE\"), root_1));\n";
		file << "\n";
		file << "        	        	        if ((stream_primType == NULL || !stream_primType->hasNext(stream_primType))  )\n";
		file << "        	        	        {\n";
		file << "        	        	            CONSTRUCTEX();\n";
		file << "        	        	            EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;\n";
		file << "        	        	            EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;\n";
		file << "        	        	        }\n";
		file << "        	        	        else\n";
		file << "        	        	        {\n";
		file << "        	        	        	while ( (stream_primType->hasNext(stream_primType))  ) {\n";
		file << "        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_primType == NULL ? NULL : stream_primType->nextTree(stream_primType));\n";
		file << "\n";
		file << "        	        	        	}\n";
		file << "        	        	        	stream_primType->reset(stream_primType);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:144:4: primType\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_primType_in_type703);\n";
		file << "        	        primType37=primType(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletypeEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, primType37.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruletypeEx; /* Prevent compiler warnings */\n";
		file << "    ruletypeEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_61 != NULL) stream_61->free(stream_61);\n";
		file << "        if (stream_primType != NULL) stream_primType->free(stream_primType);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end type */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start primType\n";
		file << " * ../../model/subgoal_learning/Pddl.g:147:1: primType : NAME ;\n";
		file << " */\n";
		file << "static PddlParser_primType_return\n";
		file << "primType(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_primType_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME38;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE NAME38_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    NAME38       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    NAME38_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:147:10: ( NAME )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:147:12: NAME\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            NAME38 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_primType713);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleprimTypeEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            NAME38_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME38));\n";
		file << "            ADAPTOR->addChild(ADAPTOR, root_0, NAME38_tree);\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleprimTypeEx; /* Prevent compiler warnings */\n";
		file << "    ruleprimTypeEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end primType */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start functionsDef\n";
		file << " * ../../model/subgoal_learning/Pddl.g:149:1: functionsDef : '(' ':functions' functionList ')' -> ^( FUNCTIONS functionList ) ;\n";
		file << " */\n";
		file << "static PddlParser_functionsDef_return\n";
		file << "functionsDef(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_functionsDef_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal39;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal40;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal42;\n";
		file << "    PddlParser_functionList_return functionList41;\n";
		file << "    #undef	RETURN_TYPE_functionList41\n";
		file << "    #define	RETURN_TYPE_functionList41 PddlParser_functionList_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal39_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal40_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal42_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_62;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_functionList;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal39       = NULL;\n";
		file << "    string_literal40       = NULL;\n";
		file << "    char_literal42       = NULL;\n";
		file << "    functionList41.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal39_tree   = NULL;\n";
		file << "    string_literal40_tree   = NULL;\n";
		file << "    char_literal42_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_62   = NULL;\n";
		file << "    #define CREATE_stream_62  if (stream_62 == NULL) {stream_62 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 62\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_functionList   = NULL;\n";
		file << "    #define CREATE_stream_functionList  if (stream_functionList == NULL) {stream_functionList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule functionList\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:150:2: ( '(' ':functions' functionList ')' -> ^( FUNCTIONS functionList ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:150:4: '(' ':functions' functionList ')'\n";
		file << "        {\n";
		file << "            char_literal39 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_functionsDef723);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefunctionsDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal39, NULL); }\n";
		file << "\n";
		file << "            string_literal40 = (pANTLR3_COMMON_TOKEN) MATCHT(62, &FOLLOW_62_in_functionsDef725);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefunctionsDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_62; stream_62->add(stream_62, string_literal40, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_functionList_in_functionsDef727);\n";
		file << "            functionList41=functionList(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefunctionsDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_functionList; stream_functionList->add(stream_functionList, functionList41.tree, NULL); }\n";
		file << "            char_literal42 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_functionsDef729);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefunctionsDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal42, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : functionList\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 151:2: -> ^( FUNCTIONS functionList )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:151:5: ^( FUNCTIONS functionList )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FUNCTIONS, (pANTLR3_UINT8)\"FUNCTIONS\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_functionList == NULL ? NULL : stream_functionList->nextTree(stream_functionList));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefunctionsDefEx; /* Prevent compiler warnings */\n";
		file << "    rulefunctionsDefEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_62 != NULL) stream_62->free(stream_62);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_functionList != NULL) stream_functionList->free(stream_functionList);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end functionsDef */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start functionList\n";
		file << " * ../../model/subgoal_learning/Pddl.g:154:1: functionList : ( ( atomicFunctionSkeleton )+ ( '-' functionType )? )* ;\n";
		file << " */\n";
		file << "static PddlParser_functionList_return\n";
		file << "functionList(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_functionList_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal44;\n";
		file << "    PddlParser_atomicFunctionSkeleton_return atomicFunctionSkeleton43;\n";
		file << "    #undef	RETURN_TYPE_atomicFunctionSkeleton43\n";
		file << "    #define	RETURN_TYPE_atomicFunctionSkeleton43 PddlParser_atomicFunctionSkeleton_return\n";
		file << "\n";
		file << "    PddlParser_functionType_return functionType45;\n";
		file << "    #undef	RETURN_TYPE_functionType45\n";
		file << "    #define	RETURN_TYPE_functionType45 PddlParser_functionType_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal44_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal44       = NULL;\n";
		file << "    atomicFunctionSkeleton43.tree = NULL;\n";
		file << "\n";
		file << "    functionType45.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal44_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:155:2: ( ( ( atomicFunctionSkeleton )+ ( '-' functionType )? )* )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:155:4: ( ( atomicFunctionSkeleton )+ ( '-' functionType )? )*\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:155:4: ( ( atomicFunctionSkeleton )+ ( '-' functionType )? )*\n";
		file << "\n";
		file << "            for (;;)\n";
		file << "            {\n";
		file << "                int alt21=2;\n";
		file << "                {\n";
		file << "                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                    */\n";
		file << "                    int LA21_0 = LA(1);\n";
		file << "                    if ( (LA21_0 == 54) )\n";
		file << "                    {\n";
		file << "                        alt21=1;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                switch (alt21)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:155:5: ( atomicFunctionSkeleton )+ ( '-' functionType )?\n";
		file << "            	    {\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:155:5: ( atomicFunctionSkeleton )+\n";
		file << "            	        {\n";
		file << "            	            int cnt19=0;\n";
		file << "\n";
		file << "            	            for (;;)\n";
		file << "            	            {\n";
		file << "            	                int alt19=2;\n";
		file << "            	        	{\n";
		file << "            	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	        	    */\n";
		file << "            	        	    int LA19_0 = LA(1);\n";
		file << "            	        	    if ( (LA19_0 == 54) )\n";
		file << "            	        	    {\n";
		file << "            	        	        {\n";
		file << "            	        	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	        	            */\n";
		file << "            	        	            int LA19_2 = LA(2);\n";
		file << "            	        	            if ( (synpred19_Pddl(ctx)) )\n";
		file << "            	        	            {\n";
		file << "            	        	                alt19=1;\n";
		file << "            	        	            }\n";
		file << "\n";
		file << "            	        	        }\n";
		file << "            	        	    }\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	switch (alt19)\n";
		file << "            	        	{\n";
		file << "            	        	    case 1:\n";
		file << "            	        	        // ../../model/subgoal_learning/Pddl.g:0:0: atomicFunctionSkeleton\n";
		file << "            	        	        {\n";
		file << "            	        	            FOLLOWPUSH(FOLLOW_atomicFunctionSkeleton_in_functionList750);\n";
		file << "            	        	            atomicFunctionSkeleton43=atomicFunctionSkeleton(ctx);\n";
		file << "\n";
		file << "            	        	            FOLLOWPOP();\n";
		file << "            	        	            if  (HASEXCEPTION())\n";
		file << "            	        	            {\n";
		file << "            	        	                goto rulefunctionListEx;\n";
		file << "            	        	            }\n";
		file << "            	        	            if (HASFAILED())\n";
		file << "            	        	            {\n";
		file << "            	        	                return retval;\n";
		file << "            	        	            }\n";
		file << "            	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, atomicFunctionSkeleton43.tree);\n";
		file << "\n";
		file << "            	        	        }\n";
		file << "            	        	        break;\n";
		file << "\n";
		file << "            	        	    default:\n";
		file << "\n";
		file << "            	        		if ( cnt19 >= 1 )\n";
		file << "            	        		{\n";
		file << "            	        		    goto loop19;\n";
		file << "            	        		}\n";
		file << "            	        		if (BACKTRACKING>0)\n";
		file << "            	        		{\n";
		file << "            	        		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            	        		    return retval;\n";
		file << "            	        		}\n";
		file << "            	        		/* mismatchedSetEx()\n";
		file << "            	        		 */\n";
		file << "            	        		CONSTRUCTEX();\n";
		file << "            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "            	        		goto rulefunctionListEx;\n";
		file << "            	        	}\n";
		file << "            	        	cnt19++;\n";
		file << "            	            }\n";
		file << "            	            loop19: ;	/* Jump to here if this rule does not match */\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:155:29: ( '-' functionType )?\n";
		file << "            	        {\n";
		file << "            	            int alt20=2;\n";
		file << "            	            {\n";
		file << "            	                int LA20_0 = LA(1);\n";
		file << "            	                if ( (LA20_0 == 60) )\n";
		file << "            	                {\n";
		file << "            	                    alt20=1;\n";
		file << "            	                }\n";
		file << "            	            }\n";
		file << "            	            switch (alt20)\n";
		file << "            	            {\n";
		file << "            	        	case 1:\n";
		file << "            	        	    // ../../model/subgoal_learning/Pddl.g:155:30: '-' functionType\n";
		file << "            	        	    {\n";
		file << "            	        	        char_literal44 = (pANTLR3_COMMON_TOKEN) MATCHT(60, &FOLLOW_60_in_functionList754);\n";
		file << "            	        	        if  (HASEXCEPTION())\n";
		file << "            	        	        {\n";
		file << "            	        	            goto rulefunctionListEx;\n";
		file << "            	        	        }\n";
		file << "            	        	        if (HASFAILED())\n";
		file << "            	        	        {\n";
		file << "            	        	            return retval;\n";
		file << "            	        	        }\n";
		file << "            	        	        if ( BACKTRACKING==0 ) {\n";
		file << "            	        	        char_literal44_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal44));\n";
		file << "            	        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal44_tree);\n";
		file << "            	        	        }\n";
		file << "            	        	        FOLLOWPUSH(FOLLOW_functionType_in_functionList756);\n";
		file << "            	        	        functionType45=functionType(ctx);\n";
		file << "\n";
		file << "            	        	        FOLLOWPOP();\n";
		file << "            	        	        if  (HASEXCEPTION())\n";
		file << "            	        	        {\n";
		file << "            	        	            goto rulefunctionListEx;\n";
		file << "            	        	        }\n";
		file << "            	        	        if (HASFAILED())\n";
		file << "            	        	        {\n";
		file << "            	        	            return retval;\n";
		file << "            	        	        }\n";
		file << "            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, functionType45.tree);\n";
		file << "\n";
		file << "            	        	    }\n";
		file << "            	        	    break;\n";
		file << "\n";
		file << "            	            }\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "            	default:\n";
		file << "            	    goto loop21;	/* break out of the loop */\n";
		file << "            	    break;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            loop21: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefunctionListEx; /* Prevent compiler warnings */\n";
		file << "    rulefunctionListEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end functionList */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start atomicFunctionSkeleton\n";
		file << " * ../../model/subgoal_learning/Pddl.g:158:1: atomicFunctionSkeleton : '(' functionSymbol typedVariableList ')' ;\n";
		file << " */\n";
		file << "static PddlParser_atomicFunctionSkeleton_return\n";
		file << "atomicFunctionSkeleton(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_atomicFunctionSkeleton_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal46;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal49;\n";
		file << "    PddlParser_functionSymbol_return functionSymbol47;\n";
		file << "    #undef	RETURN_TYPE_functionSymbol47\n";
		file << "    #define	RETURN_TYPE_functionSymbol47 PddlParser_functionSymbol_return\n";
		file << "\n";
		file << "    PddlParser_typedVariableList_return typedVariableList48;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList48\n";
		file << "    #define	RETURN_TYPE_typedVariableList48 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal46_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal49_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal46       = NULL;\n";
		file << "    char_literal49       = NULL;\n";
		file << "    functionSymbol47.tree = NULL;\n";
		file << "\n";
		file << "    typedVariableList48.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal46_tree   = NULL;\n";
		file << "    char_literal49_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:159:2: ( '(' functionSymbol typedVariableList ')' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:159:4: '(' functionSymbol typedVariableList ')'\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            char_literal46 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_atomicFunctionSkeleton772);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicFunctionSkeletonEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            FOLLOWPUSH(FOLLOW_functionSymbol_in_atomicFunctionSkeleton775);\n";
		file << "            functionSymbol47=functionSymbol(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicFunctionSkeletonEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, functionSymbol47.tree, root_0));\n";
		file << "            FOLLOWPUSH(FOLLOW_typedVariableList_in_atomicFunctionSkeleton778);\n";
		file << "            typedVariableList48=typedVariableList(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicFunctionSkeletonEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typedVariableList48.tree);\n";
		file << "            char_literal49 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_atomicFunctionSkeleton780);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicFunctionSkeletonEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleatomicFunctionSkeletonEx; /* Prevent compiler warnings */\n";
		file << "    ruleatomicFunctionSkeletonEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end atomicFunctionSkeleton */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start functionSymbol\n";
		file << " * ../../model/subgoal_learning/Pddl.g:162:1: functionSymbol : NAME ;\n";
		file << " */\n";
		file << "static PddlParser_functionSymbol_return\n";
		file << "functionSymbol(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_functionSymbol_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME50;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE NAME50_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    NAME50       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    NAME50_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:162:16: ( NAME )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:162:18: NAME\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            NAME50 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_functionSymbol791);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefunctionSymbolEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            NAME50_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME50));\n";
		file << "            ADAPTOR->addChild(ADAPTOR, root_0, NAME50_tree);\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefunctionSymbolEx; /* Prevent compiler warnings */\n";
		file << "    rulefunctionSymbolEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end functionSymbol */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start functionType\n";
		file << " * ../../model/subgoal_learning/Pddl.g:164:1: functionType : 'number' ;\n";
		file << " */\n";
		file << "static PddlParser_functionType_return\n";
		file << "functionType(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_functionType_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal51;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE string_literal51_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    string_literal51       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    string_literal51_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:164:14: ( 'number' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:164:16: 'number'\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            string_literal51 = (pANTLR3_COMMON_TOKEN) MATCHT(63, &FOLLOW_63_in_functionType800);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefunctionTypeEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            string_literal51_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal51));\n";
		file << "            ADAPTOR->addChild(ADAPTOR, root_0, string_literal51_tree);\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefunctionTypeEx; /* Prevent compiler warnings */\n";
		file << "    rulefunctionTypeEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end functionType */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start constantsDef\n";
		file << " * ../../model/subgoal_learning/Pddl.g:166:1: constantsDef : '(' ':constants' typedNameList ')' -> ^( CONSTANTS typedNameList ) ;\n";
		file << " */\n";
		file << "static PddlParser_constantsDef_return\n";
		file << "constantsDef(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_constantsDef_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal52;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal53;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal55;\n";
		file << "    PddlParser_typedNameList_return typedNameList54;\n";
		file << "    #undef	RETURN_TYPE_typedNameList54\n";
		file << "    #define	RETURN_TYPE_typedNameList54 PddlParser_typedNameList_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal52_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal53_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal55_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_64;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typedNameList;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal52       = NULL;\n";
		file << "    string_literal53       = NULL;\n";
		file << "    char_literal55       = NULL;\n";
		file << "    typedNameList54.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal52_tree   = NULL;\n";
		file << "    string_literal53_tree   = NULL;\n";
		file << "    char_literal55_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_64   = NULL;\n";
		file << "    #define CREATE_stream_64  if (stream_64 == NULL) {stream_64 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 64\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_typedNameList   = NULL;\n";
		file << "    #define CREATE_stream_typedNameList  if (stream_typedNameList == NULL) {stream_typedNameList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule typedNameList\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:167:2: ( '(' ':constants' typedNameList ')' -> ^( CONSTANTS typedNameList ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:167:4: '(' ':constants' typedNameList ')'\n";
		file << "        {\n";
		file << "            char_literal52 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_constantsDef811);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleconstantsDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal52, NULL); }\n";
		file << "\n";
		file << "            string_literal53 = (pANTLR3_COMMON_TOKEN) MATCHT(64, &FOLLOW_64_in_constantsDef813);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleconstantsDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_64; stream_64->add(stream_64, string_literal53, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_typedNameList_in_constantsDef815);\n";
		file << "            typedNameList54=typedNameList(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleconstantsDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_typedNameList; stream_typedNameList->add(stream_typedNameList, typedNameList54.tree, NULL); }\n";
		file << "            char_literal55 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_constantsDef817);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleconstantsDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal55, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : typedNameList\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 168:2: -> ^( CONSTANTS typedNameList )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:168:5: ^( CONSTANTS typedNameList )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, CONSTANTS, (pANTLR3_UINT8)\"CONSTANTS\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_typedNameList == NULL ? NULL : stream_typedNameList->nextTree(stream_typedNameList));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleconstantsDefEx; /* Prevent compiler warnings */\n";
		file << "    ruleconstantsDefEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_64 != NULL) stream_64->free(stream_64);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_typedNameList != NULL) stream_typedNameList->free(stream_typedNameList);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end constantsDef */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start predicatesDef\n";
		file << " * ../../model/subgoal_learning/Pddl.g:171:1: predicatesDef : '(' ':predicates' ( atomicFormulaSkeleton )+ ')' -> ^( PREDICATES ( atomicFormulaSkeleton )+ ) ;\n";
		file << " */\n";
		file << "static PddlParser_predicatesDef_return\n";
		file << "predicatesDef(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_predicatesDef_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal56;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal57;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal59;\n";
		file << "    PddlParser_atomicFormulaSkeleton_return atomicFormulaSkeleton58;\n";
		file << "    #undef	RETURN_TYPE_atomicFormulaSkeleton58\n";
		file << "    #define	RETURN_TYPE_atomicFormulaSkeleton58 PddlParser_atomicFormulaSkeleton_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal56_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal57_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal59_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_65;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_atomicFormulaSkeleton;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal56       = NULL;\n";
		file << "    string_literal57       = NULL;\n";
		file << "    char_literal59       = NULL;\n";
		file << "    atomicFormulaSkeleton58.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal56_tree   = NULL;\n";
		file << "    string_literal57_tree   = NULL;\n";
		file << "    char_literal59_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_65   = NULL;\n";
		file << "    #define CREATE_stream_65  if (stream_65 == NULL) {stream_65 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 65\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_atomicFormulaSkeleton   = NULL;\n";
		file << "    #define CREATE_stream_atomicFormulaSkeleton  if (stream_atomicFormulaSkeleton == NULL) {stream_atomicFormulaSkeleton = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule atomicFormulaSkeleton\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:172:2: ( '(' ':predicates' ( atomicFormulaSkeleton )+ ')' -> ^( PREDICATES ( atomicFormulaSkeleton )+ ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:172:4: '(' ':predicates' ( atomicFormulaSkeleton )+ ')'\n";
		file << "        {\n";
		file << "            char_literal56 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_predicatesDef837);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulepredicatesDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal56, NULL); }\n";
		file << "\n";
		file << "            string_literal57 = (pANTLR3_COMMON_TOKEN) MATCHT(65, &FOLLOW_65_in_predicatesDef839);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulepredicatesDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_65; stream_65->add(stream_65, string_literal57, NULL); }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:172:22: ( atomicFormulaSkeleton )+\n";
		file << "            {\n";
		file << "                int cnt22=0;\n";
		file << "\n";
		file << "                for (;;)\n";
		file << "                {\n";
		file << "                    int alt22=2;\n";
		file << "            	{\n";
		file << "            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	    */\n";
		file << "            	    int LA22_0 = LA(1);\n";
		file << "            	    if ( (LA22_0 == 54) )\n";
		file << "            	    {\n";
		file << "            	        alt22=1;\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "            	switch (alt22)\n";
		file << "            	{\n";
		file << "            	    case 1:\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:0:0: atomicFormulaSkeleton\n";
		file << "            	        {\n";
		file << "            	            FOLLOWPUSH(FOLLOW_atomicFormulaSkeleton_in_predicatesDef841);\n";
		file << "            	            atomicFormulaSkeleton58=atomicFormulaSkeleton(ctx);\n";
		file << "\n";
		file << "            	            FOLLOWPOP();\n";
		file << "            	            if  (HASEXCEPTION())\n";
		file << "            	            {\n";
		file << "            	                goto rulepredicatesDefEx;\n";
		file << "            	            }\n";
		file << "            	            if (HASFAILED())\n";
		file << "            	            {\n";
		file << "            	                return retval;\n";
		file << "            	            }\n";
		file << "            	            if ( BACKTRACKING==0 ) { CREATE_stream_atomicFormulaSkeleton; stream_atomicFormulaSkeleton->add(stream_atomicFormulaSkeleton, atomicFormulaSkeleton58.tree, NULL); }\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        break;\n";
		file << "\n";
		file << "            	    default:\n";
		file << "\n";
		file << "            		if ( cnt22 >= 1 )\n";
		file << "            		{\n";
		file << "            		    goto loop22;\n";
		file << "            		}\n";
		file << "            		if (BACKTRACKING>0)\n";
		file << "            		{\n";
		file << "            		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            		    return retval;\n";
		file << "            		}\n";
		file << "            		/* mismatchedSetEx()\n";
		file << "            		 */\n";
		file << "            		CONSTRUCTEX();\n";
		file << "            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "            		goto rulepredicatesDefEx;\n";
		file << "            	}\n";
		file << "            	cnt22++;\n";
		file << "                }\n";
		file << "                loop22: ;	/* Jump to here if this rule does not match */\n";
		file << "            }\n";
		file << "            char_literal59 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_predicatesDef844);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulepredicatesDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal59, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : atomicFormulaSkeleton\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 173:2: -> ^( PREDICATES ( atomicFormulaSkeleton )+ )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:173:5: ^( PREDICATES ( atomicFormulaSkeleton )+ )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PREDICATES, (pANTLR3_UINT8)\"PREDICATES\"), root_1));\n";
		file << "\n";
		file << "            	        if ((stream_atomicFormulaSkeleton == NULL || !stream_atomicFormulaSkeleton->hasNext(stream_atomicFormulaSkeleton))  )\n";
		file << "            	        {\n";
		file << "            	            CONSTRUCTEX();\n";
		file << "            	            EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;\n";
		file << "            	            EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;\n";
		file << "            	        }\n";
		file << "            	        else\n";
		file << "            	        {\n";
		file << "            	        	while ( (stream_atomicFormulaSkeleton->hasNext(stream_atomicFormulaSkeleton))  ) {\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_atomicFormulaSkeleton == NULL ? NULL : stream_atomicFormulaSkeleton->nextTree(stream_atomicFormulaSkeleton));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	stream_atomicFormulaSkeleton->reset(stream_atomicFormulaSkeleton);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulepredicatesDefEx; /* Prevent compiler warnings */\n";
		file << "    rulepredicatesDefEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_65 != NULL) stream_65->free(stream_65);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_atomicFormulaSkeleton != NULL) stream_atomicFormulaSkeleton->free(stream_atomicFormulaSkeleton);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end predicatesDef */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start atomicFormulaSkeleton\n";
		file << " * ../../model/subgoal_learning/Pddl.g:176:1: atomicFormulaSkeleton : '(' predicate typedVariableList ')' ;\n";
		file << " */\n";
		file << "static PddlParser_atomicFormulaSkeleton_return\n";
		file << "atomicFormulaSkeleton(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_atomicFormulaSkeleton_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal60;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal63;\n";
		file << "    PddlParser_predicate_return predicate61;\n";
		file << "    #undef	RETURN_TYPE_predicate61\n";
		file << "    #define	RETURN_TYPE_predicate61 PddlParser_predicate_return\n";
		file << "\n";
		file << "    PddlParser_typedVariableList_return typedVariableList62;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList62\n";
		file << "    #define	RETURN_TYPE_typedVariableList62 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal60_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal63_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal60       = NULL;\n";
		file << "    char_literal63       = NULL;\n";
		file << "    predicate61.tree = NULL;\n";
		file << "\n";
		file << "    typedVariableList62.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal60_tree   = NULL;\n";
		file << "    char_literal63_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:177:2: ( '(' predicate typedVariableList ')' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:177:4: '(' predicate typedVariableList ')'\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            char_literal60 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_atomicFormulaSkeleton865);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicFormulaSkeletonEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            FOLLOWPUSH(FOLLOW_predicate_in_atomicFormulaSkeleton868);\n";
		file << "            predicate61=predicate(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicFormulaSkeletonEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, predicate61.tree, root_0));\n";
		file << "            FOLLOWPUSH(FOLLOW_typedVariableList_in_atomicFormulaSkeleton871);\n";
		file << "            typedVariableList62=typedVariableList(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicFormulaSkeletonEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typedVariableList62.tree);\n";
		file << "            char_literal63 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_atomicFormulaSkeleton873);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicFormulaSkeletonEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleatomicFormulaSkeletonEx; /* Prevent compiler warnings */\n";
		file << "    ruleatomicFormulaSkeletonEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end atomicFormulaSkeleton */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start predicate\n";
		file << " * ../../model/subgoal_learning/Pddl.g:180:1: predicate : NAME ;\n";
		file << " */\n";
		file << "static PddlParser_predicate_return\n";
		file << "predicate(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_predicate_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME64;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE NAME64_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    NAME64       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    NAME64_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:180:11: ( NAME )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:180:13: NAME\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            NAME64 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_predicate884);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulepredicateEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            NAME64_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME64));\n";
		file << "            ADAPTOR->addChild(ADAPTOR, root_0, NAME64_tree);\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulepredicateEx; /* Prevent compiler warnings */\n";
		file << "    rulepredicateEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end predicate */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start typedVariableList\n";
		file << " * ../../model/subgoal_learning/Pddl.g:183:1: typedVariableList : ( ( VARIABLE )* | ( singleTypeVarList )+ ( VARIABLE )* ) ;\n";
		file << " */\n";
		file << "static PddlParser_typedVariableList_return\n";
		file << "typedVariableList(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_typedVariableList_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    VARIABLE65;\n";
		file << "    pANTLR3_COMMON_TOKEN    VARIABLE67;\n";
		file << "    PddlParser_singleTypeVarList_return singleTypeVarList66;\n";
		file << "    #undef	RETURN_TYPE_singleTypeVarList66\n";
		file << "    #define	RETURN_TYPE_singleTypeVarList66 PddlParser_singleTypeVarList_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE VARIABLE65_tree;\n";
		file << "    pANTLR3_BASE_TREE VARIABLE67_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    VARIABLE65       = NULL;\n";
		file << "    VARIABLE67       = NULL;\n";
		file << "    singleTypeVarList66.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    VARIABLE65_tree   = NULL;\n";
		file << "    VARIABLE67_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:184:5: ( ( ( VARIABLE )* | ( singleTypeVarList )+ ( VARIABLE )* ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:184:7: ( ( VARIABLE )* | ( singleTypeVarList )+ ( VARIABLE )* )\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:184:7: ( ( VARIABLE )* | ( singleTypeVarList )+ ( VARIABLE )* )\n";
		file << "            {\n";
		file << "                int alt26=2;\n";
		file << "                alt26 = cdfa26.predict(ctx, RECOGNIZER, ISTREAM, &cdfa26);\n";
		file << "                if  (HASEXCEPTION())\n";
		file << "                {\n";
		file << "                    goto ruletypedVariableListEx;\n";
		file << "                }\n";
		file << "                if (HASFAILED())\n";
		file << "                {\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                switch (alt26)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:184:8: ( VARIABLE )*\n";
		file << "            	    {\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:184:8: ( VARIABLE )*\n";
		file << "\n";
		file << "            	        for (;;)\n";
		file << "            	        {\n";
		file << "            	            int alt23=2;\n";
		file << "            	            {\n";
		file << "            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	                */\n";
		file << "            	                int LA23_0 = LA(1);\n";
		file << "            	                if ( (LA23_0 == VARIABLE) )\n";
		file << "            	                {\n";
		file << "            	                    alt23=1;\n";
		file << "            	                }\n";
		file << "\n";
		file << "            	            }\n";
		file << "            	            switch (alt23)\n";
		file << "            	            {\n";
		file << "            	        	case 1:\n";
		file << "            	        	    // ../../model/subgoal_learning/Pddl.g:0:0: VARIABLE\n";
		file << "            	        	    {\n";
		file << "            	        	        VARIABLE65 = (pANTLR3_COMMON_TOKEN) MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_typedVariableList899);\n";
		file << "            	        	        if  (HASEXCEPTION())\n";
		file << "            	        	        {\n";
		file << "            	        	            goto ruletypedVariableListEx;\n";
		file << "            	        	        }\n";
		file << "            	        	        if (HASFAILED())\n";
		file << "            	        	        {\n";
		file << "            	        	            return retval;\n";
		file << "            	        	        }\n";
		file << "            	        	        if ( BACKTRACKING==0 ) {\n";
		file << "            	        	        VARIABLE65_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, VARIABLE65));\n";
		file << "            	        	        ADAPTOR->addChild(ADAPTOR, root_0, VARIABLE65_tree);\n";
		file << "            	        	        }\n";
		file << "\n";
		file << "            	        	    }\n";
		file << "            	        	    break;\n";
		file << "\n";
		file << "            	        	default:\n";
		file << "            	        	    goto loop23;	/* break out of the loop */\n";
		file << "            	        	    break;\n";
		file << "            	            }\n";
		file << "            	        }\n";
		file << "            	        loop23: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "            	case 2:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:184:20: ( singleTypeVarList )+ ( VARIABLE )*\n";
		file << "            	    {\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:184:20: ( singleTypeVarList )+\n";
		file << "            	        {\n";
		file << "            	            int cnt24=0;\n";
		file << "\n";
		file << "            	            for (;;)\n";
		file << "            	            {\n";
		file << "            	                int alt24=2;\n";
		file << "            	        	alt24 = cdfa24.predict(ctx, RECOGNIZER, ISTREAM, &cdfa24);\n";
		file << "            	        	if  (HASEXCEPTION())\n";
		file << "            	        	{\n";
		file << "            	        	    goto ruletypedVariableListEx;\n";
		file << "            	        	}\n";
		file << "            	        	if (HASFAILED())\n";
		file << "            	        	{\n";
		file << "            	        	    return retval;\n";
		file << "            	        	}\n";
		file << "            	        	switch (alt24)\n";
		file << "            	        	{\n";
		file << "            	        	    case 1:\n";
		file << "            	        	        // ../../model/subgoal_learning/Pddl.g:0:0: singleTypeVarList\n";
		file << "            	        	        {\n";
		file << "            	        	            FOLLOWPUSH(FOLLOW_singleTypeVarList_in_typedVariableList904);\n";
		file << "            	        	            singleTypeVarList66=singleTypeVarList(ctx);\n";
		file << "\n";
		file << "            	        	            FOLLOWPOP();\n";
		file << "            	        	            if  (HASEXCEPTION())\n";
		file << "            	        	            {\n";
		file << "            	        	                goto ruletypedVariableListEx;\n";
		file << "            	        	            }\n";
		file << "            	        	            if (HASFAILED())\n";
		file << "            	        	            {\n";
		file << "            	        	                return retval;\n";
		file << "            	        	            }\n";
		file << "            	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, singleTypeVarList66.tree);\n";
		file << "\n";
		file << "            	        	        }\n";
		file << "            	        	        break;\n";
		file << "\n";
		file << "            	        	    default:\n";
		file << "\n";
		file << "            	        		if ( cnt24 >= 1 )\n";
		file << "            	        		{\n";
		file << "            	        		    goto loop24;\n";
		file << "            	        		}\n";
		file << "            	        		if (BACKTRACKING>0)\n";
		file << "            	        		{\n";
		file << "            	        		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            	        		    return retval;\n";
		file << "            	        		}\n";
		file << "            	        		/* mismatchedSetEx()\n";
		file << "            	        		 */\n";
		file << "            	        		CONSTRUCTEX();\n";
		file << "            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "            	        		goto ruletypedVariableListEx;\n";
		file << "            	        	}\n";
		file << "            	        	cnt24++;\n";
		file << "            	            }\n";
		file << "            	            loop24: ;	/* Jump to here if this rule does not match */\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:184:39: ( VARIABLE )*\n";
		file << "\n";
		file << "            	        for (;;)\n";
		file << "            	        {\n";
		file << "            	            int alt25=2;\n";
		file << "            	            {\n";
		file << "            	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "            	                */\n";
		file << "            	                int LA25_0 = LA(1);\n";
		file << "            	                if ( (LA25_0 == VARIABLE) )\n";
		file << "            	                {\n";
		file << "            	                    alt25=1;\n";
		file << "            	                }\n";
		file << "\n";
		file << "            	            }\n";
		file << "            	            switch (alt25)\n";
		file << "            	            {\n";
		file << "            	        	case 1:\n";
		file << "            	        	    // ../../model/subgoal_learning/Pddl.g:0:0: VARIABLE\n";
		file << "            	        	    {\n";
		file << "            	        	        VARIABLE67 = (pANTLR3_COMMON_TOKEN) MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_typedVariableList907);\n";
		file << "            	        	        if  (HASEXCEPTION())\n";
		file << "            	        	        {\n";
		file << "            	        	            goto ruletypedVariableListEx;\n";
		file << "            	        	        }\n";
		file << "            	        	        if (HASFAILED())\n";
		file << "            	        	        {\n";
		file << "            	        	            return retval;\n";
		file << "            	        	        }\n";
		file << "            	        	        if ( BACKTRACKING==0 ) {\n";
		file << "            	        	        VARIABLE67_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, VARIABLE67));\n";
		file << "            	        	        ADAPTOR->addChild(ADAPTOR, root_0, VARIABLE67_tree);\n";
		file << "            	        	        }\n";
		file << "\n";
		file << "            	        	    }\n";
		file << "            	        	    break;\n";
		file << "\n";
		file << "            	        	default:\n";
		file << "            	        	    goto loop25;	/* break out of the loop */\n";
		file << "            	        	    break;\n";
		file << "            	            }\n";
		file << "            	        }\n";
		file << "            	        loop25: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruletypedVariableListEx; /* Prevent compiler warnings */\n";
		file << "    ruletypedVariableListEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end typedVariableList */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start singleTypeVarList\n";
		file << " * ../../model/subgoal_learning/Pddl.g:187:1: singleTypeVarList : ( ( VARIABLE )+ '-' t= type ) -> ( ^( VARIABLE $t) )+ ;\n";
		file << " */\n";
		file << "static PddlParser_singleTypeVarList_return\n";
		file << "singleTypeVarList(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_singleTypeVarList_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    VARIABLE68;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal69;\n";
		file << "    PddlParser_type_return t;\n";
		file << "    #undef	RETURN_TYPE_t\n";
		file << "    #define	RETURN_TYPE_t PddlParser_type_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE VARIABLE68_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal69_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_VARIABLE;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_60;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_type;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    VARIABLE68       = NULL;\n";
		file << "    char_literal69       = NULL;\n";
		file << "    t.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    VARIABLE68_tree   = NULL;\n";
		file << "    char_literal69_tree   = NULL;\n";
		file << "\n";
		file << "    stream_VARIABLE   = NULL;\n";
		file << "    #define CREATE_stream_VARIABLE  if (stream_VARIABLE == NULL) {stream_VARIABLE = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token VARIABLE\"); }\n";
		file << "    stream_60   = NULL;\n";
		file << "    #define CREATE_stream_60  if (stream_60 == NULL) {stream_60 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 60\"); }\n";
		file << "    stream_type   = NULL;\n";
		file << "    #define CREATE_stream_type  if (stream_type == NULL) {stream_type = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule type\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:188:5: ( ( ( VARIABLE )+ '-' t= type ) -> ( ^( VARIABLE $t) )+ )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:188:7: ( ( VARIABLE )+ '-' t= type )\n";
		file << "        {\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:188:7: ( ( VARIABLE )+ '-' t= type )\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:188:8: ( VARIABLE )+ '-' t= type\n";
		file << "            {\n";
		file << "                // ../../model/subgoal_learning/Pddl.g:188:8: ( VARIABLE )+\n";
		file << "                {\n";
		file << "                    int cnt27=0;\n";
		file << "\n";
		file << "                    for (;;)\n";
		file << "                    {\n";
		file << "                        int alt27=2;\n";
		file << "                	{\n";
		file << "                	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                	    */\n";
		file << "                	    int LA27_0 = LA(1);\n";
		file << "                	    if ( (LA27_0 == VARIABLE) )\n";
		file << "                	    {\n";
		file << "                	        alt27=1;\n";
		file << "                	    }\n";
		file << "\n";
		file << "                	}\n";
		file << "                	switch (alt27)\n";
		file << "                	{\n";
		file << "                	    case 1:\n";
		file << "                	        // ../../model/subgoal_learning/Pddl.g:0:0: VARIABLE\n";
		file << "                	        {\n";
		file << "                	            VARIABLE68 = (pANTLR3_COMMON_TOKEN) MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_singleTypeVarList927);\n";
		file << "                	            if  (HASEXCEPTION())\n";
		file << "                	            {\n";
		file << "                	                goto rulesingleTypeVarListEx;\n";
		file << "                	            }\n";
		file << "                	            if (HASFAILED())\n";
		file << "                	            {\n";
		file << "                	                return retval;\n";
		file << "                	            }\n";
		file << "                	            if ( BACKTRACKING==0 ) { CREATE_stream_VARIABLE; stream_VARIABLE->add(stream_VARIABLE, VARIABLE68, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "                	        }\n";
		file << "                	        break;\n";
		file << "\n";
		file << "                	    default:\n";
		file << "\n";
		file << "                		if ( cnt27 >= 1 )\n";
		file << "                		{\n";
		file << "                		    goto loop27;\n";
		file << "                		}\n";
		file << "                		if (BACKTRACKING>0)\n";
		file << "                		{\n";
		file << "                		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                		    return retval;\n";
		file << "                		}\n";
		file << "                		/* mismatchedSetEx()\n";
		file << "                		 */\n";
		file << "                		CONSTRUCTEX();\n";
		file << "                		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "                		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "                		goto rulesingleTypeVarListEx;\n";
		file << "                	}\n";
		file << "                	cnt27++;\n";
		file << "                    }\n";
		file << "                    loop27: ;	/* Jump to here if this rule does not match */\n";
		file << "                }\n";
		file << "                char_literal69 = (pANTLR3_COMMON_TOKEN) MATCHT(60, &FOLLOW_60_in_singleTypeVarList930);\n";
		file << "                if  (HASEXCEPTION())\n";
		file << "                {\n";
		file << "                    goto rulesingleTypeVarListEx;\n";
		file << "                }\n";
		file << "                if (HASFAILED())\n";
		file << "                {\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                if ( BACKTRACKING==0 ) { CREATE_stream_60; stream_60->add(stream_60, char_literal69, NULL); }\n";
		file << "\n";
		file << "                FOLLOWPUSH(FOLLOW_type_in_singleTypeVarList934);\n";
		file << "                t=type(ctx);\n";
		file << "\n";
		file << "                FOLLOWPOP();\n";
		file << "                if  (HASEXCEPTION())\n";
		file << "                {\n";
		file << "                    goto rulesingleTypeVarListEx;\n";
		file << "                }\n";
		file << "                if (HASFAILED())\n";
		file << "                {\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                if ( BACKTRACKING==0 ) { CREATE_stream_type; stream_type->add(stream_type, t.tree, NULL); }\n";
		file << "\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : t, VARIABLE\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval, t\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_t;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "            	stream_t=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token t\", t.tree != NULL ? t.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 189:7: -> ( ^( VARIABLE $t) )+\n";
		file << "            	{\n";
		file << "            	    if ((stream_t == NULL || !stream_t->hasNext(stream_t)) || (stream_VARIABLE == NULL || !stream_VARIABLE->hasNext(stream_VARIABLE))  )\n";
		file << "            	    {\n";
		file << "            	        CONSTRUCTEX();\n";
		file << "            	        EXCEPTION->type         = ANTLR3_REWRITE_EARLY_EXCEPTION;\n";
		file << "            	        EXCEPTION->name         = (void *)ANTLR3_REWRITE_EARLY_EXCEPTION_NAME;\n";
		file << "            	    }\n";
		file << "            	    else\n";
		file << "            	    {\n";
		file << "            	    	while ( (stream_t->hasNext(stream_t)) || (stream_VARIABLE->hasNext(stream_VARIABLE))  ) {\n";
		file << "            	    		// ../../model/subgoal_learning/Pddl.g:189:10: ^( VARIABLE $t)\n";
		file << "            	    		{\n";
		file << "            	    		    pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	    		    root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, stream_VARIABLE == NULL ? NULL : stream_VARIABLE->nextNode(stream_VARIABLE), root_1));\n";
		file << "\n";
		file << "            	    		    ADAPTOR->addChild(ADAPTOR, root_1, stream_t == NULL ? NULL : stream_t->nextTree(stream_t));\n";
		file << "\n";
		file << "            	    		    ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    		}\n";
		file << "\n";
		file << "            	    	}\n";
		file << "            	    	stream_t->reset(stream_t);\n";
		file << "            	    	stream_VARIABLE->reset(stream_VARIABLE);\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "            	if (stream_t != NULL) stream_t->free(stream_t);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulesingleTypeVarListEx; /* Prevent compiler warnings */\n";
		file << "    rulesingleTypeVarListEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_VARIABLE != NULL) stream_VARIABLE->free(stream_VARIABLE);\n";
		file << "        if (stream_60 != NULL) stream_60->free(stream_60);\n";
		file << "        if (stream_type != NULL) stream_type->free(stream_type);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end singleTypeVarList */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start constraints\n";
		file << " * ../../model/subgoal_learning/Pddl.g:192:1: constraints : '(' ':constraints' conGD ')' ;\n";
		file << " */\n";
		file << "static PddlParser_constraints_return\n";
		file << "constraints(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_constraints_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal70;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal71;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal73;\n";
		file << "    PddlParser_conGD_return conGD72;\n";
		file << "    #undef	RETURN_TYPE_conGD72\n";
		file << "    #define	RETURN_TYPE_conGD72 PddlParser_conGD_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal70_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal71_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal73_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal70       = NULL;\n";
		file << "    string_literal71       = NULL;\n";
		file << "    char_literal73       = NULL;\n";
		file << "    conGD72.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal70_tree   = NULL;\n";
		file << "    string_literal71_tree   = NULL;\n";
		file << "    char_literal73_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:193:2: ( '(' ':constraints' conGD ')' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:193:4: '(' ':constraints' conGD ')'\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            char_literal70 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_constraints965);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleconstraintsEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            string_literal71 = (pANTLR3_COMMON_TOKEN) MATCHT(66, &FOLLOW_66_in_constraints968);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleconstraintsEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            string_literal71_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal71));\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, string_literal71_tree, root_0));\n";
		file << "            }\n";
		file << "            FOLLOWPUSH(FOLLOW_conGD_in_constraints971);\n";
		file << "            conGD72=conGD(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleconstraintsEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, conGD72.tree);\n";
		file << "            char_literal73 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_constraints973);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleconstraintsEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleconstraintsEx; /* Prevent compiler warnings */\n";
		file << "    ruleconstraintsEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end constraints */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start structureDef\n";
		file << " * ../../model/subgoal_learning/Pddl.g:196:1: structureDef : ( actionDef | durativeActionDef | derivedDef );\n";
		file << " */\n";
		file << "static PddlParser_structureDef_return\n";
		file << "structureDef(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_structureDef_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    PddlParser_actionDef_return actionDef74;\n";
		file << "    #undef	RETURN_TYPE_actionDef74\n";
		file << "    #define	RETURN_TYPE_actionDef74 PddlParser_actionDef_return\n";
		file << "\n";
		file << "    PddlParser_durativeActionDef_return durativeActionDef75;\n";
		file << "    #undef	RETURN_TYPE_durativeActionDef75\n";
		file << "    #define	RETURN_TYPE_durativeActionDef75 PddlParser_durativeActionDef_return\n";
		file << "\n";
		file << "    PddlParser_derivedDef_return derivedDef76;\n";
		file << "    #undef	RETURN_TYPE_derivedDef76\n";
		file << "    #define	RETURN_TYPE_derivedDef76 PddlParser_derivedDef_return\n";
		file << "\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    actionDef74.tree = NULL;\n";
		file << "\n";
		file << "    durativeActionDef75.tree = NULL;\n";
		file << "\n";
		file << "    derivedDef76.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:197:2: ( actionDef | durativeActionDef | derivedDef )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt28;\n";
		file << "\n";
		file << "            alt28=3;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA28_0 = LA(1);\n";
		file << "                if ( (LA28_0 == 54) )\n";
		file << "                {\n";
		file << "                    switch ( LA(2) )\n";
		file << "                    {\n";
		file << "                    case 67:\n";
		file << "                    	{\n";
		file << "                    		alt28=1;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 77:\n";
		file << "                    	{\n";
		file << "                    		alt28=2;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 86:\n";
		file << "                    	{\n";
		file << "                    		alt28=3;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "\n";
		file << "                    default:\n";
		file << "                        if (BACKTRACKING>0)\n";
		file << "                        {\n";
		file << "                            FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                            return retval;\n";
		file << "                        }\n";
		file << "                        CONSTRUCTEX();\n";
		file << "                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                        EXCEPTION->message      = (void *)\"\";\n";
		file << "                        EXCEPTION->decisionNum  = 28;\n";
		file << "                        EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                        goto rulestructureDefEx;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 28;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto rulestructureDefEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt28)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:197:4: actionDef\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_actionDef_in_structureDef985);\n";
		file << "        	        actionDef74=actionDef(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulestructureDefEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, actionDef74.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:198:4: durativeActionDef\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_durativeActionDef_in_structureDef990);\n";
		file << "        	        durativeActionDef75=durativeActionDef(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulestructureDefEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, durativeActionDef75.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:199:4: derivedDef\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_derivedDef_in_structureDef995);\n";
		file << "        	        derivedDef76=derivedDef(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulestructureDefEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, derivedDef76.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulestructureDefEx; /* Prevent compiler warnings */\n";
		file << "    rulestructureDefEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end structureDef */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start actionDef\n";
		file << " * ../../model/subgoal_learning/Pddl.g:203:1: actionDef : '(' ':action' actionSymbol actionDefBody ')' -> ^( ACTION actionSymbol actionDefBody ) ;\n";
		file << " */\n";
		file << "static PddlParser_actionDef_return\n";
		file << "actionDef(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_actionDef_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal77;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal78;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal81;\n";
		file << "    PddlParser_actionSymbol_return actionSymbol79;\n";
		file << "    #undef	RETURN_TYPE_actionSymbol79\n";
		file << "    #define	RETURN_TYPE_actionSymbol79 PddlParser_actionSymbol_return\n";
		file << "\n";
		file << "    PddlParser_actionDefBody_return actionDefBody80;\n";
		file << "    #undef	RETURN_TYPE_actionDefBody80\n";
		file << "    #define	RETURN_TYPE_actionDefBody80 PddlParser_actionDefBody_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal77_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal78_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal81_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_67;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_actionSymbol;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_actionDefBody;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal77       = NULL;\n";
		file << "    string_literal78       = NULL;\n";
		file << "    char_literal81       = NULL;\n";
		file << "    actionSymbol79.tree = NULL;\n";
		file << "\n";
		file << "    actionDefBody80.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal77_tree   = NULL;\n";
		file << "    string_literal78_tree   = NULL;\n";
		file << "    char_literal81_tree   = NULL;\n";
		file << "\n";
		file << "    stream_67   = NULL;\n";
		file << "    #define CREATE_stream_67  if (stream_67 == NULL) {stream_67 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 67\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_actionSymbol   = NULL;\n";
		file << "    #define CREATE_stream_actionSymbol  if (stream_actionSymbol == NULL) {stream_actionSymbol = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule actionSymbol\"); }\n";
		file << "    stream_actionDefBody   = NULL;\n";
		file << "    #define CREATE_stream_actionDefBody  if (stream_actionDefBody == NULL) {stream_actionDefBody = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule actionDefBody\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:206:2: ( '(' ':action' actionSymbol actionDefBody ')' -> ^( ACTION actionSymbol actionDefBody ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:206:4: '(' ':action' actionSymbol actionDefBody ')'\n";
		file << "        {\n";
		file << "            char_literal77 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_actionDef1010);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleactionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal77, NULL); }\n";
		file << "\n";
		file << "            string_literal78 = (pANTLR3_COMMON_TOKEN) MATCHT(67, &FOLLOW_67_in_actionDef1012);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleactionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_67; stream_67->add(stream_67, string_literal78, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_actionSymbol_in_actionDef1014);\n";
		file << "            actionSymbol79=actionSymbol(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleactionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_actionSymbol; stream_actionSymbol->add(stream_actionSymbol, actionSymbol79.tree, NULL); }\n";
		file << "            FOLLOWPUSH(FOLLOW_actionDefBody_in_actionDef1027);\n";
		file << "            actionDefBody80=actionDefBody(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleactionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_actionDefBody; stream_actionDefBody->add(stream_actionDefBody, actionDefBody80.tree, NULL); }\n";
		file << "            char_literal81 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_actionDef1029);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleactionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal81, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : actionDefBody, actionSymbol\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 208:8: -> ^( ACTION actionSymbol actionDefBody )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:208:11: ^( ACTION actionSymbol actionDefBody )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ACTION, (pANTLR3_UINT8)\"ACTION\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_actionSymbol == NULL ? NULL : stream_actionSymbol->nextTree(stream_actionSymbol));\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_actionDefBody == NULL ? NULL : stream_actionDefBody->nextTree(stream_actionDefBody));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleactionDefEx; /* Prevent compiler warnings */\n";
		file << "    ruleactionDefEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_67 != NULL) stream_67->free(stream_67);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_actionSymbol != NULL) stream_actionSymbol->free(stream_actionSymbol);\n";
		file << "        if (stream_actionDefBody != NULL) stream_actionDefBody->free(stream_actionDefBody);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end actionDef */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start actionSymbol\n";
		file << " * ../../model/subgoal_learning/Pddl.g:211:1: actionSymbol : NAME ;\n";
		file << " */\n";
		file << "static PddlParser_actionSymbol_return\n";
		file << "actionSymbol(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_actionSymbol_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME82;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE NAME82_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    NAME82       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    NAME82_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:211:14: ( NAME )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:211:16: NAME\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            NAME82 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_actionSymbol1059);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleactionSymbolEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            NAME82_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME82));\n";
		file << "            ADAPTOR->addChild(ADAPTOR, root_0, NAME82_tree);\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleactionSymbolEx; /* Prevent compiler warnings */\n";
		file << "    ruleactionSymbolEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end actionSymbol */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start actionDefBody\n";
		file << " * ../../model/subgoal_learning/Pddl.g:217:1: actionDefBody : ( ':parameters' '(' typedVariableList ')' )? ( ':precondition' ( ( '(' ')' ) | goalDesc ) )? ( ':effect' ( ( '(' ')' ) | effect ) )? -> ^( PARAMETERS ( typedVariableList )? ) ^( PRECONDITION ( goalDesc )? ) ^( EFFECT ( effect )? ) ;\n";
		file << " */\n";
		file << "static PddlParser_actionDefBody_return\n";
		file << "actionDefBody(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_actionDefBody_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal83;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal84;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal86;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal87;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal88;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal89;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal91;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal92;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal93;\n";
		file << "    PddlParser_typedVariableList_return typedVariableList85;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList85\n";
		file << "    #define	RETURN_TYPE_typedVariableList85 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc90;\n";
		file << "    #undef	RETURN_TYPE_goalDesc90\n";
		file << "    #define	RETURN_TYPE_goalDesc90 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_effect_return effect94;\n";
		file << "    #undef	RETURN_TYPE_effect94\n";
		file << "    #define	RETURN_TYPE_effect94 PddlParser_effect_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE string_literal83_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal84_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal86_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal87_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal88_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal89_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal91_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal92_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal93_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_69;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_68;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_70;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_effect;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_goalDesc;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typedVariableList;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    string_literal83       = NULL;\n";
		file << "    char_literal84       = NULL;\n";
		file << "    char_literal86       = NULL;\n";
		file << "    string_literal87       = NULL;\n";
		file << "    char_literal88       = NULL;\n";
		file << "    char_literal89       = NULL;\n";
		file << "    string_literal91       = NULL;\n";
		file << "    char_literal92       = NULL;\n";
		file << "    char_literal93       = NULL;\n";
		file << "    typedVariableList85.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc90.tree = NULL;\n";
		file << "\n";
		file << "    effect94.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    string_literal83_tree   = NULL;\n";
		file << "    char_literal84_tree   = NULL;\n";
		file << "    char_literal86_tree   = NULL;\n";
		file << "    string_literal87_tree   = NULL;\n";
		file << "    char_literal88_tree   = NULL;\n";
		file << "    char_literal89_tree   = NULL;\n";
		file << "    string_literal91_tree   = NULL;\n";
		file << "    char_literal92_tree   = NULL;\n";
		file << "    char_literal93_tree   = NULL;\n";
		file << "\n";
		file << "    stream_69   = NULL;\n";
		file << "    #define CREATE_stream_69  if (stream_69 == NULL) {stream_69 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 69\"); }\n";
		file << "    stream_68   = NULL;\n";
		file << "    #define CREATE_stream_68  if (stream_68 == NULL) {stream_68 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 68\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_70   = NULL;\n";
		file << "    #define CREATE_stream_70  if (stream_70 == NULL) {stream_70 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 70\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_effect   = NULL;\n";
		file << "    #define CREATE_stream_effect  if (stream_effect == NULL) {stream_effect = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule effect\"); }\n";
		file << "    stream_goalDesc   = NULL;\n";
		file << "    #define CREATE_stream_goalDesc  if (stream_goalDesc == NULL) {stream_goalDesc = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule goalDesc\"); }\n";
		file << "    stream_typedVariableList   = NULL;\n";
		file << "    #define CREATE_stream_typedVariableList  if (stream_typedVariableList == NULL) {stream_typedVariableList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule typedVariableList\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:218:2: ( ( ':parameters' '(' typedVariableList ')' )? ( ':precondition' ( ( '(' ')' ) | goalDesc ) )? ( ':effect' ( ( '(' ')' ) | effect ) )? -> ^( PARAMETERS ( typedVariableList )? ) ^( PRECONDITION ( goalDesc )? ) ^( EFFECT ( effect )? ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:218:4: ( ':parameters' '(' typedVariableList ')' )? ( ':precondition' ( ( '(' ')' ) | goalDesc ) )? ( ':effect' ( ( '(' ')' ) | effect ) )?\n";
		file << "        {\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:218:4: ( ':parameters' '(' typedVariableList ')' )?\n";
		file << "            {\n";
		file << "                int alt29=2;\n";
		file << "                {\n";
		file << "                    int LA29_0 = LA(1);\n";
		file << "                    if ( (LA29_0 == 68) )\n";
		file << "                    {\n";
		file << "                        alt29=1;\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt29)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:218:6: ':parameters' '(' typedVariableList ')'\n";
		file << "            	    {\n";
		file << "            	        string_literal83 = (pANTLR3_COMMON_TOKEN) MATCHT(68, &FOLLOW_68_in_actionDefBody1075);\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleactionDefBodyEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_68; stream_68->add(stream_68, string_literal83, NULL); }\n";
		file << "\n";
		file << "            	        char_literal84 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_actionDefBody1077);\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleactionDefBodyEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal84, NULL); }\n";
		file << "\n";
		file << "            	        FOLLOWPUSH(FOLLOW_typedVariableList_in_actionDefBody1079);\n";
		file << "            	        typedVariableList85=typedVariableList(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleactionDefBodyEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_typedVariableList; stream_typedVariableList->add(stream_typedVariableList, typedVariableList85.tree, NULL); }\n";
		file << "            	        char_literal86 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_actionDefBody1081);\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleactionDefBodyEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal86, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:219:7: ( ':precondition' ( ( '(' ')' ) | goalDesc ) )?\n";
		file << "            {\n";
		file << "                int alt31=2;\n";
		file << "                {\n";
		file << "                    int LA31_0 = LA(1);\n";
		file << "                    if ( (LA31_0 == 69) )\n";
		file << "                    {\n";
		file << "                        alt31=1;\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt31)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:219:9: ':precondition' ( ( '(' ')' ) | goalDesc )\n";
		file << "            	    {\n";
		file << "            	        string_literal87 = (pANTLR3_COMMON_TOKEN) MATCHT(69, &FOLLOW_69_in_actionDefBody1093);\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleactionDefBodyEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_69; stream_69->add(stream_69, string_literal87, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:219:25: ( ( '(' ')' ) | goalDesc )\n";
		file << "            	        {\n";
		file << "            	            int alt30=2;\n";
		file << "\n";
		file << "            	            {\n";
		file << "            	                int LA30_0 = LA(1);\n";
		file << "            	                if ( (LA30_0 == 54) )\n";
		file << "            	                {\n";
		file << "\n";
		file << "            	                    {\n";
		file << "            	                        int LA30_1 = LA(2);\n";
		file << "            	                        if ( (LA30_1 == 56) )\n";
		file << "            	                        {\n";
		file << "            	                            alt30=1;\n";
		file << "            	                        }\n";
		file << "            	                        else if ( (LA30_1 == NAME || ((LA30_1 >= 71) && (LA30_1 <= 76)) || ((LA30_1 >= 91) && (LA30_1 <= 95))) )\n";
		file << "            	                        {\n";
		file << "            	                            alt30=2;\n";
		file << "            	                        }\n";
		file << "            	                        else\n";
		file << "            	                        {\n";
		file << "            	                            if (BACKTRACKING>0)\n";
		file << "            	                            {\n";
		file << "            	                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            	                                return retval;\n";
		file << "            	                            }\n";
		file << "\n";
		file << "            	                            CONSTRUCTEX();\n";
		file << "            	                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "            	                            EXCEPTION->message      = (void *)\"\";\n";
		file << "            	                            EXCEPTION->decisionNum  = 30;\n";
		file << "            	                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "            	                            goto ruleactionDefBodyEx;\n";
		file << "            	                        }\n";
		file << "            	                    }\n";
		file << "            	                }\n";
		file << "            	                else\n";
		file << "            	                {\n";
		file << "            	                    if (BACKTRACKING>0)\n";
		file << "            	                    {\n";
		file << "            	                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            	                        return retval;\n";
		file << "            	                    }\n";
		file << "\n";
		file << "            	                    CONSTRUCTEX();\n";
		file << "            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "            	                    EXCEPTION->message      = (void *)\"\";\n";
		file << "            	                    EXCEPTION->decisionNum  = 30;\n";
		file << "            	                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "            	                    goto ruleactionDefBodyEx;\n";
		file << "            	                }\n";
		file << "            	            }\n";
		file << "            	            switch (alt30)\n";
		file << "            	            {\n";
		file << "            	        	case 1:\n";
		file << "            	        	    // ../../model/subgoal_learning/Pddl.g:219:26: ( '(' ')' )\n";
		file << "            	        	    {\n";
		file << "            	        	        // ../../model/subgoal_learning/Pddl.g:219:26: ( '(' ')' )\n";
		file << "            	        	        // ../../model/subgoal_learning/Pddl.g:219:27: '(' ')'\n";
		file << "            	        	        {\n";
		file << "            	        	            char_literal88 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_actionDefBody1097);\n";
		file << "            	        	            if  (HASEXCEPTION())\n";
		file << "            	        	            {\n";
		file << "            	        	                goto ruleactionDefBodyEx;\n";
		file << "            	        	            }\n";
		file << "            	        	            if (HASFAILED())\n";
		file << "            	        	            {\n";
		file << "            	        	                return retval;\n";
		file << "            	        	            }\n";
		file << "            	        	            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal88, NULL); }\n";
		file << "\n";
		file << "            	        	            char_literal89 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_actionDefBody1099);\n";
		file << "            	        	            if  (HASEXCEPTION())\n";
		file << "            	        	            {\n";
		file << "            	        	                goto ruleactionDefBodyEx;\n";
		file << "            	        	            }\n";
		file << "            	        	            if (HASFAILED())\n";
		file << "            	        	            {\n";
		file << "            	        	                return retval;\n";
		file << "            	        	            }\n";
		file << "            	        	            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal89, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "            	        	        }\n";
		file << "\n";
		file << "\n";
		file << "            	        	    }\n";
		file << "            	        	    break;\n";
		file << "            	        	case 2:\n";
		file << "            	        	    // ../../model/subgoal_learning/Pddl.g:219:38: goalDesc\n";
		file << "            	        	    {\n";
		file << "            	        	        FOLLOWPUSH(FOLLOW_goalDesc_in_actionDefBody1104);\n";
		file << "            	        	        goalDesc90=goalDesc(ctx);\n";
		file << "\n";
		file << "            	        	        FOLLOWPOP();\n";
		file << "            	        	        if  (HASEXCEPTION())\n";
		file << "            	        	        {\n";
		file << "            	        	            goto ruleactionDefBodyEx;\n";
		file << "            	        	        }\n";
		file << "            	        	        if (HASFAILED())\n";
		file << "            	        	        {\n";
		file << "            	        	            return retval;\n";
		file << "            	        	        }\n";
		file << "            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc90.tree, NULL); }\n";
		file << "\n";
		file << "            	        	    }\n";
		file << "            	        	    break;\n";
		file << "\n";
		file << "            	            }\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:220:4: ( ':effect' ( ( '(' ')' ) | effect ) )?\n";
		file << "            {\n";
		file << "                int alt33=2;\n";
		file << "                {\n";
		file << "                    int LA33_0 = LA(1);\n";
		file << "                    if ( (LA33_0 == 70) )\n";
		file << "                    {\n";
		file << "                        alt33=1;\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt33)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:220:6: ':effect' ( ( '(' ')' ) | effect )\n";
		file << "            	    {\n";
		file << "            	        string_literal91 = (pANTLR3_COMMON_TOKEN) MATCHT(70, &FOLLOW_70_in_actionDefBody1114);\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleactionDefBodyEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_70; stream_70->add(stream_70, string_literal91, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:220:16: ( ( '(' ')' ) | effect )\n";
		file << "            	        {\n";
		file << "            	            int alt32=2;\n";
		file << "\n";
		file << "            	            {\n";
		file << "            	                int LA32_0 = LA(1);\n";
		file << "            	                if ( (LA32_0 == 54) )\n";
		file << "            	                {\n";
		file << "\n";
		file << "            	                    {\n";
		file << "            	                        int LA32_1 = LA(2);\n";
		file << "            	                        if ( (LA32_1 == 56) )\n";
		file << "            	                        {\n";
		file << "            	                            alt32=1;\n";
		file << "            	                        }\n";
		file << "            	                        else if ( (LA32_1 == NAME || LA32_1 == 71 || LA32_1 == 73 || LA32_1 == 76 || LA32_1 == 87 || ((LA32_1 >= 96) && (LA32_1 <= 100))) )\n";
		file << "            	                        {\n";
		file << "            	                            alt32=2;\n";
		file << "            	                        }\n";
		file << "            	                        else\n";
		file << "            	                        {\n";
		file << "            	                            if (BACKTRACKING>0)\n";
		file << "            	                            {\n";
		file << "            	                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            	                                return retval;\n";
		file << "            	                            }\n";
		file << "\n";
		file << "            	                            CONSTRUCTEX();\n";
		file << "            	                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "            	                            EXCEPTION->message      = (void *)\"\";\n";
		file << "            	                            EXCEPTION->decisionNum  = 32;\n";
		file << "            	                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "            	                            goto ruleactionDefBodyEx;\n";
		file << "            	                        }\n";
		file << "            	                    }\n";
		file << "            	                }\n";
		file << "            	                else\n";
		file << "            	                {\n";
		file << "            	                    if (BACKTRACKING>0)\n";
		file << "            	                    {\n";
		file << "            	                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            	                        return retval;\n";
		file << "            	                    }\n";
		file << "\n";
		file << "            	                    CONSTRUCTEX();\n";
		file << "            	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "            	                    EXCEPTION->message      = (void *)\"\";\n";
		file << "            	                    EXCEPTION->decisionNum  = 32;\n";
		file << "            	                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "            	                    goto ruleactionDefBodyEx;\n";
		file << "            	                }\n";
		file << "            	            }\n";
		file << "            	            switch (alt32)\n";
		file << "            	            {\n";
		file << "            	        	case 1:\n";
		file << "            	        	    // ../../model/subgoal_learning/Pddl.g:220:17: ( '(' ')' )\n";
		file << "            	        	    {\n";
		file << "            	        	        // ../../model/subgoal_learning/Pddl.g:220:17: ( '(' ')' )\n";
		file << "            	        	        // ../../model/subgoal_learning/Pddl.g:220:18: '(' ')'\n";
		file << "            	        	        {\n";
		file << "            	        	            char_literal92 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_actionDefBody1118);\n";
		file << "            	        	            if  (HASEXCEPTION())\n";
		file << "            	        	            {\n";
		file << "            	        	                goto ruleactionDefBodyEx;\n";
		file << "            	        	            }\n";
		file << "            	        	            if (HASFAILED())\n";
		file << "            	        	            {\n";
		file << "            	        	                return retval;\n";
		file << "            	        	            }\n";
		file << "            	        	            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal92, NULL); }\n";
		file << "\n";
		file << "            	        	            char_literal93 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_actionDefBody1120);\n";
		file << "            	        	            if  (HASEXCEPTION())\n";
		file << "            	        	            {\n";
		file << "            	        	                goto ruleactionDefBodyEx;\n";
		file << "            	        	            }\n";
		file << "            	        	            if (HASFAILED())\n";
		file << "            	        	            {\n";
		file << "            	        	                return retval;\n";
		file << "            	        	            }\n";
		file << "            	        	            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal93, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "            	        	        }\n";
		file << "\n";
		file << "\n";
		file << "            	        	    }\n";
		file << "            	        	    break;\n";
		file << "            	        	case 2:\n";
		file << "            	        	    // ../../model/subgoal_learning/Pddl.g:220:29: effect\n";
		file << "            	        	    {\n";
		file << "            	        	        FOLLOWPUSH(FOLLOW_effect_in_actionDefBody1125);\n";
		file << "            	        	        effect94=effect(ctx);\n";
		file << "\n";
		file << "            	        	        FOLLOWPOP();\n";
		file << "            	        	        if  (HASEXCEPTION())\n";
		file << "            	        	        {\n";
		file << "            	        	            goto ruleactionDefBodyEx;\n";
		file << "            	        	        }\n";
		file << "            	        	        if (HASFAILED())\n";
		file << "            	        	        {\n";
		file << "            	        	            return retval;\n";
		file << "            	        	        }\n";
		file << "            	        	        if ( BACKTRACKING==0 ) { CREATE_stream_effect; stream_effect->add(stream_effect, effect94.tree, NULL); }\n";
		file << "\n";
		file << "            	        	    }\n";
		file << "            	        	    break;\n";
		file << "\n";
		file << "            	            }\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : goalDesc, effect, typedVariableList\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 221:4: -> ^( PARAMETERS ( typedVariableList )? ) ^( PRECONDITION ( goalDesc )? ) ^( EFFECT ( effect )? )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:221:7: ^( PARAMETERS ( typedVariableList )? )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PARAMETERS, (pANTLR3_UINT8)\"PARAMETERS\"), root_1));\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:221:20: ( typedVariableList )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_typedVariableList != NULL && stream_typedVariableList->hasNext(stream_typedVariableList))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_typedVariableList == NULL ? NULL : stream_typedVariableList->nextTree(stream_typedVariableList));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_typedVariableList != NULL) stream_typedVariableList->reset(stream_typedVariableList);\n";
		file << "\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:221:40: ^( PRECONDITION ( goalDesc )? )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PRECONDITION, (pANTLR3_UINT8)\"PRECONDITION\"), root_1));\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:221:55: ( goalDesc )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_goalDesc != NULL && stream_goalDesc->hasNext(stream_goalDesc))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_goalDesc != NULL) stream_goalDesc->reset(stream_goalDesc);\n";
		file << "\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:221:66: ^( EFFECT ( effect )? )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, EFFECT, (pANTLR3_UINT8)\"EFFECT\"), root_1));\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:221:75: ( effect )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_effect != NULL && stream_effect->hasNext(stream_effect))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_effect == NULL ? NULL : stream_effect->nextTree(stream_effect));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_effect != NULL) stream_effect->reset(stream_effect);\n";
		file << "\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleactionDefBodyEx; /* Prevent compiler warnings */\n";
		file << "    ruleactionDefBodyEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_69 != NULL) stream_69->free(stream_69);\n";
		file << "        if (stream_68 != NULL) stream_68->free(stream_68);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_70 != NULL) stream_70->free(stream_70);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_effect != NULL) stream_effect->free(stream_effect);\n";
		file << "        if (stream_goalDesc != NULL) stream_goalDesc->free(stream_goalDesc);\n";
		file << "        if (stream_typedVariableList != NULL) stream_typedVariableList->free(stream_typedVariableList);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end actionDefBody */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start goalDesc\n";
		file << " * ../../model/subgoal_learning/Pddl.g:235:1: goalDesc : ( atomicTermFormula | '(' 'and' ( goalDesc )* ')' -> ^( AND_GD ( goalDesc )* ) | '(' 'or' ( goalDesc )* ')' -> ^( OR_GD ( goalDesc )* ) | '(' 'not' goalDesc ')' -> ^( NOT_GD goalDesc ) | '(' 'imply' goalDesc goalDesc ')' -> ^( IMPLY_GD goalDesc goalDesc ) | '(' 'exists' '(' typedVariableList ')' goalDesc ')' -> ^( EXISTS_GD typedVariableList goalDesc ) | '(' 'forall' '(' typedVariableList ')' goalDesc ')' -> ^( FORALL_GD typedVariableList goalDesc ) | fComp -> ^( COMPARISON_GD fComp ) );\n";
		file << " */\n";
		file << "static PddlParser_goalDesc_return\n";
		file << "goalDesc(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_goalDesc_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal96;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal97;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal99;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal100;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal101;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal103;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal104;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal105;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal107;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal108;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal109;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal112;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal113;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal114;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal115;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal117;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal119;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal120;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal121;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal122;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal124;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal126;\n";
		file << "    PddlParser_atomicTermFormula_return atomicTermFormula95;\n";
		file << "    #undef	RETURN_TYPE_atomicTermFormula95\n";
		file << "    #define	RETURN_TYPE_atomicTermFormula95 PddlParser_atomicTermFormula_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc98;\n";
		file << "    #undef	RETURN_TYPE_goalDesc98\n";
		file << "    #define	RETURN_TYPE_goalDesc98 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc102;\n";
		file << "    #undef	RETURN_TYPE_goalDesc102\n";
		file << "    #define	RETURN_TYPE_goalDesc102 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc106;\n";
		file << "    #undef	RETURN_TYPE_goalDesc106\n";
		file << "    #define	RETURN_TYPE_goalDesc106 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc110;\n";
		file << "    #undef	RETURN_TYPE_goalDesc110\n";
		file << "    #define	RETURN_TYPE_goalDesc110 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc111;\n";
		file << "    #undef	RETURN_TYPE_goalDesc111\n";
		file << "    #define	RETURN_TYPE_goalDesc111 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_typedVariableList_return typedVariableList116;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList116\n";
		file << "    #define	RETURN_TYPE_typedVariableList116 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc118;\n";
		file << "    #undef	RETURN_TYPE_goalDesc118\n";
		file << "    #define	RETURN_TYPE_goalDesc118 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_typedVariableList_return typedVariableList123;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList123\n";
		file << "    #define	RETURN_TYPE_typedVariableList123 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc125;\n";
		file << "    #undef	RETURN_TYPE_goalDesc125\n";
		file << "    #define	RETURN_TYPE_goalDesc125 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_fComp_return fComp127;\n";
		file << "    #undef	RETURN_TYPE_fComp127\n";
		file << "    #define	RETURN_TYPE_fComp127 PddlParser_fComp_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal96_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal97_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal99_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal100_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal101_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal103_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal104_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal105_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal107_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal108_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal109_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal112_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal113_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal114_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal115_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal117_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal119_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal120_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal121_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal122_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal124_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal126_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_71;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_72;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_73;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_74;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_75;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_76;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_fComp;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_goalDesc;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typedVariableList;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal96       = NULL;\n";
		file << "    string_literal97       = NULL;\n";
		file << "    char_literal99       = NULL;\n";
		file << "    char_literal100       = NULL;\n";
		file << "    string_literal101       = NULL;\n";
		file << "    char_literal103       = NULL;\n";
		file << "    char_literal104       = NULL;\n";
		file << "    string_literal105       = NULL;\n";
		file << "    char_literal107       = NULL;\n";
		file << "    char_literal108       = NULL;\n";
		file << "    string_literal109       = NULL;\n";
		file << "    char_literal112       = NULL;\n";
		file << "    char_literal113       = NULL;\n";
		file << "    string_literal114       = NULL;\n";
		file << "    char_literal115       = NULL;\n";
		file << "    char_literal117       = NULL;\n";
		file << "    char_literal119       = NULL;\n";
		file << "    char_literal120       = NULL;\n";
		file << "    string_literal121       = NULL;\n";
		file << "    char_literal122       = NULL;\n";
		file << "    char_literal124       = NULL;\n";
		file << "    char_literal126       = NULL;\n";
		file << "    atomicTermFormula95.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc98.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc102.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc106.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc110.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc111.tree = NULL;\n";
		file << "\n";
		file << "    typedVariableList116.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc118.tree = NULL;\n";
		file << "\n";
		file << "    typedVariableList123.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc125.tree = NULL;\n";
		file << "\n";
		file << "    fComp127.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal96_tree   = NULL;\n";
		file << "    string_literal97_tree   = NULL;\n";
		file << "    char_literal99_tree   = NULL;\n";
		file << "    char_literal100_tree   = NULL;\n";
		file << "    string_literal101_tree   = NULL;\n";
		file << "    char_literal103_tree   = NULL;\n";
		file << "    char_literal104_tree   = NULL;\n";
		file << "    string_literal105_tree   = NULL;\n";
		file << "    char_literal107_tree   = NULL;\n";
		file << "    char_literal108_tree   = NULL;\n";
		file << "    string_literal109_tree   = NULL;\n";
		file << "    char_literal112_tree   = NULL;\n";
		file << "    char_literal113_tree   = NULL;\n";
		file << "    string_literal114_tree   = NULL;\n";
		file << "    char_literal115_tree   = NULL;\n";
		file << "    char_literal117_tree   = NULL;\n";
		file << "    char_literal119_tree   = NULL;\n";
		file << "    char_literal120_tree   = NULL;\n";
		file << "    string_literal121_tree   = NULL;\n";
		file << "    char_literal122_tree   = NULL;\n";
		file << "    char_literal124_tree   = NULL;\n";
		file << "    char_literal126_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_71   = NULL;\n";
		file << "    #define CREATE_stream_71  if (stream_71 == NULL) {stream_71 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 71\"); }\n";
		file << "    stream_72   = NULL;\n";
		file << "    #define CREATE_stream_72  if (stream_72 == NULL) {stream_72 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 72\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_73   = NULL;\n";
		file << "    #define CREATE_stream_73  if (stream_73 == NULL) {stream_73 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 73\"); }\n";
		file << "    stream_74   = NULL;\n";
		file << "    #define CREATE_stream_74  if (stream_74 == NULL) {stream_74 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 74\"); }\n";
		file << "    stream_75   = NULL;\n";
		file << "    #define CREATE_stream_75  if (stream_75 == NULL) {stream_75 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 75\"); }\n";
		file << "    stream_76   = NULL;\n";
		file << "    #define CREATE_stream_76  if (stream_76 == NULL) {stream_76 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 76\"); }\n";
		file << "    stream_fComp   = NULL;\n";
		file << "    #define CREATE_stream_fComp  if (stream_fComp == NULL) {stream_fComp = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule fComp\"); }\n";
		file << "    stream_goalDesc   = NULL;\n";
		file << "    #define CREATE_stream_goalDesc  if (stream_goalDesc == NULL) {stream_goalDesc = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule goalDesc\"); }\n";
		file << "    stream_typedVariableList   = NULL;\n";
		file << "    #define CREATE_stream_typedVariableList  if (stream_typedVariableList == NULL) {stream_typedVariableList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule typedVariableList\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:236:2: ( atomicTermFormula | '(' 'and' ( goalDesc )* ')' -> ^( AND_GD ( goalDesc )* ) | '(' 'or' ( goalDesc )* ')' -> ^( OR_GD ( goalDesc )* ) | '(' 'not' goalDesc ')' -> ^( NOT_GD goalDesc ) | '(' 'imply' goalDesc goalDesc ')' -> ^( IMPLY_GD goalDesc goalDesc ) | '(' 'exists' '(' typedVariableList ')' goalDesc ')' -> ^( EXISTS_GD typedVariableList goalDesc ) | '(' 'forall' '(' typedVariableList ')' goalDesc ')' -> ^( FORALL_GD typedVariableList goalDesc ) | fComp -> ^( COMPARISON_GD fComp ) )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt36;\n";
		file << "\n";
		file << "            alt36=8;\n";
		file << "\n";
		file << "            alt36 = cdfa36.predict(ctx, RECOGNIZER, ISTREAM, &cdfa36);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulegoalDescEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            switch (alt36)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:236:4: atomicTermFormula\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_atomicTermFormula_in_goalDesc1176);\n";
		file << "        	        atomicTermFormula95=atomicTermFormula(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, atomicTermFormula95.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:237:4: '(' 'and' ( goalDesc )* ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal96 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_goalDesc1181);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal96, NULL); }\n";
		file << "\n";
		file << "        	        string_literal97 = (pANTLR3_COMMON_TOKEN) MATCHT(71, &FOLLOW_71_in_goalDesc1183);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_71; stream_71->add(stream_71, string_literal97, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:237:14: ( goalDesc )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt34=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA34_0 = LA(1);\n";
		file << "        	                if ( (LA34_0 == 54) )\n";
		file << "        	                {\n";
		file << "        	                    alt34=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt34)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: goalDesc\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_goalDesc_in_goalDesc1185);\n";
		file << "        	        	        goalDesc98=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto rulegoalDescEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc98.tree, NULL); }\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop34;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop34: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal99 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_goalDesc1188);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal99, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : goalDesc\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 238:12: -> ^( AND_GD ( goalDesc )* )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:238:15: ^( AND_GD ( goalDesc )* )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, AND_GD, (pANTLR3_UINT8)\"AND_GD\"), root_1));\n";
		file << "\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:238:24: ( goalDesc )*\n";
		file << "        	        	        {\n";
		file << "        	        	        	while ( (stream_goalDesc != NULL && stream_goalDesc->hasNext(stream_goalDesc))  )\n";
		file << "        	        	        	{\n";
		file << "        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "\n";
		file << "        	        	        	}\n";
		file << "        	        	        	if (stream_goalDesc != NULL) stream_goalDesc->reset(stream_goalDesc);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:239:4: '(' 'or' ( goalDesc )* ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal100 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_goalDesc1213);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal100, NULL); }\n";
		file << "\n";
		file << "        	        string_literal101 = (pANTLR3_COMMON_TOKEN) MATCHT(72, &FOLLOW_72_in_goalDesc1215);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_72; stream_72->add(stream_72, string_literal101, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:239:13: ( goalDesc )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt35=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA35_0 = LA(1);\n";
		file << "        	                if ( (LA35_0 == 54) )\n";
		file << "        	                {\n";
		file << "        	                    alt35=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt35)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: goalDesc\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_goalDesc_in_goalDesc1217);\n";
		file << "        	        	        goalDesc102=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto rulegoalDescEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc102.tree, NULL); }\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop35;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop35: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal103 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_goalDesc1220);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal103, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : goalDesc\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 240:12: -> ^( OR_GD ( goalDesc )* )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:240:15: ^( OR_GD ( goalDesc )* )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, OR_GD, (pANTLR3_UINT8)\"OR_GD\"), root_1));\n";
		file << "\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:240:23: ( goalDesc )*\n";
		file << "        	        	        {\n";
		file << "        	        	        	while ( (stream_goalDesc != NULL && stream_goalDesc->hasNext(stream_goalDesc))  )\n";
		file << "        	        	        	{\n";
		file << "        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "\n";
		file << "        	        	        	}\n";
		file << "        	        	        	if (stream_goalDesc != NULL) stream_goalDesc->reset(stream_goalDesc);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 4:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:241:4: '(' 'not' goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal104 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_goalDesc1245);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal104, NULL); }\n";
		file << "\n";
		file << "        	        string_literal105 = (pANTLR3_COMMON_TOKEN) MATCHT(73, &FOLLOW_73_in_goalDesc1247);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_73; stream_73->add(stream_73, string_literal105, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_goalDesc1249);\n";
		file << "        	        goalDesc106=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc106.tree, NULL); }\n";
		file << "        	        char_literal107 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_goalDesc1251);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal107, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : goalDesc\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 242:12: -> ^( NOT_GD goalDesc )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:242:15: ^( NOT_GD goalDesc )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NOT_GD, (pANTLR3_UINT8)\"NOT_GD\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 5:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:243:4: '(' 'imply' goalDesc goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal108 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_goalDesc1275);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal108, NULL); }\n";
		file << "\n";
		file << "        	        string_literal109 = (pANTLR3_COMMON_TOKEN) MATCHT(74, &FOLLOW_74_in_goalDesc1277);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_74; stream_74->add(stream_74, string_literal109, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_goalDesc1279);\n";
		file << "        	        goalDesc110=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc110.tree, NULL); }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_goalDesc1281);\n";
		file << "        	        goalDesc111=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc111.tree, NULL); }\n";
		file << "        	        char_literal112 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_goalDesc1283);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal112, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : goalDesc, goalDesc\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 244:12: -> ^( IMPLY_GD goalDesc goalDesc )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:244:15: ^( IMPLY_GD goalDesc goalDesc )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, IMPLY_GD, (pANTLR3_UINT8)\"IMPLY_GD\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 6:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:245:4: '(' 'exists' '(' typedVariableList ')' goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal113 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_goalDesc1309);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal113, NULL); }\n";
		file << "\n";
		file << "        	        string_literal114 = (pANTLR3_COMMON_TOKEN) MATCHT(75, &FOLLOW_75_in_goalDesc1311);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_75; stream_75->add(stream_75, string_literal114, NULL); }\n";
		file << "\n";
		file << "        	        char_literal115 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_goalDesc1313);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal115, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_typedVariableList_in_goalDesc1315);\n";
		file << "        	        typedVariableList116=typedVariableList(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_typedVariableList; stream_typedVariableList->add(stream_typedVariableList, typedVariableList116.tree, NULL); }\n";
		file << "        	        char_literal117 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_goalDesc1317);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal117, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_goalDesc1319);\n";
		file << "        	        goalDesc118=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc118.tree, NULL); }\n";
		file << "        	        char_literal119 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_goalDesc1321);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal119, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : goalDesc, typedVariableList\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 246:12: -> ^( EXISTS_GD typedVariableList goalDesc )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:246:15: ^( EXISTS_GD typedVariableList goalDesc )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, EXISTS_GD, (pANTLR3_UINT8)\"EXISTS_GD\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_typedVariableList == NULL ? NULL : stream_typedVariableList->nextTree(stream_typedVariableList));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 7:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:247:4: '(' 'forall' '(' typedVariableList ')' goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal120 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_goalDesc1347);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal120, NULL); }\n";
		file << "\n";
		file << "        	        string_literal121 = (pANTLR3_COMMON_TOKEN) MATCHT(76, &FOLLOW_76_in_goalDesc1349);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_76; stream_76->add(stream_76, string_literal121, NULL); }\n";
		file << "\n";
		file << "        	        char_literal122 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_goalDesc1351);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal122, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_typedVariableList_in_goalDesc1353);\n";
		file << "        	        typedVariableList123=typedVariableList(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_typedVariableList; stream_typedVariableList->add(stream_typedVariableList, typedVariableList123.tree, NULL); }\n";
		file << "        	        char_literal124 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_goalDesc1355);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal124, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_goalDesc1357);\n";
		file << "        	        goalDesc125=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc125.tree, NULL); }\n";
		file << "        	        char_literal126 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_goalDesc1359);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal126, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : goalDesc, typedVariableList\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 248:12: -> ^( FORALL_GD typedVariableList goalDesc )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:248:15: ^( FORALL_GD typedVariableList goalDesc )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FORALL_GD, (pANTLR3_UINT8)\"FORALL_GD\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_typedVariableList == NULL ? NULL : stream_typedVariableList->nextTree(stream_typedVariableList));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 8:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:249:7: fComp\n";
		file << "        	    {\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fComp_in_goalDesc1388);\n";
		file << "        	        fComp127=fComp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulegoalDescEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_fComp; stream_fComp->add(stream_fComp, fComp127.tree, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : fComp\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 250:15: -> ^( COMPARISON_GD fComp )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:250:18: ^( COMPARISON_GD fComp )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, COMPARISON_GD, (pANTLR3_UINT8)\"COMPARISON_GD\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_fComp == NULL ? NULL : stream_fComp->nextTree(stream_fComp));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulegoalDescEx; /* Prevent compiler warnings */\n";
		file << "    rulegoalDescEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_71 != NULL) stream_71->free(stream_71);\n";
		file << "        if (stream_72 != NULL) stream_72->free(stream_72);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_73 != NULL) stream_73->free(stream_73);\n";
		file << "        if (stream_74 != NULL) stream_74->free(stream_74);\n";
		file << "        if (stream_75 != NULL) stream_75->free(stream_75);\n";
		file << "        if (stream_76 != NULL) stream_76->free(stream_76);\n";
		file << "        if (stream_fComp != NULL) stream_fComp->free(stream_fComp);\n";
		file << "        if (stream_goalDesc != NULL) stream_goalDesc->free(stream_goalDesc);\n";
		file << "        if (stream_typedVariableList != NULL) stream_typedVariableList->free(stream_typedVariableList);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end goalDesc */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start fComp\n";
		file << " * ../../model/subgoal_learning/Pddl.g:253:1: fComp : '(' binaryComp fExp fExp ')' ;\n";
		file << " */\n";
		file << "static PddlParser_fComp_return\n";
		file << "fComp(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_fComp_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal128;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal132;\n";
		file << "    PddlParser_binaryComp_return binaryComp129;\n";
		file << "    #undef	RETURN_TYPE_binaryComp129\n";
		file << "    #define	RETURN_TYPE_binaryComp129 PddlParser_binaryComp_return\n";
		file << "\n";
		file << "    PddlParser_fExp_return fExp130;\n";
		file << "    #undef	RETURN_TYPE_fExp130\n";
		file << "    #define	RETURN_TYPE_fExp130 PddlParser_fExp_return\n";
		file << "\n";
		file << "    PddlParser_fExp_return fExp131;\n";
		file << "    #undef	RETURN_TYPE_fExp131\n";
		file << "    #define	RETURN_TYPE_fExp131 PddlParser_fExp_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal128_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal132_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal128       = NULL;\n";
		file << "    char_literal132       = NULL;\n";
		file << "    binaryComp129.tree = NULL;\n";
		file << "\n";
		file << "    fExp130.tree = NULL;\n";
		file << "\n";
		file << "    fExp131.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal128_tree   = NULL;\n";
		file << "    char_literal132_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:254:2: ( '(' binaryComp fExp fExp ')' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:254:4: '(' binaryComp fExp fExp ')'\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            char_literal128 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_fComp1424);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefCompEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            FOLLOWPUSH(FOLLOW_binaryComp_in_fComp1427);\n";
		file << "            binaryComp129=binaryComp(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefCompEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, binaryComp129.tree);\n";
		file << "            FOLLOWPUSH(FOLLOW_fExp_in_fComp1429);\n";
		file << "            fExp130=fExp(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefCompEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExp130.tree);\n";
		file << "            FOLLOWPUSH(FOLLOW_fExp_in_fComp1431);\n";
		file << "            fExp131=fExp(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefCompEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExp131.tree);\n";
		file << "            char_literal132 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_fComp1433);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefCompEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefCompEx; /* Prevent compiler warnings */\n";
		file << "    rulefCompEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end fComp */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start atomicTermFormula\n";
		file << " * ../../model/subgoal_learning/Pddl.g:257:1: atomicTermFormula : '(' predicate ( term )* ')' -> ^( PRED_HEAD predicate ( term )* ) ;\n";
		file << " */\n";
		file << "static PddlParser_atomicTermFormula_return\n";
		file << "atomicTermFormula(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_atomicTermFormula_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal133;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal136;\n";
		file << "    PddlParser_predicate_return predicate134;\n";
		file << "    #undef	RETURN_TYPE_predicate134\n";
		file << "    #define	RETURN_TYPE_predicate134 PddlParser_predicate_return\n";
		file << "\n";
		file << "    PddlParser_term_return term135;\n";
		file << "    #undef	RETURN_TYPE_term135\n";
		file << "    #define	RETURN_TYPE_term135 PddlParser_term_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal133_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal136_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_term;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_predicate;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal133       = NULL;\n";
		file << "    char_literal136       = NULL;\n";
		file << "    predicate134.tree = NULL;\n";
		file << "\n";
		file << "    term135.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal133_tree   = NULL;\n";
		file << "    char_literal136_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_term   = NULL;\n";
		file << "    #define CREATE_stream_term  if (stream_term == NULL) {stream_term = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule term\"); }\n";
		file << "    stream_predicate   = NULL;\n";
		file << "    #define CREATE_stream_predicate  if (stream_predicate == NULL) {stream_predicate = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule predicate\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:258:2: ( '(' predicate ( term )* ')' -> ^( PRED_HEAD predicate ( term )* ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:258:4: '(' predicate ( term )* ')'\n";
		file << "        {\n";
		file << "            char_literal133 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_atomicTermFormula1445);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicTermFormulaEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal133, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_predicate_in_atomicTermFormula1447);\n";
		file << "            predicate134=predicate(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicTermFormulaEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_predicate; stream_predicate->add(stream_predicate, predicate134.tree, NULL); }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:258:18: ( term )*\n";
		file << "\n";
		file << "            for (;;)\n";
		file << "            {\n";
		file << "                int alt37=2;\n";
		file << "                {\n";
		file << "                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                    */\n";
		file << "                    int LA37_0 = LA(1);\n";
		file << "                    if ( (LA37_0 == NAME || LA37_0 == VARIABLE) )\n";
		file << "                    {\n";
		file << "                        alt37=1;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                switch (alt37)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: term\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_term_in_atomicTermFormula1449);\n";
		file << "            	        term135=term(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleatomicTermFormulaEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_term; stream_term->add(stream_term, term135.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "            	default:\n";
		file << "            	    goto loop37;	/* break out of the loop */\n";
		file << "            	    break;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            loop37: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "            char_literal136 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_atomicTermFormula1452);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicTermFormulaEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal136, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : predicate, term\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 258:28: -> ^( PRED_HEAD predicate ( term )* )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:258:31: ^( PRED_HEAD predicate ( term )* )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PRED_HEAD, (pANTLR3_UINT8)\"PRED_HEAD\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_predicate == NULL ? NULL : stream_predicate->nextTree(stream_predicate));\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:258:53: ( term )*\n";
		file << "            	        {\n";
		file << "            	        	while ( (stream_term != NULL && stream_term->hasNext(stream_term))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_term == NULL ? NULL : stream_term->nextTree(stream_term));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if (stream_term != NULL) stream_term->reset(stream_term);\n";
		file << "\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleatomicTermFormulaEx; /* Prevent compiler warnings */\n";
		file << "    ruleatomicTermFormulaEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_term != NULL) stream_term->free(stream_term);\n";
		file << "        if (stream_predicate != NULL) stream_predicate->free(stream_predicate);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end atomicTermFormula */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start term\n";
		file << " * ../../model/subgoal_learning/Pddl.g:261:1: term : ( NAME | VARIABLE );\n";
		file << " */\n";
		file << "static PddlParser_term_return\n";
		file << "term(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_term_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    set137;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE set137_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    set137       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    set137_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:261:6: ( NAME | VARIABLE )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            set137=(pANTLR3_COMMON_TOKEN)LT(1);\n";
		file << "            if ( LA(1) == NAME || LA(1) == VARIABLE )\n";
		file << "            {\n";
		file << "                CONSUME();\n";
		file << "                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set137)));\n";
		file << "                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;\n";
		file << "\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "                EXCEPTION->expectingSet = &FOLLOW_set_in_term0;\n";
		file << "                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_term0);    goto ruletermEx;\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruletermEx; /* Prevent compiler warnings */\n";
		file << "    ruletermEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end term */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start durativeActionDef\n";
		file << " * ../../model/subgoal_learning/Pddl.g:263:1: durativeActionDef : '(' ':durative-action' actionSymbol ':parameters' '(' typedVariableList ')' daDefBody ')' -> ^( DURATIVE_ACTION actionSymbol typedVariableList daDefBody ) ;\n";
		file << " */\n";
		file << "static PddlParser_durativeActionDef_return\n";
		file << "durativeActionDef(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_durativeActionDef_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal138;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal139;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal141;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal142;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal144;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal146;\n";
		file << "    PddlParser_actionSymbol_return actionSymbol140;\n";
		file << "    #undef	RETURN_TYPE_actionSymbol140\n";
		file << "    #define	RETURN_TYPE_actionSymbol140 PddlParser_actionSymbol_return\n";
		file << "\n";
		file << "    PddlParser_typedVariableList_return typedVariableList143;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList143\n";
		file << "    #define	RETURN_TYPE_typedVariableList143 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_daDefBody_return daDefBody145;\n";
		file << "    #undef	RETURN_TYPE_daDefBody145\n";
		file << "    #define	RETURN_TYPE_daDefBody145 PddlParser_daDefBody_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal138_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal139_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal141_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal142_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal144_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal146_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_68;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_77;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_actionSymbol;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_daDefBody;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typedVariableList;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal138       = NULL;\n";
		file << "    string_literal139       = NULL;\n";
		file << "    string_literal141       = NULL;\n";
		file << "    char_literal142       = NULL;\n";
		file << "    char_literal144       = NULL;\n";
		file << "    char_literal146       = NULL;\n";
		file << "    actionSymbol140.tree = NULL;\n";
		file << "\n";
		file << "    typedVariableList143.tree = NULL;\n";
		file << "\n";
		file << "    daDefBody145.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal138_tree   = NULL;\n";
		file << "    string_literal139_tree   = NULL;\n";
		file << "    string_literal141_tree   = NULL;\n";
		file << "    char_literal142_tree   = NULL;\n";
		file << "    char_literal144_tree   = NULL;\n";
		file << "    char_literal146_tree   = NULL;\n";
		file << "\n";
		file << "    stream_68   = NULL;\n";
		file << "    #define CREATE_stream_68  if (stream_68 == NULL) {stream_68 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 68\"); }\n";
		file << "    stream_77   = NULL;\n";
		file << "    #define CREATE_stream_77  if (stream_77 == NULL) {stream_77 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 77\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_actionSymbol   = NULL;\n";
		file << "    #define CREATE_stream_actionSymbol  if (stream_actionSymbol == NULL) {stream_actionSymbol = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule actionSymbol\"); }\n";
		file << "    stream_daDefBody   = NULL;\n";
		file << "    #define CREATE_stream_daDefBody  if (stream_daDefBody == NULL) {stream_daDefBody = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule daDefBody\"); }\n";
		file << "    stream_typedVariableList   = NULL;\n";
		file << "    #define CREATE_stream_typedVariableList  if (stream_typedVariableList == NULL) {stream_typedVariableList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule typedVariableList\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:266:2: ( '(' ':durative-action' actionSymbol ':parameters' '(' typedVariableList ')' daDefBody ')' -> ^( DURATIVE_ACTION actionSymbol typedVariableList daDefBody ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:266:4: '(' ':durative-action' actionSymbol ':parameters' '(' typedVariableList ')' daDefBody ')'\n";
		file << "        {\n";
		file << "            char_literal138 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_durativeActionDef1490);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledurativeActionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal138, NULL); }\n";
		file << "\n";
		file << "            string_literal139 = (pANTLR3_COMMON_TOKEN) MATCHT(77, &FOLLOW_77_in_durativeActionDef1492);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledurativeActionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_77; stream_77->add(stream_77, string_literal139, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_actionSymbol_in_durativeActionDef1494);\n";
		file << "            actionSymbol140=actionSymbol(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledurativeActionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_actionSymbol; stream_actionSymbol->add(stream_actionSymbol, actionSymbol140.tree, NULL); }\n";
		file << "            string_literal141 = (pANTLR3_COMMON_TOKEN) MATCHT(68, &FOLLOW_68_in_durativeActionDef1503);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledurativeActionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_68; stream_68->add(stream_68, string_literal141, NULL); }\n";
		file << "\n";
		file << "            char_literal142 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_durativeActionDef1505);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledurativeActionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal142, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_typedVariableList_in_durativeActionDef1507);\n";
		file << "            typedVariableList143=typedVariableList(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledurativeActionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_typedVariableList; stream_typedVariableList->add(stream_typedVariableList, typedVariableList143.tree, NULL); }\n";
		file << "            char_literal144 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_durativeActionDef1509);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledurativeActionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal144, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_daDefBody_in_durativeActionDef1522);\n";
		file << "            daDefBody145=daDefBody(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledurativeActionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_daDefBody; stream_daDefBody->add(stream_daDefBody, daDefBody145.tree, NULL); }\n";
		file << "            char_literal146 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_durativeActionDef1524);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruledurativeActionDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal146, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : typedVariableList, actionSymbol, daDefBody\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 269:8: -> ^( DURATIVE_ACTION actionSymbol typedVariableList daDefBody )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:269:11: ^( DURATIVE_ACTION actionSymbol typedVariableList daDefBody )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, DURATIVE_ACTION, (pANTLR3_UINT8)\"DURATIVE_ACTION\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_actionSymbol == NULL ? NULL : stream_actionSymbol->nextTree(stream_actionSymbol));\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_typedVariableList == NULL ? NULL : stream_typedVariableList->nextTree(stream_typedVariableList));\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_daDefBody == NULL ? NULL : stream_daDefBody->nextTree(stream_daDefBody));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruledurativeActionDefEx; /* Prevent compiler warnings */\n";
		file << "    ruledurativeActionDefEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_68 != NULL) stream_68->free(stream_68);\n";
		file << "        if (stream_77 != NULL) stream_77->free(stream_77);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_actionSymbol != NULL) stream_actionSymbol->free(stream_actionSymbol);\n";
		file << "        if (stream_daDefBody != NULL) stream_daDefBody->free(stream_daDefBody);\n";
		file << "        if (stream_typedVariableList != NULL) stream_typedVariableList->free(stream_typedVariableList);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end durativeActionDef */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start daDefBody\n";
		file << " * ../../model/subgoal_learning/Pddl.g:272:1: daDefBody : ( ':duration' durationConstraint | ':condition' ( ( '(' ')' ) | daGD ) | ':effect' ( ( '(' ')' ) | daEffect ) );\n";
		file << " */\n";
		file << "static PddlParser_daDefBody_return\n";
		file << "daDefBody(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_daDefBody_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal147;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal149;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal150;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal151;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal153;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal154;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal155;\n";
		file << "    PddlParser_durationConstraint_return durationConstraint148;\n";
		file << "    #undef	RETURN_TYPE_durationConstraint148\n";
		file << "    #define	RETURN_TYPE_durationConstraint148 PddlParser_durationConstraint_return\n";
		file << "\n";
		file << "    PddlParser_daGD_return daGD152;\n";
		file << "    #undef	RETURN_TYPE_daGD152\n";
		file << "    #define	RETURN_TYPE_daGD152 PddlParser_daGD_return\n";
		file << "\n";
		file << "    PddlParser_daEffect_return daEffect156;\n";
		file << "    #undef	RETURN_TYPE_daEffect156\n";
		file << "    #define	RETURN_TYPE_daEffect156 PddlParser_daEffect_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE string_literal147_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal149_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal150_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal151_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal153_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal154_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal155_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    string_literal147       = NULL;\n";
		file << "    string_literal149       = NULL;\n";
		file << "    char_literal150       = NULL;\n";
		file << "    char_literal151       = NULL;\n";
		file << "    string_literal153       = NULL;\n";
		file << "    char_literal154       = NULL;\n";
		file << "    char_literal155       = NULL;\n";
		file << "    durationConstraint148.tree = NULL;\n";
		file << "\n";
		file << "    daGD152.tree = NULL;\n";
		file << "\n";
		file << "    daEffect156.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    string_literal147_tree   = NULL;\n";
		file << "    string_literal149_tree   = NULL;\n";
		file << "    char_literal150_tree   = NULL;\n";
		file << "    char_literal151_tree   = NULL;\n";
		file << "    string_literal153_tree   = NULL;\n";
		file << "    char_literal154_tree   = NULL;\n";
		file << "    char_literal155_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:273:2: ( ':duration' durationConstraint | ':condition' ( ( '(' ')' ) | daGD ) | ':effect' ( ( '(' ')' ) | daEffect ) )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt40;\n";
		file << "\n";
		file << "            alt40=3;\n";
		file << "\n";
		file << "            switch ( LA(1) )\n";
		file << "            {\n";
		file << "            case 78:\n";
		file << "            	{\n";
		file << "            		alt40=1;\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "            case 79:\n";
		file << "            	{\n";
		file << "            		alt40=2;\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "            case 70:\n";
		file << "            	{\n";
		file << "            		alt40=3;\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "\n";
		file << "            default:\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                EXCEPTION->message      = (void *)\"\";\n";
		file << "                EXCEPTION->decisionNum  = 40;\n";
		file << "                EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                goto ruledaDefBodyEx;\n";
		file << "            }\n";
		file << "\n";
		file << "            switch (alt40)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:273:4: ':duration' durationConstraint\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        string_literal147 = (pANTLR3_COMMON_TOKEN) MATCHT(78, &FOLLOW_78_in_daDefBody1557);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaDefBodyEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal147_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal147));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal147_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_durationConstraint_in_daDefBody1559);\n";
		file << "        	        durationConstraint148=durationConstraint(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaDefBodyEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, durationConstraint148.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:274:4: ':condition' ( ( '(' ')' ) | daGD )\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        string_literal149 = (pANTLR3_COMMON_TOKEN) MATCHT(79, &FOLLOW_79_in_daDefBody1564);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaDefBodyEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal149_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal149));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal149_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:274:17: ( ( '(' ')' ) | daGD )\n";
		file << "        	        {\n";
		file << "        	            int alt38=2;\n";
		file << "\n";
		file << "        	            {\n";
		file << "        	                int LA38_0 = LA(1);\n";
		file << "        	                if ( (LA38_0 == 54) )\n";
		file << "        	                {\n";
		file << "\n";
		file << "        	                    {\n";
		file << "        	                        int LA38_1 = LA(2);\n";
		file << "        	                        if ( (LA38_1 == 56) )\n";
		file << "        	                        {\n";
		file << "        	                            alt38=1;\n";
		file << "        	                        }\n";
		file << "        	                        else if ( (LA38_1 == 71 || LA38_1 == 76 || ((LA38_1 >= 80) && (LA38_1 <= 82))) )\n";
		file << "        	                        {\n";
		file << "        	                            alt38=2;\n";
		file << "        	                        }\n";
		file << "        	                        else\n";
		file << "        	                        {\n";
		file << "        	                            if (BACKTRACKING>0)\n";
		file << "        	                            {\n";
		file << "        	                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	                                return retval;\n";
		file << "        	                            }\n";
		file << "\n";
		file << "        	                            CONSTRUCTEX();\n";
		file << "        	                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "        	                            EXCEPTION->message      = (void *)\"\";\n";
		file << "        	                            EXCEPTION->decisionNum  = 38;\n";
		file << "        	                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "        	                            goto ruledaDefBodyEx;\n";
		file << "        	                        }\n";
		file << "        	                    }\n";
		file << "        	                }\n";
		file << "        	                else\n";
		file << "        	                {\n";
		file << "        	                    if (BACKTRACKING>0)\n";
		file << "        	                    {\n";
		file << "        	                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	                        return retval;\n";
		file << "        	                    }\n";
		file << "\n";
		file << "        	                    CONSTRUCTEX();\n";
		file << "        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "        	                    EXCEPTION->message      = (void *)\"\";\n";
		file << "        	                    EXCEPTION->decisionNum  = 38;\n";
		file << "        	                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "        	                    goto ruledaDefBodyEx;\n";
		file << "        	                }\n";
		file << "        	            }\n";
		file << "        	            switch (alt38)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:274:18: ( '(' ')' )\n";
		file << "        	        	    {\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:274:18: ( '(' ')' )\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:274:19: '(' ')'\n";
		file << "        	        	        {\n";
		file << "        	        	            char_literal150 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daDefBody1568);\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto ruledaDefBodyEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) {\n";
		file << "        	        	            char_literal150_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal150));\n";
		file << "        	        	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal150_tree);\n";
		file << "        	        	            }\n";
		file << "        	        	            char_literal151 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daDefBody1570);\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto ruledaDefBodyEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) {\n";
		file << "        	        	            char_literal151_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal151));\n";
		file << "        	        	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal151_tree);\n";
		file << "        	        	            }\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "        	        	case 2:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:274:30: daGD\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_daGD_in_daDefBody1575);\n";
		file << "        	        	        daGD152=daGD(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto ruledaDefBodyEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, daGD152.tree);\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:275:7: ':effect' ( ( '(' ')' ) | daEffect )\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        string_literal153 = (pANTLR3_COMMON_TOKEN) MATCHT(70, &FOLLOW_70_in_daDefBody1584);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaDefBodyEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal153_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal153));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal153_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:275:17: ( ( '(' ')' ) | daEffect )\n";
		file << "        	        {\n";
		file << "        	            int alt39=2;\n";
		file << "\n";
		file << "        	            {\n";
		file << "        	                int LA39_0 = LA(1);\n";
		file << "        	                if ( (LA39_0 == 54) )\n";
		file << "        	                {\n";
		file << "\n";
		file << "        	                    {\n";
		file << "        	                        int LA39_1 = LA(2);\n";
		file << "        	                        if ( (LA39_1 == 56) )\n";
		file << "        	                        {\n";
		file << "        	                            alt39=1;\n";
		file << "        	                        }\n";
		file << "        	                        else if ( (LA39_1 == 71 || LA39_1 == 76 || LA39_1 == 81 || LA39_1 == 87 || ((LA39_1 >= 96) && (LA39_1 <= 100))) )\n";
		file << "        	                        {\n";
		file << "        	                            alt39=2;\n";
		file << "        	                        }\n";
		file << "        	                        else\n";
		file << "        	                        {\n";
		file << "        	                            if (BACKTRACKING>0)\n";
		file << "        	                            {\n";
		file << "        	                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	                                return retval;\n";
		file << "        	                            }\n";
		file << "\n";
		file << "        	                            CONSTRUCTEX();\n";
		file << "        	                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "        	                            EXCEPTION->message      = (void *)\"\";\n";
		file << "        	                            EXCEPTION->decisionNum  = 39;\n";
		file << "        	                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "        	                            goto ruledaDefBodyEx;\n";
		file << "        	                        }\n";
		file << "        	                    }\n";
		file << "        	                }\n";
		file << "        	                else\n";
		file << "        	                {\n";
		file << "        	                    if (BACKTRACKING>0)\n";
		file << "        	                    {\n";
		file << "        	                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	                        return retval;\n";
		file << "        	                    }\n";
		file << "\n";
		file << "        	                    CONSTRUCTEX();\n";
		file << "        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "        	                    EXCEPTION->message      = (void *)\"\";\n";
		file << "        	                    EXCEPTION->decisionNum  = 39;\n";
		file << "        	                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "        	                    goto ruledaDefBodyEx;\n";
		file << "        	                }\n";
		file << "        	            }\n";
		file << "        	            switch (alt39)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:275:18: ( '(' ')' )\n";
		file << "        	        	    {\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:275:18: ( '(' ')' )\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:275:19: '(' ')'\n";
		file << "        	        	        {\n";
		file << "        	        	            char_literal154 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daDefBody1588);\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto ruledaDefBodyEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) {\n";
		file << "        	        	            char_literal154_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal154));\n";
		file << "        	        	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal154_tree);\n";
		file << "        	        	            }\n";
		file << "        	        	            char_literal155 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daDefBody1590);\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto ruledaDefBodyEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) {\n";
		file << "        	        	            char_literal155_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal155));\n";
		file << "        	        	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal155_tree);\n";
		file << "        	        	            }\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "        	        	case 2:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:275:30: daEffect\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_daEffect_in_daDefBody1595);\n";
		file << "        	        	        daEffect156=daEffect(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto ruledaDefBodyEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, daEffect156.tree);\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruledaDefBodyEx; /* Prevent compiler warnings */\n";
		file << "    ruledaDefBodyEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end daDefBody */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start daGD\n";
		file << " * ../../model/subgoal_learning/Pddl.g:278:1: daGD : ( prefTimedGD | '(' 'and' ( daGD )* ')' | '(' 'forall' '(' typedVariableList ')' daGD ')' );\n";
		file << " */\n";
		file << "static PddlParser_daGD_return\n";
		file << "daGD(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_daGD_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal158;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal159;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal161;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal162;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal163;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal164;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal166;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal168;\n";
		file << "    PddlParser_prefTimedGD_return prefTimedGD157;\n";
		file << "    #undef	RETURN_TYPE_prefTimedGD157\n";
		file << "    #define	RETURN_TYPE_prefTimedGD157 PddlParser_prefTimedGD_return\n";
		file << "\n";
		file << "    PddlParser_daGD_return daGD160;\n";
		file << "    #undef	RETURN_TYPE_daGD160\n";
		file << "    #define	RETURN_TYPE_daGD160 PddlParser_daGD_return\n";
		file << "\n";
		file << "    PddlParser_typedVariableList_return typedVariableList165;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList165\n";
		file << "    #define	RETURN_TYPE_typedVariableList165 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_daGD_return daGD167;\n";
		file << "    #undef	RETURN_TYPE_daGD167\n";
		file << "    #define	RETURN_TYPE_daGD167 PddlParser_daGD_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal158_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal159_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal161_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal162_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal163_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal164_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal166_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal168_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal158       = NULL;\n";
		file << "    string_literal159       = NULL;\n";
		file << "    char_literal161       = NULL;\n";
		file << "    char_literal162       = NULL;\n";
		file << "    string_literal163       = NULL;\n";
		file << "    char_literal164       = NULL;\n";
		file << "    char_literal166       = NULL;\n";
		file << "    char_literal168       = NULL;\n";
		file << "    prefTimedGD157.tree = NULL;\n";
		file << "\n";
		file << "    daGD160.tree = NULL;\n";
		file << "\n";
		file << "    typedVariableList165.tree = NULL;\n";
		file << "\n";
		file << "    daGD167.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal158_tree   = NULL;\n";
		file << "    string_literal159_tree   = NULL;\n";
		file << "    char_literal161_tree   = NULL;\n";
		file << "    char_literal162_tree   = NULL;\n";
		file << "    string_literal163_tree   = NULL;\n";
		file << "    char_literal164_tree   = NULL;\n";
		file << "    char_literal166_tree   = NULL;\n";
		file << "    char_literal168_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:279:2: ( prefTimedGD | '(' 'and' ( daGD )* ')' | '(' 'forall' '(' typedVariableList ')' daGD ')' )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt42;\n";
		file << "\n";
		file << "            alt42=3;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA42_0 = LA(1);\n";
		file << "                if ( (LA42_0 == 54) )\n";
		file << "                {\n";
		file << "                    switch ( LA(2) )\n";
		file << "                    {\n";
		file << "                    case 80:\n";
		file << "                    case 81:\n";
		file << "                    case 82:\n";
		file << "                    	{\n";
		file << "                    		alt42=1;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 71:\n";
		file << "                    	{\n";
		file << "                    		alt42=2;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 76:\n";
		file << "                    	{\n";
		file << "                    		alt42=3;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "\n";
		file << "                    default:\n";
		file << "                        if (BACKTRACKING>0)\n";
		file << "                        {\n";
		file << "                            FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                            return retval;\n";
		file << "                        }\n";
		file << "                        CONSTRUCTEX();\n";
		file << "                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                        EXCEPTION->message      = (void *)\"\";\n";
		file << "                        EXCEPTION->decisionNum  = 42;\n";
		file << "                        EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                        goto ruledaGDEx;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 42;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruledaGDEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt42)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:279:4: prefTimedGD\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_prefTimedGD_in_daGD1610);\n";
		file << "        	        prefTimedGD157=prefTimedGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, prefTimedGD157.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:280:4: '(' 'and' ( daGD )* ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal158 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daGD1615);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal158_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal158));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal158_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal159 = (pANTLR3_COMMON_TOKEN) MATCHT(71, &FOLLOW_71_in_daGD1617);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal159_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal159));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal159_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:280:14: ( daGD )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt41=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA41_0 = LA(1);\n";
		file << "        	                if ( (LA41_0 == 54) )\n";
		file << "        	                {\n";
		file << "        	                    alt41=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt41)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: daGD\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_daGD_in_daGD1619);\n";
		file << "        	        	        daGD160=daGD(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto ruledaGDEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, daGD160.tree);\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop41;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop41: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal161 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daGD1622);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal161_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal161));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal161_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:281:4: '(' 'forall' '(' typedVariableList ')' daGD ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal162 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daGD1627);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal162_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal162));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal162_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal163 = (pANTLR3_COMMON_TOKEN) MATCHT(76, &FOLLOW_76_in_daGD1629);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal163_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal163));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal163_tree);\n";
		file << "        	        }\n";
		file << "        	        char_literal164 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daGD1631);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal164_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal164));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal164_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_typedVariableList_in_daGD1633);\n";
		file << "        	        typedVariableList165=typedVariableList(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typedVariableList165.tree);\n";
		file << "        	        char_literal166 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daGD1635);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal166_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal166));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal166_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_daGD_in_daGD1637);\n";
		file << "        	        daGD167=daGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, daGD167.tree);\n";
		file << "        	        char_literal168 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daGD1639);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal168_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal168));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal168_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruledaGDEx; /* Prevent compiler warnings */\n";
		file << "    ruledaGDEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end daGD */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start prefTimedGD\n";
		file << " * ../../model/subgoal_learning/Pddl.g:284:1: prefTimedGD : ( timedGD | '(' 'preference' ( NAME )? timedGD ')' );\n";
		file << " */\n";
		file << "static PddlParser_prefTimedGD_return\n";
		file << "prefTimedGD(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_prefTimedGD_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal170;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal171;\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME172;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal174;\n";
		file << "    PddlParser_timedGD_return timedGD169;\n";
		file << "    #undef	RETURN_TYPE_timedGD169\n";
		file << "    #define	RETURN_TYPE_timedGD169 PddlParser_timedGD_return\n";
		file << "\n";
		file << "    PddlParser_timedGD_return timedGD173;\n";
		file << "    #undef	RETURN_TYPE_timedGD173\n";
		file << "    #define	RETURN_TYPE_timedGD173 PddlParser_timedGD_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal170_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal171_tree;\n";
		file << "    pANTLR3_BASE_TREE NAME172_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal174_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal170       = NULL;\n";
		file << "    string_literal171       = NULL;\n";
		file << "    NAME172       = NULL;\n";
		file << "    char_literal174       = NULL;\n";
		file << "    timedGD169.tree = NULL;\n";
		file << "\n";
		file << "    timedGD173.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal170_tree   = NULL;\n";
		file << "    string_literal171_tree   = NULL;\n";
		file << "    NAME172_tree   = NULL;\n";
		file << "    char_literal174_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:285:2: ( timedGD | '(' 'preference' ( NAME )? timedGD ')' )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt44;\n";
		file << "\n";
		file << "            alt44=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA44_0 = LA(1);\n";
		file << "                if ( (LA44_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA44_1 = LA(2);\n";
		file << "                        if ( (((LA44_1 >= 81) && (LA44_1 <= 82))) )\n";
		file << "                        {\n";
		file << "                            alt44=1;\n";
		file << "                        }\n";
		file << "                        else if ( (LA44_1 == 80) )\n";
		file << "                        {\n";
		file << "                            alt44=2;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 44;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto ruleprefTimedGDEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 44;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruleprefTimedGDEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt44)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:285:4: timedGD\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_timedGD_in_prefTimedGD1650);\n";
		file << "        	        timedGD169=timedGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefTimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, timedGD169.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:286:4: '(' 'preference' ( NAME )? timedGD ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal170 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_prefTimedGD1655);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefTimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal170_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal170));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal170_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal171 = (pANTLR3_COMMON_TOKEN) MATCHT(80, &FOLLOW_80_in_prefTimedGD1657);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefTimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal171_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal171));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal171_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:286:21: ( NAME )?\n";
		file << "        	        {\n";
		file << "        	            int alt43=2;\n";
		file << "        	            {\n";
		file << "        	                int LA43_0 = LA(1);\n";
		file << "        	                if ( (LA43_0 == NAME) )\n";
		file << "        	                {\n";
		file << "        	                    alt43=1;\n";
		file << "        	                }\n";
		file << "        	            }\n";
		file << "        	            switch (alt43)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: NAME\n";
		file << "        	        	    {\n";
		file << "        	        	        NAME172 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_prefTimedGD1659);\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto ruleprefTimedGDEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        	        NAME172_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME172));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, NAME172_tree);\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_timedGD_in_prefTimedGD1662);\n";
		file << "        	        timedGD173=timedGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefTimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, timedGD173.tree);\n";
		file << "        	        char_literal174 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_prefTimedGD1664);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefTimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal174_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal174));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal174_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleprefTimedGDEx; /* Prevent compiler warnings */\n";
		file << "    ruleprefTimedGDEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end prefTimedGD */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start timedGD\n";
		file << " * ../../model/subgoal_learning/Pddl.g:289:1: timedGD : ( '(' 'at' timeSpecifier goalDesc ')' | '(' 'over' interval goalDesc ')' );\n";
		file << " */\n";
		file << "static PddlParser_timedGD_return\n";
		file << "timedGD(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_timedGD_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal175;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal176;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal179;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal180;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal181;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal184;\n";
		file << "    PddlParser_timeSpecifier_return timeSpecifier177;\n";
		file << "    #undef	RETURN_TYPE_timeSpecifier177\n";
		file << "    #define	RETURN_TYPE_timeSpecifier177 PddlParser_timeSpecifier_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc178;\n";
		file << "    #undef	RETURN_TYPE_goalDesc178\n";
		file << "    #define	RETURN_TYPE_goalDesc178 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_interval_return interval182;\n";
		file << "    #undef	RETURN_TYPE_interval182\n";
		file << "    #define	RETURN_TYPE_interval182 PddlParser_interval_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc183;\n";
		file << "    #undef	RETURN_TYPE_goalDesc183\n";
		file << "    #define	RETURN_TYPE_goalDesc183 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal175_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal176_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal179_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal180_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal181_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal184_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal175       = NULL;\n";
		file << "    string_literal176       = NULL;\n";
		file << "    char_literal179       = NULL;\n";
		file << "    char_literal180       = NULL;\n";
		file << "    string_literal181       = NULL;\n";
		file << "    char_literal184       = NULL;\n";
		file << "    timeSpecifier177.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc178.tree = NULL;\n";
		file << "\n";
		file << "    interval182.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc183.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal175_tree   = NULL;\n";
		file << "    string_literal176_tree   = NULL;\n";
		file << "    char_literal179_tree   = NULL;\n";
		file << "    char_literal180_tree   = NULL;\n";
		file << "    string_literal181_tree   = NULL;\n";
		file << "    char_literal184_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:290:2: ( '(' 'at' timeSpecifier goalDesc ')' | '(' 'over' interval goalDesc ')' )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt45;\n";
		file << "\n";
		file << "            alt45=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA45_0 = LA(1);\n";
		file << "                if ( (LA45_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA45_1 = LA(2);\n";
		file << "                        if ( (LA45_1 == 81) )\n";
		file << "                        {\n";
		file << "                            alt45=1;\n";
		file << "                        }\n";
		file << "                        else if ( (LA45_1 == 82) )\n";
		file << "                        {\n";
		file << "                            alt45=2;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 45;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto ruletimedGDEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 45;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruletimedGDEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt45)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:290:4: '(' 'at' timeSpecifier goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal175 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_timedGD1675);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal175_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal175));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal175_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal176 = (pANTLR3_COMMON_TOKEN) MATCHT(81, &FOLLOW_81_in_timedGD1677);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal176_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal176));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal176_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_timeSpecifier_in_timedGD1679);\n";
		file << "        	        timeSpecifier177=timeSpecifier(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, timeSpecifier177.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_timedGD1681);\n";
		file << "        	        goalDesc178=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc178.tree);\n";
		file << "        	        char_literal179 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_timedGD1683);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal179_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal179));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal179_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:291:4: '(' 'over' interval goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal180 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_timedGD1688);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal180_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal180));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal180_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal181 = (pANTLR3_COMMON_TOKEN) MATCHT(82, &FOLLOW_82_in_timedGD1690);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal181_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal181));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal181_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_interval_in_timedGD1692);\n";
		file << "        	        interval182=interval(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, interval182.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_timedGD1694);\n";
		file << "        	        goalDesc183=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc183.tree);\n";
		file << "        	        char_literal184 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_timedGD1696);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal184_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal184));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal184_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruletimedGDEx; /* Prevent compiler warnings */\n";
		file << "    ruletimedGDEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end timedGD */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start timeSpecifier\n";
		file << " * ../../model/subgoal_learning/Pddl.g:294:1: timeSpecifier : ( 'start' | 'end' );\n";
		file << " */\n";
		file << "static PddlParser_timeSpecifier_return\n";
		file << "timeSpecifier(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_timeSpecifier_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    set185;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE set185_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    set185       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    set185_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:294:15: ( 'start' | 'end' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            set185=(pANTLR3_COMMON_TOKEN)LT(1);\n";
		file << "            if ( ((LA(1) >= 83) && (LA(1) <= 84)) )\n";
		file << "            {\n";
		file << "                CONSUME();\n";
		file << "                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set185)));\n";
		file << "                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;\n";
		file << "\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "                EXCEPTION->expectingSet = &FOLLOW_set_in_timeSpecifier0;\n";
		file << "                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_timeSpecifier0);    goto ruletimeSpecifierEx;\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruletimeSpecifierEx; /* Prevent compiler warnings */\n";
		file << "    ruletimeSpecifierEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end timeSpecifier */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start interval\n";
		file << " * ../../model/subgoal_learning/Pddl.g:295:1: interval : 'all' ;\n";
		file << " */\n";
		file << "static PddlParser_interval_return\n";
		file << "interval(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_interval_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal186;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE string_literal186_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    string_literal186       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    string_literal186_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:295:10: ( 'all' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:295:12: 'all'\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            string_literal186 = (pANTLR3_COMMON_TOKEN) MATCHT(85, &FOLLOW_85_in_interval1718);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleintervalEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            string_literal186_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal186));\n";
		file << "            ADAPTOR->addChild(ADAPTOR, root_0, string_literal186_tree);\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleintervalEx; /* Prevent compiler warnings */\n";
		file << "    ruleintervalEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end interval */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start derivedDef\n";
		file << " * ../../model/subgoal_learning/Pddl.g:297:1: derivedDef : '(' ':derived' typedVariableList goalDesc ')' ;\n";
		file << " */\n";
		file << "static PddlParser_derivedDef_return\n";
		file << "derivedDef(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_derivedDef_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal187;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal188;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal191;\n";
		file << "    PddlParser_typedVariableList_return typedVariableList189;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList189\n";
		file << "    #define	RETURN_TYPE_typedVariableList189 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc190;\n";
		file << "    #undef	RETURN_TYPE_goalDesc190\n";
		file << "    #define	RETURN_TYPE_goalDesc190 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal187_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal188_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal191_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal187       = NULL;\n";
		file << "    string_literal188       = NULL;\n";
		file << "    char_literal191       = NULL;\n";
		file << "    typedVariableList189.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc190.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal187_tree   = NULL;\n";
		file << "    string_literal188_tree   = NULL;\n";
		file << "    char_literal191_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:300:2: ( '(' ':derived' typedVariableList goalDesc ')' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:300:4: '(' ':derived' typedVariableList goalDesc ')'\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            char_literal187 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_derivedDef1731);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulederivedDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            string_literal188 = (pANTLR3_COMMON_TOKEN) MATCHT(86, &FOLLOW_86_in_derivedDef1734);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulederivedDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            string_literal188_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal188));\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, string_literal188_tree, root_0));\n";
		file << "            }\n";
		file << "            FOLLOWPUSH(FOLLOW_typedVariableList_in_derivedDef1737);\n";
		file << "            typedVariableList189=typedVariableList(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulederivedDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typedVariableList189.tree);\n";
		file << "            FOLLOWPUSH(FOLLOW_goalDesc_in_derivedDef1739);\n";
		file << "            goalDesc190=goalDesc(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulederivedDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc190.tree);\n";
		file << "            char_literal191 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_derivedDef1741);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulederivedDefEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulederivedDefEx; /* Prevent compiler warnings */\n";
		file << "    rulederivedDefEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end derivedDef */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start fExp\n";
		file << " * ../../model/subgoal_learning/Pddl.g:303:1: fExp : ( NUMBER | '(' binaryOp fExp fExp2 ')' -> ^( BINARY_OP binaryOp fExp fExp2 ) | '(' '-' fExp ')' -> ^( UNARY_MINUS fExp ) | fHead | VARIABLE );\n";
		file << " */\n";
		file << "static PddlParser_fExp_return\n";
		file << "fExp(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_fExp_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER192;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal193;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal197;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal198;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal199;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal201;\n";
		file << "    pANTLR3_COMMON_TOKEN    VARIABLE203;\n";
		file << "    PddlParser_binaryOp_return binaryOp194;\n";
		file << "    #undef	RETURN_TYPE_binaryOp194\n";
		file << "    #define	RETURN_TYPE_binaryOp194 PddlParser_binaryOp_return\n";
		file << "\n";
		file << "    PddlParser_fExp_return fExp195;\n";
		file << "    #undef	RETURN_TYPE_fExp195\n";
		file << "    #define	RETURN_TYPE_fExp195 PddlParser_fExp_return\n";
		file << "\n";
		file << "    PddlParser_fExp2_return fExp2196;\n";
		file << "    #undef	RETURN_TYPE_fExp2196\n";
		file << "    #define	RETURN_TYPE_fExp2196 PddlParser_fExp2_return\n";
		file << "\n";
		file << "    PddlParser_fExp_return fExp200;\n";
		file << "    #undef	RETURN_TYPE_fExp200\n";
		file << "    #define	RETURN_TYPE_fExp200 PddlParser_fExp_return\n";
		file << "\n";
		file << "    PddlParser_fHead_return fHead202;\n";
		file << "    #undef	RETURN_TYPE_fHead202\n";
		file << "    #define	RETURN_TYPE_fHead202 PddlParser_fHead_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE NUMBER192_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal193_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal197_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal198_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal199_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal201_tree;\n";
		file << "    pANTLR3_BASE_TREE VARIABLE203_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_60;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_fExp2;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_fExp;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_binaryOp;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    NUMBER192       = NULL;\n";
		file << "    char_literal193       = NULL;\n";
		file << "    char_literal197       = NULL;\n";
		file << "    char_literal198       = NULL;\n";
		file << "    char_literal199       = NULL;\n";
		file << "    char_literal201       = NULL;\n";
		file << "    VARIABLE203       = NULL;\n";
		file << "    binaryOp194.tree = NULL;\n";
		file << "\n";
		file << "    fExp195.tree = NULL;\n";
		file << "\n";
		file << "    fExp2196.tree = NULL;\n";
		file << "\n";
		file << "    fExp200.tree = NULL;\n";
		file << "\n";
		file << "    fHead202.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    NUMBER192_tree   = NULL;\n";
		file << "    char_literal193_tree   = NULL;\n";
		file << "    char_literal197_tree   = NULL;\n";
		file << "    char_literal198_tree   = NULL;\n";
		file << "    char_literal199_tree   = NULL;\n";
		file << "    char_literal201_tree   = NULL;\n";
		file << "    VARIABLE203_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_60   = NULL;\n";
		file << "    #define CREATE_stream_60  if (stream_60 == NULL) {stream_60 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 60\"); }\n";
		file << "    stream_fExp2   = NULL;\n";
		file << "    #define CREATE_stream_fExp2  if (stream_fExp2 == NULL) {stream_fExp2 = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule fExp2\"); }\n";
		file << "    stream_fExp   = NULL;\n";
		file << "    #define CREATE_stream_fExp  if (stream_fExp == NULL) {stream_fExp = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule fExp\"); }\n";
		file << "    stream_binaryOp   = NULL;\n";
		file << "    #define CREATE_stream_binaryOp  if (stream_binaryOp == NULL) {stream_binaryOp = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule binaryOp\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:306:2: ( NUMBER | '(' binaryOp fExp fExp2 ')' -> ^( BINARY_OP binaryOp fExp fExp2 ) | '(' '-' fExp ')' -> ^( UNARY_MINUS fExp ) | fHead | VARIABLE )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt46;\n";
		file << "\n";
		file << "            alt46=5;\n";
		file << "\n";
		file << "            switch ( LA(1) )\n";
		file << "            {\n";
		file << "            case NUMBER:\n";
		file << "            	{\n";
		file << "            		alt46=1;\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "            case 54:\n";
		file << "            	{\n";
		file << "\n";
		file << "            		{\n";
		file << "            		    int LA46_2 = LA(2);\n";
		file << "            		    if ( (synpred58_Pddl(ctx)) )\n";
		file << "            		    {\n";
		file << "            		        alt46=2;\n";
		file << "            		    }\n";
		file << "            		    else if ( (synpred59_Pddl(ctx)) )\n";
		file << "            		    {\n";
		file << "            		        alt46=3;\n";
		file << "            		    }\n";
		file << "            		    else if ( (synpred60_Pddl(ctx)) )\n";
		file << "            		    {\n";
		file << "            		        alt46=4;\n";
		file << "            		    }\n";
		file << "            		    else\n";
		file << "            		    {\n";
		file << "            		        if (BACKTRACKING>0)\n";
		file << "            		        {\n";
		file << "            		            FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            		            return retval;\n";
		file << "            		        }\n";
		file << "\n";
		file << "            		        CONSTRUCTEX();\n";
		file << "            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "            		        EXCEPTION->message      = (void *)\"\";\n";
		file << "            		        EXCEPTION->decisionNum  = 46;\n";
		file << "            		        EXCEPTION->state        = 2;\n";
		file << "\n";
		file << "\n";
		file << "            		        goto rulefExpEx;\n";
		file << "            		    }\n";
		file << "            		}\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "            case NAME:\n";
		file << "            	{\n";
		file << "            		alt46=4;\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "            case VARIABLE:\n";
		file << "            	{\n";
		file << "            		alt46=5;\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "\n";
		file << "            default:\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                EXCEPTION->message      = (void *)\"\";\n";
		file << "                EXCEPTION->decisionNum  = 46;\n";
		file << "                EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                goto rulefExpEx;\n";
		file << "            }\n";
		file << "\n";
		file << "            switch (alt46)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:306:4: NUMBER\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        NUMBER192 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_fExp1756);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        NUMBER192_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER192));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER192_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:307:4: '(' binaryOp fExp fExp2 ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal193 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_fExp1761);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal193, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_binaryOp_in_fExp1763);\n";
		file << "        	        binaryOp194=binaryOp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_binaryOp; stream_binaryOp->add(stream_binaryOp, binaryOp194.tree, NULL); }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fExp_in_fExp1765);\n";
		file << "        	        fExp195=fExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_fExp; stream_fExp->add(stream_fExp, fExp195.tree, NULL); }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fExp2_in_fExp1767);\n";
		file << "        	        fExp2196=fExp2(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_fExp2; stream_fExp2->add(stream_fExp2, fExp2196.tree, NULL); }\n";
		file << "        	        char_literal197 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_fExp1769);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal197, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : fExp2, fExp, binaryOp\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 307:32: -> ^( BINARY_OP binaryOp fExp fExp2 )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:307:35: ^( BINARY_OP binaryOp fExp fExp2 )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, BINARY_OP, (pANTLR3_UINT8)\"BINARY_OP\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_binaryOp == NULL ? NULL : stream_binaryOp->nextTree(stream_binaryOp));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_fExp == NULL ? NULL : stream_fExp->nextTree(stream_fExp));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_fExp2 == NULL ? NULL : stream_fExp2->nextTree(stream_fExp2));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:308:4: '(' '-' fExp ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal198 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_fExp1786);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal198, NULL); }\n";
		file << "\n";
		file << "        	        char_literal199 = (pANTLR3_COMMON_TOKEN) MATCHT(60, &FOLLOW_60_in_fExp1788);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_60; stream_60->add(stream_60, char_literal199, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fExp_in_fExp1790);\n";
		file << "        	        fExp200=fExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_fExp; stream_fExp->add(stream_fExp, fExp200.tree, NULL); }\n";
		file << "        	        char_literal201 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_fExp1792);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal201, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : fExp\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 308:21: -> ^( UNARY_MINUS fExp )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:308:24: ^( UNARY_MINUS fExp )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, UNARY_MINUS, (pANTLR3_UINT8)\"UNARY_MINUS\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_fExp == NULL ? NULL : stream_fExp->nextTree(stream_fExp));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 4:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:309:4: fHead\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fHead_in_fExp1805);\n";
		file << "        	        fHead202=fHead(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fHead202.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 5:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:310:4: VARIABLE\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        VARIABLE203 = (pANTLR3_COMMON_TOKEN) MATCHT(VARIABLE, &FOLLOW_VARIABLE_in_fExp1810);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        VARIABLE203_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, VARIABLE203));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, VARIABLE203_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefExpEx; /* Prevent compiler warnings */\n";
		file << "    rulefExpEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_60 != NULL) stream_60->free(stream_60);\n";
		file << "        if (stream_fExp2 != NULL) stream_fExp2->free(stream_fExp2);\n";
		file << "        if (stream_fExp != NULL) stream_fExp->free(stream_fExp);\n";
		file << "        if (stream_binaryOp != NULL) stream_binaryOp->free(stream_binaryOp);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end fExp */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start fExp2\n";
		file << " * ../../model/subgoal_learning/Pddl.g:315:1: fExp2 : fExp ;\n";
		file << " */\n";
		file << "static PddlParser_fExp2_return\n";
		file << "fExp2(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_fExp2_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    PddlParser_fExp_return fExp204;\n";
		file << "    #undef	RETURN_TYPE_fExp204\n";
		file << "    #define	RETURN_TYPE_fExp204 PddlParser_fExp_return\n";
		file << "\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    fExp204.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:315:7: ( fExp )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:315:9: fExp\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_fExp_in_fExp21822);\n";
		file << "            fExp204=fExp(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefExp2Ex;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExp204.tree);\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefExp2Ex; /* Prevent compiler warnings */\n";
		file << "    rulefExp2Ex: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end fExp2 */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start fHead\n";
		file << " * ../../model/subgoal_learning/Pddl.g:317:1: fHead : ( '(' functionSymbol ( term )* ')' -> ^( FUNC_HEAD functionSymbol ( term )* ) | functionSymbol -> ^( FUNC_HEAD functionSymbol ) );\n";
		file << " */\n";
		file << "static PddlParser_fHead_return\n";
		file << "fHead(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_fHead_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal205;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal208;\n";
		file << "    PddlParser_functionSymbol_return functionSymbol206;\n";
		file << "    #undef	RETURN_TYPE_functionSymbol206\n";
		file << "    #define	RETURN_TYPE_functionSymbol206 PddlParser_functionSymbol_return\n";
		file << "\n";
		file << "    PddlParser_term_return term207;\n";
		file << "    #undef	RETURN_TYPE_term207\n";
		file << "    #define	RETURN_TYPE_term207 PddlParser_term_return\n";
		file << "\n";
		file << "    PddlParser_functionSymbol_return functionSymbol209;\n";
		file << "    #undef	RETURN_TYPE_functionSymbol209\n";
		file << "    #define	RETURN_TYPE_functionSymbol209 PddlParser_functionSymbol_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal205_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal208_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_term;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_functionSymbol;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal205       = NULL;\n";
		file << "    char_literal208       = NULL;\n";
		file << "    functionSymbol206.tree = NULL;\n";
		file << "\n";
		file << "    term207.tree = NULL;\n";
		file << "\n";
		file << "    functionSymbol209.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal205_tree   = NULL;\n";
		file << "    char_literal208_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_term   = NULL;\n";
		file << "    #define CREATE_stream_term  if (stream_term == NULL) {stream_term = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule term\"); }\n";
		file << "    stream_functionSymbol   = NULL;\n";
		file << "    #define CREATE_stream_functionSymbol  if (stream_functionSymbol == NULL) {stream_functionSymbol = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule functionSymbol\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:318:2: ( '(' functionSymbol ( term )* ')' -> ^( FUNC_HEAD functionSymbol ( term )* ) | functionSymbol -> ^( FUNC_HEAD functionSymbol ) )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt48;\n";
		file << "\n";
		file << "            alt48=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA48_0 = LA(1);\n";
		file << "                if ( (LA48_0 == 54) )\n";
		file << "                {\n";
		file << "                    alt48=1;\n";
		file << "                }\n";
		file << "                else if ( (LA48_0 == NAME) )\n";
		file << "                {\n";
		file << "                    alt48=2;\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 48;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto rulefHeadEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt48)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:318:4: '(' functionSymbol ( term )* ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal205 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_fHead1832);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefHeadEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal205, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_functionSymbol_in_fHead1834);\n";
		file << "        	        functionSymbol206=functionSymbol(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefHeadEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_functionSymbol; stream_functionSymbol->add(stream_functionSymbol, functionSymbol206.tree, NULL); }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:318:23: ( term )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt47=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA47_0 = LA(1);\n";
		file << "        	                if ( (LA47_0 == NAME || LA47_0 == VARIABLE) )\n";
		file << "        	                {\n";
		file << "        	                    alt47=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt47)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: term\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_term_in_fHead1836);\n";
		file << "        	        	        term207=term(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto rulefHeadEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_term; stream_term->add(stream_term, term207.tree, NULL); }\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop47;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop47: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal208 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_fHead1839);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefHeadEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal208, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : term, functionSymbol\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 318:33: -> ^( FUNC_HEAD functionSymbol ( term )* )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:318:36: ^( FUNC_HEAD functionSymbol ( term )* )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FUNC_HEAD, (pANTLR3_UINT8)\"FUNC_HEAD\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_functionSymbol == NULL ? NULL : stream_functionSymbol->nextTree(stream_functionSymbol));\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:318:63: ( term )*\n";
		file << "        	        	        {\n";
		file << "        	        	        	while ( (stream_term != NULL && stream_term->hasNext(stream_term))  )\n";
		file << "        	        	        	{\n";
		file << "        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_term == NULL ? NULL : stream_term->nextTree(stream_term));\n";
		file << "\n";
		file << "        	        	        	}\n";
		file << "        	        	        	if (stream_term != NULL) stream_term->reset(stream_term);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:319:4: functionSymbol\n";
		file << "        	    {\n";
		file << "        	        FOLLOWPUSH(FOLLOW_functionSymbol_in_fHead1855);\n";
		file << "        	        functionSymbol209=functionSymbol(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefHeadEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_functionSymbol; stream_functionSymbol->add(stream_functionSymbol, functionSymbol209.tree, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : functionSymbol\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 319:19: -> ^( FUNC_HEAD functionSymbol )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:319:22: ^( FUNC_HEAD functionSymbol )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FUNC_HEAD, (pANTLR3_UINT8)\"FUNC_HEAD\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_functionSymbol == NULL ? NULL : stream_functionSymbol->nextTree(stream_functionSymbol));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefHeadEx; /* Prevent compiler warnings */\n";
		file << "    rulefHeadEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_term != NULL) stream_term->free(stream_term);\n";
		file << "        if (stream_functionSymbol != NULL) stream_functionSymbol->free(stream_functionSymbol);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end fHead */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start effect\n";
		file << " * ../../model/subgoal_learning/Pddl.g:322:1: effect : ( '(' 'and' ( cEffect )* ')' -> ^( AND_EFFECT ( cEffect )* ) | cEffect );\n";
		file << " */\n";
		file << "static PddlParser_effect_return\n";
		file << "effect(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_effect_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal210;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal211;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal213;\n";
		file << "    PddlParser_cEffect_return cEffect212;\n";
		file << "    #undef	RETURN_TYPE_cEffect212\n";
		file << "    #define	RETURN_TYPE_cEffect212 PddlParser_cEffect_return\n";
		file << "\n";
		file << "    PddlParser_cEffect_return cEffect214;\n";
		file << "    #undef	RETURN_TYPE_cEffect214\n";
		file << "    #define	RETURN_TYPE_cEffect214 PddlParser_cEffect_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal210_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal211_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal213_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_71;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_cEffect;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal210       = NULL;\n";
		file << "    string_literal211       = NULL;\n";
		file << "    char_literal213       = NULL;\n";
		file << "    cEffect212.tree = NULL;\n";
		file << "\n";
		file << "    cEffect214.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal210_tree   = NULL;\n";
		file << "    string_literal211_tree   = NULL;\n";
		file << "    char_literal213_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_71   = NULL;\n";
		file << "    #define CREATE_stream_71  if (stream_71 == NULL) {stream_71 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 71\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_cEffect   = NULL;\n";
		file << "    #define CREATE_stream_cEffect  if (stream_cEffect == NULL) {stream_cEffect = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule cEffect\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:323:2: ( '(' 'and' ( cEffect )* ')' -> ^( AND_EFFECT ( cEffect )* ) | cEffect )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt50;\n";
		file << "\n";
		file << "            alt50=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA50_0 = LA(1);\n";
		file << "                if ( (LA50_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA50_1 = LA(2);\n";
		file << "                        if ( (LA50_1 == 71) )\n";
		file << "                        {\n";
		file << "                            alt50=1;\n";
		file << "                        }\n";
		file << "                        else if ( (LA50_1 == NAME || LA50_1 == 73 || LA50_1 == 76 || LA50_1 == 87 || ((LA50_1 >= 96) && (LA50_1 <= 100))) )\n";
		file << "                        {\n";
		file << "                            alt50=2;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 50;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto ruleeffectEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 50;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruleeffectEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt50)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:323:4: '(' 'and' ( cEffect )* ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal210 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_effect1874);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleeffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal210, NULL); }\n";
		file << "\n";
		file << "        	        string_literal211 = (pANTLR3_COMMON_TOKEN) MATCHT(71, &FOLLOW_71_in_effect1876);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleeffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_71; stream_71->add(stream_71, string_literal211, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:323:14: ( cEffect )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt49=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA49_0 = LA(1);\n";
		file << "        	                if ( (LA49_0 == 54) )\n";
		file << "        	                {\n";
		file << "        	                    alt49=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt49)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: cEffect\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_cEffect_in_effect1878);\n";
		file << "        	        	        cEffect212=cEffect(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto ruleeffectEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_cEffect; stream_cEffect->add(stream_cEffect, cEffect212.tree, NULL); }\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop49;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop49: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal213 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_effect1881);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleeffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal213, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : cEffect\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 323:27: -> ^( AND_EFFECT ( cEffect )* )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:323:30: ^( AND_EFFECT ( cEffect )* )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, AND_EFFECT, (pANTLR3_UINT8)\"AND_EFFECT\"), root_1));\n";
		file << "\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:323:43: ( cEffect )*\n";
		file << "        	        	        {\n";
		file << "        	        	        	while ( (stream_cEffect != NULL && stream_cEffect->hasNext(stream_cEffect))  )\n";
		file << "        	        	        	{\n";
		file << "        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_cEffect == NULL ? NULL : stream_cEffect->nextTree(stream_cEffect));\n";
		file << "\n";
		file << "        	        	        	}\n";
		file << "        	        	        	if (stream_cEffect != NULL) stream_cEffect->reset(stream_cEffect);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:324:4: cEffect\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_cEffect_in_effect1895);\n";
		file << "        	        cEffect214=cEffect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleeffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, cEffect214.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleeffectEx; /* Prevent compiler warnings */\n";
		file << "    ruleeffectEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_71 != NULL) stream_71->free(stream_71);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_cEffect != NULL) stream_cEffect->free(stream_cEffect);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end effect */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start cEffect\n";
		file << " * ../../model/subgoal_learning/Pddl.g:327:1: cEffect : ( '(' 'forall' '(' typedVariableList ')' effect ')' -> ^( FORALL_EFFECT typedVariableList effect ) | '(' 'when' goalDesc condEffect ')' -> ^( WHEN_EFFECT goalDesc condEffect ) | pEffect );\n";
		file << " */\n";
		file << "static PddlParser_cEffect_return\n";
		file << "cEffect(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_cEffect_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal215;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal216;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal217;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal219;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal221;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal222;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal223;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal226;\n";
		file << "    PddlParser_typedVariableList_return typedVariableList218;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList218\n";
		file << "    #define	RETURN_TYPE_typedVariableList218 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_effect_return effect220;\n";
		file << "    #undef	RETURN_TYPE_effect220\n";
		file << "    #define	RETURN_TYPE_effect220 PddlParser_effect_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc224;\n";
		file << "    #undef	RETURN_TYPE_goalDesc224\n";
		file << "    #define	RETURN_TYPE_goalDesc224 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_condEffect_return condEffect225;\n";
		file << "    #undef	RETURN_TYPE_condEffect225\n";
		file << "    #define	RETURN_TYPE_condEffect225 PddlParser_condEffect_return\n";
		file << "\n";
		file << "    PddlParser_pEffect_return pEffect227;\n";
		file << "    #undef	RETURN_TYPE_pEffect227\n";
		file << "    #define	RETURN_TYPE_pEffect227 PddlParser_pEffect_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal215_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal216_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal217_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal219_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal221_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal222_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal223_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal226_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_87;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_76;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_effect;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_condEffect;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_goalDesc;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typedVariableList;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal215       = NULL;\n";
		file << "    string_literal216       = NULL;\n";
		file << "    char_literal217       = NULL;\n";
		file << "    char_literal219       = NULL;\n";
		file << "    char_literal221       = NULL;\n";
		file << "    char_literal222       = NULL;\n";
		file << "    string_literal223       = NULL;\n";
		file << "    char_literal226       = NULL;\n";
		file << "    typedVariableList218.tree = NULL;\n";
		file << "\n";
		file << "    effect220.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc224.tree = NULL;\n";
		file << "\n";
		file << "    condEffect225.tree = NULL;\n";
		file << "\n";
		file << "    pEffect227.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal215_tree   = NULL;\n";
		file << "    string_literal216_tree   = NULL;\n";
		file << "    char_literal217_tree   = NULL;\n";
		file << "    char_literal219_tree   = NULL;\n";
		file << "    char_literal221_tree   = NULL;\n";
		file << "    char_literal222_tree   = NULL;\n";
		file << "    string_literal223_tree   = NULL;\n";
		file << "    char_literal226_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_87   = NULL;\n";
		file << "    #define CREATE_stream_87  if (stream_87 == NULL) {stream_87 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 87\"); }\n";
		file << "    stream_76   = NULL;\n";
		file << "    #define CREATE_stream_76  if (stream_76 == NULL) {stream_76 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 76\"); }\n";
		file << "    stream_effect   = NULL;\n";
		file << "    #define CREATE_stream_effect  if (stream_effect == NULL) {stream_effect = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule effect\"); }\n";
		file << "    stream_condEffect   = NULL;\n";
		file << "    #define CREATE_stream_condEffect  if (stream_condEffect == NULL) {stream_condEffect = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule condEffect\"); }\n";
		file << "    stream_goalDesc   = NULL;\n";
		file << "    #define CREATE_stream_goalDesc  if (stream_goalDesc == NULL) {stream_goalDesc = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule goalDesc\"); }\n";
		file << "    stream_typedVariableList   = NULL;\n";
		file << "    #define CREATE_stream_typedVariableList  if (stream_typedVariableList == NULL) {stream_typedVariableList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule typedVariableList\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:328:2: ( '(' 'forall' '(' typedVariableList ')' effect ')' -> ^( FORALL_EFFECT typedVariableList effect ) | '(' 'when' goalDesc condEffect ')' -> ^( WHEN_EFFECT goalDesc condEffect ) | pEffect )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt51;\n";
		file << "\n";
		file << "            alt51=3;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA51_0 = LA(1);\n";
		file << "                if ( (LA51_0 == 54) )\n";
		file << "                {\n";
		file << "                    switch ( LA(2) )\n";
		file << "                    {\n";
		file << "                    case 76:\n";
		file << "                    	{\n";
		file << "                    		alt51=1;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 87:\n";
		file << "                    	{\n";
		file << "                    		alt51=2;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case NAME:\n";
		file << "                    case 73:\n";
		file << "                    case 96:\n";
		file << "                    case 97:\n";
		file << "                    case 98:\n";
		file << "                    case 99:\n";
		file << "                    case 100:\n";
		file << "                    	{\n";
		file << "                    		alt51=3;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "\n";
		file << "                    default:\n";
		file << "                        if (BACKTRACKING>0)\n";
		file << "                        {\n";
		file << "                            FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                            return retval;\n";
		file << "                        }\n";
		file << "                        CONSTRUCTEX();\n";
		file << "                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                        EXCEPTION->message      = (void *)\"\";\n";
		file << "                        EXCEPTION->decisionNum  = 51;\n";
		file << "                        EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                        goto rulecEffectEx;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 51;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto rulecEffectEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt51)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:328:4: '(' 'forall' '(' typedVariableList ')' effect ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal215 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_cEffect1906);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal215, NULL); }\n";
		file << "\n";
		file << "        	        string_literal216 = (pANTLR3_COMMON_TOKEN) MATCHT(76, &FOLLOW_76_in_cEffect1908);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_76; stream_76->add(stream_76, string_literal216, NULL); }\n";
		file << "\n";
		file << "        	        char_literal217 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_cEffect1910);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal217, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_typedVariableList_in_cEffect1912);\n";
		file << "        	        typedVariableList218=typedVariableList(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_typedVariableList; stream_typedVariableList->add(stream_typedVariableList, typedVariableList218.tree, NULL); }\n";
		file << "        	        char_literal219 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_cEffect1914);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal219, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_effect_in_cEffect1916);\n";
		file << "        	        effect220=effect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_effect; stream_effect->add(stream_effect, effect220.tree, NULL); }\n";
		file << "        	        char_literal221 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_cEffect1918);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal221, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : typedVariableList, effect\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 329:4: -> ^( FORALL_EFFECT typedVariableList effect )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:329:7: ^( FORALL_EFFECT typedVariableList effect )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, FORALL_EFFECT, (pANTLR3_UINT8)\"FORALL_EFFECT\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_typedVariableList == NULL ? NULL : stream_typedVariableList->nextTree(stream_typedVariableList));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_effect == NULL ? NULL : stream_effect->nextTree(stream_effect));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:330:4: '(' 'when' goalDesc condEffect ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal222 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_cEffect1936);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal222, NULL); }\n";
		file << "\n";
		file << "        	        string_literal223 = (pANTLR3_COMMON_TOKEN) MATCHT(87, &FOLLOW_87_in_cEffect1938);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_87; stream_87->add(stream_87, string_literal223, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_cEffect1940);\n";
		file << "        	        goalDesc224=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc224.tree, NULL); }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_condEffect_in_cEffect1942);\n";
		file << "        	        condEffect225=condEffect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_condEffect; stream_condEffect->add(stream_condEffect, condEffect225.tree, NULL); }\n";
		file << "        	        char_literal226 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_cEffect1944);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal226, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : goalDesc, condEffect\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 331:4: -> ^( WHEN_EFFECT goalDesc condEffect )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:331:7: ^( WHEN_EFFECT goalDesc condEffect )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, WHEN_EFFECT, (pANTLR3_UINT8)\"WHEN_EFFECT\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_condEffect == NULL ? NULL : stream_condEffect->nextTree(stream_condEffect));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:332:4: pEffect\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_pEffect_in_cEffect1962);\n";
		file << "        	        pEffect227=pEffect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, pEffect227.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulecEffectEx; /* Prevent compiler warnings */\n";
		file << "    rulecEffectEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_87 != NULL) stream_87->free(stream_87);\n";
		file << "        if (stream_76 != NULL) stream_76->free(stream_76);\n";
		file << "        if (stream_effect != NULL) stream_effect->free(stream_effect);\n";
		file << "        if (stream_condEffect != NULL) stream_condEffect->free(stream_condEffect);\n";
		file << "        if (stream_goalDesc != NULL) stream_goalDesc->free(stream_goalDesc);\n";
		file << "        if (stream_typedVariableList != NULL) stream_typedVariableList->free(stream_typedVariableList);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end cEffect */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start pEffect\n";
		file << " * ../../model/subgoal_learning/Pddl.g:335:1: pEffect : ( '(' assignOp fHead fExp ')' -> ^( ASSIGN_EFFECT assignOp fHead fExp ) | '(' 'not' atomicTermFormula ')' -> ^( NOT_EFFECT atomicTermFormula ) | atomicTermFormula );\n";
		file << " */\n";
		file << "static PddlParser_pEffect_return\n";
		file << "pEffect(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_pEffect_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal228;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal232;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal233;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal234;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal236;\n";
		file << "    PddlParser_assignOp_return assignOp229;\n";
		file << "    #undef	RETURN_TYPE_assignOp229\n";
		file << "    #define	RETURN_TYPE_assignOp229 PddlParser_assignOp_return\n";
		file << "\n";
		file << "    PddlParser_fHead_return fHead230;\n";
		file << "    #undef	RETURN_TYPE_fHead230\n";
		file << "    #define	RETURN_TYPE_fHead230 PddlParser_fHead_return\n";
		file << "\n";
		file << "    PddlParser_fExp_return fExp231;\n";
		file << "    #undef	RETURN_TYPE_fExp231\n";
		file << "    #define	RETURN_TYPE_fExp231 PddlParser_fExp_return\n";
		file << "\n";
		file << "    PddlParser_atomicTermFormula_return atomicTermFormula235;\n";
		file << "    #undef	RETURN_TYPE_atomicTermFormula235\n";
		file << "    #define	RETURN_TYPE_atomicTermFormula235 PddlParser_atomicTermFormula_return\n";
		file << "\n";
		file << "    PddlParser_atomicTermFormula_return atomicTermFormula237;\n";
		file << "    #undef	RETURN_TYPE_atomicTermFormula237\n";
		file << "    #define	RETURN_TYPE_atomicTermFormula237 PddlParser_atomicTermFormula_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal228_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal232_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal233_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal234_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal236_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_73;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_fHead;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_assignOp;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_atomicTermFormula;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_fExp;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal228       = NULL;\n";
		file << "    char_literal232       = NULL;\n";
		file << "    char_literal233       = NULL;\n";
		file << "    string_literal234       = NULL;\n";
		file << "    char_literal236       = NULL;\n";
		file << "    assignOp229.tree = NULL;\n";
		file << "\n";
		file << "    fHead230.tree = NULL;\n";
		file << "\n";
		file << "    fExp231.tree = NULL;\n";
		file << "\n";
		file << "    atomicTermFormula235.tree = NULL;\n";
		file << "\n";
		file << "    atomicTermFormula237.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal228_tree   = NULL;\n";
		file << "    char_literal232_tree   = NULL;\n";
		file << "    char_literal233_tree   = NULL;\n";
		file << "    string_literal234_tree   = NULL;\n";
		file << "    char_literal236_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_73   = NULL;\n";
		file << "    #define CREATE_stream_73  if (stream_73 == NULL) {stream_73 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 73\"); }\n";
		file << "    stream_fHead   = NULL;\n";
		file << "    #define CREATE_stream_fHead  if (stream_fHead == NULL) {stream_fHead = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule fHead\"); }\n";
		file << "    stream_assignOp   = NULL;\n";
		file << "    #define CREATE_stream_assignOp  if (stream_assignOp == NULL) {stream_assignOp = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule assignOp\"); }\n";
		file << "    stream_atomicTermFormula   = NULL;\n";
		file << "    #define CREATE_stream_atomicTermFormula  if (stream_atomicTermFormula == NULL) {stream_atomicTermFormula = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule atomicTermFormula\"); }\n";
		file << "    stream_fExp   = NULL;\n";
		file << "    #define CREATE_stream_fExp  if (stream_fExp == NULL) {stream_fExp = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule fExp\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:336:2: ( '(' assignOp fHead fExp ')' -> ^( ASSIGN_EFFECT assignOp fHead fExp ) | '(' 'not' atomicTermFormula ')' -> ^( NOT_EFFECT atomicTermFormula ) | atomicTermFormula )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt52;\n";
		file << "\n";
		file << "            alt52=3;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA52_0 = LA(1);\n";
		file << "                if ( (LA52_0 == 54) )\n";
		file << "                {\n";
		file << "                    switch ( LA(2) )\n";
		file << "                    {\n";
		file << "                    case 73:\n";
		file << "                    	{\n";
		file << "                    		alt52=2;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case NAME:\n";
		file << "                    	{\n";
		file << "                    		alt52=3;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 96:\n";
		file << "                    case 97:\n";
		file << "                    case 98:\n";
		file << "                    case 99:\n";
		file << "                    case 100:\n";
		file << "                    	{\n";
		file << "                    		alt52=1;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "\n";
		file << "                    default:\n";
		file << "                        if (BACKTRACKING>0)\n";
		file << "                        {\n";
		file << "                            FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                            return retval;\n";
		file << "                        }\n";
		file << "                        CONSTRUCTEX();\n";
		file << "                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                        EXCEPTION->message      = (void *)\"\";\n";
		file << "                        EXCEPTION->decisionNum  = 52;\n";
		file << "                        EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                        goto rulepEffectEx;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 52;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto rulepEffectEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt52)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:336:4: '(' assignOp fHead fExp ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal228 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_pEffect1973);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal228, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_assignOp_in_pEffect1975);\n";
		file << "        	        assignOp229=assignOp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_assignOp; stream_assignOp->add(stream_assignOp, assignOp229.tree, NULL); }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fHead_in_pEffect1977);\n";
		file << "        	        fHead230=fHead(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_fHead; stream_fHead->add(stream_fHead, fHead230.tree, NULL); }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fExp_in_pEffect1979);\n";
		file << "        	        fExp231=fExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_fExp; stream_fExp->add(stream_fExp, fExp231.tree, NULL); }\n";
		file << "        	        char_literal232 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_pEffect1981);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal232, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : fHead, fExp, assignOp\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 337:4: -> ^( ASSIGN_EFFECT assignOp fHead fExp )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:337:7: ^( ASSIGN_EFFECT assignOp fHead fExp )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, ASSIGN_EFFECT, (pANTLR3_UINT8)\"ASSIGN_EFFECT\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_assignOp == NULL ? NULL : stream_assignOp->nextTree(stream_assignOp));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_fHead == NULL ? NULL : stream_fHead->nextTree(stream_fHead));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_fExp == NULL ? NULL : stream_fExp->nextTree(stream_fExp));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:338:4: '(' 'not' atomicTermFormula ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal233 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_pEffect2001);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal233, NULL); }\n";
		file << "\n";
		file << "        	        string_literal234 = (pANTLR3_COMMON_TOKEN) MATCHT(73, &FOLLOW_73_in_pEffect2003);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_73; stream_73->add(stream_73, string_literal234, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_atomicTermFormula_in_pEffect2005);\n";
		file << "        	        atomicTermFormula235=atomicTermFormula(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_atomicTermFormula; stream_atomicTermFormula->add(stream_atomicTermFormula, atomicTermFormula235.tree, NULL); }\n";
		file << "        	        char_literal236 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_pEffect2007);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal236, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : atomicTermFormula\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 339:4: -> ^( NOT_EFFECT atomicTermFormula )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:339:7: ^( NOT_EFFECT atomicTermFormula )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NOT_EFFECT, (pANTLR3_UINT8)\"NOT_EFFECT\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_atomicTermFormula == NULL ? NULL : stream_atomicTermFormula->nextTree(stream_atomicTermFormula));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:340:4: atomicTermFormula\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_atomicTermFormula_in_pEffect2023);\n";
		file << "        	        atomicTermFormula237=atomicTermFormula(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulepEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, atomicTermFormula237.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulepEffectEx; /* Prevent compiler warnings */\n";
		file << "    rulepEffectEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_73 != NULL) stream_73->free(stream_73);\n";
		file << "        if (stream_fHead != NULL) stream_fHead->free(stream_fHead);\n";
		file << "        if (stream_assignOp != NULL) stream_assignOp->free(stream_assignOp);\n";
		file << "        if (stream_atomicTermFormula != NULL) stream_atomicTermFormula->free(stream_atomicTermFormula);\n";
		file << "        if (stream_fExp != NULL) stream_fExp->free(stream_fExp);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end pEffect */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start condEffect\n";
		file << " * ../../model/subgoal_learning/Pddl.g:345:1: condEffect : ( '(' 'and' ( pEffect )* ')' -> ^( AND_EFFECT ( pEffect )* ) | pEffect );\n";
		file << " */\n";
		file << "static PddlParser_condEffect_return\n";
		file << "condEffect(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_condEffect_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal238;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal239;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal241;\n";
		file << "    PddlParser_pEffect_return pEffect240;\n";
		file << "    #undef	RETURN_TYPE_pEffect240\n";
		file << "    #define	RETURN_TYPE_pEffect240 PddlParser_pEffect_return\n";
		file << "\n";
		file << "    PddlParser_pEffect_return pEffect242;\n";
		file << "    #undef	RETURN_TYPE_pEffect242\n";
		file << "    #define	RETURN_TYPE_pEffect242 PddlParser_pEffect_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal238_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal239_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal241_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_71;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_pEffect;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal238       = NULL;\n";
		file << "    string_literal239       = NULL;\n";
		file << "    char_literal241       = NULL;\n";
		file << "    pEffect240.tree = NULL;\n";
		file << "\n";
		file << "    pEffect242.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal238_tree   = NULL;\n";
		file << "    string_literal239_tree   = NULL;\n";
		file << "    char_literal241_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_71   = NULL;\n";
		file << "    #define CREATE_stream_71  if (stream_71 == NULL) {stream_71 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 71\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_pEffect   = NULL;\n";
		file << "    #define CREATE_stream_pEffect  if (stream_pEffect == NULL) {stream_pEffect = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule pEffect\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:346:2: ( '(' 'and' ( pEffect )* ')' -> ^( AND_EFFECT ( pEffect )* ) | pEffect )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt54;\n";
		file << "\n";
		file << "            alt54=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA54_0 = LA(1);\n";
		file << "                if ( (LA54_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA54_1 = LA(2);\n";
		file << "                        if ( (LA54_1 == 71) )\n";
		file << "                        {\n";
		file << "                            alt54=1;\n";
		file << "                        }\n";
		file << "                        else if ( (LA54_1 == NAME || LA54_1 == 73 || ((LA54_1 >= 96) && (LA54_1 <= 100))) )\n";
		file << "                        {\n";
		file << "                            alt54=2;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 54;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto rulecondEffectEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 54;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto rulecondEffectEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt54)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:346:4: '(' 'and' ( pEffect )* ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal238 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_condEffect2036);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecondEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal238, NULL); }\n";
		file << "\n";
		file << "        	        string_literal239 = (pANTLR3_COMMON_TOKEN) MATCHT(71, &FOLLOW_71_in_condEffect2038);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecondEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_71; stream_71->add(stream_71, string_literal239, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:346:14: ( pEffect )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt53=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA53_0 = LA(1);\n";
		file << "        	                if ( (LA53_0 == 54) )\n";
		file << "        	                {\n";
		file << "        	                    alt53=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt53)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: pEffect\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_pEffect_in_condEffect2040);\n";
		file << "        	        	        pEffect240=pEffect(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto rulecondEffectEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) { CREATE_stream_pEffect; stream_pEffect->add(stream_pEffect, pEffect240.tree, NULL); }\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop53;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop53: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal241 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_condEffect2043);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecondEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal241, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : pEffect\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 346:27: -> ^( AND_EFFECT ( pEffect )* )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:346:30: ^( AND_EFFECT ( pEffect )* )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, AND_EFFECT, (pANTLR3_UINT8)\"AND_EFFECT\"), root_1));\n";
		file << "\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:346:43: ( pEffect )*\n";
		file << "        	        	        {\n";
		file << "        	        	        	while ( (stream_pEffect != NULL && stream_pEffect->hasNext(stream_pEffect))  )\n";
		file << "        	        	        	{\n";
		file << "        	        	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_pEffect == NULL ? NULL : stream_pEffect->nextTree(stream_pEffect));\n";
		file << "\n";
		file << "        	        	        	}\n";
		file << "        	        	        	if (stream_pEffect != NULL) stream_pEffect->reset(stream_pEffect);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:347:4: pEffect\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_pEffect_in_condEffect2057);\n";
		file << "        	        pEffect242=pEffect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulecondEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, pEffect242.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulecondEffectEx; /* Prevent compiler warnings */\n";
		file << "    rulecondEffectEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_71 != NULL) stream_71->free(stream_71);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_pEffect != NULL) stream_pEffect->free(stream_pEffect);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end condEffect */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start binaryOp\n";
		file << " * ../../model/subgoal_learning/Pddl.g:351:1: binaryOp : ( '*' | '+' | '-' | '/' );\n";
		file << " */\n";
		file << "static PddlParser_binaryOp_return\n";
		file << "binaryOp(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_binaryOp_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    set243;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE set243_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    set243       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    set243_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:351:10: ( '*' | '+' | '-' | '/' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            set243=(pANTLR3_COMMON_TOKEN)LT(1);\n";
		file << "            if ( LA(1) == 60 || ((LA(1) >= 88) && (LA(1) <= 90)) )\n";
		file << "            {\n";
		file << "                CONSUME();\n";
		file << "                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set243)));\n";
		file << "                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;\n";
		file << "\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "                EXCEPTION->expectingSet = &FOLLOW_set_in_binaryOp0;\n";
		file << "                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_binaryOp0);    goto rulebinaryOpEx;\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulebinaryOpEx; /* Prevent compiler warnings */\n";
		file << "    rulebinaryOpEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end binaryOp */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start binaryComp\n";
		file << " * ../../model/subgoal_learning/Pddl.g:353:1: binaryComp : ( '>' | '<' | '=' | '>=' | '<=' );\n";
		file << " */\n";
		file << "static PddlParser_binaryComp_return\n";
		file << "binaryComp(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_binaryComp_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    set244;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE set244_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    set244       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    set244_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:353:12: ( '>' | '<' | '=' | '>=' | '<=' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            set244=(pANTLR3_COMMON_TOKEN)LT(1);\n";
		file << "            if ( ((LA(1) >= 91) && (LA(1) <= 95)) )\n";
		file << "            {\n";
		file << "                CONSUME();\n";
		file << "                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set244)));\n";
		file << "                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;\n";
		file << "\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "                EXCEPTION->expectingSet = &FOLLOW_set_in_binaryComp0;\n";
		file << "                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_binaryComp0);    goto rulebinaryCompEx;\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulebinaryCompEx; /* Prevent compiler warnings */\n";
		file << "    rulebinaryCompEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end binaryComp */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start assignOp\n";
		file << " * ../../model/subgoal_learning/Pddl.g:355:1: assignOp : ( 'assign' | 'scale-up' | 'scale-down' | 'increase' | 'decrease' );\n";
		file << " */\n";
		file << "static PddlParser_assignOp_return\n";
		file << "assignOp(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_assignOp_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    set245;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE set245_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    set245       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    set245_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:355:10: ( 'assign' | 'scale-up' | 'scale-down' | 'increase' | 'decrease' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            set245=(pANTLR3_COMMON_TOKEN)LT(1);\n";
		file << "            if ( ((LA(1) >= 96) && (LA(1) <= 100)) )\n";
		file << "            {\n";
		file << "                CONSUME();\n";
		file << "                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set245)));\n";
		file << "                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;\n";
		file << "\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "                EXCEPTION->expectingSet = &FOLLOW_set_in_assignOp0;\n";
		file << "                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_assignOp0);    goto ruleassignOpEx;\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleassignOpEx; /* Prevent compiler warnings */\n";
		file << "    ruleassignOpEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end assignOp */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start durationConstraint\n";
		file << " * ../../model/subgoal_learning/Pddl.g:358:1: durationConstraint : ( '(' 'and' ( simpleDurationConstraint )+ ')' | '(' ')' | simpleDurationConstraint );\n";
		file << " */\n";
		file << "static PddlParser_durationConstraint_return\n";
		file << "durationConstraint(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_durationConstraint_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal246;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal247;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal249;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal250;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal251;\n";
		file << "    PddlParser_simpleDurationConstraint_return simpleDurationConstraint248;\n";
		file << "    #undef	RETURN_TYPE_simpleDurationConstraint248\n";
		file << "    #define	RETURN_TYPE_simpleDurationConstraint248 PddlParser_simpleDurationConstraint_return\n";
		file << "\n";
		file << "    PddlParser_simpleDurationConstraint_return simpleDurationConstraint252;\n";
		file << "    #undef	RETURN_TYPE_simpleDurationConstraint252\n";
		file << "    #define	RETURN_TYPE_simpleDurationConstraint252 PddlParser_simpleDurationConstraint_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal246_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal247_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal249_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal250_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal251_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal246       = NULL;\n";
		file << "    string_literal247       = NULL;\n";
		file << "    char_literal249       = NULL;\n";
		file << "    char_literal250       = NULL;\n";
		file << "    char_literal251       = NULL;\n";
		file << "    simpleDurationConstraint248.tree = NULL;\n";
		file << "\n";
		file << "    simpleDurationConstraint252.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal246_tree   = NULL;\n";
		file << "    string_literal247_tree   = NULL;\n";
		file << "    char_literal249_tree   = NULL;\n";
		file << "    char_literal250_tree   = NULL;\n";
		file << "    char_literal251_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:361:2: ( '(' 'and' ( simpleDurationConstraint )+ ')' | '(' ')' | simpleDurationConstraint )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt56;\n";
		file << "\n";
		file << "            alt56=3;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA56_0 = LA(1);\n";
		file << "                if ( (LA56_0 == 54) )\n";
		file << "                {\n";
		file << "                    switch ( LA(2) )\n";
		file << "                    {\n";
		file << "                    case 71:\n";
		file << "                    	{\n";
		file << "                    		alt56=1;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 56:\n";
		file << "                    	{\n";
		file << "                    		alt56=2;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 81:\n";
		file << "                    case 93:\n";
		file << "                    case 94:\n";
		file << "                    case 95:\n";
		file << "                    	{\n";
		file << "                    		alt56=3;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "\n";
		file << "                    default:\n";
		file << "                        if (BACKTRACKING>0)\n";
		file << "                        {\n";
		file << "                            FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                            return retval;\n";
		file << "                        }\n";
		file << "                        CONSTRUCTEX();\n";
		file << "                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                        EXCEPTION->message      = (void *)\"\";\n";
		file << "                        EXCEPTION->decisionNum  = 56;\n";
		file << "                        EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                        goto ruledurationConstraintEx;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 56;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruledurationConstraintEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt56)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:361:4: '(' 'and' ( simpleDurationConstraint )+ ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal246 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_durationConstraint2144);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal246_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal246));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal246_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal247 = (pANTLR3_COMMON_TOKEN) MATCHT(71, &FOLLOW_71_in_durationConstraint2146);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal247_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal247));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal247_tree);\n";
		file << "        	        }\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:361:14: ( simpleDurationConstraint )+\n";
		file << "        	        {\n";
		file << "        	            int cnt55=0;\n";
		file << "\n";
		file << "        	            for (;;)\n";
		file << "        	            {\n";
		file << "        	                int alt55=2;\n";
		file << "        	        	{\n";
		file << "        	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	        	    */\n";
		file << "        	        	    int LA55_0 = LA(1);\n";
		file << "        	        	    if ( (LA55_0 == 54) )\n";
		file << "        	        	    {\n";
		file << "        	        	        alt55=1;\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "        	        	switch (alt55)\n";
		file << "        	        	{\n";
		file << "        	        	    case 1:\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:0:0: simpleDurationConstraint\n";
		file << "        	        	        {\n";
		file << "        	        	            FOLLOWPUSH(FOLLOW_simpleDurationConstraint_in_durationConstraint2148);\n";
		file << "        	        	            simpleDurationConstraint248=simpleDurationConstraint(ctx);\n";
		file << "\n";
		file << "        	        	            FOLLOWPOP();\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto ruledurationConstraintEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, simpleDurationConstraint248.tree);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "        	        	        break;\n";
		file << "\n";
		file << "        	        	    default:\n";
		file << "\n";
		file << "        	        		if ( cnt55 >= 1 )\n";
		file << "        	        		{\n";
		file << "        	        		    goto loop55;\n";
		file << "        	        		}\n";
		file << "        	        		if (BACKTRACKING>0)\n";
		file << "        	        		{\n";
		file << "        	        		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	        		    return retval;\n";
		file << "        	        		}\n";
		file << "        	        		/* mismatchedSetEx()\n";
		file << "        	        		 */\n";
		file << "        	        		CONSTRUCTEX();\n";
		file << "        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "        	        		goto ruledurationConstraintEx;\n";
		file << "        	        	}\n";
		file << "        	        	cnt55++;\n";
		file << "        	            }\n";
		file << "        	            loop55: ;	/* Jump to here if this rule does not match */\n";
		file << "        	        }\n";
		file << "        	        char_literal249 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_durationConstraint2151);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal249_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal249));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal249_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:362:4: '(' ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal250 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_durationConstraint2156);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal250_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal250));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal250_tree);\n";
		file << "        	        }\n";
		file << "        	        char_literal251 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_durationConstraint2158);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal251_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal251));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal251_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:363:4: simpleDurationConstraint\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_simpleDurationConstraint_in_durationConstraint2163);\n";
		file << "        	        simpleDurationConstraint252=simpleDurationConstraint(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, simpleDurationConstraint252.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruledurationConstraintEx; /* Prevent compiler warnings */\n";
		file << "    ruledurationConstraintEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end durationConstraint */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start simpleDurationConstraint\n";
		file << " * ../../model/subgoal_learning/Pddl.g:366:1: simpleDurationConstraint : ( '(' durOp '?duration' durValue ')' | '(' 'at' timeSpecifier simpleDurationConstraint ')' );\n";
		file << " */\n";
		file << "static PddlParser_simpleDurationConstraint_return\n";
		file << "simpleDurationConstraint(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_simpleDurationConstraint_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal253;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal255;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal257;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal258;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal259;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal262;\n";
		file << "    PddlParser_durOp_return durOp254;\n";
		file << "    #undef	RETURN_TYPE_durOp254\n";
		file << "    #define	RETURN_TYPE_durOp254 PddlParser_durOp_return\n";
		file << "\n";
		file << "    PddlParser_durValue_return durValue256;\n";
		file << "    #undef	RETURN_TYPE_durValue256\n";
		file << "    #define	RETURN_TYPE_durValue256 PddlParser_durValue_return\n";
		file << "\n";
		file << "    PddlParser_timeSpecifier_return timeSpecifier260;\n";
		file << "    #undef	RETURN_TYPE_timeSpecifier260\n";
		file << "    #define	RETURN_TYPE_timeSpecifier260 PddlParser_timeSpecifier_return\n";
		file << "\n";
		file << "    PddlParser_simpleDurationConstraint_return simpleDurationConstraint261;\n";
		file << "    #undef	RETURN_TYPE_simpleDurationConstraint261\n";
		file << "    #define	RETURN_TYPE_simpleDurationConstraint261 PddlParser_simpleDurationConstraint_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal253_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal255_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal257_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal258_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal259_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal262_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal253       = NULL;\n";
		file << "    string_literal255       = NULL;\n";
		file << "    char_literal257       = NULL;\n";
		file << "    char_literal258       = NULL;\n";
		file << "    string_literal259       = NULL;\n";
		file << "    char_literal262       = NULL;\n";
		file << "    durOp254.tree = NULL;\n";
		file << "\n";
		file << "    durValue256.tree = NULL;\n";
		file << "\n";
		file << "    timeSpecifier260.tree = NULL;\n";
		file << "\n";
		file << "    simpleDurationConstraint261.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal253_tree   = NULL;\n";
		file << "    string_literal255_tree   = NULL;\n";
		file << "    char_literal257_tree   = NULL;\n";
		file << "    char_literal258_tree   = NULL;\n";
		file << "    string_literal259_tree   = NULL;\n";
		file << "    char_literal262_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:367:2: ( '(' durOp '?duration' durValue ')' | '(' 'at' timeSpecifier simpleDurationConstraint ')' )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt57;\n";
		file << "\n";
		file << "            alt57=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA57_0 = LA(1);\n";
		file << "                if ( (LA57_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA57_1 = LA(2);\n";
		file << "                        if ( (LA57_1 == 81) )\n";
		file << "                        {\n";
		file << "                            alt57=2;\n";
		file << "                        }\n";
		file << "                        else if ( (((LA57_1 >= 93) && (LA57_1 <= 95))) )\n";
		file << "                        {\n";
		file << "                            alt57=1;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 57;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto rulesimpleDurationConstraintEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 57;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto rulesimpleDurationConstraintEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt57)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:367:4: '(' durOp '?duration' durValue ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal253 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_simpleDurationConstraint2174);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal253_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal253));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal253_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_durOp_in_simpleDurationConstraint2176);\n";
		file << "        	        durOp254=durOp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, durOp254.tree);\n";
		file << "        	        string_literal255 = (pANTLR3_COMMON_TOKEN) MATCHT(101, &FOLLOW_101_in_simpleDurationConstraint2178);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal255_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal255));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal255_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_durValue_in_simpleDurationConstraint2180);\n";
		file << "        	        durValue256=durValue(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, durValue256.tree);\n";
		file << "        	        char_literal257 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_simpleDurationConstraint2182);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal257_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal257));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal257_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:368:4: '(' 'at' timeSpecifier simpleDurationConstraint ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal258 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_simpleDurationConstraint2187);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal258_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal258));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal258_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal259 = (pANTLR3_COMMON_TOKEN) MATCHT(81, &FOLLOW_81_in_simpleDurationConstraint2189);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal259_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal259));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal259_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_timeSpecifier_in_simpleDurationConstraint2191);\n";
		file << "        	        timeSpecifier260=timeSpecifier(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, timeSpecifier260.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_simpleDurationConstraint_in_simpleDurationConstraint2193);\n";
		file << "        	        simpleDurationConstraint261=simpleDurationConstraint(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, simpleDurationConstraint261.tree);\n";
		file << "        	        char_literal262 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_simpleDurationConstraint2195);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesimpleDurationConstraintEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal262_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal262));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal262_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulesimpleDurationConstraintEx; /* Prevent compiler warnings */\n";
		file << "    rulesimpleDurationConstraintEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end simpleDurationConstraint */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start durOp\n";
		file << " * ../../model/subgoal_learning/Pddl.g:371:1: durOp : ( '<=' | '>=' | '=' );\n";
		file << " */\n";
		file << "static PddlParser_durOp_return\n";
		file << "durOp(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_durOp_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    set263;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE set263_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    set263       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    set263_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:371:7: ( '<=' | '>=' | '=' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            set263=(pANTLR3_COMMON_TOKEN)LT(1);\n";
		file << "            if ( ((LA(1) >= 93) && (LA(1) <= 95)) )\n";
		file << "            {\n";
		file << "                CONSUME();\n";
		file << "                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set263)));\n";
		file << "                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;\n";
		file << "\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "                EXCEPTION->expectingSet = &FOLLOW_set_in_durOp0;\n";
		file << "                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_durOp0);    goto ruledurOpEx;\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruledurOpEx; /* Prevent compiler warnings */\n";
		file << "    ruledurOpEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end durOp */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start durValue\n";
		file << " * ../../model/subgoal_learning/Pddl.g:373:1: durValue : ( NUMBER | fExp );\n";
		file << " */\n";
		file << "static PddlParser_durValue_return\n";
		file << "durValue(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_durValue_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER264;\n";
		file << "    PddlParser_fExp_return fExp265;\n";
		file << "    #undef	RETURN_TYPE_fExp265\n";
		file << "    #define	RETURN_TYPE_fExp265 PddlParser_fExp_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE NUMBER264_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    NUMBER264       = NULL;\n";
		file << "    fExp265.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    NUMBER264_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:373:10: ( NUMBER | fExp )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt58;\n";
		file << "\n";
		file << "            alt58=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA58_0 = LA(1);\n";
		file << "                if ( (LA58_0 == NUMBER) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA58_1 = LA(2);\n";
		file << "                        if ( (synpred88_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt58=1;\n";
		file << "                        }\n";
		file << "                        else if ( (ANTLR3_TRUE) )\n";
		file << "                        {\n";
		file << "                            alt58=2;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 58;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto ruledurValueEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else if ( (LA58_0 == NAME || LA58_0 == VARIABLE || LA58_0 == 54) )\n";
		file << "                {\n";
		file << "                    alt58=2;\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 58;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruledurValueEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt58)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:373:12: NUMBER\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        NUMBER264 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_durValue2222);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledurValueEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        NUMBER264_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER264));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER264_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:373:21: fExp\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fExp_in_durValue2226);\n";
		file << "        	        fExp265=fExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledurValueEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExp265.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruledurValueEx; /* Prevent compiler warnings */\n";
		file << "    ruledurValueEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end durValue */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start daEffect\n";
		file << " * ../../model/subgoal_learning/Pddl.g:375:1: daEffect : ( '(' 'and' ( daEffect )* ')' | timedEffect | '(' 'forall' '(' typedVariableList ')' daEffect ')' | '(' 'when' daGD timedEffect ')' | '(' assignOp fHead fExpDA ')' );\n";
		file << " */\n";
		file << "static PddlParser_daEffect_return\n";
		file << "daEffect(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_daEffect_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal266;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal267;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal269;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal271;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal272;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal273;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal275;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal277;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal278;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal279;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal282;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal283;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal287;\n";
		file << "    PddlParser_daEffect_return daEffect268;\n";
		file << "    #undef	RETURN_TYPE_daEffect268\n";
		file << "    #define	RETURN_TYPE_daEffect268 PddlParser_daEffect_return\n";
		file << "\n";
		file << "    PddlParser_timedEffect_return timedEffect270;\n";
		file << "    #undef	RETURN_TYPE_timedEffect270\n";
		file << "    #define	RETURN_TYPE_timedEffect270 PddlParser_timedEffect_return\n";
		file << "\n";
		file << "    PddlParser_typedVariableList_return typedVariableList274;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList274\n";
		file << "    #define	RETURN_TYPE_typedVariableList274 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_daEffect_return daEffect276;\n";
		file << "    #undef	RETURN_TYPE_daEffect276\n";
		file << "    #define	RETURN_TYPE_daEffect276 PddlParser_daEffect_return\n";
		file << "\n";
		file << "    PddlParser_daGD_return daGD280;\n";
		file << "    #undef	RETURN_TYPE_daGD280\n";
		file << "    #define	RETURN_TYPE_daGD280 PddlParser_daGD_return\n";
		file << "\n";
		file << "    PddlParser_timedEffect_return timedEffect281;\n";
		file << "    #undef	RETURN_TYPE_timedEffect281\n";
		file << "    #define	RETURN_TYPE_timedEffect281 PddlParser_timedEffect_return\n";
		file << "\n";
		file << "    PddlParser_assignOp_return assignOp284;\n";
		file << "    #undef	RETURN_TYPE_assignOp284\n";
		file << "    #define	RETURN_TYPE_assignOp284 PddlParser_assignOp_return\n";
		file << "\n";
		file << "    PddlParser_fHead_return fHead285;\n";
		file << "    #undef	RETURN_TYPE_fHead285\n";
		file << "    #define	RETURN_TYPE_fHead285 PddlParser_fHead_return\n";
		file << "\n";
		file << "    PddlParser_fExpDA_return fExpDA286;\n";
		file << "    #undef	RETURN_TYPE_fExpDA286\n";
		file << "    #define	RETURN_TYPE_fExpDA286 PddlParser_fExpDA_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal266_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal267_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal269_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal271_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal272_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal273_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal275_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal277_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal278_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal279_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal282_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal283_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal287_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal266       = NULL;\n";
		file << "    string_literal267       = NULL;\n";
		file << "    char_literal269       = NULL;\n";
		file << "    char_literal271       = NULL;\n";
		file << "    string_literal272       = NULL;\n";
		file << "    char_literal273       = NULL;\n";
		file << "    char_literal275       = NULL;\n";
		file << "    char_literal277       = NULL;\n";
		file << "    char_literal278       = NULL;\n";
		file << "    string_literal279       = NULL;\n";
		file << "    char_literal282       = NULL;\n";
		file << "    char_literal283       = NULL;\n";
		file << "    char_literal287       = NULL;\n";
		file << "    daEffect268.tree = NULL;\n";
		file << "\n";
		file << "    timedEffect270.tree = NULL;\n";
		file << "\n";
		file << "    typedVariableList274.tree = NULL;\n";
		file << "\n";
		file << "    daEffect276.tree = NULL;\n";
		file << "\n";
		file << "    daGD280.tree = NULL;\n";
		file << "\n";
		file << "    timedEffect281.tree = NULL;\n";
		file << "\n";
		file << "    assignOp284.tree = NULL;\n";
		file << "\n";
		file << "    fHead285.tree = NULL;\n";
		file << "\n";
		file << "    fExpDA286.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal266_tree   = NULL;\n";
		file << "    string_literal267_tree   = NULL;\n";
		file << "    char_literal269_tree   = NULL;\n";
		file << "    char_literal271_tree   = NULL;\n";
		file << "    string_literal272_tree   = NULL;\n";
		file << "    char_literal273_tree   = NULL;\n";
		file << "    char_literal275_tree   = NULL;\n";
		file << "    char_literal277_tree   = NULL;\n";
		file << "    char_literal278_tree   = NULL;\n";
		file << "    string_literal279_tree   = NULL;\n";
		file << "    char_literal282_tree   = NULL;\n";
		file << "    char_literal283_tree   = NULL;\n";
		file << "    char_literal287_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:376:2: ( '(' 'and' ( daEffect )* ')' | timedEffect | '(' 'forall' '(' typedVariableList ')' daEffect ')' | '(' 'when' daGD timedEffect ')' | '(' assignOp fHead fExpDA ')' )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt60;\n";
		file << "\n";
		file << "            alt60=5;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA60_0 = LA(1);\n";
		file << "                if ( (LA60_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA60_1 = LA(2);\n";
		file << "                        if ( (synpred90_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt60=1;\n";
		file << "                        }\n";
		file << "                        else if ( (synpred91_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt60=2;\n";
		file << "                        }\n";
		file << "                        else if ( (synpred92_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt60=3;\n";
		file << "                        }\n";
		file << "                        else if ( (synpred93_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt60=4;\n";
		file << "                        }\n";
		file << "                        else if ( (ANTLR3_TRUE) )\n";
		file << "                        {\n";
		file << "                            alt60=5;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 60;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto ruledaEffectEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 60;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruledaEffectEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt60)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:376:4: '(' 'and' ( daEffect )* ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal266 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daEffect2236);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal266_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal266));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal266_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal267 = (pANTLR3_COMMON_TOKEN) MATCHT(71, &FOLLOW_71_in_daEffect2238);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal267_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal267));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal267_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:376:14: ( daEffect )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt59=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA59_0 = LA(1);\n";
		file << "        	                if ( (LA59_0 == 54) )\n";
		file << "        	                {\n";
		file << "        	                    alt59=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt59)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: daEffect\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_daEffect_in_daEffect2240);\n";
		file << "        	        	        daEffect268=daEffect(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto ruledaEffectEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, daEffect268.tree);\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop59;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop59: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal269 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daEffect2243);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal269_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal269));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal269_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:377:4: timedEffect\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_timedEffect_in_daEffect2248);\n";
		file << "        	        timedEffect270=timedEffect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, timedEffect270.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:378:4: '(' 'forall' '(' typedVariableList ')' daEffect ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal271 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daEffect2253);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal271_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal271));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal271_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal272 = (pANTLR3_COMMON_TOKEN) MATCHT(76, &FOLLOW_76_in_daEffect2255);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal272_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal272));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal272_tree);\n";
		file << "        	        }\n";
		file << "        	        char_literal273 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daEffect2257);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal273_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal273));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal273_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_typedVariableList_in_daEffect2259);\n";
		file << "        	        typedVariableList274=typedVariableList(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typedVariableList274.tree);\n";
		file << "        	        char_literal275 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daEffect2261);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal275_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal275));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal275_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_daEffect_in_daEffect2263);\n";
		file << "        	        daEffect276=daEffect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, daEffect276.tree);\n";
		file << "        	        char_literal277 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daEffect2265);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal277_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal277));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal277_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 4:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:379:4: '(' 'when' daGD timedEffect ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal278 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daEffect2270);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal278_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal278));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal278_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal279 = (pANTLR3_COMMON_TOKEN) MATCHT(87, &FOLLOW_87_in_daEffect2272);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal279_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal279));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal279_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_daGD_in_daEffect2274);\n";
		file << "        	        daGD280=daGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, daGD280.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_timedEffect_in_daEffect2276);\n";
		file << "        	        timedEffect281=timedEffect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, timedEffect281.tree);\n";
		file << "        	        char_literal282 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daEffect2278);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal282_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal282));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal282_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 5:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:380:4: '(' assignOp fHead fExpDA ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal283 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_daEffect2283);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal283_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal283));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal283_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_assignOp_in_daEffect2285);\n";
		file << "        	        assignOp284=assignOp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, assignOp284.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fHead_in_daEffect2287);\n";
		file << "        	        fHead285=fHead(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fHead285.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fExpDA_in_daEffect2289);\n";
		file << "        	        fExpDA286=fExpDA(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExpDA286.tree);\n";
		file << "        	        char_literal287 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_daEffect2291);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruledaEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal287_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal287));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal287_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruledaEffectEx; /* Prevent compiler warnings */\n";
		file << "    ruledaEffectEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end daEffect */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start timedEffect\n";
		file << " * ../../model/subgoal_learning/Pddl.g:383:1: timedEffect : ( '(' 'at' timeSpecifier daEffect ')' | '(' 'at' timeSpecifier fAssignDA ')' | '(' assignOp fHead fExp ')' );\n";
		file << " */\n";
		file << "static PddlParser_timedEffect_return\n";
		file << "timedEffect(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_timedEffect_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal288;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal289;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal292;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal293;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal294;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal297;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal298;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal302;\n";
		file << "    PddlParser_timeSpecifier_return timeSpecifier290;\n";
		file << "    #undef	RETURN_TYPE_timeSpecifier290\n";
		file << "    #define	RETURN_TYPE_timeSpecifier290 PddlParser_timeSpecifier_return\n";
		file << "\n";
		file << "    PddlParser_daEffect_return daEffect291;\n";
		file << "    #undef	RETURN_TYPE_daEffect291\n";
		file << "    #define	RETURN_TYPE_daEffect291 PddlParser_daEffect_return\n";
		file << "\n";
		file << "    PddlParser_timeSpecifier_return timeSpecifier295;\n";
		file << "    #undef	RETURN_TYPE_timeSpecifier295\n";
		file << "    #define	RETURN_TYPE_timeSpecifier295 PddlParser_timeSpecifier_return\n";
		file << "\n";
		file << "    PddlParser_fAssignDA_return fAssignDA296;\n";
		file << "    #undef	RETURN_TYPE_fAssignDA296\n";
		file << "    #define	RETURN_TYPE_fAssignDA296 PddlParser_fAssignDA_return\n";
		file << "\n";
		file << "    PddlParser_assignOp_return assignOp299;\n";
		file << "    #undef	RETURN_TYPE_assignOp299\n";
		file << "    #define	RETURN_TYPE_assignOp299 PddlParser_assignOp_return\n";
		file << "\n";
		file << "    PddlParser_fHead_return fHead300;\n";
		file << "    #undef	RETURN_TYPE_fHead300\n";
		file << "    #define	RETURN_TYPE_fHead300 PddlParser_fHead_return\n";
		file << "\n";
		file << "    PddlParser_fExp_return fExp301;\n";
		file << "    #undef	RETURN_TYPE_fExp301\n";
		file << "    #define	RETURN_TYPE_fExp301 PddlParser_fExp_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal288_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal289_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal292_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal293_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal294_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal297_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal298_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal302_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal288       = NULL;\n";
		file << "    string_literal289       = NULL;\n";
		file << "    char_literal292       = NULL;\n";
		file << "    char_literal293       = NULL;\n";
		file << "    string_literal294       = NULL;\n";
		file << "    char_literal297       = NULL;\n";
		file << "    char_literal298       = NULL;\n";
		file << "    char_literal302       = NULL;\n";
		file << "    timeSpecifier290.tree = NULL;\n";
		file << "\n";
		file << "    daEffect291.tree = NULL;\n";
		file << "\n";
		file << "    timeSpecifier295.tree = NULL;\n";
		file << "\n";
		file << "    fAssignDA296.tree = NULL;\n";
		file << "\n";
		file << "    assignOp299.tree = NULL;\n";
		file << "\n";
		file << "    fHead300.tree = NULL;\n";
		file << "\n";
		file << "    fExp301.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal288_tree   = NULL;\n";
		file << "    string_literal289_tree   = NULL;\n";
		file << "    char_literal292_tree   = NULL;\n";
		file << "    char_literal293_tree   = NULL;\n";
		file << "    string_literal294_tree   = NULL;\n";
		file << "    char_literal297_tree   = NULL;\n";
		file << "    char_literal298_tree   = NULL;\n";
		file << "    char_literal302_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:384:2: ( '(' 'at' timeSpecifier daEffect ')' | '(' 'at' timeSpecifier fAssignDA ')' | '(' assignOp fHead fExp ')' )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt61;\n";
		file << "\n";
		file << "            alt61=3;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA61_0 = LA(1);\n";
		file << "                if ( (LA61_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA61_1 = LA(2);\n";
		file << "                        if ( (synpred94_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt61=1;\n";
		file << "                        }\n";
		file << "                        else if ( (synpred95_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt61=2;\n";
		file << "                        }\n";
		file << "                        else if ( (ANTLR3_TRUE) )\n";
		file << "                        {\n";
		file << "                            alt61=3;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 61;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto ruletimedEffectEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 61;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruletimedEffectEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt61)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:384:4: '(' 'at' timeSpecifier daEffect ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal288 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_timedEffect2302);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal288_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal288));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal288_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal289 = (pANTLR3_COMMON_TOKEN) MATCHT(81, &FOLLOW_81_in_timedEffect2304);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal289_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal289));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal289_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_timeSpecifier_in_timedEffect2306);\n";
		file << "        	        timeSpecifier290=timeSpecifier(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, timeSpecifier290.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_daEffect_in_timedEffect2308);\n";
		file << "        	        daEffect291=daEffect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, daEffect291.tree);\n";
		file << "        	        char_literal292 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_timedEffect2310);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal292_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal292));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal292_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:385:4: '(' 'at' timeSpecifier fAssignDA ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal293 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_timedEffect2320);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal293_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal293));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal293_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal294 = (pANTLR3_COMMON_TOKEN) MATCHT(81, &FOLLOW_81_in_timedEffect2322);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal294_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal294));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal294_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_timeSpecifier_in_timedEffect2324);\n";
		file << "        	        timeSpecifier295=timeSpecifier(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, timeSpecifier295.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fAssignDA_in_timedEffect2326);\n";
		file << "        	        fAssignDA296=fAssignDA(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fAssignDA296.tree);\n";
		file << "        	        char_literal297 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_timedEffect2328);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal297_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal297));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal297_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:386:4: '(' assignOp fHead fExp ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal298 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_timedEffect2333);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal298_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal298));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal298_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_assignOp_in_timedEffect2335);\n";
		file << "        	        assignOp299=assignOp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, assignOp299.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fHead_in_timedEffect2337);\n";
		file << "        	        fHead300=fHead(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fHead300.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fExp_in_timedEffect2339);\n";
		file << "        	        fExp301=fExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExp301.tree);\n";
		file << "        	        char_literal302 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_timedEffect2341);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruletimedEffectEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal302_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal302));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal302_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruletimedEffectEx; /* Prevent compiler warnings */\n";
		file << "    ruletimedEffectEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end timedEffect */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start fAssignDA\n";
		file << " * ../../model/subgoal_learning/Pddl.g:389:1: fAssignDA : '(' assignOp fHead fExpDA ')' ;\n";
		file << " */\n";
		file << "static PddlParser_fAssignDA_return\n";
		file << "fAssignDA(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_fAssignDA_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal303;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal307;\n";
		file << "    PddlParser_assignOp_return assignOp304;\n";
		file << "    #undef	RETURN_TYPE_assignOp304\n";
		file << "    #define	RETURN_TYPE_assignOp304 PddlParser_assignOp_return\n";
		file << "\n";
		file << "    PddlParser_fHead_return fHead305;\n";
		file << "    #undef	RETURN_TYPE_fHead305\n";
		file << "    #define	RETURN_TYPE_fHead305 PddlParser_fHead_return\n";
		file << "\n";
		file << "    PddlParser_fExpDA_return fExpDA306;\n";
		file << "    #undef	RETURN_TYPE_fExpDA306\n";
		file << "    #define	RETURN_TYPE_fExpDA306 PddlParser_fExpDA_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal303_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal307_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal303       = NULL;\n";
		file << "    char_literal307       = NULL;\n";
		file << "    assignOp304.tree = NULL;\n";
		file << "\n";
		file << "    fHead305.tree = NULL;\n";
		file << "\n";
		file << "    fExpDA306.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal303_tree   = NULL;\n";
		file << "    char_literal307_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:390:2: ( '(' assignOp fHead fExpDA ')' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:390:4: '(' assignOp fHead fExpDA ')'\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            char_literal303 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_fAssignDA2361);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefAssignDAEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            char_literal303_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal303));\n";
		file << "            ADAPTOR->addChild(ADAPTOR, root_0, char_literal303_tree);\n";
		file << "            }\n";
		file << "            FOLLOWPUSH(FOLLOW_assignOp_in_fAssignDA2363);\n";
		file << "            assignOp304=assignOp(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefAssignDAEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, assignOp304.tree);\n";
		file << "            FOLLOWPUSH(FOLLOW_fHead_in_fAssignDA2365);\n";
		file << "            fHead305=fHead(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefAssignDAEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fHead305.tree);\n";
		file << "            FOLLOWPUSH(FOLLOW_fExpDA_in_fAssignDA2367);\n";
		file << "            fExpDA306=fExpDA(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefAssignDAEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExpDA306.tree);\n";
		file << "            char_literal307 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_fAssignDA2369);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulefAssignDAEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) {\n";
		file << "            char_literal307_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal307));\n";
		file << "            ADAPTOR->addChild(ADAPTOR, root_0, char_literal307_tree);\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefAssignDAEx; /* Prevent compiler warnings */\n";
		file << "    rulefAssignDAEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end fAssignDA */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start fExpDA\n";
		file << " * ../../model/subgoal_learning/Pddl.g:393:1: fExpDA : ( '(' ( ( binaryOp fExpDA fExpDA ) | ( '-' fExpDA ) ) ')' | '?duration' | fExp );\n";
		file << " */\n";
		file << "static PddlParser_fExpDA_return\n";
		file << "fExpDA(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_fExpDA_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal308;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal312;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal314;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal315;\n";
		file << "    PddlParser_binaryOp_return binaryOp309;\n";
		file << "    #undef	RETURN_TYPE_binaryOp309\n";
		file << "    #define	RETURN_TYPE_binaryOp309 PddlParser_binaryOp_return\n";
		file << "\n";
		file << "    PddlParser_fExpDA_return fExpDA310;\n";
		file << "    #undef	RETURN_TYPE_fExpDA310\n";
		file << "    #define	RETURN_TYPE_fExpDA310 PddlParser_fExpDA_return\n";
		file << "\n";
		file << "    PddlParser_fExpDA_return fExpDA311;\n";
		file << "    #undef	RETURN_TYPE_fExpDA311\n";
		file << "    #define	RETURN_TYPE_fExpDA311 PddlParser_fExpDA_return\n";
		file << "\n";
		file << "    PddlParser_fExpDA_return fExpDA313;\n";
		file << "    #undef	RETURN_TYPE_fExpDA313\n";
		file << "    #define	RETURN_TYPE_fExpDA313 PddlParser_fExpDA_return\n";
		file << "\n";
		file << "    PddlParser_fExp_return fExp316;\n";
		file << "    #undef	RETURN_TYPE_fExp316\n";
		file << "    #define	RETURN_TYPE_fExp316 PddlParser_fExp_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal308_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal312_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal314_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal315_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal308       = NULL;\n";
		file << "    char_literal312       = NULL;\n";
		file << "    char_literal314       = NULL;\n";
		file << "    string_literal315       = NULL;\n";
		file << "    binaryOp309.tree = NULL;\n";
		file << "\n";
		file << "    fExpDA310.tree = NULL;\n";
		file << "\n";
		file << "    fExpDA311.tree = NULL;\n";
		file << "\n";
		file << "    fExpDA313.tree = NULL;\n";
		file << "\n";
		file << "    fExp316.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal308_tree   = NULL;\n";
		file << "    char_literal312_tree   = NULL;\n";
		file << "    char_literal314_tree   = NULL;\n";
		file << "    string_literal315_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:394:2: ( '(' ( ( binaryOp fExpDA fExpDA ) | ( '-' fExpDA ) ) ')' | '?duration' | fExp )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt63;\n";
		file << "\n";
		file << "            alt63=3;\n";
		file << "\n";
		file << "            switch ( LA(1) )\n";
		file << "            {\n";
		file << "            case 54:\n";
		file << "            	{\n";
		file << "\n";
		file << "            		{\n";
		file << "            		    int LA63_1 = LA(2);\n";
		file << "            		    if ( (synpred97_Pddl(ctx)) )\n";
		file << "            		    {\n";
		file << "            		        alt63=1;\n";
		file << "            		    }\n";
		file << "            		    else if ( (ANTLR3_TRUE) )\n";
		file << "            		    {\n";
		file << "            		        alt63=3;\n";
		file << "            		    }\n";
		file << "            		    else\n";
		file << "            		    {\n";
		file << "            		        if (BACKTRACKING>0)\n";
		file << "            		        {\n";
		file << "            		            FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "            		            return retval;\n";
		file << "            		        }\n";
		file << "\n";
		file << "            		        CONSTRUCTEX();\n";
		file << "            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "            		        EXCEPTION->message      = (void *)\"\";\n";
		file << "            		        EXCEPTION->decisionNum  = 63;\n";
		file << "            		        EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "            		        goto rulefExpDAEx;\n";
		file << "            		    }\n";
		file << "            		}\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "            case 101:\n";
		file << "            	{\n";
		file << "            		alt63=2;\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "            case NAME:\n";
		file << "            case VARIABLE:\n";
		file << "            case NUMBER:\n";
		file << "            	{\n";
		file << "            		alt63=3;\n";
		file << "            	}\n";
		file << "                break;\n";
		file << "\n";
		file << "            default:\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                EXCEPTION->message      = (void *)\"\";\n";
		file << "                EXCEPTION->decisionNum  = 63;\n";
		file << "                EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                goto rulefExpDAEx;\n";
		file << "            }\n";
		file << "\n";
		file << "            switch (alt63)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:394:4: '(' ( ( binaryOp fExpDA fExpDA ) | ( '-' fExpDA ) ) ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal308 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_fExpDA2380);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpDAEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal308_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal308));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal308_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:394:8: ( ( binaryOp fExpDA fExpDA ) | ( '-' fExpDA ) )\n";
		file << "        	        {\n";
		file << "        	            int alt62=2;\n";
		file << "\n";
		file << "        	            {\n";
		file << "        	                int LA62_0 = LA(1);\n";
		file << "        	                if ( (LA62_0 == 60) )\n";
		file << "        	                {\n";
		file << "\n";
		file << "        	                    {\n";
		file << "        	                        int LA62_1 = LA(2);\n";
		file << "        	                        if ( (synpred96_Pddl(ctx)) )\n";
		file << "        	                        {\n";
		file << "        	                            alt62=1;\n";
		file << "        	                        }\n";
		file << "        	                        else if ( (ANTLR3_TRUE) )\n";
		file << "        	                        {\n";
		file << "        	                            alt62=2;\n";
		file << "        	                        }\n";
		file << "        	                        else\n";
		file << "        	                        {\n";
		file << "        	                            if (BACKTRACKING>0)\n";
		file << "        	                            {\n";
		file << "        	                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	                                return retval;\n";
		file << "        	                            }\n";
		file << "\n";
		file << "        	                            CONSTRUCTEX();\n";
		file << "        	                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "        	                            EXCEPTION->message      = (void *)\"\";\n";
		file << "        	                            EXCEPTION->decisionNum  = 62;\n";
		file << "        	                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "        	                            goto rulefExpDAEx;\n";
		file << "        	                        }\n";
		file << "        	                    }\n";
		file << "        	                }\n";
		file << "        	                else if ( (((LA62_0 >= 88) && (LA62_0 <= 90))) )\n";
		file << "        	                {\n";
		file << "        	                    alt62=1;\n";
		file << "        	                }\n";
		file << "        	                else\n";
		file << "        	                {\n";
		file << "        	                    if (BACKTRACKING>0)\n";
		file << "        	                    {\n";
		file << "        	                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	                        return retval;\n";
		file << "        	                    }\n";
		file << "\n";
		file << "        	                    CONSTRUCTEX();\n";
		file << "        	                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "        	                    EXCEPTION->message      = (void *)\"\";\n";
		file << "        	                    EXCEPTION->decisionNum  = 62;\n";
		file << "        	                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "        	                    goto rulefExpDAEx;\n";
		file << "        	                }\n";
		file << "        	            }\n";
		file << "        	            switch (alt62)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:394:9: ( binaryOp fExpDA fExpDA )\n";
		file << "        	        	    {\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:394:9: ( binaryOp fExpDA fExpDA )\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:394:10: binaryOp fExpDA fExpDA\n";
		file << "        	        	        {\n";
		file << "        	        	            FOLLOWPUSH(FOLLOW_binaryOp_in_fExpDA2384);\n";
		file << "        	        	            binaryOp309=binaryOp(ctx);\n";
		file << "\n";
		file << "        	        	            FOLLOWPOP();\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto rulefExpDAEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, binaryOp309.tree);\n";
		file << "        	        	            FOLLOWPUSH(FOLLOW_fExpDA_in_fExpDA2386);\n";
		file << "        	        	            fExpDA310=fExpDA(ctx);\n";
		file << "\n";
		file << "        	        	            FOLLOWPOP();\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto rulefExpDAEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExpDA310.tree);\n";
		file << "        	        	            FOLLOWPUSH(FOLLOW_fExpDA_in_fExpDA2388);\n";
		file << "        	        	            fExpDA311=fExpDA(ctx);\n";
		file << "\n";
		file << "        	        	            FOLLOWPOP();\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto rulefExpDAEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExpDA311.tree);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "        	        	case 2:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:394:36: ( '-' fExpDA )\n";
		file << "        	        	    {\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:394:36: ( '-' fExpDA )\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:394:37: '-' fExpDA\n";
		file << "        	        	        {\n";
		file << "        	        	            char_literal312 = (pANTLR3_COMMON_TOKEN) MATCHT(60, &FOLLOW_60_in_fExpDA2394);\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto rulefExpDAEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) {\n";
		file << "        	        	            char_literal312_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal312));\n";
		file << "        	        	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal312_tree);\n";
		file << "        	        	            }\n";
		file << "        	        	            FOLLOWPUSH(FOLLOW_fExpDA_in_fExpDA2396);\n";
		file << "        	        	            fExpDA313=fExpDA(ctx);\n";
		file << "\n";
		file << "        	        	            FOLLOWPOP();\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto rulefExpDAEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExpDA313.tree);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        char_literal314 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_fExpDA2400);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpDAEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal314_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal314));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal314_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:395:4: '?duration'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        string_literal315 = (pANTLR3_COMMON_TOKEN) MATCHT(101, &FOLLOW_101_in_fExpDA2405);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpDAEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal315_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal315));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal315_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:396:4: fExp\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fExp_in_fExpDA2410);\n";
		file << "        	        fExp316=fExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulefExpDAEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fExp316.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulefExpDAEx; /* Prevent compiler warnings */\n";
		file << "    rulefExpDAEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end fExpDA */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start problem\n";
		file << " * ../../model/subgoal_learning/Pddl.g:399:1: problem : '(' 'define' problemDecl problemDomain ( requireDef )? ( objectDecl )? init goal ( probConstraints )? ( metricSpec )? ')' -> ^( PROBLEM problemDecl problemDomain ( requireDef )? ( objectDecl )? init goal ( probConstraints )? ( metricSpec )? ) ;\n";
		file << " */\n";
		file << "static PddlParser_problem_return\n";
		file << "problem(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_problem_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal317;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal318;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal327;\n";
		file << "    PddlParser_problemDecl_return problemDecl319;\n";
		file << "    #undef	RETURN_TYPE_problemDecl319\n";
		file << "    #define	RETURN_TYPE_problemDecl319 PddlParser_problemDecl_return\n";
		file << "\n";
		file << "    PddlParser_problemDomain_return problemDomain320;\n";
		file << "    #undef	RETURN_TYPE_problemDomain320\n";
		file << "    #define	RETURN_TYPE_problemDomain320 PddlParser_problemDomain_return\n";
		file << "\n";
		file << "    PddlParser_requireDef_return requireDef321;\n";
		file << "    #undef	RETURN_TYPE_requireDef321\n";
		file << "    #define	RETURN_TYPE_requireDef321 PddlParser_requireDef_return\n";
		file << "\n";
		file << "    PddlParser_objectDecl_return objectDecl322;\n";
		file << "    #undef	RETURN_TYPE_objectDecl322\n";
		file << "    #define	RETURN_TYPE_objectDecl322 PddlParser_objectDecl_return\n";
		file << "\n";
		file << "    PddlParser_init_return init323;\n";
		file << "    #undef	RETURN_TYPE_init323\n";
		file << "    #define	RETURN_TYPE_init323 PddlParser_init_return\n";
		file << "\n";
		file << "    PddlParser_goal_return goal324;\n";
		file << "    #undef	RETURN_TYPE_goal324\n";
		file << "    #define	RETURN_TYPE_goal324 PddlParser_goal_return\n";
		file << "\n";
		file << "    PddlParser_probConstraints_return probConstraints325;\n";
		file << "    #undef	RETURN_TYPE_probConstraints325\n";
		file << "    #define	RETURN_TYPE_probConstraints325 PddlParser_probConstraints_return\n";
		file << "\n";
		file << "    PddlParser_metricSpec_return metricSpec326;\n";
		file << "    #undef	RETURN_TYPE_metricSpec326\n";
		file << "    #define	RETURN_TYPE_metricSpec326 PddlParser_metricSpec_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal317_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal318_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal327_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_55;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_metricSpec;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_objectDecl;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_problemDecl;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_probConstraints;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_requireDef;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_init;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_problemDomain;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_goal;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal317       = NULL;\n";
		file << "    string_literal318       = NULL;\n";
		file << "    char_literal327       = NULL;\n";
		file << "    problemDecl319.tree = NULL;\n";
		file << "\n";
		file << "    problemDomain320.tree = NULL;\n";
		file << "\n";
		file << "    requireDef321.tree = NULL;\n";
		file << "\n";
		file << "    objectDecl322.tree = NULL;\n";
		file << "\n";
		file << "    init323.tree = NULL;\n";
		file << "\n";
		file << "    goal324.tree = NULL;\n";
		file << "\n";
		file << "    probConstraints325.tree = NULL;\n";
		file << "\n";
		file << "    metricSpec326.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal317_tree   = NULL;\n";
		file << "    string_literal318_tree   = NULL;\n";
		file << "    char_literal327_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_55   = NULL;\n";
		file << "    #define CREATE_stream_55  if (stream_55 == NULL) {stream_55 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 55\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_metricSpec   = NULL;\n";
		file << "    #define CREATE_stream_metricSpec  if (stream_metricSpec == NULL) {stream_metricSpec = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule metricSpec\"); }\n";
		file << "    stream_objectDecl   = NULL;\n";
		file << "    #define CREATE_stream_objectDecl  if (stream_objectDecl == NULL) {stream_objectDecl = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule objectDecl\"); }\n";
		file << "    stream_problemDecl   = NULL;\n";
		file << "    #define CREATE_stream_problemDecl  if (stream_problemDecl == NULL) {stream_problemDecl = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule problemDecl\"); }\n";
		file << "    stream_probConstraints   = NULL;\n";
		file << "    #define CREATE_stream_probConstraints  if (stream_probConstraints == NULL) {stream_probConstraints = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule probConstraints\"); }\n";
		file << "    stream_requireDef   = NULL;\n";
		file << "    #define CREATE_stream_requireDef  if (stream_requireDef == NULL) {stream_requireDef = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule requireDef\"); }\n";
		file << "    stream_init   = NULL;\n";
		file << "    #define CREATE_stream_init  if (stream_init == NULL) {stream_init = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule init\"); }\n";
		file << "    stream_problemDomain   = NULL;\n";
		file << "    #define CREATE_stream_problemDomain  if (stream_problemDomain == NULL) {stream_problemDomain = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule problemDomain\"); }\n";
		file << "    stream_goal   = NULL;\n";
		file << "    #define CREATE_stream_goal  if (stream_goal == NULL) {stream_goal = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule goal\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:402:2: ( '(' 'define' problemDecl problemDomain ( requireDef )? ( objectDecl )? init goal ( probConstraints )? ( metricSpec )? ')' -> ^( PROBLEM problemDecl problemDomain ( requireDef )? ( objectDecl )? init goal ( probConstraints )? ( metricSpec )? ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:402:4: '(' 'define' problemDecl problemDomain ( requireDef )? ( objectDecl )? init goal ( probConstraints )? ( metricSpec )? ')'\n";
		file << "        {\n";
		file << "            char_literal317 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_problem2424);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal317, NULL); }\n";
		file << "\n";
		file << "            string_literal318 = (pANTLR3_COMMON_TOKEN) MATCHT(55, &FOLLOW_55_in_problem2426);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_55; stream_55->add(stream_55, string_literal318, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_problemDecl_in_problem2428);\n";
		file << "            problemDecl319=problemDecl(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_problemDecl; stream_problemDecl->add(stream_problemDecl, problemDecl319.tree, NULL); }\n";
		file << "            FOLLOWPUSH(FOLLOW_problemDomain_in_problem2433);\n";
		file << "            problemDomain320=problemDomain(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_problemDomain; stream_problemDomain->add(stream_problemDomain, problemDomain320.tree, NULL); }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:404:7: ( requireDef )?\n";
		file << "            {\n";
		file << "                int alt64=2;\n";
		file << "                {\n";
		file << "                    int LA64_0 = LA(1);\n";
		file << "                    if ( (LA64_0 == 54) )\n";
		file << "                    {\n";
		file << "                        {\n";
		file << "                            int LA64_1 = LA(2);\n";
		file << "                            if ( (LA64_1 == 58) )\n";
		file << "                            {\n";
		file << "                                alt64=1;\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt64)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: requireDef\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_requireDef_in_problem2441);\n";
		file << "            	        requireDef321=requireDef(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleproblemEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_requireDef; stream_requireDef->add(stream_requireDef, requireDef321.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:405:7: ( objectDecl )?\n";
		file << "            {\n";
		file << "                int alt65=2;\n";
		file << "                {\n";
		file << "                    int LA65_0 = LA(1);\n";
		file << "                    if ( (LA65_0 == 54) )\n";
		file << "                    {\n";
		file << "                        {\n";
		file << "                            int LA65_1 = LA(2);\n";
		file << "                            if ( (LA65_1 == 104) )\n";
		file << "                            {\n";
		file << "                                alt65=1;\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt65)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: objectDecl\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_objectDecl_in_problem2450);\n";
		file << "            	        objectDecl322=objectDecl(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleproblemEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_objectDecl; stream_objectDecl->add(stream_objectDecl, objectDecl322.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "            FOLLOWPUSH(FOLLOW_init_in_problem2459);\n";
		file << "            init323=init(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_init; stream_init->add(stream_init, init323.tree, NULL); }\n";
		file << "            FOLLOWPUSH(FOLLOW_goal_in_problem2467);\n";
		file << "            goal324=goal(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_goal; stream_goal->add(stream_goal, goal324.tree, NULL); }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:408:7: ( probConstraints )?\n";
		file << "            {\n";
		file << "                int alt66=2;\n";
		file << "                {\n";
		file << "                    int LA66_0 = LA(1);\n";
		file << "                    if ( (LA66_0 == 54) )\n";
		file << "                    {\n";
		file << "                        {\n";
		file << "                            int LA66_1 = LA(2);\n";
		file << "                            if ( (LA66_1 == 66) )\n";
		file << "                            {\n";
		file << "                                alt66=1;\n";
		file << "                            }\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt66)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: probConstraints\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_probConstraints_in_problem2475);\n";
		file << "            	        probConstraints325=probConstraints(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleproblemEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_probConstraints; stream_probConstraints->add(stream_probConstraints, probConstraints325.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:409:7: ( metricSpec )?\n";
		file << "            {\n";
		file << "                int alt67=2;\n";
		file << "                {\n";
		file << "                    int LA67_0 = LA(1);\n";
		file << "                    if ( (LA67_0 == 54) )\n";
		file << "                    {\n";
		file << "                        alt67=1;\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                switch (alt67)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: metricSpec\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_metricSpec_in_problem2484);\n";
		file << "            	        metricSpec326=metricSpec(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleproblemEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_metricSpec; stream_metricSpec->add(stream_metricSpec, metricSpec326.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "                }\n";
		file << "            }\n";
		file << "            char_literal327 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_problem2500);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal327, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : requireDef, metricSpec, probConstraints, init, goal, problemDecl, objectDecl, problemDomain\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 412:7: -> ^( PROBLEM problemDecl problemDomain ( requireDef )? ( objectDecl )? init goal ( probConstraints )? ( metricSpec )? )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:412:10: ^( PROBLEM problemDecl problemDomain ( requireDef )? ( objectDecl )? init goal ( probConstraints )? ( metricSpec )? )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PROBLEM, (pANTLR3_UINT8)\"PROBLEM\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_problemDecl == NULL ? NULL : stream_problemDecl->nextTree(stream_problemDecl));\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_problemDomain == NULL ? NULL : stream_problemDomain->nextTree(stream_problemDomain));\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:412:46: ( requireDef )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_requireDef != NULL && stream_requireDef->hasNext(stream_requireDef))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_requireDef == NULL ? NULL : stream_requireDef->nextTree(stream_requireDef));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_requireDef != NULL) stream_requireDef->reset(stream_requireDef);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:412:58: ( objectDecl )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_objectDecl != NULL && stream_objectDecl->hasNext(stream_objectDecl))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_objectDecl == NULL ? NULL : stream_objectDecl->nextTree(stream_objectDecl));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_objectDecl != NULL) stream_objectDecl->reset(stream_objectDecl);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_init == NULL ? NULL : stream_init->nextTree(stream_init));\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_goal == NULL ? NULL : stream_goal->nextTree(stream_goal));\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:413:19: ( probConstraints )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_probConstraints != NULL && stream_probConstraints->hasNext(stream_probConstraints))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_probConstraints == NULL ? NULL : stream_probConstraints->nextTree(stream_probConstraints));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_probConstraints != NULL) stream_probConstraints->reset(stream_probConstraints);\n";
		file << "\n";
		file << "            	        }\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:413:36: ( metricSpec )?\n";
		file << "            	        {\n";
		file << "            	        	if ( (stream_metricSpec != NULL && stream_metricSpec->hasNext(stream_metricSpec))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_metricSpec == NULL ? NULL : stream_metricSpec->nextTree(stream_metricSpec));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if ( stream_metricSpec != NULL) stream_metricSpec->reset(stream_metricSpec);\n";
		file << "\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleproblemEx; /* Prevent compiler warnings */\n";
		file << "    ruleproblemEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_55 != NULL) stream_55->free(stream_55);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_metricSpec != NULL) stream_metricSpec->free(stream_metricSpec);\n";
		file << "        if (stream_objectDecl != NULL) stream_objectDecl->free(stream_objectDecl);\n";
		file << "        if (stream_problemDecl != NULL) stream_problemDecl->free(stream_problemDecl);\n";
		file << "        if (stream_probConstraints != NULL) stream_probConstraints->free(stream_probConstraints);\n";
		file << "        if (stream_requireDef != NULL) stream_requireDef->free(stream_requireDef);\n";
		file << "        if (stream_init != NULL) stream_init->free(stream_init);\n";
		file << "        if (stream_problemDomain != NULL) stream_problemDomain->free(stream_problemDomain);\n";
		file << "        if (stream_goal != NULL) stream_goal->free(stream_goal);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end problem */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start problemDecl\n";
		file << " * ../../model/subgoal_learning/Pddl.g:416:1: problemDecl : '(' 'problem' NAME ')' -> ^( PROBLEM_NAME NAME ) ;\n";
		file << " */\n";
		file << "static PddlParser_problemDecl_return\n";
		file << "problemDecl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_problemDecl_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal328;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal329;\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME330;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal331;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal328_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal329_tree;\n";
		file << "    pANTLR3_BASE_TREE NAME330_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal331_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NAME;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_102;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal328       = NULL;\n";
		file << "    string_literal329       = NULL;\n";
		file << "    NAME330       = NULL;\n";
		file << "    char_literal331       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal328_tree   = NULL;\n";
		file << "    string_literal329_tree   = NULL;\n";
		file << "    NAME330_tree   = NULL;\n";
		file << "    char_literal331_tree   = NULL;\n";
		file << "\n";
		file << "    stream_NAME   = NULL;\n";
		file << "    #define CREATE_stream_NAME  if (stream_NAME == NULL) {stream_NAME = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token NAME\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_102   = NULL;\n";
		file << "    #define CREATE_stream_102  if (stream_102 == NULL) {stream_102 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 102\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:417:5: ( '(' 'problem' NAME ')' -> ^( PROBLEM_NAME NAME ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:417:7: '(' 'problem' NAME ')'\n";
		file << "        {\n";
		file << "            char_literal328 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_problemDecl2557);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemDeclEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal328, NULL); }\n";
		file << "\n";
		file << "            string_literal329 = (pANTLR3_COMMON_TOKEN) MATCHT(102, &FOLLOW_102_in_problemDecl2559);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemDeclEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_102; stream_102->add(stream_102, string_literal329, NULL); }\n";
		file << "\n";
		file << "            NAME330 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_problemDecl2561);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemDeclEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_NAME; stream_NAME->add(stream_NAME, NAME330, NULL); }\n";
		file << "\n";
		file << "            char_literal331 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_problemDecl2563);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemDeclEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal331, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : NAME\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 418:5: -> ^( PROBLEM_NAME NAME )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:418:8: ^( PROBLEM_NAME NAME )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PROBLEM_NAME, (pANTLR3_UINT8)\"PROBLEM_NAME\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_NAME == NULL ? NULL : stream_NAME->nextNode(stream_NAME));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleproblemDeclEx; /* Prevent compiler warnings */\n";
		file << "    ruleproblemDeclEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_NAME != NULL) stream_NAME->free(stream_NAME);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_102 != NULL) stream_102->free(stream_102);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end problemDecl */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start problemDomain\n";
		file << " * ../../model/subgoal_learning/Pddl.g:421:1: problemDomain : '(' ':domain' NAME ')' -> ^( PROBLEM_DOMAIN NAME ) ;\n";
		file << " */\n";
		file << "static PddlParser_problemDomain_return\n";
		file << "problemDomain(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_problemDomain_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal332;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal333;\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME334;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal335;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal332_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal333_tree;\n";
		file << "    pANTLR3_BASE_TREE NAME334_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal335_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NAME;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_103;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal332       = NULL;\n";
		file << "    string_literal333       = NULL;\n";
		file << "    NAME334       = NULL;\n";
		file << "    char_literal335       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal332_tree   = NULL;\n";
		file << "    string_literal333_tree   = NULL;\n";
		file << "    NAME334_tree   = NULL;\n";
		file << "    char_literal335_tree   = NULL;\n";
		file << "\n";
		file << "    stream_NAME   = NULL;\n";
		file << "    #define CREATE_stream_NAME  if (stream_NAME == NULL) {stream_NAME = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token NAME\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_103   = NULL;\n";
		file << "    #define CREATE_stream_103  if (stream_103 == NULL) {stream_103 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 103\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:422:2: ( '(' ':domain' NAME ')' -> ^( PROBLEM_DOMAIN NAME ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:422:4: '(' ':domain' NAME ')'\n";
		file << "        {\n";
		file << "            char_literal332 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_problemDomain2589);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemDomainEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal332, NULL); }\n";
		file << "\n";
		file << "            string_literal333 = (pANTLR3_COMMON_TOKEN) MATCHT(103, &FOLLOW_103_in_problemDomain2591);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemDomainEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_103; stream_103->add(stream_103, string_literal333, NULL); }\n";
		file << "\n";
		file << "            NAME334 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_problemDomain2593);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemDomainEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_NAME; stream_NAME->add(stream_NAME, NAME334, NULL); }\n";
		file << "\n";
		file << "            char_literal335 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_problemDomain2595);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleproblemDomainEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal335, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : NAME\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 423:2: -> ^( PROBLEM_DOMAIN NAME )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:423:5: ^( PROBLEM_DOMAIN NAME )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PROBLEM_DOMAIN, (pANTLR3_UINT8)\"PROBLEM_DOMAIN\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_NAME == NULL ? NULL : stream_NAME->nextNode(stream_NAME));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleproblemDomainEx; /* Prevent compiler warnings */\n";
		file << "    ruleproblemDomainEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_NAME != NULL) stream_NAME->free(stream_NAME);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_103 != NULL) stream_103->free(stream_103);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end problemDomain */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start objectDecl\n";
		file << " * ../../model/subgoal_learning/Pddl.g:426:1: objectDecl : '(' ':objects' typedNameList ')' -> ^( OBJECTS typedNameList ) ;\n";
		file << " */\n";
		file << "static PddlParser_objectDecl_return\n";
		file << "objectDecl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_objectDecl_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal336;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal337;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal339;\n";
		file << "    PddlParser_typedNameList_return typedNameList338;\n";
		file << "    #undef	RETURN_TYPE_typedNameList338\n";
		file << "    #define	RETURN_TYPE_typedNameList338 PddlParser_typedNameList_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal336_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal337_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal339_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_104;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_typedNameList;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal336       = NULL;\n";
		file << "    string_literal337       = NULL;\n";
		file << "    char_literal339       = NULL;\n";
		file << "    typedNameList338.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal336_tree   = NULL;\n";
		file << "    string_literal337_tree   = NULL;\n";
		file << "    char_literal339_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_104   = NULL;\n";
		file << "    #define CREATE_stream_104  if (stream_104 == NULL) {stream_104 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 104\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_typedNameList   = NULL;\n";
		file << "    #define CREATE_stream_typedNameList  if (stream_typedNameList == NULL) {stream_typedNameList = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule typedNameList\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:427:2: ( '(' ':objects' typedNameList ')' -> ^( OBJECTS typedNameList ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:427:4: '(' ':objects' typedNameList ')'\n";
		file << "        {\n";
		file << "            char_literal336 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_objectDecl2615);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleobjectDeclEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal336, NULL); }\n";
		file << "\n";
		file << "            string_literal337 = (pANTLR3_COMMON_TOKEN) MATCHT(104, &FOLLOW_104_in_objectDecl2617);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleobjectDeclEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_104; stream_104->add(stream_104, string_literal337, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_typedNameList_in_objectDecl2619);\n";
		file << "            typedNameList338=typedNameList(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleobjectDeclEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_typedNameList; stream_typedNameList->add(stream_typedNameList, typedNameList338.tree, NULL); }\n";
		file << "            char_literal339 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_objectDecl2621);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleobjectDeclEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal339, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : typedNameList\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 428:2: -> ^( OBJECTS typedNameList )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:428:5: ^( OBJECTS typedNameList )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, OBJECTS, (pANTLR3_UINT8)\"OBJECTS\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_typedNameList == NULL ? NULL : stream_typedNameList->nextTree(stream_typedNameList));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleobjectDeclEx; /* Prevent compiler warnings */\n";
		file << "    ruleobjectDeclEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_104 != NULL) stream_104->free(stream_104);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_typedNameList != NULL) stream_typedNameList->free(stream_typedNameList);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end objectDecl */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start init\n";
		file << " * ../../model/subgoal_learning/Pddl.g:431:1: init : '(' ':init' ( initEl )* ')' -> ^( INIT ( initEl )* ) ;\n";
		file << " */\n";
		file << "static PddlParser_init_return\n";
		file << "init(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_init_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal340;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal341;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal343;\n";
		file << "    PddlParser_initEl_return initEl342;\n";
		file << "    #undef	RETURN_TYPE_initEl342\n";
		file << "    #define	RETURN_TYPE_initEl342 PddlParser_initEl_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal340_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal341_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal343_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_105;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_initEl;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal340       = NULL;\n";
		file << "    string_literal341       = NULL;\n";
		file << "    char_literal343       = NULL;\n";
		file << "    initEl342.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal340_tree   = NULL;\n";
		file << "    string_literal341_tree   = NULL;\n";
		file << "    char_literal343_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_105   = NULL;\n";
		file << "    #define CREATE_stream_105  if (stream_105 == NULL) {stream_105 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 105\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_initEl   = NULL;\n";
		file << "    #define CREATE_stream_initEl  if (stream_initEl == NULL) {stream_initEl = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule initEl\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:432:2: ( '(' ':init' ( initEl )* ')' -> ^( INIT ( initEl )* ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:432:4: '(' ':init' ( initEl )* ')'\n";
		file << "        {\n";
		file << "            char_literal340 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_init2641);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleinitEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal340, NULL); }\n";
		file << "\n";
		file << "            string_literal341 = (pANTLR3_COMMON_TOKEN) MATCHT(105, &FOLLOW_105_in_init2643);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleinitEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_105; stream_105->add(stream_105, string_literal341, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:432:16: ( initEl )*\n";
		file << "\n";
		file << "            for (;;)\n";
		file << "            {\n";
		file << "                int alt68=2;\n";
		file << "                {\n";
		file << "                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                    */\n";
		file << "                    int LA68_0 = LA(1);\n";
		file << "                    if ( (LA68_0 == 54) )\n";
		file << "                    {\n";
		file << "                        alt68=1;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                switch (alt68)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: initEl\n";
		file << "            	    {\n";
		file << "            	        FOLLOWPUSH(FOLLOW_initEl_in_init2645);\n";
		file << "            	        initEl342=initEl(ctx);\n";
		file << "\n";
		file << "            	        FOLLOWPOP();\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleinitEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_initEl; stream_initEl->add(stream_initEl, initEl342.tree, NULL); }\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "            	default:\n";
		file << "            	    goto loop68;	/* break out of the loop */\n";
		file << "            	    break;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            loop68: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "            char_literal343 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_init2648);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleinitEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal343, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : initEl\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 433:2: -> ^( INIT ( initEl )* )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:433:5: ^( INIT ( initEl )* )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, INIT, (pANTLR3_UINT8)\"INIT\"), root_1));\n";
		file << "\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:433:12: ( initEl )*\n";
		file << "            	        {\n";
		file << "            	        	while ( (stream_initEl != NULL && stream_initEl->hasNext(stream_initEl))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_initEl == NULL ? NULL : stream_initEl->nextTree(stream_initEl));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if (stream_initEl != NULL) stream_initEl->reset(stream_initEl);\n";
		file << "\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleinitEx; /* Prevent compiler warnings */\n";
		file << "    ruleinitEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_105 != NULL) stream_105->free(stream_105);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_initEl != NULL) stream_initEl->free(stream_initEl);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end init */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start initEl\n";
		file << " * ../../model/subgoal_learning/Pddl.g:436:1: initEl : ( nameLiteral | '(' '=' fHead NUMBER ')' -> ^( INIT_EQ fHead NUMBER ) | '(' 'at' NUMBER nameLiteral ')' -> ^( INIT_AT NUMBER nameLiteral ) );\n";
		file << " */\n";
		file << "static PddlParser_initEl_return\n";
		file << "initEl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_initEl_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal345;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal346;\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER348;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal349;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal350;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal351;\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER352;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal354;\n";
		file << "    PddlParser_nameLiteral_return nameLiteral344;\n";
		file << "    #undef	RETURN_TYPE_nameLiteral344\n";
		file << "    #define	RETURN_TYPE_nameLiteral344 PddlParser_nameLiteral_return\n";
		file << "\n";
		file << "    PddlParser_fHead_return fHead347;\n";
		file << "    #undef	RETURN_TYPE_fHead347\n";
		file << "    #define	RETURN_TYPE_fHead347 PddlParser_fHead_return\n";
		file << "\n";
		file << "    PddlParser_nameLiteral_return nameLiteral353;\n";
		file << "    #undef	RETURN_TYPE_nameLiteral353\n";
		file << "    #define	RETURN_TYPE_nameLiteral353 PddlParser_nameLiteral_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal345_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal346_tree;\n";
		file << "    pANTLR3_BASE_TREE NUMBER348_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal349_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal350_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal351_tree;\n";
		file << "    pANTLR3_BASE_TREE NUMBER352_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal354_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_93;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_81;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NUMBER;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_fHead;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_nameLiteral;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal345       = NULL;\n";
		file << "    char_literal346       = NULL;\n";
		file << "    NUMBER348       = NULL;\n";
		file << "    char_literal349       = NULL;\n";
		file << "    char_literal350       = NULL;\n";
		file << "    string_literal351       = NULL;\n";
		file << "    NUMBER352       = NULL;\n";
		file << "    char_literal354       = NULL;\n";
		file << "    nameLiteral344.tree = NULL;\n";
		file << "\n";
		file << "    fHead347.tree = NULL;\n";
		file << "\n";
		file << "    nameLiteral353.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal345_tree   = NULL;\n";
		file << "    char_literal346_tree   = NULL;\n";
		file << "    NUMBER348_tree   = NULL;\n";
		file << "    char_literal349_tree   = NULL;\n";
		file << "    char_literal350_tree   = NULL;\n";
		file << "    string_literal351_tree   = NULL;\n";
		file << "    NUMBER352_tree   = NULL;\n";
		file << "    char_literal354_tree   = NULL;\n";
		file << "\n";
		file << "    stream_93   = NULL;\n";
		file << "    #define CREATE_stream_93  if (stream_93 == NULL) {stream_93 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 93\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_81   = NULL;\n";
		file << "    #define CREATE_stream_81  if (stream_81 == NULL) {stream_81 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 81\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_NUMBER   = NULL;\n";
		file << "    #define CREATE_stream_NUMBER  if (stream_NUMBER == NULL) {stream_NUMBER = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token NUMBER\"); }\n";
		file << "    stream_fHead   = NULL;\n";
		file << "    #define CREATE_stream_fHead  if (stream_fHead == NULL) {stream_fHead = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule fHead\"); }\n";
		file << "    stream_nameLiteral   = NULL;\n";
		file << "    #define CREATE_stream_nameLiteral  if (stream_nameLiteral == NULL) {stream_nameLiteral = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule nameLiteral\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:437:2: ( nameLiteral | '(' '=' fHead NUMBER ')' -> ^( INIT_EQ fHead NUMBER ) | '(' 'at' NUMBER nameLiteral ')' -> ^( INIT_AT NUMBER nameLiteral ) )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt69;\n";
		file << "\n";
		file << "            alt69=3;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA69_0 = LA(1);\n";
		file << "                if ( (LA69_0 == 54) )\n";
		file << "                {\n";
		file << "                    switch ( LA(2) )\n";
		file << "                    {\n";
		file << "                    case NAME:\n";
		file << "                    case 73:\n";
		file << "                    	{\n";
		file << "                    		alt69=1;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 93:\n";
		file << "                    	{\n";
		file << "                    		alt69=2;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "                    case 81:\n";
		file << "                    	{\n";
		file << "                    		alt69=3;\n";
		file << "                    	}\n";
		file << "                        break;\n";
		file << "\n";
		file << "                    default:\n";
		file << "                        if (BACKTRACKING>0)\n";
		file << "                        {\n";
		file << "                            FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                            return retval;\n";
		file << "                        }\n";
		file << "                        CONSTRUCTEX();\n";
		file << "                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                        EXCEPTION->message      = (void *)\"\";\n";
		file << "                        EXCEPTION->decisionNum  = 69;\n";
		file << "                        EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                        goto ruleinitElEx;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 69;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruleinitElEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt69)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:437:4: nameLiteral\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_nameLiteral_in_initEl2669);\n";
		file << "        	        nameLiteral344=nameLiteral(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, nameLiteral344.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:438:4: '(' '=' fHead NUMBER ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal345 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_initEl2674);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal345, NULL); }\n";
		file << "\n";
		file << "        	        char_literal346 = (pANTLR3_COMMON_TOKEN) MATCHT(93, &FOLLOW_93_in_initEl2676);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_93; stream_93->add(stream_93, char_literal346, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_fHead_in_initEl2678);\n";
		file << "        	        fHead347=fHead(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_fHead; stream_fHead->add(stream_fHead, fHead347.tree, NULL); }\n";
		file << "        	        NUMBER348 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_initEl2680);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_NUMBER; stream_NUMBER->add(stream_NUMBER, NUMBER348, NULL); }\n";
		file << "\n";
		file << "        	        char_literal349 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_initEl2682);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal349, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : fHead, NUMBER\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 438:37: -> ^( INIT_EQ fHead NUMBER )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:438:40: ^( INIT_EQ fHead NUMBER )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, INIT_EQ, (pANTLR3_UINT8)\"INIT_EQ\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_fHead == NULL ? NULL : stream_fHead->nextTree(stream_fHead));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_NUMBER == NULL ? NULL : stream_NUMBER->nextNode(stream_NUMBER));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:439:4: '(' 'at' NUMBER nameLiteral ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal350 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_initEl2705);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal350, NULL); }\n";
		file << "\n";
		file << "        	        string_literal351 = (pANTLR3_COMMON_TOKEN) MATCHT(81, &FOLLOW_81_in_initEl2707);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_81; stream_81->add(stream_81, string_literal351, NULL); }\n";
		file << "\n";
		file << "        	        NUMBER352 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_initEl2709);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_NUMBER; stream_NUMBER->add(stream_NUMBER, NUMBER352, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_nameLiteral_in_initEl2711);\n";
		file << "        	        nameLiteral353=nameLiteral(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_nameLiteral; stream_nameLiteral->add(stream_nameLiteral, nameLiteral353.tree, NULL); }\n";
		file << "        	        char_literal354 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_initEl2713);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleinitElEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal354, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : nameLiteral, NUMBER\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 439:37: -> ^( INIT_AT NUMBER nameLiteral )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:439:40: ^( INIT_AT NUMBER nameLiteral )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, INIT_AT, (pANTLR3_UINT8)\"INIT_AT\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_NUMBER == NULL ? NULL : stream_NUMBER->nextNode(stream_NUMBER));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_nameLiteral == NULL ? NULL : stream_nameLiteral->nextTree(stream_nameLiteral));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleinitElEx; /* Prevent compiler warnings */\n";
		file << "    ruleinitElEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_93 != NULL) stream_93->free(stream_93);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_81 != NULL) stream_81->free(stream_81);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_NUMBER != NULL) stream_NUMBER->free(stream_NUMBER);\n";
		file << "        if (stream_fHead != NULL) stream_fHead->free(stream_fHead);\n";
		file << "        if (stream_nameLiteral != NULL) stream_nameLiteral->free(stream_nameLiteral);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end initEl */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start nameLiteral\n";
		file << " * ../../model/subgoal_learning/Pddl.g:442:1: nameLiteral : ( atomicNameFormula | '(' 'not' atomicNameFormula ')' -> ^( NOT_PRED_INIT atomicNameFormula ) );\n";
		file << " */\n";
		file << "static PddlParser_nameLiteral_return\n";
		file << "nameLiteral(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_nameLiteral_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal356;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal357;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal359;\n";
		file << "    PddlParser_atomicNameFormula_return atomicNameFormula355;\n";
		file << "    #undef	RETURN_TYPE_atomicNameFormula355\n";
		file << "    #define	RETURN_TYPE_atomicNameFormula355 PddlParser_atomicNameFormula_return\n";
		file << "\n";
		file << "    PddlParser_atomicNameFormula_return atomicNameFormula358;\n";
		file << "    #undef	RETURN_TYPE_atomicNameFormula358\n";
		file << "    #define	RETURN_TYPE_atomicNameFormula358 PddlParser_atomicNameFormula_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal356_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal357_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal359_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_73;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_atomicNameFormula;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal356       = NULL;\n";
		file << "    string_literal357       = NULL;\n";
		file << "    char_literal359       = NULL;\n";
		file << "    atomicNameFormula355.tree = NULL;\n";
		file << "\n";
		file << "    atomicNameFormula358.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal356_tree   = NULL;\n";
		file << "    string_literal357_tree   = NULL;\n";
		file << "    char_literal359_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_73   = NULL;\n";
		file << "    #define CREATE_stream_73  if (stream_73 == NULL) {stream_73 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 73\"); }\n";
		file << "    stream_atomicNameFormula   = NULL;\n";
		file << "    #define CREATE_stream_atomicNameFormula  if (stream_atomicNameFormula == NULL) {stream_atomicNameFormula = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule atomicNameFormula\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:443:2: ( atomicNameFormula | '(' 'not' atomicNameFormula ')' -> ^( NOT_PRED_INIT atomicNameFormula ) )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt70;\n";
		file << "\n";
		file << "            alt70=2;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA70_0 = LA(1);\n";
		file << "                if ( (LA70_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA70_1 = LA(2);\n";
		file << "                        if ( (LA70_1 == 73) )\n";
		file << "                        {\n";
		file << "                            alt70=2;\n";
		file << "                        }\n";
		file << "                        else if ( (LA70_1 == NAME) )\n";
		file << "                        {\n";
		file << "                            alt70=1;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 70;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto rulenameLiteralEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 70;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto rulenameLiteralEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt70)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:443:4: atomicNameFormula\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_atomicNameFormula_in_nameLiteral2735);\n";
		file << "        	        atomicNameFormula355=atomicNameFormula(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulenameLiteralEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, atomicNameFormula355.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:444:4: '(' 'not' atomicNameFormula ')'\n";
		file << "        	    {\n";
		file << "        	        char_literal356 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_nameLiteral2740);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulenameLiteralEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal356, NULL); }\n";
		file << "\n";
		file << "        	        string_literal357 = (pANTLR3_COMMON_TOKEN) MATCHT(73, &FOLLOW_73_in_nameLiteral2742);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulenameLiteralEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_73; stream_73->add(stream_73, string_literal357, NULL); }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_atomicNameFormula_in_nameLiteral2744);\n";
		file << "        	        atomicNameFormula358=atomicNameFormula(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulenameLiteralEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_atomicNameFormula; stream_atomicNameFormula->add(stream_atomicNameFormula, atomicNameFormula358.tree, NULL); }\n";
		file << "        	        char_literal359 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_nameLiteral2746);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulenameLiteralEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal359, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "        	        /* AST REWRITE\n";
		file << "        	         * elements          : atomicNameFormula\n";
		file << "        	         * token labels      :\n";
		file << "        	         * rule labels       : retval\n";
		file << "        	         * token list labels :\n";
		file << "        	         * rule list labels  :\n";
		file << "        	         */\n";
		file << "        	        if ( BACKTRACKING==0 )\n";
		file << "        	        {\n";
		file << "        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	retval.tree    = root_0;\n";
		file << "        	        	// 444:36: -> ^( NOT_PRED_INIT atomicNameFormula )\n";
		file << "        	        	{\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:444:39: ^( NOT_PRED_INIT atomicNameFormula )\n";
		file << "        	        	    {\n";
		file << "        	        	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "        	        	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, NOT_PRED_INIT, (pANTLR3_UINT8)\"NOT_PRED_INIT\"), root_1));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_1, stream_atomicNameFormula == NULL ? NULL : stream_atomicNameFormula->nextTree(stream_atomicNameFormula));\n";
		file << "\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "\n";
		file << "        	        	retval.tree = root_0; // set result root\n";
		file << "        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulenameLiteralEx; /* Prevent compiler warnings */\n";
		file << "    rulenameLiteralEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_73 != NULL) stream_73->free(stream_73);\n";
		file << "        if (stream_atomicNameFormula != NULL) stream_atomicNameFormula->free(stream_atomicNameFormula);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end nameLiteral */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start atomicNameFormula\n";
		file << " * ../../model/subgoal_learning/Pddl.g:447:1: atomicNameFormula : '(' predicate ( NAME )* ')' -> ^( PRED_INST predicate ( NAME )* ) ;\n";
		file << " */\n";
		file << "static PddlParser_atomicNameFormula_return\n";
		file << "atomicNameFormula(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_atomicNameFormula_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal360;\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME362;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal363;\n";
		file << "    PddlParser_predicate_return predicate361;\n";
		file << "    #undef	RETURN_TYPE_predicate361\n";
		file << "    #define	RETURN_TYPE_predicate361 PddlParser_predicate_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal360_tree;\n";
		file << "    pANTLR3_BASE_TREE NAME362_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal363_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_NAME;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_predicate;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal360       = NULL;\n";
		file << "    NAME362       = NULL;\n";
		file << "    char_literal363       = NULL;\n";
		file << "    predicate361.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal360_tree   = NULL;\n";
		file << "    NAME362_tree   = NULL;\n";
		file << "    char_literal363_tree   = NULL;\n";
		file << "\n";
		file << "    stream_NAME   = NULL;\n";
		file << "    #define CREATE_stream_NAME  if (stream_NAME == NULL) {stream_NAME = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token NAME\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_predicate   = NULL;\n";
		file << "    #define CREATE_stream_predicate  if (stream_predicate == NULL) {stream_predicate = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule predicate\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:448:2: ( '(' predicate ( NAME )* ')' -> ^( PRED_INST predicate ( NAME )* ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:448:4: '(' predicate ( NAME )* ')'\n";
		file << "        {\n";
		file << "            char_literal360 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_atomicNameFormula2765);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicNameFormulaEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal360, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_predicate_in_atomicNameFormula2767);\n";
		file << "            predicate361=predicate(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicNameFormulaEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_predicate; stream_predicate->add(stream_predicate, predicate361.tree, NULL); }\n";
		file << "\n";
		file << "            // ../../model/subgoal_learning/Pddl.g:448:18: ( NAME )*\n";
		file << "\n";
		file << "            for (;;)\n";
		file << "            {\n";
		file << "                int alt71=2;\n";
		file << "                {\n";
		file << "                   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                    */\n";
		file << "                    int LA71_0 = LA(1);\n";
		file << "                    if ( (LA71_0 == NAME) )\n";
		file << "                    {\n";
		file << "                        alt71=1;\n";
		file << "                    }\n";
		file << "\n";
		file << "                }\n";
		file << "                switch (alt71)\n";
		file << "                {\n";
		file << "            	case 1:\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:0:0: NAME\n";
		file << "            	    {\n";
		file << "            	        NAME362 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_atomicNameFormula2769);\n";
		file << "            	        if  (HASEXCEPTION())\n";
		file << "            	        {\n";
		file << "            	            goto ruleatomicNameFormulaEx;\n";
		file << "            	        }\n";
		file << "            	        if (HASFAILED())\n";
		file << "            	        {\n";
		file << "            	            return retval;\n";
		file << "            	        }\n";
		file << "            	        if ( BACKTRACKING==0 ) { CREATE_stream_NAME; stream_NAME->add(stream_NAME, NAME362, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "            	    }\n";
		file << "            	    break;\n";
		file << "\n";
		file << "            	default:\n";
		file << "            	    goto loop71;	/* break out of the loop */\n";
		file << "            	    break;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            loop71: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "            char_literal363 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_atomicNameFormula2772);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleatomicNameFormulaEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal363, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : NAME, predicate\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 448:28: -> ^( PRED_INST predicate ( NAME )* )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:448:31: ^( PRED_INST predicate ( NAME )* )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PRED_INST, (pANTLR3_UINT8)\"PRED_INST\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_predicate == NULL ? NULL : stream_predicate->nextTree(stream_predicate));\n";
		file << "            	        // ../../model/subgoal_learning/Pddl.g:448:53: ( NAME )*\n";
		file << "            	        {\n";
		file << "            	        	while ( (stream_NAME != NULL && stream_NAME->hasNext(stream_NAME))  )\n";
		file << "            	        	{\n";
		file << "            	        		ADAPTOR->addChild(ADAPTOR, root_1, stream_NAME == NULL ? NULL : stream_NAME->nextNode(stream_NAME));\n";
		file << "\n";
		file << "            	        	}\n";
		file << "            	        	if (stream_NAME != NULL) stream_NAME->reset(stream_NAME);\n";
		file << "\n";
		file << "            	        }\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleatomicNameFormulaEx; /* Prevent compiler warnings */\n";
		file << "    ruleatomicNameFormulaEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_NAME != NULL) stream_NAME->free(stream_NAME);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_predicate != NULL) stream_predicate->free(stream_predicate);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end atomicNameFormula */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start goal\n";
		file << " * ../../model/subgoal_learning/Pddl.g:455:1: goal : '(' ':goal' goalDesc ')' -> ^( GOAL goalDesc ) ;\n";
		file << " */\n";
		file << "static PddlParser_goal_return\n";
		file << "goal(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_goal_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal364;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal365;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal367;\n";
		file << "    PddlParser_goalDesc_return goalDesc366;\n";
		file << "    #undef	RETURN_TYPE_goalDesc366\n";
		file << "    #define	RETURN_TYPE_goalDesc366 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal364_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal365_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal367_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_106;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_goalDesc;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal364       = NULL;\n";
		file << "    string_literal365       = NULL;\n";
		file << "    char_literal367       = NULL;\n";
		file << "    goalDesc366.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal364_tree   = NULL;\n";
		file << "    string_literal365_tree   = NULL;\n";
		file << "    char_literal367_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_106   = NULL;\n";
		file << "    #define CREATE_stream_106  if (stream_106 == NULL) {stream_106 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 106\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_goalDesc   = NULL;\n";
		file << "    #define CREATE_stream_goalDesc  if (stream_goalDesc == NULL) {stream_goalDesc = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule goalDesc\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:455:6: ( '(' ':goal' goalDesc ')' -> ^( GOAL goalDesc ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:455:8: '(' ':goal' goalDesc ')'\n";
		file << "        {\n";
		file << "            char_literal364 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_goal2797);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulegoalEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal364, NULL); }\n";
		file << "\n";
		file << "            string_literal365 = (pANTLR3_COMMON_TOKEN) MATCHT(106, &FOLLOW_106_in_goal2799);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulegoalEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_106; stream_106->add(stream_106, string_literal365, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_goalDesc_in_goal2801);\n";
		file << "            goalDesc366=goalDesc(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulegoalEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_goalDesc; stream_goalDesc->add(stream_goalDesc, goalDesc366.tree, NULL); }\n";
		file << "            char_literal367 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_goal2803);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulegoalEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal367, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : goalDesc\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 455:33: -> ^( GOAL goalDesc )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:455:36: ^( GOAL goalDesc )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, GOAL, (pANTLR3_UINT8)\"GOAL\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_goalDesc == NULL ? NULL : stream_goalDesc->nextTree(stream_goalDesc));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulegoalEx; /* Prevent compiler warnings */\n";
		file << "    rulegoalEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_106 != NULL) stream_106->free(stream_106);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_goalDesc != NULL) stream_goalDesc->free(stream_goalDesc);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end goal */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start probConstraints\n";
		file << " * ../../model/subgoal_learning/Pddl.g:457:1: probConstraints : '(' ':constraints' prefConGD ')' -> ^( PROBLEM_CONSTRAINT prefConGD ) ;\n";
		file << " */\n";
		file << "static PddlParser_probConstraints_return\n";
		file << "probConstraints(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_probConstraints_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal368;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal369;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal371;\n";
		file << "    PddlParser_prefConGD_return prefConGD370;\n";
		file << "    #undef	RETURN_TYPE_prefConGD370\n";
		file << "    #define	RETURN_TYPE_prefConGD370 PddlParser_prefConGD_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal368_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal369_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal371_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_66;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_prefConGD;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal368       = NULL;\n";
		file << "    string_literal369       = NULL;\n";
		file << "    char_literal371       = NULL;\n";
		file << "    prefConGD370.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal368_tree   = NULL;\n";
		file << "    string_literal369_tree   = NULL;\n";
		file << "    char_literal371_tree   = NULL;\n";
		file << "\n";
		file << "    stream_66   = NULL;\n";
		file << "    #define CREATE_stream_66  if (stream_66 == NULL) {stream_66 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 66\"); }\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_prefConGD   = NULL;\n";
		file << "    #define CREATE_stream_prefConGD  if (stream_prefConGD == NULL) {stream_prefConGD = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule prefConGD\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:458:2: ( '(' ':constraints' prefConGD ')' -> ^( PROBLEM_CONSTRAINT prefConGD ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:458:4: '(' ':constraints' prefConGD ')'\n";
		file << "        {\n";
		file << "            char_literal368 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_probConstraints2821);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleprobConstraintsEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal368, NULL); }\n";
		file << "\n";
		file << "            string_literal369 = (pANTLR3_COMMON_TOKEN) MATCHT(66, &FOLLOW_66_in_probConstraints2823);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleprobConstraintsEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_66; stream_66->add(stream_66, string_literal369, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_prefConGD_in_probConstraints2826);\n";
		file << "            prefConGD370=prefConGD(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleprobConstraintsEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_prefConGD; stream_prefConGD->add(stream_prefConGD, prefConGD370.tree, NULL); }\n";
		file << "            char_literal371 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_probConstraints2828);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleprobConstraintsEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal371, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : prefConGD\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 459:4: -> ^( PROBLEM_CONSTRAINT prefConGD )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:459:7: ^( PROBLEM_CONSTRAINT prefConGD )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PROBLEM_CONSTRAINT, (pANTLR3_UINT8)\"PROBLEM_CONSTRAINT\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_prefConGD == NULL ? NULL : stream_prefConGD->nextTree(stream_prefConGD));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleprobConstraintsEx; /* Prevent compiler warnings */\n";
		file << "    ruleprobConstraintsEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_66 != NULL) stream_66->free(stream_66);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_prefConGD != NULL) stream_prefConGD->free(stream_prefConGD);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end probConstraints */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start prefConGD\n";
		file << " * ../../model/subgoal_learning/Pddl.g:462:1: prefConGD : ( '(' 'and' ( prefConGD )* ')' | '(' 'forall' '(' typedVariableList ')' prefConGD ')' | '(' 'preference' ( NAME )? conGD ')' | conGD );\n";
		file << " */\n";
		file << "static PddlParser_prefConGD_return\n";
		file << "prefConGD(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_prefConGD_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal372;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal373;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal375;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal376;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal377;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal378;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal380;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal382;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal383;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal384;\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME385;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal387;\n";
		file << "    PddlParser_prefConGD_return prefConGD374;\n";
		file << "    #undef	RETURN_TYPE_prefConGD374\n";
		file << "    #define	RETURN_TYPE_prefConGD374 PddlParser_prefConGD_return\n";
		file << "\n";
		file << "    PddlParser_typedVariableList_return typedVariableList379;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList379\n";
		file << "    #define	RETURN_TYPE_typedVariableList379 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_prefConGD_return prefConGD381;\n";
		file << "    #undef	RETURN_TYPE_prefConGD381\n";
		file << "    #define	RETURN_TYPE_prefConGD381 PddlParser_prefConGD_return\n";
		file << "\n";
		file << "    PddlParser_conGD_return conGD386;\n";
		file << "    #undef	RETURN_TYPE_conGD386\n";
		file << "    #define	RETURN_TYPE_conGD386 PddlParser_conGD_return\n";
		file << "\n";
		file << "    PddlParser_conGD_return conGD388;\n";
		file << "    #undef	RETURN_TYPE_conGD388\n";
		file << "    #define	RETURN_TYPE_conGD388 PddlParser_conGD_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal372_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal373_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal375_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal376_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal377_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal378_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal380_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal382_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal383_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal384_tree;\n";
		file << "    pANTLR3_BASE_TREE NAME385_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal387_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal372       = NULL;\n";
		file << "    string_literal373       = NULL;\n";
		file << "    char_literal375       = NULL;\n";
		file << "    char_literal376       = NULL;\n";
		file << "    string_literal377       = NULL;\n";
		file << "    char_literal378       = NULL;\n";
		file << "    char_literal380       = NULL;\n";
		file << "    char_literal382       = NULL;\n";
		file << "    char_literal383       = NULL;\n";
		file << "    string_literal384       = NULL;\n";
		file << "    NAME385       = NULL;\n";
		file << "    char_literal387       = NULL;\n";
		file << "    prefConGD374.tree = NULL;\n";
		file << "\n";
		file << "    typedVariableList379.tree = NULL;\n";
		file << "\n";
		file << "    prefConGD381.tree = NULL;\n";
		file << "\n";
		file << "    conGD386.tree = NULL;\n";
		file << "\n";
		file << "    conGD388.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal372_tree   = NULL;\n";
		file << "    string_literal373_tree   = NULL;\n";
		file << "    char_literal375_tree   = NULL;\n";
		file << "    char_literal376_tree   = NULL;\n";
		file << "    string_literal377_tree   = NULL;\n";
		file << "    char_literal378_tree   = NULL;\n";
		file << "    char_literal380_tree   = NULL;\n";
		file << "    char_literal382_tree   = NULL;\n";
		file << "    char_literal383_tree   = NULL;\n";
		file << "    string_literal384_tree   = NULL;\n";
		file << "    NAME385_tree   = NULL;\n";
		file << "    char_literal387_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:463:2: ( '(' 'and' ( prefConGD )* ')' | '(' 'forall' '(' typedVariableList ')' prefConGD ')' | '(' 'preference' ( NAME )? conGD ')' | conGD )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt74;\n";
		file << "\n";
		file << "            alt74=4;\n";
		file << "\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA74_0 = LA(1);\n";
		file << "                if ( (LA74_0 == 54) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA74_1 = LA(2);\n";
		file << "                        if ( (synpred109_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt74=1;\n";
		file << "                        }\n";
		file << "                        else if ( (synpred110_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt74=2;\n";
		file << "                        }\n";
		file << "                        else if ( (synpred112_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt74=3;\n";
		file << "                        }\n";
		file << "                        else if ( (ANTLR3_TRUE) )\n";
		file << "                        {\n";
		file << "                            alt74=4;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return retval;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 74;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto ruleprefConGDEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return retval;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 74;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto ruleprefConGDEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt74)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:463:4: '(' 'and' ( prefConGD )* ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal372 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_prefConGD2850);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal372_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal372));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal372_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal373 = (pANTLR3_COMMON_TOKEN) MATCHT(71, &FOLLOW_71_in_prefConGD2852);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal373_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal373));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal373_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:463:14: ( prefConGD )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt72=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA72_0 = LA(1);\n";
		file << "        	                if ( (LA72_0 == 54) )\n";
		file << "        	                {\n";
		file << "        	                    alt72=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt72)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: prefConGD\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_prefConGD_in_prefConGD2854);\n";
		file << "        	        	        prefConGD374=prefConGD(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto ruleprefConGDEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, prefConGD374.tree);\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop72;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop72: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal375 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_prefConGD2857);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal375_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal375));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal375_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:464:4: '(' 'forall' '(' typedVariableList ')' prefConGD ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal376 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_prefConGD2862);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal376_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal376));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal376_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal377 = (pANTLR3_COMMON_TOKEN) MATCHT(76, &FOLLOW_76_in_prefConGD2864);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal377_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal377));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal377_tree);\n";
		file << "        	        }\n";
		file << "        	        char_literal378 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_prefConGD2866);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal378_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal378));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal378_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_typedVariableList_in_prefConGD2868);\n";
		file << "        	        typedVariableList379=typedVariableList(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typedVariableList379.tree);\n";
		file << "        	        char_literal380 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_prefConGD2870);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal380_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal380));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal380_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_prefConGD_in_prefConGD2872);\n";
		file << "        	        prefConGD381=prefConGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, prefConGD381.tree);\n";
		file << "        	        char_literal382 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_prefConGD2874);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal382_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal382));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal382_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:465:4: '(' 'preference' ( NAME )? conGD ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal383 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_prefConGD2879);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal383_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal383));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal383_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal384 = (pANTLR3_COMMON_TOKEN) MATCHT(80, &FOLLOW_80_in_prefConGD2881);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal384_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal384));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal384_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:465:21: ( NAME )?\n";
		file << "        	        {\n";
		file << "        	            int alt73=2;\n";
		file << "        	            {\n";
		file << "        	                int LA73_0 = LA(1);\n";
		file << "        	                if ( (LA73_0 == NAME) )\n";
		file << "        	                {\n";
		file << "        	                    alt73=1;\n";
		file << "        	                }\n";
		file << "        	            }\n";
		file << "        	            switch (alt73)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: NAME\n";
		file << "        	        	    {\n";
		file << "        	        	        NAME385 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_prefConGD2883);\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto ruleprefConGDEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        	        NAME385_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME385));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, NAME385_tree);\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_conGD_in_prefConGD2886);\n";
		file << "        	        conGD386=conGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, conGD386.tree);\n";
		file << "        	        char_literal387 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_prefConGD2888);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal387_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal387));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal387_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 4:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:466:4: conGD\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_conGD_in_prefConGD2893);\n";
		file << "        	        conGD388=conGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleprefConGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, conGD388.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleprefConGDEx; /* Prevent compiler warnings */\n";
		file << "    ruleprefConGDEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end prefConGD */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start metricSpec\n";
		file << " * ../../model/subgoal_learning/Pddl.g:469:1: metricSpec : '(' ':metric' optimization metricFExp ')' -> ^( PROBLEM_METRIC optimization metricFExp ) ;\n";
		file << " */\n";
		file << "static PddlParser_metricSpec_return\n";
		file << "metricSpec(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_metricSpec_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal389;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal390;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal393;\n";
		file << "    PddlParser_optimization_return optimization391;\n";
		file << "    #undef	RETURN_TYPE_optimization391\n";
		file << "    #define	RETURN_TYPE_optimization391 PddlParser_optimization_return\n";
		file << "\n";
		file << "    PddlParser_metricFExp_return metricFExp392;\n";
		file << "    #undef	RETURN_TYPE_metricFExp392\n";
		file << "    #define	RETURN_TYPE_metricFExp392 PddlParser_metricFExp_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal389_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal390_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal393_tree;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_56;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_107;\n";
		file << "    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_54;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_optimization;\n";
		file << "    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_metricFExp;\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal389       = NULL;\n";
		file << "    string_literal390       = NULL;\n";
		file << "    char_literal393       = NULL;\n";
		file << "    optimization391.tree = NULL;\n";
		file << "\n";
		file << "    metricFExp392.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal389_tree   = NULL;\n";
		file << "    string_literal390_tree   = NULL;\n";
		file << "    char_literal393_tree   = NULL;\n";
		file << "\n";
		file << "    stream_56   = NULL;\n";
		file << "    #define CREATE_stream_56  if (stream_56 == NULL) {stream_56 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 56\"); }\n";
		file << "    stream_107   = NULL;\n";
		file << "    #define CREATE_stream_107  if (stream_107 == NULL) {stream_107 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 107\"); }\n";
		file << "    stream_54   = NULL;\n";
		file << "    #define CREATE_stream_54  if (stream_54 == NULL) {stream_54 = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"token 54\"); }\n";
		file << "    stream_optimization   = NULL;\n";
		file << "    #define CREATE_stream_optimization  if (stream_optimization == NULL) {stream_optimization = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule optimization\"); }\n";
		file << "    stream_metricFExp   = NULL;\n";
		file << "    #define CREATE_stream_metricFExp  if (stream_metricFExp == NULL) {stream_metricFExp = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)\"rule metricFExp\"); }\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:470:2: ( '(' ':metric' optimization metricFExp ')' -> ^( PROBLEM_METRIC optimization metricFExp ) )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:470:4: '(' ':metric' optimization metricFExp ')'\n";
		file << "        {\n";
		file << "            char_literal389 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_metricSpec2904);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulemetricSpecEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_54; stream_54->add(stream_54, char_literal389, NULL); }\n";
		file << "\n";
		file << "            string_literal390 = (pANTLR3_COMMON_TOKEN) MATCHT(107, &FOLLOW_107_in_metricSpec2906);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulemetricSpecEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_107; stream_107->add(stream_107, string_literal390, NULL); }\n";
		file << "\n";
		file << "            FOLLOWPUSH(FOLLOW_optimization_in_metricSpec2908);\n";
		file << "            optimization391=optimization(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulemetricSpecEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_optimization; stream_optimization->add(stream_optimization, optimization391.tree, NULL); }\n";
		file << "            FOLLOWPUSH(FOLLOW_metricFExp_in_metricSpec2910);\n";
		file << "            metricFExp392=metricFExp(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulemetricSpecEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_metricFExp; stream_metricFExp->add(stream_metricFExp, metricFExp392.tree, NULL); }\n";
		file << "            char_literal393 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_metricSpec2912);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulemetricSpecEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            if ( BACKTRACKING==0 ) { CREATE_stream_56; stream_56->add(stream_56, char_literal393, NULL); }\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "            /* AST REWRITE\n";
		file << "             * elements          : metricFExp, optimization\n";
		file << "             * token labels      :\n";
		file << "             * rule labels       : retval\n";
		file << "             * token list labels :\n";
		file << "             * rule list labels  :\n";
		file << "             */\n";
		file << "            if ( BACKTRACKING==0 )\n";
		file << "            {\n";
		file << "            	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;\n";
		file << "\n";
		file << "            	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)\"token retval\", retval.tree != NULL ? retval.tree : NULL);\n";
		file << "\n";
		file << "            	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	retval.tree    = root_0;\n";
		file << "            	// 471:4: -> ^( PROBLEM_METRIC optimization metricFExp )\n";
		file << "            	{\n";
		file << "            	    // ../../model/subgoal_learning/Pddl.g:471:7: ^( PROBLEM_METRIC optimization metricFExp )\n";
		file << "            	    {\n";
		file << "            	        pANTLR3_BASE_TREE root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "            	        root_1 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, (pANTLR3_BASE_TREE)ADAPTOR->createTypeText(ADAPTOR, PROBLEM_METRIC, (pANTLR3_UINT8)\"PROBLEM_METRIC\"), root_1));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_optimization == NULL ? NULL : stream_optimization->nextTree(stream_optimization));\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_1, stream_metricFExp == NULL ? NULL : stream_metricFExp->nextTree(stream_metricFExp));\n";
		file << "\n";
		file << "            	        ADAPTOR->addChild(ADAPTOR, root_0, root_1);\n";
		file << "            	    }\n";
		file << "\n";
		file << "            	}\n";
		file << "\n";
		file << "            	retval.tree = root_0; // set result root\n";
		file << "            	if (stream_retval != NULL) stream_retval->free(stream_retval);\n";
		file << "\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulemetricSpecEx; /* Prevent compiler warnings */\n";
		file << "    rulemetricSpecEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "        if (stream_56 != NULL) stream_56->free(stream_56);\n";
		file << "        if (stream_107 != NULL) stream_107->free(stream_107);\n";
		file << "        if (stream_54 != NULL) stream_54->free(stream_54);\n";
		file << "        if (stream_optimization != NULL) stream_optimization->free(stream_optimization);\n";
		file << "        if (stream_metricFExp != NULL) stream_metricFExp->free(stream_metricFExp);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end metricSpec */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start optimization\n";
		file << " * ../../model/subgoal_learning/Pddl.g:474:1: optimization : ( 'minimize' | 'maximize' );\n";
		file << " */\n";
		file << "static PddlParser_optimization_return\n";
		file << "optimization(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_optimization_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    set394;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE set394_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    set394       = NULL;\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    set394_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:474:14: ( 'minimize' | 'maximize' )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:\n";
		file << "        {\n";
		file << "            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "            set394=(pANTLR3_COMMON_TOKEN)LT(1);\n";
		file << "            if ( ((LA(1) >= 108) && (LA(1) <= 109)) )\n";
		file << "            {\n";
		file << "                CONSUME();\n";
		file << "                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set394)));\n";
		file << "                PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;\n";
		file << "\n";
		file << "            }\n";
		file << "            else\n";
		file << "            {\n";
		file << "                if (BACKTRACKING>0)\n";
		file << "                {\n";
		file << "                    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                    return retval;\n";
		file << "                }\n";
		file << "                CONSTRUCTEX();\n";
		file << "                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "                EXCEPTION->expectingSet = &FOLLOW_set_in_optimization0;\n";
		file << "                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_optimization0);    goto ruleoptimizationEx;\n";
		file << "            }\n";
		file << "\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleoptimizationEx; /* Prevent compiler warnings */\n";
		file << "    ruleoptimizationEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end optimization */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start metricFExp\n";
		file << " * ../../model/subgoal_learning/Pddl.g:476:1: metricFExp : ( '(' binaryOp metricFExp metricFExp ')' | '(' ( '*' | '/' ) metricFExp ( metricFExp )+ ')' | '(' '-' metricFExp ')' | NUMBER | '(' functionSymbol ( NAME )* ')' | functionSymbol | 'total-time' | '(' 'is-violated' NAME ')' );\n";
		file << " */\n";
		file << "static PddlParser_metricFExp_return\n";
		file << "metricFExp(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_metricFExp_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal395;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal399;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal400;\n";
		file << "    pANTLR3_COMMON_TOKEN    set401;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal404;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal405;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal406;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal408;\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER409;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal410;\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME412;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal413;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal415;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal416;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal417;\n";
		file << "    pANTLR3_COMMON_TOKEN    NAME418;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal419;\n";
		file << "    PddlParser_binaryOp_return binaryOp396;\n";
		file << "    #undef	RETURN_TYPE_binaryOp396\n";
		file << "    #define	RETURN_TYPE_binaryOp396 PddlParser_binaryOp_return\n";
		file << "\n";
		file << "    PddlParser_metricFExp_return metricFExp397;\n";
		file << "    #undef	RETURN_TYPE_metricFExp397\n";
		file << "    #define	RETURN_TYPE_metricFExp397 PddlParser_metricFExp_return\n";
		file << "\n";
		file << "    PddlParser_metricFExp_return metricFExp398;\n";
		file << "    #undef	RETURN_TYPE_metricFExp398\n";
		file << "    #define	RETURN_TYPE_metricFExp398 PddlParser_metricFExp_return\n";
		file << "\n";
		file << "    PddlParser_metricFExp_return metricFExp402;\n";
		file << "    #undef	RETURN_TYPE_metricFExp402\n";
		file << "    #define	RETURN_TYPE_metricFExp402 PddlParser_metricFExp_return\n";
		file << "\n";
		file << "    PddlParser_metricFExp_return metricFExp403;\n";
		file << "    #undef	RETURN_TYPE_metricFExp403\n";
		file << "    #define	RETURN_TYPE_metricFExp403 PddlParser_metricFExp_return\n";
		file << "\n";
		file << "    PddlParser_metricFExp_return metricFExp407;\n";
		file << "    #undef	RETURN_TYPE_metricFExp407\n";
		file << "    #define	RETURN_TYPE_metricFExp407 PddlParser_metricFExp_return\n";
		file << "\n";
		file << "    PddlParser_functionSymbol_return functionSymbol411;\n";
		file << "    #undef	RETURN_TYPE_functionSymbol411\n";
		file << "    #define	RETURN_TYPE_functionSymbol411 PddlParser_functionSymbol_return\n";
		file << "\n";
		file << "    PddlParser_functionSymbol_return functionSymbol414;\n";
		file << "    #undef	RETURN_TYPE_functionSymbol414\n";
		file << "    #define	RETURN_TYPE_functionSymbol414 PddlParser_functionSymbol_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal395_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal399_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal400_tree;\n";
		file << "    pANTLR3_BASE_TREE set401_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal404_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal405_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal406_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal408_tree;\n";
		file << "    pANTLR3_BASE_TREE NUMBER409_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal410_tree;\n";
		file << "    pANTLR3_BASE_TREE NAME412_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal413_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal415_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal416_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal417_tree;\n";
		file << "    pANTLR3_BASE_TREE NAME418_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal419_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal395       = NULL;\n";
		file << "    char_literal399       = NULL;\n";
		file << "    char_literal400       = NULL;\n";
		file << "    set401       = NULL;\n";
		file << "    char_literal404       = NULL;\n";
		file << "    char_literal405       = NULL;\n";
		file << "    char_literal406       = NULL;\n";
		file << "    char_literal408       = NULL;\n";
		file << "    NUMBER409       = NULL;\n";
		file << "    char_literal410       = NULL;\n";
		file << "    NAME412       = NULL;\n";
		file << "    char_literal413       = NULL;\n";
		file << "    string_literal415       = NULL;\n";
		file << "    char_literal416       = NULL;\n";
		file << "    string_literal417       = NULL;\n";
		file << "    NAME418       = NULL;\n";
		file << "    char_literal419       = NULL;\n";
		file << "    binaryOp396.tree = NULL;\n";
		file << "\n";
		file << "    metricFExp397.tree = NULL;\n";
		file << "\n";
		file << "    metricFExp398.tree = NULL;\n";
		file << "\n";
		file << "    metricFExp402.tree = NULL;\n";
		file << "\n";
		file << "    metricFExp403.tree = NULL;\n";
		file << "\n";
		file << "    metricFExp407.tree = NULL;\n";
		file << "\n";
		file << "    functionSymbol411.tree = NULL;\n";
		file << "\n";
		file << "    functionSymbol414.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal395_tree   = NULL;\n";
		file << "    char_literal399_tree   = NULL;\n";
		file << "    char_literal400_tree   = NULL;\n";
		file << "    set401_tree   = NULL;\n";
		file << "    char_literal404_tree   = NULL;\n";
		file << "    char_literal405_tree   = NULL;\n";
		file << "    char_literal406_tree   = NULL;\n";
		file << "    char_literal408_tree   = NULL;\n";
		file << "    NUMBER409_tree   = NULL;\n";
		file << "    char_literal410_tree   = NULL;\n";
		file << "    NAME412_tree   = NULL;\n";
		file << "    char_literal413_tree   = NULL;\n";
		file << "    string_literal415_tree   = NULL;\n";
		file << "    char_literal416_tree   = NULL;\n";
		file << "    string_literal417_tree   = NULL;\n";
		file << "    NAME418_tree   = NULL;\n";
		file << "    char_literal419_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:477:2: ( '(' binaryOp metricFExp metricFExp ')' | '(' ( '*' | '/' ) metricFExp ( metricFExp )+ ')' | '(' '-' metricFExp ')' | NUMBER | '(' functionSymbol ( NAME )* ')' | functionSymbol | 'total-time' | '(' 'is-violated' NAME ')' )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt77;\n";
		file << "\n";
		file << "            alt77=8;\n";
		file << "\n";
		file << "            alt77 = cdfa77.predict(ctx, RECOGNIZER, ISTREAM, &cdfa77);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulemetricFExpEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            switch (alt77)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:477:4: '(' binaryOp metricFExp metricFExp ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal395 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_metricFExp2949);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal395_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal395));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal395_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_binaryOp_in_metricFExp2951);\n";
		file << "        	        binaryOp396=binaryOp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, binaryOp396.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_metricFExp_in_metricFExp2953);\n";
		file << "        	        metricFExp397=metricFExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, metricFExp397.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_metricFExp_in_metricFExp2955);\n";
		file << "        	        metricFExp398=metricFExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, metricFExp398.tree);\n";
		file << "        	        char_literal399 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_metricFExp2957);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal399_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal399));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal399_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:478:4: '(' ( '*' | '/' ) metricFExp ( metricFExp )+ ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal400 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_metricFExp2962);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal400_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal400));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal400_tree);\n";
		file << "        	        }\n";
		file << "        	        set401=(pANTLR3_COMMON_TOKEN)LT(1);\n";
		file << "        	        if ( LA(1) == 88 || LA(1) == 90 )\n";
		file << "        	        {\n";
		file << "        	            CONSUME();\n";
		file << "        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set401)));\n";
		file << "        	            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	        else\n";
		file << "        	        {\n";
		file << "        	            if (BACKTRACKING>0)\n";
		file << "        	            {\n";
		file << "        	                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	                return retval;\n";
		file << "        	            }\n";
		file << "        	            CONSTRUCTEX();\n";
		file << "        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "        	            EXCEPTION->expectingSet = &FOLLOW_set_in_metricFExp2964;\n";
		file << "        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_metricFExp2964);    goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_metricFExp_in_metricFExp2970);\n";
		file << "        	        metricFExp402=metricFExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, metricFExp402.tree);\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:478:29: ( metricFExp )+\n";
		file << "        	        {\n";
		file << "        	            int cnt75=0;\n";
		file << "\n";
		file << "        	            for (;;)\n";
		file << "        	            {\n";
		file << "        	                int alt75=2;\n";
		file << "        	        	{\n";
		file << "        	        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	        	    */\n";
		file << "        	        	    int LA75_0 = LA(1);\n";
		file << "        	        	    if ( (LA75_0 == NAME || LA75_0 == NUMBER || LA75_0 == 54 || LA75_0 == 110) )\n";
		file << "        	        	    {\n";
		file << "        	        	        alt75=1;\n";
		file << "        	        	    }\n";
		file << "\n";
		file << "        	        	}\n";
		file << "        	        	switch (alt75)\n";
		file << "        	        	{\n";
		file << "        	        	    case 1:\n";
		file << "        	        	        // ../../model/subgoal_learning/Pddl.g:0:0: metricFExp\n";
		file << "        	        	        {\n";
		file << "        	        	            FOLLOWPUSH(FOLLOW_metricFExp_in_metricFExp2972);\n";
		file << "        	        	            metricFExp403=metricFExp(ctx);\n";
		file << "\n";
		file << "        	        	            FOLLOWPOP();\n";
		file << "        	        	            if  (HASEXCEPTION())\n";
		file << "        	        	            {\n";
		file << "        	        	                goto rulemetricFExpEx;\n";
		file << "        	        	            }\n";
		file << "        	        	            if (HASFAILED())\n";
		file << "        	        	            {\n";
		file << "        	        	                return retval;\n";
		file << "        	        	            }\n";
		file << "        	        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, metricFExp403.tree);\n";
		file << "\n";
		file << "        	        	        }\n";
		file << "        	        	        break;\n";
		file << "\n";
		file << "        	        	    default:\n";
		file << "\n";
		file << "        	        		if ( cnt75 >= 1 )\n";
		file << "        	        		{\n";
		file << "        	        		    goto loop75;\n";
		file << "        	        		}\n";
		file << "        	        		if (BACKTRACKING>0)\n";
		file << "        	        		{\n";
		file << "        	        		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        	        		    return retval;\n";
		file << "        	        		}\n";
		file << "        	        		/* mismatchedSetEx()\n";
		file << "        	        		 */\n";
		file << "        	        		CONSTRUCTEX();\n";
		file << "        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "        	        		goto rulemetricFExpEx;\n";
		file << "        	        	}\n";
		file << "        	        	cnt75++;\n";
		file << "        	            }\n";
		file << "        	            loop75: ;	/* Jump to here if this rule does not match */\n";
		file << "        	        }\n";
		file << "        	        char_literal404 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_metricFExp2975);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal404_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal404));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal404_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:479:4: '(' '-' metricFExp ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal405 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_metricFExp2980);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal405_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal405));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal405_tree);\n";
		file << "        	        }\n";
		file << "        	        char_literal406 = (pANTLR3_COMMON_TOKEN) MATCHT(60, &FOLLOW_60_in_metricFExp2982);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal406_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal406));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal406_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_metricFExp_in_metricFExp2984);\n";
		file << "        	        metricFExp407=metricFExp(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, metricFExp407.tree);\n";
		file << "        	        char_literal408 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_metricFExp2986);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal408_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal408));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal408_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 4:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:480:4: NUMBER\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        NUMBER409 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_metricFExp2991);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        NUMBER409_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER409));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER409_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 5:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:481:4: '(' functionSymbol ( NAME )* ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal410 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_metricFExp2996);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal410_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal410));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal410_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_functionSymbol_in_metricFExp2998);\n";
		file << "        	        functionSymbol411=functionSymbol(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, functionSymbol411.tree);\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:481:23: ( NAME )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt76=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA76_0 = LA(1);\n";
		file << "        	                if ( (LA76_0 == NAME) )\n";
		file << "        	                {\n";
		file << "        	                    alt76=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt76)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: NAME\n";
		file << "        	        	    {\n";
		file << "        	        	        NAME412 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_metricFExp3000);\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto rulemetricFExpEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        	        NAME412_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME412));\n";
		file << "        	        	        ADAPTOR->addChild(ADAPTOR, root_0, NAME412_tree);\n";
		file << "        	        	        }\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop76;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop76: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal413 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_metricFExp3003);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal413_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal413));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal413_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 6:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:482:4: functionSymbol\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        FOLLOWPUSH(FOLLOW_functionSymbol_in_metricFExp3008);\n";
		file << "        	        functionSymbol414=functionSymbol(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, functionSymbol414.tree);\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 7:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:483:7: 'total-time'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        string_literal415 = (pANTLR3_COMMON_TOKEN) MATCHT(110, &FOLLOW_110_in_metricFExp3016);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal415_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal415));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal415_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 8:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:484:4: '(' 'is-violated' NAME ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal416 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_metricFExp3021);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal416_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal416));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal416_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal417 = (pANTLR3_COMMON_TOKEN) MATCHT(111, &FOLLOW_111_in_metricFExp3023);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal417_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal417));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal417_tree);\n";
		file << "        	        }\n";
		file << "        	        NAME418 = (pANTLR3_COMMON_TOKEN) MATCHT(NAME, &FOLLOW_NAME_in_metricFExp3025);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        NAME418_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAME418));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, NAME418_tree);\n";
		file << "        	        }\n";
		file << "        	        char_literal419 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_metricFExp3027);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulemetricFExpEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal419_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal419));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal419_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto rulemetricFExpEx; /* Prevent compiler warnings */\n";
		file << "    rulemetricFExpEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end metricFExp */\n";
		file << "\n";
		file << "/**\n";
		file << " * $ANTLR start conGD\n";
		file << " * ../../model/subgoal_learning/Pddl.g:487:1: conGD : ( '(' 'and' ( conGD )* ')' | '(' 'forall' '(' typedVariableList ')' conGD ')' | '(' 'at' 'end' goalDesc ')' | '(' 'always' goalDesc ')' | '(' 'sometime' goalDesc ')' | '(' 'within' NUMBER goalDesc ')' | '(' 'at-most-once' goalDesc ')' | '(' 'sometime-after' goalDesc goalDesc ')' | '(' 'sometime-before' goalDesc goalDesc ')' | '(' 'always-within' NUMBER goalDesc goalDesc ')' | '(' 'hold-during' NUMBER NUMBER goalDesc ')' | '(' 'hold-after' NUMBER goalDesc ')' );\n";
		file << " */\n";
		file << "static PddlParser_conGD_return\n";
		file << "conGD(pPddlParser ctx)\n";
		file << "{\n";
		file << "    PddlParser_conGD_return retval;\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE root_0;\n";
		file << "\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal420;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal421;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal423;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal424;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal425;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal426;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal428;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal430;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal431;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal432;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal433;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal435;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal436;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal437;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal439;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal440;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal441;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal443;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal444;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal445;\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER446;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal448;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal449;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal450;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal452;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal453;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal454;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal457;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal458;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal459;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal462;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal463;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal464;\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER465;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal468;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal469;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal470;\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER471;\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER472;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal474;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal475;\n";
		file << "    pANTLR3_COMMON_TOKEN    string_literal476;\n";
		file << "    pANTLR3_COMMON_TOKEN    NUMBER477;\n";
		file << "    pANTLR3_COMMON_TOKEN    char_literal479;\n";
		file << "    PddlParser_conGD_return conGD422;\n";
		file << "    #undef	RETURN_TYPE_conGD422\n";
		file << "    #define	RETURN_TYPE_conGD422 PddlParser_conGD_return\n";
		file << "\n";
		file << "    PddlParser_typedVariableList_return typedVariableList427;\n";
		file << "    #undef	RETURN_TYPE_typedVariableList427\n";
		file << "    #define	RETURN_TYPE_typedVariableList427 PddlParser_typedVariableList_return\n";
		file << "\n";
		file << "    PddlParser_conGD_return conGD429;\n";
		file << "    #undef	RETURN_TYPE_conGD429\n";
		file << "    #define	RETURN_TYPE_conGD429 PddlParser_conGD_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc434;\n";
		file << "    #undef	RETURN_TYPE_goalDesc434\n";
		file << "    #define	RETURN_TYPE_goalDesc434 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc438;\n";
		file << "    #undef	RETURN_TYPE_goalDesc438\n";
		file << "    #define	RETURN_TYPE_goalDesc438 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc442;\n";
		file << "    #undef	RETURN_TYPE_goalDesc442\n";
		file << "    #define	RETURN_TYPE_goalDesc442 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc447;\n";
		file << "    #undef	RETURN_TYPE_goalDesc447\n";
		file << "    #define	RETURN_TYPE_goalDesc447 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc451;\n";
		file << "    #undef	RETURN_TYPE_goalDesc451\n";
		file << "    #define	RETURN_TYPE_goalDesc451 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc455;\n";
		file << "    #undef	RETURN_TYPE_goalDesc455\n";
		file << "    #define	RETURN_TYPE_goalDesc455 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc456;\n";
		file << "    #undef	RETURN_TYPE_goalDesc456\n";
		file << "    #define	RETURN_TYPE_goalDesc456 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc460;\n";
		file << "    #undef	RETURN_TYPE_goalDesc460\n";
		file << "    #define	RETURN_TYPE_goalDesc460 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc461;\n";
		file << "    #undef	RETURN_TYPE_goalDesc461\n";
		file << "    #define	RETURN_TYPE_goalDesc461 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc466;\n";
		file << "    #undef	RETURN_TYPE_goalDesc466\n";
		file << "    #define	RETURN_TYPE_goalDesc466 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc467;\n";
		file << "    #undef	RETURN_TYPE_goalDesc467\n";
		file << "    #define	RETURN_TYPE_goalDesc467 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc473;\n";
		file << "    #undef	RETURN_TYPE_goalDesc473\n";
		file << "    #define	RETURN_TYPE_goalDesc473 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    PddlParser_goalDesc_return goalDesc478;\n";
		file << "    #undef	RETURN_TYPE_goalDesc478\n";
		file << "    #define	RETURN_TYPE_goalDesc478 PddlParser_goalDesc_return\n";
		file << "\n";
		file << "    pANTLR3_BASE_TREE char_literal420_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal421_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal423_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal424_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal425_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal426_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal428_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal430_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal431_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal432_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal433_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal435_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal436_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal437_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal439_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal440_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal441_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal443_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal444_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal445_tree;\n";
		file << "    pANTLR3_BASE_TREE NUMBER446_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal448_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal449_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal450_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal452_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal453_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal454_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal457_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal458_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal459_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal462_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal463_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal464_tree;\n";
		file << "    pANTLR3_BASE_TREE NUMBER465_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal468_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal469_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal470_tree;\n";
		file << "    pANTLR3_BASE_TREE NUMBER471_tree;\n";
		file << "    pANTLR3_BASE_TREE NUMBER472_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal474_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal475_tree;\n";
		file << "    pANTLR3_BASE_TREE string_literal476_tree;\n";
		file << "    pANTLR3_BASE_TREE NUMBER477_tree;\n";
		file << "    pANTLR3_BASE_TREE char_literal479_tree;\n";
		file << "\n";
		file << "    /* Initialize rule variables\n";
		file << "     */\n";
		file << "\n";
		file << "\n";
		file << "    root_0 = NULL;\n";
		file << "\n";
		file << "    char_literal420       = NULL;\n";
		file << "    string_literal421       = NULL;\n";
		file << "    char_literal423       = NULL;\n";
		file << "    char_literal424       = NULL;\n";
		file << "    string_literal425       = NULL;\n";
		file << "    char_literal426       = NULL;\n";
		file << "    char_literal428       = NULL;\n";
		file << "    char_literal430       = NULL;\n";
		file << "    char_literal431       = NULL;\n";
		file << "    string_literal432       = NULL;\n";
		file << "    string_literal433       = NULL;\n";
		file << "    char_literal435       = NULL;\n";
		file << "    char_literal436       = NULL;\n";
		file << "    string_literal437       = NULL;\n";
		file << "    char_literal439       = NULL;\n";
		file << "    char_literal440       = NULL;\n";
		file << "    string_literal441       = NULL;\n";
		file << "    char_literal443       = NULL;\n";
		file << "    char_literal444       = NULL;\n";
		file << "    string_literal445       = NULL;\n";
		file << "    NUMBER446       = NULL;\n";
		file << "    char_literal448       = NULL;\n";
		file << "    char_literal449       = NULL;\n";
		file << "    string_literal450       = NULL;\n";
		file << "    char_literal452       = NULL;\n";
		file << "    char_literal453       = NULL;\n";
		file << "    string_literal454       = NULL;\n";
		file << "    char_literal457       = NULL;\n";
		file << "    char_literal458       = NULL;\n";
		file << "    string_literal459       = NULL;\n";
		file << "    char_literal462       = NULL;\n";
		file << "    char_literal463       = NULL;\n";
		file << "    string_literal464       = NULL;\n";
		file << "    NUMBER465       = NULL;\n";
		file << "    char_literal468       = NULL;\n";
		file << "    char_literal469       = NULL;\n";
		file << "    string_literal470       = NULL;\n";
		file << "    NUMBER471       = NULL;\n";
		file << "    NUMBER472       = NULL;\n";
		file << "    char_literal474       = NULL;\n";
		file << "    char_literal475       = NULL;\n";
		file << "    string_literal476       = NULL;\n";
		file << "    NUMBER477       = NULL;\n";
		file << "    char_literal479       = NULL;\n";
		file << "    conGD422.tree = NULL;\n";
		file << "\n";
		file << "    typedVariableList427.tree = NULL;\n";
		file << "\n";
		file << "    conGD429.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc434.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc438.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc442.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc447.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc451.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc455.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc456.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc460.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc461.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc466.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc467.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc473.tree = NULL;\n";
		file << "\n";
		file << "    goalDesc478.tree = NULL;\n";
		file << "\n";
		file << "    retval.start = LT(1); retval.stop = retval.start;\n";
		file << "\n";
		file << "    char_literal420_tree   = NULL;\n";
		file << "    string_literal421_tree   = NULL;\n";
		file << "    char_literal423_tree   = NULL;\n";
		file << "    char_literal424_tree   = NULL;\n";
		file << "    string_literal425_tree   = NULL;\n";
		file << "    char_literal426_tree   = NULL;\n";
		file << "    char_literal428_tree   = NULL;\n";
		file << "    char_literal430_tree   = NULL;\n";
		file << "    char_literal431_tree   = NULL;\n";
		file << "    string_literal432_tree   = NULL;\n";
		file << "    string_literal433_tree   = NULL;\n";
		file << "    char_literal435_tree   = NULL;\n";
		file << "    char_literal436_tree   = NULL;\n";
		file << "    string_literal437_tree   = NULL;\n";
		file << "    char_literal439_tree   = NULL;\n";
		file << "    char_literal440_tree   = NULL;\n";
		file << "    string_literal441_tree   = NULL;\n";
		file << "    char_literal443_tree   = NULL;\n";
		file << "    char_literal444_tree   = NULL;\n";
		file << "    string_literal445_tree   = NULL;\n";
		file << "    NUMBER446_tree   = NULL;\n";
		file << "    char_literal448_tree   = NULL;\n";
		file << "    char_literal449_tree   = NULL;\n";
		file << "    string_literal450_tree   = NULL;\n";
		file << "    char_literal452_tree   = NULL;\n";
		file << "    char_literal453_tree   = NULL;\n";
		file << "    string_literal454_tree   = NULL;\n";
		file << "    char_literal457_tree   = NULL;\n";
		file << "    char_literal458_tree   = NULL;\n";
		file << "    string_literal459_tree   = NULL;\n";
		file << "    char_literal462_tree   = NULL;\n";
		file << "    char_literal463_tree   = NULL;\n";
		file << "    string_literal464_tree   = NULL;\n";
		file << "    NUMBER465_tree   = NULL;\n";
		file << "    char_literal468_tree   = NULL;\n";
		file << "    char_literal469_tree   = NULL;\n";
		file << "    string_literal470_tree   = NULL;\n";
		file << "    NUMBER471_tree   = NULL;\n";
		file << "    NUMBER472_tree   = NULL;\n";
		file << "    char_literal474_tree   = NULL;\n";
		file << "    char_literal475_tree   = NULL;\n";
		file << "    string_literal476_tree   = NULL;\n";
		file << "    NUMBER477_tree   = NULL;\n";
		file << "    char_literal479_tree   = NULL;\n";
		file << "\n";
		file << "\n";
		file << "    retval.tree  = NULL;\n";
		file << "    {\n";
		file << "        {\n";
		file << "            //  ../../model/subgoal_learning/Pddl.g:490:2: ( '(' 'and' ( conGD )* ')' | '(' 'forall' '(' typedVariableList ')' conGD ')' | '(' 'at' 'end' goalDesc ')' | '(' 'always' goalDesc ')' | '(' 'sometime' goalDesc ')' | '(' 'within' NUMBER goalDesc ')' | '(' 'at-most-once' goalDesc ')' | '(' 'sometime-after' goalDesc goalDesc ')' | '(' 'sometime-before' goalDesc goalDesc ')' | '(' 'always-within' NUMBER goalDesc goalDesc ')' | '(' 'hold-during' NUMBER NUMBER goalDesc ')' | '(' 'hold-after' NUMBER goalDesc ')' )\n";
		file << "\n";
		file << "            ANTLR3_UINT32 alt79;\n";
		file << "\n";
		file << "            alt79=12;\n";
		file << "\n";
		file << "            alt79 = cdfa79.predict(ctx, RECOGNIZER, ISTREAM, &cdfa79);\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto ruleconGDEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return retval;\n";
		file << "            }\n";
		file << "            switch (alt79)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:490:4: '(' 'and' ( conGD )* ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal420 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3041);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal420_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal420));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal420_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal421 = (pANTLR3_COMMON_TOKEN) MATCHT(71, &FOLLOW_71_in_conGD3043);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal421_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal421));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal421_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:490:14: ( conGD )*\n";
		file << "\n";
		file << "        	        for (;;)\n";
		file << "        	        {\n";
		file << "        	            int alt78=2;\n";
		file << "        	            {\n";
		file << "        	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	                */\n";
		file << "        	                int LA78_0 = LA(1);\n";
		file << "        	                if ( (LA78_0 == 54) )\n";
		file << "        	                {\n";
		file << "        	                    alt78=1;\n";
		file << "        	                }\n";
		file << "\n";
		file << "        	            }\n";
		file << "        	            switch (alt78)\n";
		file << "        	            {\n";
		file << "        	        	case 1:\n";
		file << "        	        	    // ../../model/subgoal_learning/Pddl.g:0:0: conGD\n";
		file << "        	        	    {\n";
		file << "        	        	        FOLLOWPUSH(FOLLOW_conGD_in_conGD3045);\n";
		file << "        	        	        conGD422=conGD(ctx);\n";
		file << "\n";
		file << "        	        	        FOLLOWPOP();\n";
		file << "        	        	        if  (HASEXCEPTION())\n";
		file << "        	        	        {\n";
		file << "        	        	            goto ruleconGDEx;\n";
		file << "        	        	        }\n";
		file << "        	        	        if (HASFAILED())\n";
		file << "        	        	        {\n";
		file << "        	        	            return retval;\n";
		file << "        	        	        }\n";
		file << "        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, conGD422.tree);\n";
		file << "\n";
		file << "        	        	    }\n";
		file << "        	        	    break;\n";
		file << "\n";
		file << "        	        	default:\n";
		file << "        	        	    goto loop78;	/* break out of the loop */\n";
		file << "        	        	    break;\n";
		file << "        	            }\n";
		file << "        	        }\n";
		file << "        	        loop78: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "        	        char_literal423 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3048);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal423_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal423));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal423_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:491:4: '(' 'forall' '(' typedVariableList ')' conGD ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal424 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3053);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal424_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal424));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal424_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal425 = (pANTLR3_COMMON_TOKEN) MATCHT(76, &FOLLOW_76_in_conGD3055);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal425_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal425));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal425_tree);\n";
		file << "        	        }\n";
		file << "        	        char_literal426 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3057);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal426_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal426));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal426_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_typedVariableList_in_conGD3059);\n";
		file << "        	        typedVariableList427=typedVariableList(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typedVariableList427.tree);\n";
		file << "        	        char_literal428 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3061);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal428_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal428));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal428_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_conGD_in_conGD3063);\n";
		file << "        	        conGD429=conGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, conGD429.tree);\n";
		file << "        	        char_literal430 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3065);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal430_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal430));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal430_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 3:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:492:4: '(' 'at' 'end' goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal431 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3070);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal431_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal431));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal431_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal432 = (pANTLR3_COMMON_TOKEN) MATCHT(81, &FOLLOW_81_in_conGD3072);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal432_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal432));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal432_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal433 = (pANTLR3_COMMON_TOKEN) MATCHT(84, &FOLLOW_84_in_conGD3074);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal433_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal433));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal433_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3076);\n";
		file << "        	        goalDesc434=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc434.tree);\n";
		file << "        	        char_literal435 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3078);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal435_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal435));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal435_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 4:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:493:7: '(' 'always' goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal436 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3086);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal436_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal436));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal436_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal437 = (pANTLR3_COMMON_TOKEN) MATCHT(112, &FOLLOW_112_in_conGD3088);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal437_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal437));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal437_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3090);\n";
		file << "        	        goalDesc438=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc438.tree);\n";
		file << "        	        char_literal439 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3092);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal439_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal439));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal439_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 5:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:494:4: '(' 'sometime' goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal440 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3097);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal440_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal440));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal440_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal441 = (pANTLR3_COMMON_TOKEN) MATCHT(113, &FOLLOW_113_in_conGD3099);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal441_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal441));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal441_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3101);\n";
		file << "        	        goalDesc442=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc442.tree);\n";
		file << "        	        char_literal443 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3103);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal443_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal443));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal443_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 6:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:495:5: '(' 'within' NUMBER goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal444 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3109);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal444_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal444));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal444_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal445 = (pANTLR3_COMMON_TOKEN) MATCHT(114, &FOLLOW_114_in_conGD3111);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal445_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal445));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal445_tree);\n";
		file << "        	        }\n";
		file << "        	        NUMBER446 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_conGD3113);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        NUMBER446_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER446));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER446_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3115);\n";
		file << "        	        goalDesc447=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc447.tree);\n";
		file << "        	        char_literal448 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3117);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal448_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal448));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal448_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 7:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:496:4: '(' 'at-most-once' goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal449 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3122);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal449_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal449));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal449_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal450 = (pANTLR3_COMMON_TOKEN) MATCHT(115, &FOLLOW_115_in_conGD3124);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal450_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal450));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal450_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3126);\n";
		file << "        	        goalDesc451=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc451.tree);\n";
		file << "        	        char_literal452 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3128);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal452_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal452));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal452_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 8:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:497:4: '(' 'sometime-after' goalDesc goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal453 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3133);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal453_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal453));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal453_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal454 = (pANTLR3_COMMON_TOKEN) MATCHT(116, &FOLLOW_116_in_conGD3135);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal454_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal454));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal454_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3137);\n";
		file << "        	        goalDesc455=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc455.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3139);\n";
		file << "        	        goalDesc456=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc456.tree);\n";
		file << "        	        char_literal457 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3141);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal457_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal457));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal457_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 9:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:498:4: '(' 'sometime-before' goalDesc goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal458 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3146);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal458_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal458));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal458_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal459 = (pANTLR3_COMMON_TOKEN) MATCHT(117, &FOLLOW_117_in_conGD3148);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal459_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal459));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal459_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3150);\n";
		file << "        	        goalDesc460=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc460.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3152);\n";
		file << "        	        goalDesc461=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc461.tree);\n";
		file << "        	        char_literal462 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3154);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal462_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal462));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal462_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 10:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:499:4: '(' 'always-within' NUMBER goalDesc goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal463 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3159);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal463_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal463));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal463_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal464 = (pANTLR3_COMMON_TOKEN) MATCHT(118, &FOLLOW_118_in_conGD3161);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal464_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal464));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal464_tree);\n";
		file << "        	        }\n";
		file << "        	        NUMBER465 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_conGD3163);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        NUMBER465_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER465));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER465_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3165);\n";
		file << "        	        goalDesc466=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc466.tree);\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3167);\n";
		file << "        	        goalDesc467=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc467.tree);\n";
		file << "        	        char_literal468 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3169);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal468_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal468));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal468_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 11:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:500:4: '(' 'hold-during' NUMBER NUMBER goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal469 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3174);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal469_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal469));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal469_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal470 = (pANTLR3_COMMON_TOKEN) MATCHT(119, &FOLLOW_119_in_conGD3176);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal470_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal470));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal470_tree);\n";
		file << "        	        }\n";
		file << "        	        NUMBER471 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_conGD3178);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        NUMBER471_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER471));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER471_tree);\n";
		file << "        	        }\n";
		file << "        	        NUMBER472 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_conGD3180);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        NUMBER472_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER472));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER472_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3182);\n";
		file << "        	        goalDesc473=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc473.tree);\n";
		file << "        	        char_literal474 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3184);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal474_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal474));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal474_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 12:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:501:4: '(' 'hold-after' NUMBER goalDesc ')'\n";
		file << "        	    {\n";
		file << "        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));\n";
		file << "\n";
		file << "        	        char_literal475 = (pANTLR3_COMMON_TOKEN) MATCHT(54, &FOLLOW_54_in_conGD3189);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal475_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal475));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal475_tree);\n";
		file << "        	        }\n";
		file << "        	        string_literal476 = (pANTLR3_COMMON_TOKEN) MATCHT(120, &FOLLOW_120_in_conGD3191);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        string_literal476_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, string_literal476));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, string_literal476_tree);\n";
		file << "        	        }\n";
		file << "        	        NUMBER477 = (pANTLR3_COMMON_TOKEN) MATCHT(NUMBER, &FOLLOW_NUMBER_in_conGD3193);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        NUMBER477_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NUMBER477));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, NUMBER477_tree);\n";
		file << "        	        }\n";
		file << "        	        FOLLOWPUSH(FOLLOW_goalDesc_in_conGD3195);\n";
		file << "        	        goalDesc478=goalDesc(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, goalDesc478.tree);\n";
		file << "        	        char_literal479 = (pANTLR3_COMMON_TOKEN) MATCHT(56, &FOLLOW_56_in_conGD3197);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto ruleconGDEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return retval;\n";
		file << "        	        }\n";
		file << "        	        if ( BACKTRACKING==0 ) {\n";
		file << "        	        char_literal479_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal479));\n";
		file << "        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal479_tree);\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "    }\n";
		file << "\n";
		file << "\n";
		file << "    // This is where rules clean up and exit\n";
		file << "    //\n";
		file << "    goto ruleconGDEx; /* Prevent compiler warnings */\n";
		file << "    ruleconGDEx: ;\n";
		file << "    retval.stop = LT(-1);\n";
		file << "\n";
		file << "    if ( BACKTRACKING==0 )\n";
		file << "    {\n";
		file << "    	retval.stop = LT(-1);\n";
		file << "    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));\n";
		file << "    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);\n";
		file << "    }\n";
		file << "\n";
		file << "    if (HASEXCEPTION())\n";
		file << "    {\n";
		file << "        PREPORTERROR();\n";
		file << "        PRECOVER();\n";
		file << "        retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));\n";
		file << "    }\n";
		file << "\n";
		file << "    return retval;\n";
		file << "}\n";
		file << "/* $ANTLR end conGD */\n";
		file << "\n";
		file << "// $ANTLR start synpred19_Pddl\n";
		file << "static void synpred19_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:155:5: ( atomicFunctionSkeleton )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:155:5: atomicFunctionSkeleton\n";
		file << "    {\n";
		file << "        FOLLOWPUSH(FOLLOW_atomicFunctionSkeleton_in_synpred19_Pddl750);\n";
		file << "        atomicFunctionSkeleton(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred19_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred19_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred19_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred19_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred58_Pddl\n";
		file << "static void synpred58_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:307:4: ( '(' binaryOp fExp fExp2 ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:307:4: '(' binaryOp fExp fExp2 ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred58_Pddl1761);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred58_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_binaryOp_in_synpred58_Pddl1763);\n";
		file << "        binaryOp(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred58_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_fExp_in_synpred58_Pddl1765);\n";
		file << "        fExp(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred58_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_fExp2_in_synpred58_Pddl1767);\n";
		file << "        fExp2(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred58_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred58_Pddl1769);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred58_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred58_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred58_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred58_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred59_Pddl\n";
		file << "static void synpred59_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:308:4: ( '(' '-' fExp ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:308:4: '(' '-' fExp ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred59_Pddl1786);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred59_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(60, &FOLLOW_60_in_synpred59_Pddl1788);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred59_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_fExp_in_synpred59_Pddl1790);\n";
		file << "        fExp(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred59_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred59_Pddl1792);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred59_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred59_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred59_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred59_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred60_Pddl\n";
		file << "static void synpred60_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:309:4: ( fHead )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:309:4: fHead\n";
		file << "    {\n";
		file << "        FOLLOWPUSH(FOLLOW_fHead_in_synpred60_Pddl1805);\n";
		file << "        fHead(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred60_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred60_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred60_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred60_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred88_Pddl\n";
		file << "static void synpred88_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:373:12: ( NUMBER )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:373:12: NUMBER\n";
		file << "    {\n";
		file << "         MATCHT(NUMBER, &FOLLOW_NUMBER_in_synpred88_Pddl2222);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred88_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred88_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred88_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred88_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred90_Pddl\n";
		file << "static void synpred90_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:376:4: ( '(' 'and' ( daEffect )* ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:376:4: '(' 'and' ( daEffect )* ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred90_Pddl2236);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred90_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(71, &FOLLOW_71_in_synpred90_Pddl2238);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred90_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:376:14: ( daEffect )*\n";
		file << "\n";
		file << "        for (;;)\n";
		file << "        {\n";
		file << "            int alt95=2;\n";
		file << "            {\n";
		file << "               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                */\n";
		file << "                int LA95_0 = LA(1);\n";
		file << "                if ( (LA95_0 == 54) )\n";
		file << "                {\n";
		file << "                    alt95=1;\n";
		file << "                }\n";
		file << "\n";
		file << "            }\n";
		file << "            switch (alt95)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:0:0: daEffect\n";
		file << "        	    {\n";
		file << "        	        FOLLOWPUSH(FOLLOW_daEffect_in_synpred90_Pddl2240);\n";
		file << "        	        daEffect(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesynpred90_PddlEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return ;\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "        	default:\n";
		file << "        	    goto loop95;	/* break out of the loop */\n";
		file << "        	    break;\n";
		file << "            }\n";
		file << "        }\n";
		file << "        loop95: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred90_Pddl2243);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred90_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred90_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred90_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred90_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred91_Pddl\n";
		file << "static void synpred91_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:377:4: ( timedEffect )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:377:4: timedEffect\n";
		file << "    {\n";
		file << "        FOLLOWPUSH(FOLLOW_timedEffect_in_synpred91_Pddl2248);\n";
		file << "        timedEffect(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred91_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred91_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred91_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred91_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred92_Pddl\n";
		file << "static void synpred92_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:378:4: ( '(' 'forall' '(' typedVariableList ')' daEffect ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:378:4: '(' 'forall' '(' typedVariableList ')' daEffect ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred92_Pddl2253);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred92_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(76, &FOLLOW_76_in_synpred92_Pddl2255);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred92_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred92_Pddl2257);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred92_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_typedVariableList_in_synpred92_Pddl2259);\n";
		file << "        typedVariableList(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred92_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred92_Pddl2261);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred92_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_daEffect_in_synpred92_Pddl2263);\n";
		file << "        daEffect(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred92_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred92_Pddl2265);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred92_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred92_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred92_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred92_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred93_Pddl\n";
		file << "static void synpred93_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:379:4: ( '(' 'when' daGD timedEffect ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:379:4: '(' 'when' daGD timedEffect ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred93_Pddl2270);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred93_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(87, &FOLLOW_87_in_synpred93_Pddl2272);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred93_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_daGD_in_synpred93_Pddl2274);\n";
		file << "        daGD(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred93_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_timedEffect_in_synpred93_Pddl2276);\n";
		file << "        timedEffect(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred93_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred93_Pddl2278);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred93_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred93_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred93_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred93_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred94_Pddl\n";
		file << "static void synpred94_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:384:4: ( '(' 'at' timeSpecifier daEffect ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:384:4: '(' 'at' timeSpecifier daEffect ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred94_Pddl2302);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred94_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(81, &FOLLOW_81_in_synpred94_Pddl2304);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred94_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_timeSpecifier_in_synpred94_Pddl2306);\n";
		file << "        timeSpecifier(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred94_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_daEffect_in_synpred94_Pddl2308);\n";
		file << "        daEffect(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred94_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred94_Pddl2310);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred94_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred94_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred94_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred94_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred95_Pddl\n";
		file << "static void synpred95_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:385:4: ( '(' 'at' timeSpecifier fAssignDA ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:385:4: '(' 'at' timeSpecifier fAssignDA ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred95_Pddl2320);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred95_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(81, &FOLLOW_81_in_synpred95_Pddl2322);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred95_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_timeSpecifier_in_synpred95_Pddl2324);\n";
		file << "        timeSpecifier(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred95_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_fAssignDA_in_synpred95_Pddl2326);\n";
		file << "        fAssignDA(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred95_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred95_Pddl2328);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred95_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred95_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred95_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred95_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred96_Pddl\n";
		file << "static void synpred96_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:394:9: ( ( binaryOp fExpDA fExpDA ) )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:394:9: ( binaryOp fExpDA fExpDA )\n";
		file << "    {\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:394:9: ( binaryOp fExpDA fExpDA )\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:394:10: binaryOp fExpDA fExpDA\n";
		file << "        {\n";
		file << "            FOLLOWPUSH(FOLLOW_binaryOp_in_synpred96_Pddl2384);\n";
		file << "            binaryOp(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulesynpred96_PddlEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return ;\n";
		file << "            }\n";
		file << "            FOLLOWPUSH(FOLLOW_fExpDA_in_synpred96_Pddl2386);\n";
		file << "            fExpDA(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulesynpred96_PddlEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return ;\n";
		file << "            }\n";
		file << "            FOLLOWPUSH(FOLLOW_fExpDA_in_synpred96_Pddl2388);\n";
		file << "            fExpDA(ctx);\n";
		file << "\n";
		file << "            FOLLOWPOP();\n";
		file << "            if  (HASEXCEPTION())\n";
		file << "            {\n";
		file << "                goto rulesynpred96_PddlEx;\n";
		file << "            }\n";
		file << "            if (HASFAILED())\n";
		file << "            {\n";
		file << "                return ;\n";
		file << "            }\n";
		file << "\n";
		file << "        }\n";
		file << "\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred96_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred96_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred96_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred97_Pddl\n";
		file << "static void synpred97_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:394:4: ( '(' ( ( binaryOp fExpDA fExpDA ) | ( '-' fExpDA ) ) ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:394:4: '(' ( ( binaryOp fExpDA fExpDA ) | ( '-' fExpDA ) ) ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred97_Pddl2380);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred97_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:394:8: ( ( binaryOp fExpDA fExpDA ) | ( '-' fExpDA ) )\n";
		file << "        {\n";
		file << "            int alt96=2;\n";
		file << "\n";
		file << "            {\n";
		file << "                int LA96_0 = LA(1);\n";
		file << "                if ( (LA96_0 == 60) )\n";
		file << "                {\n";
		file << "\n";
		file << "                    {\n";
		file << "                        int LA96_1 = LA(2);\n";
		file << "                        if ( (synpred96_Pddl(ctx)) )\n";
		file << "                        {\n";
		file << "                            alt96=1;\n";
		file << "                        }\n";
		file << "                        else if ( (ANTLR3_TRUE) )\n";
		file << "                        {\n";
		file << "                            alt96=2;\n";
		file << "                        }\n";
		file << "                        else\n";
		file << "                        {\n";
		file << "                            if (BACKTRACKING>0)\n";
		file << "                            {\n";
		file << "                                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                                return ;\n";
		file << "                            }\n";
		file << "\n";
		file << "                            CONSTRUCTEX();\n";
		file << "                            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                            EXCEPTION->message      = (void *)\"\";\n";
		file << "                            EXCEPTION->decisionNum  = 96;\n";
		file << "                            EXCEPTION->state        = 1;\n";
		file << "\n";
		file << "\n";
		file << "                            goto rulesynpred97_PddlEx;\n";
		file << "                        }\n";
		file << "                    }\n";
		file << "                }\n";
		file << "                else if ( (((LA96_0 >= 88) && (LA96_0 <= 90))) )\n";
		file << "                {\n";
		file << "                    alt96=1;\n";
		file << "                }\n";
		file << "                else\n";
		file << "                {\n";
		file << "                    if (BACKTRACKING>0)\n";
		file << "                    {\n";
		file << "                        FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                        return ;\n";
		file << "                    }\n";
		file << "\n";
		file << "                    CONSTRUCTEX();\n";
		file << "                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;\n";
		file << "                    EXCEPTION->message      = (void *)\"\";\n";
		file << "                    EXCEPTION->decisionNum  = 96;\n";
		file << "                    EXCEPTION->state        = 0;\n";
		file << "\n";
		file << "\n";
		file << "                    goto rulesynpred97_PddlEx;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt96)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:394:9: ( binaryOp fExpDA fExpDA )\n";
		file << "        	    {\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:394:9: ( binaryOp fExpDA fExpDA )\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:394:10: binaryOp fExpDA fExpDA\n";
		file << "        	        {\n";
		file << "        	            FOLLOWPUSH(FOLLOW_binaryOp_in_synpred97_Pddl2384);\n";
		file << "        	            binaryOp(ctx);\n";
		file << "\n";
		file << "        	            FOLLOWPOP();\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto rulesynpred97_PddlEx;\n";
		file << "        	            }\n";
		file << "        	            if (HASFAILED())\n";
		file << "        	            {\n";
		file << "        	                return ;\n";
		file << "        	            }\n";
		file << "        	            FOLLOWPUSH(FOLLOW_fExpDA_in_synpred97_Pddl2386);\n";
		file << "        	            fExpDA(ctx);\n";
		file << "\n";
		file << "        	            FOLLOWPOP();\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto rulesynpred97_PddlEx;\n";
		file << "        	            }\n";
		file << "        	            if (HASFAILED())\n";
		file << "        	            {\n";
		file << "        	                return ;\n";
		file << "        	            }\n";
		file << "        	            FOLLOWPUSH(FOLLOW_fExpDA_in_synpred97_Pddl2388);\n";
		file << "        	            fExpDA(ctx);\n";
		file << "\n";
		file << "        	            FOLLOWPOP();\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto rulesynpred97_PddlEx;\n";
		file << "        	            }\n";
		file << "        	            if (HASFAILED())\n";
		file << "        	            {\n";
		file << "        	                return ;\n";
		file << "        	            }\n";
		file << "\n";
		file << "        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "        	case 2:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:394:36: ( '-' fExpDA )\n";
		file << "        	    {\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:394:36: ( '-' fExpDA )\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:394:37: '-' fExpDA\n";
		file << "        	        {\n";
		file << "        	             MATCHT(60, &FOLLOW_60_in_synpred97_Pddl2394);\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto rulesynpred97_PddlEx;\n";
		file << "        	            }\n";
		file << "        	            if (HASFAILED())\n";
		file << "        	            {\n";
		file << "        	                return ;\n";
		file << "        	            }\n";
		file << "        	            FOLLOWPUSH(FOLLOW_fExpDA_in_synpred97_Pddl2396);\n";
		file << "        	            fExpDA(ctx);\n";
		file << "\n";
		file << "        	            FOLLOWPOP();\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto rulesynpred97_PddlEx;\n";
		file << "        	            }\n";
		file << "        	            if (HASFAILED())\n";
		file << "        	            {\n";
		file << "        	                return ;\n";
		file << "        	            }\n";
		file << "\n";
		file << "        	        }\n";
		file << "\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred97_Pddl2400);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred97_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred97_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred97_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred97_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred109_Pddl\n";
		file << "static void synpred109_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:463:4: ( '(' 'and' ( prefConGD )* ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:463:4: '(' 'and' ( prefConGD )* ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred109_Pddl2850);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred109_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(71, &FOLLOW_71_in_synpred109_Pddl2852);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred109_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:463:14: ( prefConGD )*\n";
		file << "\n";
		file << "        for (;;)\n";
		file << "        {\n";
		file << "            int alt97=2;\n";
		file << "            {\n";
		file << "               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                */\n";
		file << "                int LA97_0 = LA(1);\n";
		file << "                if ( (LA97_0 == 54) )\n";
		file << "                {\n";
		file << "                    alt97=1;\n";
		file << "                }\n";
		file << "\n";
		file << "            }\n";
		file << "            switch (alt97)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:0:0: prefConGD\n";
		file << "        	    {\n";
		file << "        	        FOLLOWPUSH(FOLLOW_prefConGD_in_synpred109_Pddl2854);\n";
		file << "        	        prefConGD(ctx);\n";
		file << "\n";
		file << "        	        FOLLOWPOP();\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesynpred109_PddlEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return ;\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "        	default:\n";
		file << "        	    goto loop97;	/* break out of the loop */\n";
		file << "        	    break;\n";
		file << "            }\n";
		file << "        }\n";
		file << "        loop97: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred109_Pddl2857);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred109_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred109_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred109_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred109_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred110_Pddl\n";
		file << "static void synpred110_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:464:4: ( '(' 'forall' '(' typedVariableList ')' prefConGD ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:464:4: '(' 'forall' '(' typedVariableList ')' prefConGD ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred110_Pddl2862);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred110_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(76, &FOLLOW_76_in_synpred110_Pddl2864);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred110_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred110_Pddl2866);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred110_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_typedVariableList_in_synpred110_Pddl2868);\n";
		file << "        typedVariableList(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred110_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred110_Pddl2870);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred110_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_prefConGD_in_synpred110_Pddl2872);\n";
		file << "        prefConGD(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred110_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred110_Pddl2874);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred110_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred110_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred110_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred110_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred112_Pddl\n";
		file << "static void synpred112_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:465:4: ( '(' 'preference' ( NAME )? conGD ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:465:4: '(' 'preference' ( NAME )? conGD ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred112_Pddl2879);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred112_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(80, &FOLLOW_80_in_synpred112_Pddl2881);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred112_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:465:21: ( NAME )?\n";
		file << "        {\n";
		file << "            int alt98=2;\n";
		file << "            {\n";
		file << "                int LA98_0 = LA(1);\n";
		file << "                if ( (LA98_0 == NAME) )\n";
		file << "                {\n";
		file << "                    alt98=1;\n";
		file << "                }\n";
		file << "            }\n";
		file << "            switch (alt98)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:0:0: NAME\n";
		file << "        	    {\n";
		file << "        	         MATCHT(NAME, &FOLLOW_NAME_in_synpred112_Pddl2883);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesynpred112_PddlEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return ;\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "            }\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_conGD_in_synpred112_Pddl2886);\n";
		file << "        conGD(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred112_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred112_Pddl2888);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred112_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred112_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred112_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred112_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred114_Pddl\n";
		file << "static void synpred114_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:477:4: ( '(' binaryOp metricFExp metricFExp ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:477:4: '(' binaryOp metricFExp metricFExp ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred114_Pddl2949);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred114_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_binaryOp_in_synpred114_Pddl2951);\n";
		file << "        binaryOp(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred114_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_metricFExp_in_synpred114_Pddl2953);\n";
		file << "        metricFExp(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred114_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_metricFExp_in_synpred114_Pddl2955);\n";
		file << "        metricFExp(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred114_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred114_Pddl2957);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred114_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred114_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred114_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred114_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred117_Pddl\n";
		file << "static void synpred117_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:478:4: ( '(' ( '*' | '/' ) metricFExp ( metricFExp )+ ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:478:4: '(' ( '*' | '/' ) metricFExp ( metricFExp )+ ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred117_Pddl2962);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred117_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        if ( LA(1) == 88 || LA(1) == 90 )\n";
		file << "        {\n";
		file << "            CONSUME();\n";
		file << "            PERRORRECOVERY=ANTLR3_FALSE;FAILEDFLAG=ANTLR3_FALSE;\n";
		file << "\n";
		file << "        }\n";
		file << "        else\n";
		file << "        {\n";
		file << "            if (BACKTRACKING>0)\n";
		file << "            {\n";
		file << "                FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "                return ;\n";
		file << "            }\n";
		file << "            CONSTRUCTEX();\n";
		file << "            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;\n";
		file << "            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;\n";
		file << "            EXCEPTION->expectingSet = &FOLLOW_set_in_synpred117_Pddl2964;\n";
		file << "            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_synpred117_Pddl2964);    goto rulesynpred117_PddlEx;\n";
		file << "        }\n";
		file << "\n";
		file << "        FOLLOWPUSH(FOLLOW_metricFExp_in_synpred117_Pddl2970);\n";
		file << "        metricFExp(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred117_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:478:29: ( metricFExp )+\n";
		file << "        {\n";
		file << "            int cnt99=0;\n";
		file << "\n";
		file << "            for (;;)\n";
		file << "            {\n";
		file << "                int alt99=2;\n";
		file << "        	{\n";
		file << "        	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "        	    */\n";
		file << "        	    int LA99_0 = LA(1);\n";
		file << "        	    if ( (LA99_0 == NAME || LA99_0 == NUMBER || LA99_0 == 54 || LA99_0 == 110) )\n";
		file << "        	    {\n";
		file << "        	        alt99=1;\n";
		file << "        	    }\n";
		file << "\n";
		file << "        	}\n";
		file << "        	switch (alt99)\n";
		file << "        	{\n";
		file << "        	    case 1:\n";
		file << "        	        // ../../model/subgoal_learning/Pddl.g:0:0: metricFExp\n";
		file << "        	        {\n";
		file << "        	            FOLLOWPUSH(FOLLOW_metricFExp_in_synpred117_Pddl2972);\n";
		file << "        	            metricFExp(ctx);\n";
		file << "\n";
		file << "        	            FOLLOWPOP();\n";
		file << "        	            if  (HASEXCEPTION())\n";
		file << "        	            {\n";
		file << "        	                goto rulesynpred117_PddlEx;\n";
		file << "        	            }\n";
		file << "        	            if (HASFAILED())\n";
		file << "        	            {\n";
		file << "        	                return ;\n";
		file << "        	            }\n";
		file << "\n";
		file << "        	        }\n";
		file << "        	        break;\n";
		file << "\n";
		file << "        	    default:\n";
		file << "\n";
		file << "        		if ( cnt99 >= 1 )\n";
		file << "        		{\n";
		file << "        		    goto loop99;\n";
		file << "        		}\n";
		file << "        		if (BACKTRACKING>0)\n";
		file << "        		{\n";
		file << "        		    FAILEDFLAG = ANTLR3_TRUE;\n";
		file << "        		    return ;\n";
		file << "        		}\n";
		file << "        		/* mismatchedSetEx()\n";
		file << "        		 */\n";
		file << "        		CONSTRUCTEX();\n";
		file << "        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;\n";
		file << "        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;\n";
		file << "\n";
		file << "\n";
		file << "        		goto rulesynpred117_PddlEx;\n";
		file << "        	}\n";
		file << "        	cnt99++;\n";
		file << "            }\n";
		file << "            loop99: ;	/* Jump to here if this rule does not match */\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred117_Pddl2975);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred117_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred117_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred117_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred117_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred118_Pddl\n";
		file << "static void synpred118_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:479:4: ( '(' '-' metricFExp ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:479:4: '(' '-' metricFExp ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred118_Pddl2980);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred118_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(60, &FOLLOW_60_in_synpred118_Pddl2982);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred118_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_metricFExp_in_synpred118_Pddl2984);\n";
		file << "        metricFExp(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred118_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred118_Pddl2986);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred118_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred118_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred118_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred118_Pddl\n";
		file << "\n";
		file << "// $ANTLR start synpred121_Pddl\n";
		file << "static void synpred121_Pddl_fragment(pPddlParser ctx )\n";
		file << "{\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:481:4: ( '(' functionSymbol ( NAME )* ')' )\n";
		file << "    // ../../model/subgoal_learning/Pddl.g:481:4: '(' functionSymbol ( NAME )* ')'\n";
		file << "    {\n";
		file << "         MATCHT(54, &FOLLOW_54_in_synpred121_Pddl2996);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred121_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "        FOLLOWPUSH(FOLLOW_functionSymbol_in_synpred121_Pddl2998);\n";
		file << "        functionSymbol(ctx);\n";
		file << "\n";
		file << "        FOLLOWPOP();\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred121_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "        // ../../model/subgoal_learning/Pddl.g:481:23: ( NAME )*\n";
		file << "\n";
		file << "        for (;;)\n";
		file << "        {\n";
		file << "            int alt100=2;\n";
		file << "            {\n";
		file << "               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)\n";
		file << "                */\n";
		file << "                int LA100_0 = LA(1);\n";
		file << "                if ( (LA100_0 == NAME) )\n";
		file << "                {\n";
		file << "                    alt100=1;\n";
		file << "                }\n";
		file << "\n";
		file << "            }\n";
		file << "            switch (alt100)\n";
		file << "            {\n";
		file << "        	case 1:\n";
		file << "        	    // ../../model/subgoal_learning/Pddl.g:0:0: NAME\n";
		file << "        	    {\n";
		file << "        	         MATCHT(NAME, &FOLLOW_NAME_in_synpred121_Pddl3000);\n";
		file << "        	        if  (HASEXCEPTION())\n";
		file << "        	        {\n";
		file << "        	            goto rulesynpred121_PddlEx;\n";
		file << "        	        }\n";
		file << "        	        if (HASFAILED())\n";
		file << "        	        {\n";
		file << "        	            return ;\n";
		file << "        	        }\n";
		file << "\n";
		file << "        	    }\n";
		file << "        	    break;\n";
		file << "\n";
		file << "        	default:\n";
		file << "        	    goto loop100;	/* break out of the loop */\n";
		file << "        	    break;\n";
		file << "            }\n";
		file << "        }\n";
		file << "        loop100: ; /* Jump out to here if this rule does not match */\n";
		file << "\n";
		file << "         MATCHT(56, &FOLLOW_56_in_synpred121_Pddl3003);\n";
		file << "        if  (HASEXCEPTION())\n";
		file << "        {\n";
		file << "            goto rulesynpred121_PddlEx;\n";
		file << "        }\n";
		file << "        if (HASFAILED())\n";
		file << "        {\n";
		file << "            return ;\n";
		file << "        }\n";
		file << "\n";
		file << "    }\n";
		file << "\n";
		file << "// This is where rules clean up and exit\n";
		file << "//\n";
		file << "goto rulesynpred121_PddlEx; /* Prevent compiler warnings */\n";
		file << "rulesynpred121_PddlEx: ;\n";
		file << "\n";
		file << "}\n";
		file << "// $ANTLR end synpred121_Pddl\n";
		file << "/* End of parsing rules\n";
		file << " * ==============================================\n";
		file << " */\n";
		file << "\n";
		file << "/* ==============================================\n";
		file << " * Syntactic predicates\n";
		file << " */\n";
		file << "static ANTLR3_BOOLEAN synpred94_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred94_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred88_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred88_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred96_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred96_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred121_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred121_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred114_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred114_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred60_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred60_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred95_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred95_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred118_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred118_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred93_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred93_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred58_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred58_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred109_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred109_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred117_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred117_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred59_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred59_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred112_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred112_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred91_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred91_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred19_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred19_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred92_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred92_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred110_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred110_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred90_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred90_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "static ANTLR3_BOOLEAN synpred97_Pddl(pPddlParser ctx)\n";
		file << "{\n";
		file << "    ANTLR3_MARKER   start;\n";
		file << "    ANTLR3_BOOLEAN  success;\n";
		file << "\n";
		file << "    BACKTRACKING++;\n";
		file << "    start	= MARK();\n";
		file << "    synpred97_Pddl_fragment(ctx);	    // can never throw exception\n";
		file << "    success	= !(FAILEDFLAG);\n";
		file << "    REWIND(start);\n";
		file << "    BACKTRACKING--;\n";
		file << "    FAILEDFLAG	= ANTLR3_FALSE;\n";
		file << "    return success;\n";
		file << "}\n";
		file << "\n";
		file << "/* End of syntactic predicates\n";
		file << " * ==============================================\n";
		file << " */\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "#pragma GCC diagnostic pop\n";
		file << "\n";
		file << "\n";
		file << "/* End of code\n";
		file << " * =============================================================================\n";
		file << " */\n";
		file.close ();
	}



	{
		ofstream file ("PddlParser.h", ios_base::out);
		file << "/** \\file\n";
		file << " *  This C header file was generated by $ANTLR version 3.1.3 Mar 17, 2009 19:23:44\n";
		file << " *\n";
		file << " *     -  From the grammar source file : ../../model/subgoal_learning/Pddl.g\n";
		file << " *     -                            On : 2011-12-04 10:25:05\n";
		file << " *     -                for the parser : PddlParserParser *\n";
		file << " * Editing it, at least manually, is not wise.\n";
		file << " *\n";
		file << " * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.\n";
		file << " *\n";
		file << " *\n";
		file << " * The parser PddlParser has the callable functions (rules) shown below,\n";
		file << " * which will invoke the code for the associated rule in the source grammar\n";
		file << " * assuming that the input stream is pointing to a token/text stream that could begin\n";
		file << " * this rule.\n";
		file << " *\n";
		file << " * For instance if you call the first (topmost) rule in a parser grammar, you will\n";
		file << " * get the results of a full parse, but calling a rule half way through the grammar will\n";
		file << " * allow you to pass part of a full token stream to the parser, such as for syntax checking\n";
		file << " * in editors and so on.\n";
		file << " *\n";
		file << " * The parser entry points are called indirectly (by function pointer to function) via\n";
		file << " * a parser context typedef pPddlParser, which is returned from a call to PddlParserNew().\n";
		file << " *\n";
		file << " * The methods in pPddlParser are  as follows:\n";
		file << " *\n";
		file << " *  - PddlParser_getDomain_return      pPddlParser->getDomain(pPddlParser)\n";
		file << " *  - PddlParser_getProblem_return      pPddlParser->getProblem(pPddlParser)\n";
		file << " *  - PddlParser_pddlDoc_return      pPddlParser->pddlDoc(pPddlParser)\n";
		file << " *  - PddlParser_domain_return      pPddlParser->domain(pPddlParser)\n";
		file << " *  - PddlParser_domainName_return      pPddlParser->domainName(pPddlParser)\n";
		file << " *  - PddlParser_requireDef_return      pPddlParser->requireDef(pPddlParser)\n";
		file << " *  - PddlParser_typesDef_return      pPddlParser->typesDef(pPddlParser)\n";
		file << " *  - PddlParser_typedNameList_return      pPddlParser->typedNameList(pPddlParser)\n";
		file << " *  - PddlParser_singleTypeNameList_return      pPddlParser->singleTypeNameList(pPddlParser)\n";
		file << " *  - PddlParser_type_return      pPddlParser->type(pPddlParser)\n";
		file << " *  - PddlParser_primType_return      pPddlParser->primType(pPddlParser)\n";
		file << " *  - PddlParser_functionsDef_return      pPddlParser->functionsDef(pPddlParser)\n";
		file << " *  - PddlParser_functionList_return      pPddlParser->functionList(pPddlParser)\n";
		file << " *  - PddlParser_atomicFunctionSkeleton_return      pPddlParser->atomicFunctionSkeleton(pPddlParser)\n";
		file << " *  - PddlParser_functionSymbol_return      pPddlParser->functionSymbol(pPddlParser)\n";
		file << " *  - PddlParser_functionType_return      pPddlParser->functionType(pPddlParser)\n";
		file << " *  - PddlParser_constantsDef_return      pPddlParser->constantsDef(pPddlParser)\n";
		file << " *  - PddlParser_predicatesDef_return      pPddlParser->predicatesDef(pPddlParser)\n";
		file << " *  - PddlParser_atomicFormulaSkeleton_return      pPddlParser->atomicFormulaSkeleton(pPddlParser)\n";
		file << " *  - PddlParser_predicate_return      pPddlParser->predicate(pPddlParser)\n";
		file << " *  - PddlParser_typedVariableList_return      pPddlParser->typedVariableList(pPddlParser)\n";
		file << " *  - PddlParser_singleTypeVarList_return      pPddlParser->singleTypeVarList(pPddlParser)\n";
		file << " *  - PddlParser_constraints_return      pPddlParser->constraints(pPddlParser)\n";
		file << " *  - PddlParser_structureDef_return      pPddlParser->structureDef(pPddlParser)\n";
		file << " *  - PddlParser_actionDef_return      pPddlParser->actionDef(pPddlParser)\n";
		file << " *  - PddlParser_actionSymbol_return      pPddlParser->actionSymbol(pPddlParser)\n";
		file << " *  - PddlParser_actionDefBody_return      pPddlParser->actionDefBody(pPddlParser)\n";
		file << " *  - PddlParser_goalDesc_return      pPddlParser->goalDesc(pPddlParser)\n";
		file << " *  - PddlParser_fComp_return      pPddlParser->fComp(pPddlParser)\n";
		file << " *  - PddlParser_atomicTermFormula_return      pPddlParser->atomicTermFormula(pPddlParser)\n";
		file << " *  - PddlParser_term_return      pPddlParser->term(pPddlParser)\n";
		file << " *  - PddlParser_durativeActionDef_return      pPddlParser->durativeActionDef(pPddlParser)\n";
		file << " *  - PddlParser_daDefBody_return      pPddlParser->daDefBody(pPddlParser)\n";
		file << " *  - PddlParser_daGD_return      pPddlParser->daGD(pPddlParser)\n";
		file << " *  - PddlParser_prefTimedGD_return      pPddlParser->prefTimedGD(pPddlParser)\n";
		file << " *  - PddlParser_timedGD_return      pPddlParser->timedGD(pPddlParser)\n";
		file << " *  - PddlParser_timeSpecifier_return      pPddlParser->timeSpecifier(pPddlParser)\n";
		file << " *  - PddlParser_interval_return      pPddlParser->interval(pPddlParser)\n";
		file << " *  - PddlParser_derivedDef_return      pPddlParser->derivedDef(pPddlParser)\n";
		file << " *  - PddlParser_fExp_return      pPddlParser->fExp(pPddlParser)\n";
		file << " *  - PddlParser_fExp2_return      pPddlParser->fExp2(pPddlParser)\n";
		file << " *  - PddlParser_fHead_return      pPddlParser->fHead(pPddlParser)\n";
		file << " *  - PddlParser_effect_return      pPddlParser->effect(pPddlParser)\n";
		file << " *  - PddlParser_cEffect_return      pPddlParser->cEffect(pPddlParser)\n";
		file << " *  - PddlParser_pEffect_return      pPddlParser->pEffect(pPddlParser)\n";
		file << " *  - PddlParser_condEffect_return      pPddlParser->condEffect(pPddlParser)\n";
		file << " *  - PddlParser_binaryOp_return      pPddlParser->binaryOp(pPddlParser)\n";
		file << " *  - PddlParser_binaryComp_return      pPddlParser->binaryComp(pPddlParser)\n";
		file << " *  - PddlParser_assignOp_return      pPddlParser->assignOp(pPddlParser)\n";
		file << " *  - PddlParser_durationConstraint_return      pPddlParser->durationConstraint(pPddlParser)\n";
		file << " *  - PddlParser_simpleDurationConstraint_return      pPddlParser->simpleDurationConstraint(pPddlParser)\n";
		file << " *  - PddlParser_durOp_return      pPddlParser->durOp(pPddlParser)\n";
		file << " *  - PddlParser_durValue_return      pPddlParser->durValue(pPddlParser)\n";
		file << " *  - PddlParser_daEffect_return      pPddlParser->daEffect(pPddlParser)\n";
		file << " *  - PddlParser_timedEffect_return      pPddlParser->timedEffect(pPddlParser)\n";
		file << " *  - PddlParser_fAssignDA_return      pPddlParser->fAssignDA(pPddlParser)\n";
		file << " *  - PddlParser_fExpDA_return      pPddlParser->fExpDA(pPddlParser)\n";
		file << " *  - PddlParser_problem_return      pPddlParser->problem(pPddlParser)\n";
		file << " *  - PddlParser_problemDecl_return      pPddlParser->problemDecl(pPddlParser)\n";
		file << " *  - PddlParser_problemDomain_return      pPddlParser->problemDomain(pPddlParser)\n";
		file << " *  - PddlParser_objectDecl_return      pPddlParser->objectDecl(pPddlParser)\n";
		file << " *  - PddlParser_init_return      pPddlParser->init(pPddlParser)\n";
		file << " *  - PddlParser_initEl_return      pPddlParser->initEl(pPddlParser)\n";
		file << " *  - PddlParser_nameLiteral_return      pPddlParser->nameLiteral(pPddlParser)\n";
		file << " *  - PddlParser_atomicNameFormula_return      pPddlParser->atomicNameFormula(pPddlParser)\n";
		file << " *  - PddlParser_goal_return      pPddlParser->goal(pPddlParser)\n";
		file << " *  - PddlParser_probConstraints_return      pPddlParser->probConstraints(pPddlParser)\n";
		file << " *  - PddlParser_prefConGD_return      pPddlParser->prefConGD(pPddlParser)\n";
		file << " *  - PddlParser_metricSpec_return      pPddlParser->metricSpec(pPddlParser)\n";
		file << " *  - PddlParser_optimization_return      pPddlParser->optimization(pPddlParser)\n";
		file << " *  - PddlParser_metricFExp_return      pPddlParser->metricFExp(pPddlParser)\n";
		file << " *  - PddlParser_conGD_return      pPddlParser->conGD(pPddlParser)\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " *\n";
		file << " * The return type for any particular rule is of course determined by the source\n";
		file << " * grammar file.\n";
		file << " */\n";
		file << "// [The \"BSD licence\"]\n";
		file << "// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC\n";
		file << "// http://www.temporal-wave.com\n";
		file << "// http://www.linkedin.com/in/jimidle\n";
		file << "//\n";
		file << "// All rights reserved.\n";
		file << "//\n";
		file << "// Redistribution and use in source and binary forms, with or without\n";
		file << "// modification, are permitted provided that the following conditions\n";
		file << "// are met:\n";
		file << "// 1. Redistributions of source code must retain the above copyright\n";
		file << "//    notice, this list of conditions and the following disclaimer.\n";
		file << "// 2. Redistributions in binary form must reproduce the above copyright\n";
		file << "//    notice, this list of conditions and the following disclaimer in the\n";
		file << "//    documentation and/or other materials provided with the distribution.\n";
		file << "// 3. The name of the author may not be used to endorse or promote products\n";
		file << "//    derived from this software without specific prior written permission.\n";
		file << "//\n";
		file << "// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n";
		file << "// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n";
		file << "// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n";
		file << "// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n";
		file << "// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n";
		file << "// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n";
		file << "// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n";
		file << "// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n";
		file << "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n";
		file << "// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n";
		file << "\n";
		file << "#ifndef	_PddlParser_H\n";
		file << "#define _PddlParser_H\n";
		file << "/* =============================================================================\n";
		file << " * Standard antlr3 C runtime definitions\n";
		file << " */\n";
		file << "#include    <antlr3.h>\n";
		file << "\n";
		file << "/* End of standard antlr 3 runtime definitions\n";
		file << " * =============================================================================\n";
		file << " */\n";
		file << "\n";
		file << "#ifdef __cplusplus\n";
		file << "extern \"C\" {\n";
		file << "#endif\n";
		file << "\n";
		file << "// Forward declare the context typedef so that we can use it before it is\n";
		file << "// properly defined. Delegators and delegates (from import statements) are\n";
		file << "// interdependent and their context structures contain pointers to each other\n";
		file << "// C only allows such things to be declared if you pre-declare the typedef.\n";
		file << "//\n";
		file << "typedef struct PddlParser_Ctx_struct PddlParser, * pPddlParser;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "#ifdef	ANTLR3_WINDOWS\n";
		file << "// Disable: Unreferenced parameter,							- Rules with parameters that are not used\n";
		file << "//          constant conditional,							- ANTLR realizes that a prediction is always true (synpred usually)\n";
		file << "//          initialized but unused variable					- tree rewrite variables declared but not needed\n";
		file << "//          Unreferenced local variable						- lexer rule declares but does not always use _type\n";
		file << "//          potentially unitialized variable used			- retval always returned from a rule\n";
		file << "//			unreferenced local function has been removed	- susually getTokenNames or freeScope, they can go without warnigns\n";
		file << "//\n";
		file << "// These are only really displayed at warning level /W4 but that is the code ideal I am aiming at\n";
		file << "// and the codegen must generate some of these warnings by necessity, apart from 4100, which is\n";
		file << "// usually generated when a parser rule is given a parameter that it does not use. Mostly though\n";
		file << "// this is a matter of orthogonality hence I disable that one.\n";
		file << "//\n";
		file << "#pragma warning( disable : 4100 )\n";
		file << "#pragma warning( disable : 4101 )\n";
		file << "#pragma warning( disable : 4127 )\n";
		file << "#pragma warning( disable : 4189 )\n";
		file << "#pragma warning( disable : 4505 )\n";
		file << "#pragma warning( disable : 4701 )\n";
		file << "#endif\n";
		file << "\n";
		file << "/* ========================\n";
		file << " * BACKTRACKING IS ENABLED\n";
		file << " * ========================\n";
		file << " */\n";
		file << "typedef struct PddlParser_getDomain_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_getDomain_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_getProblem_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_getProblem_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_pddlDoc_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_pddlDoc_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_domain_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_domain_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_domainName_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_domainName_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_requireDef_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_requireDef_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_typesDef_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_typesDef_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_typedNameList_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_typedNameList_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_singleTypeNameList_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_singleTypeNameList_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_type_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_type_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_primType_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_primType_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_functionsDef_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_functionsDef_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_functionList_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_functionList_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_atomicFunctionSkeleton_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_atomicFunctionSkeleton_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_functionSymbol_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_functionSymbol_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_functionType_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_functionType_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_constantsDef_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_constantsDef_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_predicatesDef_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_predicatesDef_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_atomicFormulaSkeleton_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_atomicFormulaSkeleton_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_predicate_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_predicate_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_typedVariableList_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_typedVariableList_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_singleTypeVarList_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_singleTypeVarList_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_constraints_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_constraints_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_structureDef_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_structureDef_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_actionDef_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_actionDef_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_actionSymbol_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_actionSymbol_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_actionDefBody_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_actionDefBody_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_goalDesc_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_goalDesc_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_fComp_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_fComp_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_atomicTermFormula_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_atomicTermFormula_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_term_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_term_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_durativeActionDef_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_durativeActionDef_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_daDefBody_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_daDefBody_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_daGD_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_daGD_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_prefTimedGD_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_prefTimedGD_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_timedGD_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_timedGD_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_timeSpecifier_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_timeSpecifier_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_interval_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_interval_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_derivedDef_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_derivedDef_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_fExp_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_fExp_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_fExp2_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_fExp2_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_fHead_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_fHead_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_effect_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_effect_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_cEffect_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_cEffect_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_pEffect_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_pEffect_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_condEffect_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_condEffect_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_binaryOp_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_binaryOp_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_binaryComp_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_binaryComp_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_assignOp_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_assignOp_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_durationConstraint_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_durationConstraint_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_simpleDurationConstraint_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_simpleDurationConstraint_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_durOp_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_durOp_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_durValue_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_durValue_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_daEffect_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_daEffect_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_timedEffect_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_timedEffect_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_fAssignDA_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_fAssignDA_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_fExpDA_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_fExpDA_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_problem_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_problem_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_problemDecl_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_problemDecl_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_problemDomain_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_problemDomain_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_objectDecl_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_objectDecl_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_init_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_init_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_initEl_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_initEl_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_nameLiteral_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_nameLiteral_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_atomicNameFormula_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_atomicNameFormula_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_goal_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_goal_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_probConstraints_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_probConstraints_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_prefConGD_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_prefConGD_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_metricSpec_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_metricSpec_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_optimization_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_optimization_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_metricFExp_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_metricFExp_return;\n";
		file << "\n";
		file << "typedef struct PddlParser_conGD_return_struct\n";
		file << "{\n";
		file << "    /** Generic return elements for ANTLR3 rules that are not in tree parsers or returning trees\n";
		file << "     */\n";
		file << "    pANTLR3_COMMON_TOKEN    start;\n";
		file << "    pANTLR3_COMMON_TOKEN    stop;\n";
		file << "    pANTLR3_BASE_TREE	tree;\n";
		file << "\n";
		file << "}\n";
		file << "    PddlParser_conGD_return;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "/** Context tracking structure for PddlParser\n";
		file << " */\n";
		file << "struct PddlParser_Ctx_struct\n";
		file << "{\n";
		file << "    /** Built in ANTLR3 context tracker contains all the generic elements\n";
		file << "     *  required for context tracking.\n";
		file << "     */\n";
		file << "    pANTLR3_PARSER   pParser;\n";
		file << "\n";
		file << "\n";
		file << "     PddlParser_getDomain_return (*getDomain)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_getProblem_return (*getProblem)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_pddlDoc_return (*pddlDoc)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_domain_return (*domain)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_domainName_return (*domainName)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_requireDef_return (*requireDef)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_typesDef_return (*typesDef)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_typedNameList_return (*typedNameList)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_singleTypeNameList_return (*singleTypeNameList)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_type_return (*type)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_primType_return (*primType)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_functionsDef_return (*functionsDef)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_functionList_return (*functionList)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_atomicFunctionSkeleton_return (*atomicFunctionSkeleton)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_functionSymbol_return (*functionSymbol)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_functionType_return (*functionType)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_constantsDef_return (*constantsDef)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_predicatesDef_return (*predicatesDef)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_atomicFormulaSkeleton_return (*atomicFormulaSkeleton)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_predicate_return (*predicate)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_typedVariableList_return (*typedVariableList)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_singleTypeVarList_return (*singleTypeVarList)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_constraints_return (*constraints)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_structureDef_return (*structureDef)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_actionDef_return (*actionDef)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_actionSymbol_return (*actionSymbol)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_actionDefBody_return (*actionDefBody)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_goalDesc_return (*goalDesc)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_fComp_return (*fComp)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_atomicTermFormula_return (*atomicTermFormula)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_term_return (*term)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_durativeActionDef_return (*durativeActionDef)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_daDefBody_return (*daDefBody)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_daGD_return (*daGD)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_prefTimedGD_return (*prefTimedGD)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_timedGD_return (*timedGD)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_timeSpecifier_return (*timeSpecifier)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_interval_return (*interval)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_derivedDef_return (*derivedDef)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_fExp_return (*fExp)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_fExp2_return (*fExp2)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_fHead_return (*fHead)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_effect_return (*effect)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_cEffect_return (*cEffect)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_pEffect_return (*pEffect)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_condEffect_return (*condEffect)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_binaryOp_return (*binaryOp)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_binaryComp_return (*binaryComp)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_assignOp_return (*assignOp)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_durationConstraint_return (*durationConstraint)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_simpleDurationConstraint_return (*simpleDurationConstraint)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_durOp_return (*durOp)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_durValue_return (*durValue)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_daEffect_return (*daEffect)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_timedEffect_return (*timedEffect)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_fAssignDA_return (*fAssignDA)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_fExpDA_return (*fExpDA)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_problem_return (*problem)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_problemDecl_return (*problemDecl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_problemDomain_return (*problemDomain)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_objectDecl_return (*objectDecl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_init_return (*init)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_initEl_return (*initEl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_nameLiteral_return (*nameLiteral)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_atomicNameFormula_return (*atomicNameFormula)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_goal_return (*goal)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_probConstraints_return (*probConstraints)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_prefConGD_return (*prefConGD)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_metricSpec_return (*metricSpec)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_optimization_return (*optimization)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_metricFExp_return (*metricFExp)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     PddlParser_conGD_return (*conGD)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred19_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred58_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred59_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred60_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred88_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred90_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred91_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred92_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred93_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred94_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred95_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred96_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred97_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred109_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred110_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred112_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred114_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred117_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred118_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "     ANTLR3_BOOLEAN (*synpred121_Pddl)	(struct PddlParser_Ctx_struct * ctx);\n";
		file << "    // Delegated rules\n";
		file << "    const char * (*getGrammarFileName)();\n";
		file << "    void	    (*free)   (struct PddlParser_Ctx_struct * ctx);\n";
		file << "    /* @headerFile.members() */\n";
		file << "    pANTLR3_BASE_TREE_ADAPTOR	adaptor;\n";
		file << "    pANTLR3_VECTOR_FACTORY		vectors;\n";
		file << "    /* End @headerFile.members() */\n";
		file << "};\n";
		file << "\n";
		file << "// Function protoypes for the constructor functions that external translation units\n";
		file << "// such as delegators and delegates may wish to call.\n";
		file << "//\n";
		file << "ANTLR3_API pPddlParser PddlParserNew         (pANTLR3_COMMON_TOKEN_STREAM instream);\n";
		file << "ANTLR3_API pPddlParser PddlParserNewSSD      (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state);\n";
		file << "\n";
		file << "/** Symbolic definitions of all the tokens that the parser will work with.\n";
		file << " * \\{\n";
		file << " *\n";
		file << " * Antlr will define EOF, but we can't use that as it it is too common in\n";
		file << " * in C header files and that would be confusing. There is no way to filter this out at the moment\n";
		file << " * so we just undef it here for now. That isn't the value we get back from C recognizers\n";
		file << " * anyway. We are looking for ANTLR3_TOKEN_EOF.\n";
		file << " */\n";
		file << "#ifdef	EOF\n";
		file << "#undef	EOF\n";
		file << "#endif\n";
		file << "#ifdef	Tokens\n";
		file << "#undef	Tokens\n";
		file << "#endif\n";
		file << "#define REQUIRE_KEY      46\n";
		file << "#define FUNCTIONS      10\n";
		file << "#define LETTER      49\n";
		file << "#define PRED_INST      42\n";
		file << "#define TYPES      7\n";
		file << "#define EXISTS_GD      27\n";
		file << "#define EOF      -1\n";
		file << "#define COMPARISON_GD      29\n";
		file << "#define ACTION      13\n";
		file << "#define T__93      93\n";
		file << "#define ANY_CHAR      50\n";
		file << "#define T__94      94\n";
		file << "#define NOT_EFFECT      34\n";
		file << "#define T__91      91\n";
		file << "#define NAME      45\n";
		file << "#define T__92      92\n";
		file << "#define T__90      90\n";
		file << "#define PROBLEM_DOMAIN      17\n";
		file << "#define OBJECTS      18\n";
		file << "#define ASSIGN_EFFECT      33\n";
		file << "#define T__99      99\n";
		file << "#define T__98      98\n";
		file << "#define T__97      97\n";
		file << "#define T__96      96\n";
		file << "#define T__95      95\n";
		file << "#define T__80      80\n";
		file << "#define T__81      81\n";
		file << "#define T__82      82\n";
		file << "#define T__83      83\n";
		file << "#define LINE_COMMENT      52\n";
		file << "#define PROBLEM      15\n";
		file << "#define NUMBER      48\n";
		file << "#define WHITESPACE      53\n";
		file << "#define UNARY_MINUS      38\n";
		file << "#define OR_GD      24\n";
		file << "#define T__85      85\n";
		file << "#define T__84      84\n";
		file << "#define T__87      87\n";
		file << "#define T__86      86\n";
		file << "#define T__89      89\n";
		file << "#define T__88      88\n";
		file << "#define DOMAIN_NAME      5\n";
		file << "#define PRED_HEAD      35\n";
		file << "#define T__71      71\n";
		file << "#define T__72      72\n";
		file << "#define PREDICATES      11\n";
		file << "#define VARIABLE      47\n";
		file << "#define T__70      70\n";
		file << "#define INIT_AT      40\n";
		file << "#define T__76      76\n";
		file << "#define T__75      75\n";
		file << "#define T__74      74\n";
		file << "#define INIT      19\n";
		file << "#define T__73      73\n";
		file << "#define T__79      79\n";
		file << "#define T__78      78\n";
		file << "#define T__77      77\n";
		file << "#define AND_GD      23\n";
		file << "#define T__68      68\n";
		file << "#define T__69      69\n";
		file << "#define T__66      66\n";
		file << "#define T__67      67\n";
		file << "#define T__64      64\n";
		file << "#define FUNC_HEAD      20\n";
		file << "#define T__65      65\n";
		file << "#define T__62      62\n";
		file << "#define T__63      63\n";
		file << "#define PARAMETERS      12\n";
		file << "#define NOT_GD      25\n";
		file << "#define PROBLEM_NAME      16\n";
		file << "#define T__118      118\n";
		file << "#define DURATIVE_ACTION      14\n";
		file << "#define T__119      119\n";
		file << "#define T__116      116\n";
		file << "#define T__117      117\n";
		file << "#define T__114      114\n";
		file << "#define T__115      115\n";
		file << "#define PROBLEM_METRIC      44\n";
		file << "#define T__120      120\n";
		file << "#define CONSTANTS      9\n";
		file << "#define T__61      61\n";
		file << "#define T__60      60\n";
		file << "#define T__55      55\n";
		file << "#define T__56      56\n";
		file << "#define T__57      57\n";
		file << "#define T__58      58\n";
		file << "#define T__54      54\n";
		file << "#define IMPLY_GD      26\n";
		file << "#define T__107      107\n";
		file << "#define T__108      108\n";
		file << "#define T__109      109\n";
		file << "#define T__59      59\n";
		file << "#define T__103      103\n";
		file << "#define T__104      104\n";
		file << "#define T__105      105\n";
		file << "#define T__106      106\n";
		file << "#define T__111      111\n";
		file << "#define T__110      110\n";
		file << "#define T__113      113\n";
		file << "#define T__112      112\n";
		file << "#define INIT_EQ      39\n";
		file << "#define DIGIT      51\n";
		file << "#define NOT_PRED_INIT      41\n";
		file << "#define BINARY_OP      37\n";
		file << "#define GOAL      36\n";
		file << "#define FORALL_GD      28\n";
		file << "#define T__102      102\n";
		file << "#define T__101      101\n";
		file << "#define T__100      100\n";
		file << "#define DOMAIN      4\n";
		file << "#define WHEN_EFFECT      32\n";
		file << "#define PRECONDITION      21\n";
		file << "#define EFFECT      22\n";
		file << "#define PROBLEM_CONSTRAINT      43\n";
		file << "#define AND_EFFECT      30\n";
		file << "#define EITHER_TYPE      8\n";
		file << "#define FORALL_EFFECT      31\n";
		file << "#define REQUIREMENTS      6\n";
		file << "#ifdef	EOF\n";
		file << "#undef	EOF\n";
		file << "#define	EOF	ANTLR3_TOKEN_EOF\n";
		file << "#endif\n";
		file << "\n";
		file << "#ifndef TOKENSOURCE\n";
		file << "#define TOKENSOURCE(lxr) lxr->pLexer->rec->state->tokSource\n";
		file << "#endif\n";
		file << "\n";
		file << "/* End of token definitions for PddlParser\n";
		file << " * =============================================================================\n";
		file << " */\n";
		file << "/** \\} */\n";
		file << "\n";
		file << "#ifdef __cplusplus\n";
		file << "}\n";
		file << "#endif\n";
		file << "\n";
		file << "#endif\n";
		file << "\n";
		file << "/* END - Note:Keep extra line feed to satisfy UNIX systems */\n";
		file.close ();
	}



	{
		ofstream file ("GNUmakefile", ios_base::out);
		file << "CC=	g++\n";
		file << "RM=	rm\n";
		file << "SHARED_OBJECT_FLAG = -shared\n";
		file << "INC_PATH = -I../include -I../include/antlr31\n";
		file << "LIB_PATH = -L../lib\n";
		file << "\n";
		file << "DEBUG = -ggdb #-DNDEBUG\n";
		file << "OPTIMIZE = -O3 -DNDEBUG\n";
		file << "LARGE_FILE_SUPPORT = -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE\n";
		file << "\n";
		file << "ENABLE_SOURCE_DUMP = 1\n";
		file << "\n";
		file << "# set debug & optimization flags...	----------------\n";
		file << "CFLAGS = $(INC_PATH) \\\n";
		file << "		   -Wall \\\n";
		file << "		   $(CUSTOM_FLAGS) \\\n";
		file << "		   -fPIC \\\n";
		file << "\n";
		file << "\n";
		file << "CXXFLAGS = $(INC_PATH) \\\n";
		file << "		   -Wall \\\n";
		file << "		   $(CUSTOM_FLAGS) \\\n";
		file << "		   -fPIC \\\n";
		file << "		   -fno-rtti \\\n";
		file << "		   # $(LARGE_FILE_SUPPORT)\n";
		file << "\n";
		file << "\n";
		file << "# build targets  -----------------------------------\n";
		file << "# test: clean build\n";
		file << "\n";
		file << "# use this for performance\n";
		file << "CUSTOM_FLAGS = $(OPTIMIZE) \\\n";
		file << "			   -m64 \\\n";
		file << "			   -Wno-deprecated \\\n";
		file << "			   #-ggdb #-pg\n";
		file << "\n";
		file << "# use this for debug:\n";
		file << "#CUSTOM_FLAGS = -Wno-deprecated \\\n";
		file << "			   -ggdb\n";
		file << "\n";
		file << "TARGET = lhla_v33\n";
		file << "\n";
		file << "OBJS = Probability.o \\\n";
		file << "	   Feature.o \\\n";
		file << "	   LogLinearPolicy.o \\\n";
		file << "	   Zlib.o \\\n";
		file << "	   CompressedBuffer.o \\\n";
		file << "	   FFInterface.o \\\n";
		file << "	   Pddl.o \\\n";
		file << "	   PddlParser.o \\\n";
		file << "	   PddlLexer.o \\\n";
		file << "	   PddlInterface.o \\\n";
		file << "	   SubgoalPolicy.o \\\n";
		file << "	   Learner.o \\\n";
		file << "	   main.o \\\n";
		file << "	   Problems.o \\\n";
		file << "	   SourceDump.o\n";
		file << "\n";
		file << "\n";
		file << "LIBS = -lnlp_string \\\n";
		file << "	   -lnlp_config \\\n";
		file << "	   -lnlp_filesystem \\\n";
		file << "	   -lnlp_time \\\n";
		file << "	   -lnlp_socket \\\n";
		file << "	   -lnlp_distr \\\n";
		file << "	   -lpthread \\\n";
		file << "	   -lgsl \\\n";
		file << "	   -lgslcblas \\\n";
		file << "	   -lz \\\n";
		file << "	   -lantlr3c\n";
		file << "\n";
		file << "build: preproc $(TARGET)\n";
		file << "\n";
		file << "$(TARGET): $(OBJS)\n";
		file << "	$(CXX) $(CUSTOM_FLAGS) $(LIB_PATH) -o$(TARGET) $(OBJS) $(LIBS)\n";
		file << "\n";
		file << "%.o: %.c\n";
		file << "	gcc -c -o $@ $< $(CFLAGS)\n";
		file << "\n";
		file << "SourceDump.o: SourceDump.cpp\n";
		file << "	g++ $(INC_PATH) -fno-rtti -DNDEBUG -Wno-deprecated -fPIC -c -o SourceDump.o SourceDump.cpp\n";
		file << "\n";
		file << "preproc:\n";
		file << "	python source.py\n";
		file << "\n";
		file << "clean:\n";
		file << "	@echo \"  -- cleaning out object files : \" $(TARGET)  $(OBJS)\n";
		file << "	-@$(RM) -f $(OBJS) $(TARGET)\n";
		file << "\n";
		file << "all: clean build\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("Probability.cpp", ios_base::out);
		file << "#include \"Probability.h\"\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "LogProbability::LogProbability (size_t _iSize)\n";
		file << "{\n";
		file << "	vec_LogProb.Reserve (_iSize);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "LogProbability::LogProbability (void)\n";
		file << "{\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "LogProbability::~LogProbability (void)\n";
		file << "{\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void LogProbability::Create (size_t _iSize)\n";
		file << "{\n";
		file << "	vec_LogProb.Reserve (_iSize);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void LogProbability::RemoveOffset (void)\n";
		file << "{\n";
		file << "	double dMaxLogProb = vec_LogProb.Max ();\n";
		file << "	for (size_t i = 0; i < vec_LogProb.Size (); ++ i)\n";
		file << "		vec_LogProb [i] -= dMaxLogProb;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void LogProbability::Normalize (void)\n";
		file << "{\n";
		file << "	double dMaxLogProb = vec_LogProb.Max ();\n";
		file << "	double dSum = 0;\n";
		file << "	for (size_t i = 0; i < vec_LogProb.Size (); ++ i)\n";
		file << "	{\n";
		file << "		vec_LogProb [i] -= dMaxLogProb;\n";
		file << "		double dProb = exp (vec_LogProb [i]);\n";
		file << "		dSum += dProb;\n";
		file << "	}\n";
		file << "\n";
		file << "	if (0 != dSum)\n";
		file << "	{\n";
		file << "		for (size_t i = 0; i < vec_LogProb.Size (); ++ i)\n";
		file << "			vec_LogProb [i] -= log (dSum);\n";
		file << "	}\n";
		file << "	else\n";
		file << "	{\n";
		file << "		double dLogUniform = log (1 / (double) vec_LogProb.Size ());\n";
		file << "		for (size_t i = 0; i < vec_LogProb.Size (); ++ i)\n";
		file << "			vec_LogProb [i] = dLogUniform;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "LogProbability& LogProbability::operator= (const Probability& _rProb)\n";
		file << "{\n";
		file << "	size_t iSize = _rProb.vec_Prob.Size ();\n";
		file << "	if (0 == iSize)\n";
		file << "		return *this;\n";
		file << "\n";
		file << "	vec_LogProb.Reserve (iSize);\n";
		file << "	for (size_t i = 0; i < iSize; ++ i)\n";
		file << "		vec_LogProb [i] = log (_rProb.vec_Prob [i]);\n";
		file << "\n";
		file << "	return *this;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "LogProbability& LogProbability::operator= (const LogProbability& _rLogProb)\n";
		file << "{\n";
		file << "	size_t iSize = _rLogProb.vec_LogProb.Size ();\n";
		file << "	if (0 == iSize)\n";
		file << "		return *this;\n";
		file << "\n";
		file << "	vec_LogProb.Reserve (iSize);\n";
		file << "	for (size_t i = 0; i < iSize; ++ i)\n";
		file << "		vec_LogProb [i] = _rLogProb.vec_LogProb [i];\n";
		file << "\n";
		file << "	return *this;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "LogProbability& LogProbability::operator+= (const LogProbability& _rLogProb)\n";
		file << "{\n";
		file << "	size_t iSize = _rLogProb.vec_LogProb.Size ();\n";
		file << "	if (0 == iSize)\n";
		file << "		return *this;\n";
		file << "\n";
		file << "	if (0 == vec_LogProb.Size ())\n";
		file << "		*this = _rLogProb;\n";
		file << "	else if (vec_LogProb.Size () == iSize)\n";
		file << "	{\n";
		file << "		for (size_t i = 0; i < iSize; ++ i)\n";
		file << "			vec_LogProb [i] += _rLogProb.vec_LogProb [i];\n";
		file << "	}\n";
		file << "	else\n";
		file << "		cerr << \"[ERROR] Size mismatch between LogProbability objects during assignment.\"\n";
		file << "			 << endl;\n";
		file << "\n";
		file << "	return *this;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double LogProbability::Entropy (void)\n";
		file << "{\n";
		file << "	Probability oProb (*this);\n";
		file << "	return oProb.Entropy ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double LogProbability::MaxMinDiff (void)\n";
		file << "{\n";
		file << "	Probability oProb (*this);\n";
		file << "	return oProb.MaxMinDiff ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Probability::Probability (size_t _iSize)\n";
		file << "{\n";
		file << "	vec_Prob.Reserve (_iSize);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Probability::Probability (const LogProbability& _rLogProb)\n";
		file << "{\n";
		file << "	size_t iSize = _rLogProb.vec_LogProb.Size ();\n";
		file << "	if (0 == iSize)\n";
		file << "		return;\n";
		file << "\n";
		file << "	vec_Prob.Reserve (iSize);\n";
		file << "	double dMaxLogProb = _rLogProb.vec_LogProb.Max ();\n";
		file << "	double dSum = 0;\n";
		file << "	for (size_t i = 0; i < iSize; ++ i)\n";
		file << "	{\n";
		file << "		double dProb = exp (_rLogProb.vec_LogProb [i] - dMaxLogProb);\n";
		file << "		vec_Prob [i] = dProb;\n";
		file << "		dSum += dProb;\n";
		file << "	}\n";
		file << "\n";
		file << "	for (size_t i = 0; i < iSize; ++ i)\n";
		file << "		vec_Prob [i] /= dSum;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "Probability::Probability (void)\n";
		file << "{\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Probability::~Probability (void)\n";
		file << "{\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Probability::Create (size_t _iSize)\n";
		file << "{\n";
		file << "	vec_Prob.Reserve (_iSize);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Probability::Normalize (void)\n";
		file << "{\n";
		file << "	double dSum = 0;\n";
		file << "	for (size_t i = 0; i < vec_Prob.Size (); ++ i)\n";
		file << "		dSum += vec_Prob [i];\n";
		file << "\n";
		file << "	if (0 != dSum)\n";
		file << "	{\n";
		file << "		for (size_t i = 0; i < vec_Prob.Size (); ++ i)\n";
		file << "			vec_Prob [i] /= dSum;\n";
		file << "	}\n";
		file << "	else\n";
		file << "	{\n";
		file << "		double dUniform = 1 / (double) vec_Prob.Size ();\n";
		file << "		for (size_t i = 0; i < vec_Prob.Size (); ++ i)\n";
		file << "			vec_Prob [i] = dUniform;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Probability& Probability::operator= (const Probability& _rProb)\n";
		file << "{\n";
		file << "	size_t iSize = _rProb.vec_Prob.Size ();\n";
		file << "	if (0 == iSize)\n";
		file << "		return *this;\n";
		file << "\n";
		file << "	vec_Prob.Reserve (iSize);\n";
		file << "	for (size_t i = 0; i < iSize; ++ i)\n";
		file << "		vec_Prob [i] = _rProb.vec_Prob [i];\n";
		file << "\n";
		file << "	return *this;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Probability& Probability::operator= (const LogProbability& _rLogProb)\n";
		file << "{\n";
		file << "	size_t iSize = _rLogProb.vec_LogProb.Size ();\n";
		file << "	if (0 == iSize)\n";
		file << "		return *this;\n";
		file << "\n";
		file << "	vec_Prob.Reserve (iSize);\n";
		file << "	double dMaxLogProb = _rLogProb.vec_LogProb.Max ();\n";
		file << "	double dSum = 0;\n";
		file << "	for (size_t i = 0; i < iSize; ++ i)\n";
		file << "	{\n";
		file << "		double dProb = exp (_rLogProb.vec_LogProb [i] - dMaxLogProb);\n";
		file << "		vec_Prob [i] = dProb;\n";
		file << "		dSum += dProb;\n";
		file << "	}\n";
		file << "\n";
		file << "	for (size_t i = 0; i < iSize; ++ i)\n";
		file << "		vec_Prob [i] /= dSum;\n";
		file << "\n";
		file << "	return *this;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double Probability::Entropy (void)\n";
		file << "{\n";
		file << "	double dEntropy = 0;\n";
		file << "	for (size_t i = 0; i < vec_Prob.Size (); ++ i)\n";
		file << "	{\n";
		file << "		if (0 == vec_Prob [i])\n";
		file << "			continue;\n";
		file << "		dEntropy -= vec_Prob [i] * log (vec_Prob [i]);\n";
		file << "	}\n";
		file << "\n";
		file << "	return dEntropy;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double Probability::MaxMinDiff (void)\n";
		file << "{\n";
		file << "	double dMin = 1;\n";
		file << "	double dMax = 0;\n";
		file << "	for (size_t i = 0; i < vec_Prob.Size (); ++ i)\n";
		file << "	{\n";
		file << "		if (dMin > vec_Prob [i])\n";
		file << "			dMin = vec_Prob [i];\n";
		file << "		if (dMax < vec_Prob [i])\n";
		file << "			dMax = vec_Prob [i];\n";
		file << "	}\n";
		file << "\n";
		file << "	return dMax - dMin;\n";
		file << "}\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("Probability.h", ios_base::out);
		file << "#ifndef __PROB_LOGPROB__\n";
		file << "#define __PROB_LOGPROB__\n";
		file << "\n";
		file << "#include <nlp_vector.h>\n";
		file << "#include <iostream>\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "\n";
		file << "class LogProbability;\n";
		file << "typedef Vector<double>	double_Vec_t;\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class Probability\n";
		file << "{\n";
		file << "	friend class LogProbability;\n";
		file << "	private:\n";
		file << "		double_Vec_t	vec_Prob;\n";
		file << "\n";
		file << "	public:\n";
		file << "		Probability (const LogProbability& _rLogProb);\n";
		file << "		Probability (size_t _iSize);\n";
		file << "		Probability (void);\n";
		file << "		~Probability (void);\n";
		file << "\n";
		file << "		void Create (size_t _iSize);\n";
		file << "		void Normalize (void);\n";
		file << "		void Memset (size_t _iValue)\n";
		file << "		{ vec_Prob.Memset (_iValue); };\n";
		file << "		size_t Size (void)\n";
		file << "		{ return vec_Prob.Size (); };\n";
		file << "		double& operator[] (size_t _iIndex)\n";
		file << "		{\n";
		file << "			assert (_iIndex < vec_Prob.Size ());\n";
		file << "			return vec_Prob [_iIndex];\n";
		file << "		};\n";
		file << "		Probability& operator= (const Probability& _rProb);\n";
		file << "		Probability& operator= (const LogProbability& _rLogProb);\n";
		file << "\n";
		file << "		void PrintToStream (ostream& _rStream) const\n";
		file << "		{ _rStream << vec_Prob; };\n";
		file << "\n";
		file << "		double* GetData (void)\n";
		file << "		{ return vec_Prob; };\n";
		file << "\n";
		file << "		double Entropy (void);\n";
		file << "		double MaxMinDiff (void);\n";
		file << "};\n";
		file << "\n";
		file << "inline ostream& operator<< (ostream& _rStream, const Probability& _rProb)\n";
		file << "{\n";
		file << "	_rProb.PrintToStream (_rStream);\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "class LogProbability\n";
		file << "{\n";
		file << "	friend class Probability;\n";
		file << "	private:\n";
		file << "		double_Vec_t	vec_LogProb;\n";
		file << "\n";
		file << "	public:\n";
		file << "		LogProbability (size_t _iSize);\n";
		file << "		LogProbability (void);\n";
		file << "		~LogProbability (void);\n";
		file << "\n";
		file << "		void Create (size_t _iSize);\n";
		file << "		void RemoveOffset (void);\n";
		file << "		void Normalize (void);\n";
		file << "		void Memset (size_t _iValue)\n";
		file << "		{ vec_LogProb.Memset (_iValue); };\n";
		file << "		size_t Size (void) const\n";
		file << "		{ return vec_LogProb.Size (); };\n";
		file << "		double& operator[] (size_t _iIndex)\n";
		file << "		{\n";
		file << "			assert (_iIndex < vec_LogProb.Size ());\n";
		file << "			return vec_LogProb [_iIndex];\n";
		file << "		};\n";
		file << "		LogProbability& operator= (const Probability& _rProb);\n";
		file << "		LogProbability& operator= (const LogProbability& _rLogProb);\n";
		file << "		LogProbability& operator+= (const LogProbability& _rLogProb);\n";
		file << "\n";
		file << "		void PrintToStream (ostream& _rStream) const\n";
		file << "		{ _rStream << vec_LogProb; };\n";
		file << "\n";
		file << "		double* GetData (void)\n";
		file << "		{ return vec_LogProb; };\n";
		file << "\n";
		file << "		double Entropy (void);\n";
		file << "		double MaxMinDiff (void);\n";
		file << "};\n";
		file << "\n";
		file << "inline ostream& operator<< (ostream& _rStream, const LogProbability& _rLogProb)\n";
		file << "{\n";
		file << "	_rLogProb.PrintToStream (_rStream);\n";
		file << "	return _rStream;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("Problems.cpp", ios_base::out);
		file << "#include \"Problems.h\"\n";
		file << "#include \"PddlInterface.h\"\n";
		file << "#include <assert.h>\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Problem::Problem (String& _rProblem, String& _rFileName)\n";
		file << "{\n";
		file << "	s_FileName = _rFileName;\n";
		file << "	s_Problem = _rProblem;\n";
		file << "	b_SubgoalsNotNeeded = false;\n";
		file << "	p_SolutionSequence = NULL;\n";
		file << "	d_SolutionReward = 0;\n";
		file << "	i_SolutionIteration = -100;\n";
		file << "\n";
		file << "	PddlProblem* pPddl = PddlInterface::ParseProblemPddl (s_Problem);\n";
		file << "	s_PddlPreamble = pPddl->o_StartState.s_Preamble;\n";
		file << "	delete pPddl;\n";
		file << "	p_PddlProblem = NULL;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Problem::~Problem (void)\n";
		file << "{\n";
		file << "	delete p_PddlProblem;\n";
		file << "	delete p_SolutionSequence;\n";
		file << "	p_PddlProblem = (PddlProblem*)0x1;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlProblem& Problem::GetPddlProblem (void)\n";
		file << "{\n";
		file << "	if (NULL == p_PddlProblem)\n";
		file << "		p_PddlProblem = PddlInterface::ParseProblemPddl (s_Problem);\n";
		file << "\n";
		file << "	return *p_PddlProblem;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool Problem::AddSolution (SubgoalSequence* _pSequence,\n";
		file << "						   double _dReward,\n";
		file << "						   int _iIteration)\n";
		file << "{\n";
		file << "	String sSolution = _pSequence->ToLogString ();\n";
		file << "	SolutionsToCount_map_t::iterator	ite;\n";
		file << "	ite = map_SolutionsToCount.find (sSolution);\n";
		file << "	if (map_SolutionsToCount.end () == ite)\n";
		file << "		map_SolutionsToCount [sSolution] = 1;\n";
		file << "	else\n";
		file << "		++ ite->second;\n";
		file << "\n";
		file << "	if (d_SolutionReward >= _dReward)\n";
		file << "		return false;\n";
		file << "\n";
		file << "	delete p_SolutionSequence;\n";
		file << "	p_SolutionSequence = _pSequence;\n";
		file << "	d_SolutionReward = _dReward;\n";
		file << "	i_SolutionIteration = _iIteration;\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool Problem::Load (void)\n";
		file << "{\n";
		file << "	cout << \"Loading planning problems...\" << endl;\n";
		file << "	String sPath ((config)\"problems_path\");\n";
		file << "\n";
		file << "	String_dq_t dqFiles;\n";
		file << "	if (false == Path::GetFileList (sPath, dqFiles))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed to get problem file list.\"\n";
		file << "			 << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	ITERATE (String_dq_t, dqFiles, ite)\n";
		file << "	{\n";
		file << "		String sFilePath;\n";
		file << "		sFilePath << sPath << '/' << *ite;\n";
		file << "		if (false == Path::IsRegularFile (sFilePath))\n";
		file << "			continue;\n";
		file << "\n";
		file << "		String_dq_t dqLines;\n";
		file << "		if (false == File::ReadLines (sFilePath, dqLines))\n";
		file << "			continue;\n";
		file << "\n";
		file << "		String sProblem;\n";
		file << "		sProblem.Join (dqLines, '\\n');\n";
		file << "		dq_Problems.push_back (Problem (sProblem, *ite));\n";
		file << "	}\n";
		file << "\n";
		file << "	cout << \"   \" << dq_Problems.size () << \" problems loaded.\" << endl;\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "long Problem::TotalSolvedProblems (void)\n";
		file << "{\n";
		file << "	long lTotalSolutions = 0;\n";
		file << "	ITERATE (Problem_dq_t, dq_Problems, iteProblem)\n";
		file << "	{\n";
		file << "		Problem& rProblem = *iteProblem;\n";
		file << "		if ((false == rProblem.b_SubgoalsNotNeeded) &&\n";
		file << "			(true == rProblem.map_SolutionsToCount.empty ()))\n";
		file << "			continue;\n";
		file << "		++ lTotalSolutions;\n";
		file << "	}\n";
		file << "	return lTotalSolutions;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool Problem::LogSolutions (const char* _zPath)\n";
		file << "{\n";
		file << "	if (false == Path::Exists (_zPath))\n";
		file << "		Path::CreatePath (_zPath, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);\n";
		file << "	if (false == Path::IsDirectory (_zPath))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Output path for problem solutions is not a directory.\\n\"\n";
		file << "			 << _zPath << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "	if (false == Path::Writable (_zPath))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Output path for problem solutions is not writable.\\n\"\n";
		file << "			 << _zPath << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	ITERATE (Problem_dq_t, dq_Problems, iteProblem)\n";
		file << "	{\n";
		file << "		Problem& rProblem = *iteProblem;\n";
		file << "		if (true == rProblem.map_SolutionsToCount.empty ())\n";
		file << "			continue;\n";
		file << "\n";
		file << "		String sFilePath;\n";
		file << "		sFilePath << _zPath << '/' << rProblem.s_FileName;\n";
		file << "\n";
		file << "		File file;\n";
		file << "		if (false == file.Open (sFilePath, ios_base::out))\n";
		file << "		{\n";
		file << "			cerr << \"[ERROR] Failed to open file for writing : \"\n";
		file << "				 << sFilePath << endl;\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "\n";
		file << "		file << rProblem.p_PddlProblem->o_PartialGoalState.GetPredicatePddlString ()\n";
		file << "			 << \"\\n===========================\\n\";\n";
		file << "		if (true == rProblem.b_SubgoalsNotNeeded)\n";
		file << "			file << \"[SUBGOALS NOT NEEDED]\" << endl;\n";
		file << "		else\n";
		file << "		{\n";
		file << "			ITERATE (SolutionsToCount_map_t, rProblem.map_SolutionsToCount, ite)\n";
		file << "			{\n";
		file << "				file << ite->second << '\\n'\n";
		file << "					 << ite->first\n";
		file << "					 << \"\\n---------------------------\\n\";\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		file.flush ();\n";
		file << "		file.Close ();\n";
		file << "	}\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void Problem::PrintSolvedProblems (void)\n";
		file << "{\n";
		file << "	ITERATE (Problem_dq_t, dq_Problems, iteProblem)\n";
		file << "	{\n";
		file << "		Problem& rProblem = *iteProblem;\n";
		file << "		cout << \"   \" << rProblem.s_FileName;\n";
		file << "\n";
		file << "		if (true == rProblem.map_SolutionsToCount.empty ())\n";
		file << "		{\n";
		file << "			cout << \"  [NOT SOLVED]\" << endl;\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "		if (true == rProblem.b_SubgoalsNotNeeded)\n";
		file << "		{\n";
		file << "			cout << \"  [SUBGOALS NOT NEEDED]\" << endl;\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "\n";
		file << "		String sMostCommonSolution;\n";
		file << "		int iCount = 0;\n";
		file << "		ITERATE (SolutionsToCount_map_t, rProblem.map_SolutionsToCount, ite)\n";
		file << "		{\n";
		file << "			if (iCount >= ite->second)\n";
		file << "				continue;\n";
		file << "			iCount = ite->second;\n";
		file << "			sMostCommonSolution = ite->first;\n";
		file << "		}\n";
		file << "\n";
		file << "		sMostCommonSolution.Replace (\"\\n\", \" \");\n";
		file << "		cout << \"  \" << sMostCommonSolution << endl;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("Problems.h", ios_base::out);
		file << "#ifndef __PLANNING_PROBLEM__\n";
		file << "#define __PLANNING_PROBLEM__\n";
		file << "\n";
		file << "#include \"SubgoalPolicy.h\"\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <nlp_filesystem.h>\n";
		file << "#include <nlp_config.h>\n";
		file << "#include <nlp_macros.h>\n";
		file << "#include \"Pddl.h\"\n";
		file << "\n";
		file << "\n";
		file << "class Problem;\n";
		file << "typedef deque <Problem>		Problem_dq_t;\n";
		file << "typedef map <String, int>	SolutionsToCount_map_t;\n";
		file << "\n";
		file << "class Problem\n";
		file << "{\n";
		file << "	private:\n";
		file << "		static Problem_dq_t	dq_Problems;\n";
		file << "\n";
		file << "	public:\n";
		file << "		String				s_FileName;\n";
		file << "		String				s_Problem;\n";
		file << "		String				s_PddlPreamble;\n";
		file << "		PddlProblem*		p_PddlProblem;\n";
		file << "		SubgoalSequence*	p_SolutionSequence;\n";
		file << "		double				d_SolutionReward;\n";
		file << "		int					i_SolutionIteration;\n";
		file << "		bool				b_SubgoalsNotNeeded;\n";
		file << "		SolutionsToCount_map_t	map_SolutionsToCount;\n";
		file << "\n";
		file << "		int_Vec_t			vec_InitPredicateIdentityFI;\n";
		file << "		int_Vec_t			vec_InitPredicateNameFI;\n";
		file << "		int_Vec_t			vec_InitParameterValueFI;\n";
		file << "		int_Vec_t			vec_TargetPredicateIdentityFI;\n";
		file << "		int_Vec_t			vec_TargetPredicateNameFI;\n";
		file << "		int_Vec_t			vec_TargetParameterValueFI;\n";
		file << "\n";
		file << "		//\n";
		file << "		Problem (String& _rProblem, String& _rFileName);\n";
		file << "		~Problem (void);\n";
		file << "\n";
		file << "		PddlProblem& GetPddlProblem (void);\n";
		file << "		bool AddSolution (SubgoalSequence* _pSequence,\n";
		file << "						  double _dReward,\n";
		file << "						  int _iIteration);\n";
		file << "		SubgoalSequence* GetCurrentSolution (void)\n";
		file << "		{ return p_SolutionSequence; };\n";
		file << "		double GetCurrentSolutionReward (void)\n";
		file << "		{ return d_SolutionReward; };\n";
		file << "		int GetCurrentSolutionIteration (void)\n";
		file << "		{ return i_SolutionIteration; };\n";
		file << "\n";
		file << "\n";
		file << "		static bool Load (void);\n";
		file << "\n";
		file << "		static void Clear (void)\n";
		file << "		{ dq_Problems.clear (); }\n";
		file << "\n";
		file << "		static long GetProblemCount (void)\n";
		file << "		{ return dq_Problems.size (); };\n";
		file << "\n";
		file << "		static Problem* GetProblem (int _iProblem)\n";
		file << "		{ return &dq_Problems [_iProblem]; };\n";
		file << "\n";
		file << "		static long TotalSolvedProblems (void);\n";
		file << "		static bool LogSolutions (const char* _zPath);\n";
		file << "		static void PrintSolvedProblems (void);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file.close ();
	}



	{
		ofstream file ("Zlib.h", ios_base::out);
		file << "#ifndef __ZLIB__\n";
		file << "#define __ZLIB__\n";
		file << "\n";
		file << "#include <nlp_string.h>\n";
		file << "#include <nlp_socket.h>\n";
		file << "#include <zlib.h>\n";
		file << "using namespace std;\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "// -----------------------------------------------------\n";
		file << "class ZlibWrapper\n";
		file << "{\n";
		file << "	public:\n";
		file << "		static bool Compress (const String& _rText,\n";
		file << "							  Buffer* _pBuffer);\n";
		file << "		static bool Uncompress (const Buffer& _rBuffer,\n";
		file << "								int _iUncompressedLength,\n";
		file << "								String* _pText);\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("CompressedBuffer.cpp", ios_base::out);
		file << "#include \"CompressedBuffer.h\"\n";
		file << "#include \"Zlib.h\"\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "CompressedBuffer::CompressedBuffer (void)\n";
		file << "	: Buffer ()\n";
		file << "{\n";
		file << "	i_UncompressedSize = 0;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "CompressedBuffer::CompressedBuffer (const CompressedBuffer& _rBuffer)\n";
		file << "	: Buffer (_rBuffer)\n";
		file << "{\n";
		file << "	i_UncompressedSize = _rBuffer.i_UncompressedSize;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "CompressedBuffer::CompressedBuffer (const String& _rText)\n";
		file << "{\n";
		file << "	i_UncompressedSize = _rText.length () + 1;\n";
		file << "	if (true == ZlibWrapper::Compress (_rText, this))\n";
		file << "		return;\n";
		file << "\n";
		file << "	cerr << \"[ERROR] Error during compression of text (length \"\n";
		file << "		 << i_UncompressedSize\n";
		file << "		 << \") in CompressedBuffer::CompressedBuffer ()\"\n";
		file << "		 << endl;\n";
		file << "	i_UncompressedSize = 0;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void CompressedBuffer::SetData (const void* _zData,\n";
		file << "								size_t _lCompressedSize,\n";
		file << "								size_t _lUncompressedSize)\n";
		file << "{\n";
		file << "	Buffer::SetData (_zData, _lCompressedSize);\n";
		file << "	i_UncompressedSize = _lUncompressedSize;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool CompressedBuffer::Compress (const String& _rUncompressedText)\n";
		file << "{\n";
		file << "	i_UncompressedSize = _rUncompressedText.length () + 1;\n";
		file << "	if (true == ZlibWrapper::Compress (_rUncompressedText, this))\n";
		file << "		return true;\n";
		file << "\n";
		file << "	cerr << \"[ERROR] Error during compression of text (length \"\n";
		file << "		 << i_UncompressedSize\n";
		file << "		 << \") in CompressedBuffer::CompressedBuffer ()\"\n";
		file << "		 << endl;\n";
		file << "	i_UncompressedSize = 0;\n";
		file << "	return false;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool CompressedBuffer::Uncompress (String* _pUncompressedText) const\n";
		file << "{\n";
		file << "	return ZlibWrapper::Uncompress (*this,\n";
		file << "									i_UncompressedSize,\n";
		file << "									_pUncompressedText);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



	{
		ofstream file ("CompressedBuffer.h", ios_base::out);
		file << "#ifndef __COMPRESSED_BUFFER__\n";
		file << "#define __COMPRESSED_BUFFER__\n";
		file << "\n";
		file << "#include <nlp_socket.h>\n";
		file << "\n";
		file << "\n";
		file << "class CompressedBuffer : public Buffer\n";
		file << "{\n";
		file << "	private:\n";
		file << "		size_t	i_UncompressedSize;\n";
		file << "\n";
		file << "	public:\n";
		file << "		CompressedBuffer (void);\n";
		file << "		CompressedBuffer (const CompressedBuffer& _rBuffer);\n";
		file << "		CompressedBuffer (const String& _rText);\n";
		file << "\n";
		file << "		void SetData (const void* _zData,\n";
		file << "					  size_t _lCompressedSize,\n";
		file << "					  size_t _lUncompressedSize);\n";
		file << "		bool Compress (const String& _rUncompressedText);\n";
		file << "		bool Uncompress (String* _pUncompressedText) const;\n";
		file << "\n";
		file << "		size_t UncompressedSize (void) const\n";
		file << "		{ return i_UncompressedSize; };\n";
		file << "		size_t CompressedSize (void) const\n";
		file << "		{ return Buffer::Length (); };\n";
		file << "\n";
		file << "		bool operator== (const CompressedBuffer& _rBuffer) const\n";
		file << "		{ return *((Buffer*)this) == (const Buffer&)_rBuffer; };\n";
		file << "};\n";
		file << "\n";
		file << "\n";
		file << "namespace __gnu_cxx\n";
		file << "{\n";
		file << "	template <>\n";
		file << "	struct hash<CompressedBuffer>\n";
		file << "	{\n";
		file << "		size_t operator()(const CompressedBuffer& b) const\n";
		file << "		{\n";
		file << "			unsigned long __h = 0;\n";
		file << "			for (unsigned long i = 0;i < b.Length (); ++i)\n";
		file << "				__h ^= (( __h << 5) + (__h >> 2) + (int) b[i]);\n";
		file << "\n";
		file << "			return size_t(__h);\n";
		file << "		}\n";
		file << "	};\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "#endif\n";
		file.close ();
	}



	{
		ofstream file ("SubgoalPolicy.sp.cpp", ios_base::out);
		file << "#include \"SubgoalPolicy.h\"\n";
		file << "#include <nlp_config.h>\n";
		file << "#include <nlp_filesystem.h>\n";
		file << "#include <nlp_macros.h>\n";
		file << "#include <assert.h>\n";
		file << "#include \"Problems.h\"\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "Subgoal::Subgoal (void)\n";
		file << "{\n";
		file << "	l_States = -1;\n";
		file << "	i_SubgoalSelection = -1;\n";
		file << "	i_SequenceEnd = -1;\n";
		file << "	e_PlanningOutcome = po_unknown;\n";
		file << "	p_PddlProblem = NULL;\n";
		file << "	p_PddlTargetProblem = NULL;\n";
		file << "	p_PddlSubgoalPredicate = NULL;\n";
		file << "	b_IsLastSubgoalToTarget = false;\n";
		file << "	b_ForcedSequenceEnd = false;\n";
		file << "	p_SelectedPredicateFeatures = NULL;\n";
		file << "}\n";
		file << "\n";
		file << "Subgoal::~Subgoal (void)\n";
		file << "{\n";
		file << "	l_States = -2;\n";
		file << "	e_PlanningOutcome = po_unknown;\n";
		file << "	delete p_PddlProblem;\n";
		file << "\n";
		file << "	ITERATE (Features_vec_t, vec_SequenceEndFeatureVectors, ite)\n";
		file << "		delete *ite;\n";
		file << "	vec_SequenceEndFeatureVectors.clear ();\n";
		file << "	delete p_SelectedPredicateFeatures;\n";
		file << "\n";
		file << "	ITERATE (Features_vec_t, vec_SubgoalFeatureVectors, ite)\n";
		file << "		delete *ite;\n";
		file << "	vec_SubgoalFeatureVectors.clear ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "SubgoalSequence::SubgoalSequence (void)\n";
		file << "{\n";
		file << "}\n";
		file << "\n";
		file << "SubgoalSequence::~SubgoalSequence (void)\n";
		file << "{\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalSequence::SetSubtaskFFResponse (unsigned int _iIndex,\n";
		file << "										   FFResponse& _rResponse)\n";
		file << "{\n";
		file << "	// current subgoal ...\n";
		file << "	#ifndef NDEBUG\n";
		file << "	if (_iIndex > dq_Subgoals.size ())\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] subgoal index in SetSubtaskFFResponse [\"\n";
		file << "			 << _iIndex << \"] out-of-bounds of sequence (length \"\n";
		file << "			 << dq_Subgoals.size () << \").\" << endl;\n";
		file << "		assert (false);\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	Subgoal& rCurrentSubgoal = dq_Subgoals [_iIndex];\n";
		file << "	rCurrentSubgoal.s_FFOutput = _rResponse.s_FFOutput;\n";
		file << "	rCurrentSubgoal.s_Plan = _rResponse.s_Plan;\n";
		file << "	rCurrentSubgoal.l_States = _rResponse.l_States;\n";
		file << "	rCurrentSubgoal.e_PlanningOutcome = _rResponse.e_PlanningOutcome;\n";
		file << "\n";
		file << "\n";
		file << "	// next subgoal ...\n";
		file << "	unsigned int iSubgoalIndex = _iIndex + 1;\n";
		file << "	if (iSubgoalIndex == dq_Subgoals.size ())\n";
		file << "	{\n";
		file << "		assert (true == dq_Subgoals [_iIndex].b_IsLastSubgoalToTarget);\n";
		file << "		// This is the last subgoal, so no need to\n";
		file << "		// the init state of next subgoal.\n";
		file << "		return;\n";
		file << "	}\n";
		file << "\n";
		file << "	#ifndef NDEBUG\n";
		file << "	if (iSubgoalIndex > dq_Subgoals.size ())\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] next subgoal index in SetSubtaskFFResponse [\"\n";
		file << "			 << iSubgoalIndex << \"] out-of-bounds of sequence (length \"\n";
		file << "			 << dq_Subgoals.size () << \").\" << endl;\n";
		file << "		assert (false);\n";
		file << "	}\n";
		file << "	#endif\n";
		file << "\n";
		file << "	Subgoal& rNextSubgoal = dq_Subgoals [iSubgoalIndex];\n";
		file << "	assert (\"\" == rNextSubgoal.s_StartStatePredicates);\n";
		file << "	rNextSubgoal.s_StartStatePredicates = _rResponse.s_EndStatePredicates;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalSequence::GetSubtask (unsigned int _iIndex,\n";
		file << "								  String* _pProblemPddl)\n";
		file << "{\n";
		file << "	if (_iIndex >= dq_Subgoals.size ())\n";
		file << "		return false;\n";
		file << "	Subgoal& rSubgoal = dq_Subgoals [_iIndex];\n";
		file << "	assert (SEQUENCE_END != rSubgoal.i_SequenceEnd);\n";
		file << "\n";
		file << "	assert (\"\" != s_ProblemPddlPreamble);\n";
		file << "	assert (\"\" != rSubgoal.s_StartStatePredicates);\n";
		file << "\n";
		file << "	String sGoal;\n";
		file << "	if (_iIndex + 1 == dq_Subgoals.size ())\n";
		file << "	{\n";
		file << "		if (false == rSubgoal.b_IsLastSubgoalToTarget)\n";
		file << "			return false;\n";
		file << "\n";
		file << "		assert (true == rSubgoal.b_IsLastSubgoalToTarget);\n";
		file << "		sGoal = rSubgoal.p_PddlTargetProblem->o_PartialGoalState.GetPredicatePddlString ();\n";
		file << "	}\n";
		file << "	else\n";
		file << "	{\n";
		file << "		assert (false == rSubgoal.b_IsLastSubgoalToTarget);\n";
		file << "		sGoal = rSubgoal.p_PddlSubgoalPredicate->GetPddlString ();\n";
		file << "	}\n";
		file << "\n";
		file << "	sGoal.Strip ();\n";
		file << "	if (\"\" == sGoal)\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] empty goal\";\n";
		file << "		if (true == rSubgoal.b_IsLastSubgoalToTarget)\n";
		file << "		{\n";
		file << "			cerr << \", last subgoal to target\" << endl;\n";
		file << "			cerr << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\";\n";
		file << "			cerr << rSubgoal.p_PddlTargetProblem->o_PartialGoalState << '\\n';\n";
		file << "			cerr << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\" << endl;\n";
		file << "		}\n";
		file << "		else\n";
		file << "		{\n";
		file << "			cerr << \", NOT last subgoal to target\" << endl;\n";
		file << "			cerr << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\";\n";
		file << "			cerr << *rSubgoal.p_PddlSubgoalPredicate << '\\n';\n";
		file << "			cerr << \"~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n\" << endl;\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	assert (\"\" != sGoal);\n";
		file << "\n";
		file << "	*_pProblemPddl = \"\";\n";
		file << "	*_pProblemPddl << \"(define\\n\"\n";
		file << "				   << s_ProblemPddlPreamble << \"\\n\\n\"\n";
		file << "				   << \"(:init \\n\"\n";
		file << "				   << rSubgoal.s_StartStatePredicates\n";
		file << "				   << \")\\n\"\n";
		file << "				   << \"(:goal \\n\"\n";
		file << "				   << sGoal\n";
		file << "				   << \"\\n)\\n)\";\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalSequence::SetSubtask (unsigned int _iIndex,\n";
		file << "								  String _rProblemPddl,\n";
		file << "								  PddlProblem* _pPddlProblem)\n";
		file << "{\n";
		file << "	assert (_iIndex < dq_Subgoals.size ());\n";
		file << "	dq_Subgoals [_iIndex].s_ProblemPddl = _rProblemPddl;\n";
		file << "	dq_Subgoals [_iIndex].p_PddlProblem = _pPddlProblem;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String SubgoalSequence::ToLogString (void)\n";
		file << "{\n";
		file << "	String sReturn;\n";
		file << "	ITERATE (Subgoal_dq_t, dq_Subgoals, ite)\n";
		file << "	{\n";
		file << "		Subgoal& rSubgoal = *ite;\n";
		file << "		if (SEQUENCE_END == rSubgoal.i_SequenceEnd)\n";
		file << "			continue;\n";
		file << "		if (true == rSubgoal.b_IsLastSubgoalToTarget)\n";
		file << "			continue;\n";
		file << "\n";
		file << "		if (\"\" != sReturn)\n";
		file << "			sReturn << '\\n';\n";
		file << "		sReturn << rSubgoal.p_PddlSubgoalPredicate->GetPddlString ();\n";
		file << "	}\n";
		file << "	return sReturn;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void ExplorationParameters::SetParamsFromConfig (String _rPrefix)\n";
		file << "{\n";
		file << "	f_EpsilonMin		= (config)(_rPrefix + \":epsilon-min\");\n";
		file << "	f_EpsilonRange		= ((float)(config)(_rPrefix + \":epsilon-max\")) - f_EpsilonMin;\n";
		file << "	f_BetaMin			= log2 ((config)(_rPrefix + \":beta-min\"));\n";
		file << "	f_BetaRange			= log2 ((config)(_rPrefix + \":beta-max\")) - f_BetaMin;\n";
		file << "	e_ExplorationType	= ToEnum ((config)(_rPrefix + \":exploration_type\"));\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String ExplorationParameters::SampleParameters (Sample& _rSample)\n";
		file << "{\n";
		file << "	String sExploration;\n";
		file << "\n";
		file << "	if ((et_epsilon_greedy == e_ExplorationType) ||\n";
		file << "		(et_epsilon_softmax == e_ExplorationType))\n";
		file << "	{\n";
		file << "		f_Epsilon = f_EpsilonMin + f_EpsilonRange * _rSample.SampleUniform ();\n";
		file << "		sExploration << \"e:\" << f_Epsilon << ' ';\n";
		file << "	}\n";
		file << "\n";
		file << "	if ((et_softmax == e_ExplorationType) ||\n";
		file << "		(et_epsilon_softmax == e_ExplorationType))\n";
		file << "	{\n";
		file << "		f_Beta = pow (2, f_BetaMin + f_BetaRange * _rSample.SampleUniform ());\n";
		file << "		sExploration << \"b:\" << f_Beta << ' ';\n";
		file << "	}\n";
		file << "\n";
		file << "	return sExploration;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void ExplorationParameters::PrintConfiguration (const char* _zPrefix)\n";
		file << "{\n";
		file << "	cout << \"   \" << _zPrefix << \" exploration : \"\n";
		file << "		 << ToString (e_ExplorationType)\n";
		file << "		 << endl;\n";
		file << "	if ((et_epsilon_greedy == e_ExplorationType) ||\n";
		file << "		(et_epsilon_softmax == e_ExplorationType))\n";
		file << "	{\n";
		file << "		cout << \"   \" << _zPrefix << \" epsilon     : \"\n";
		file << "			 << f_EpsilonMin << \" < \"\n";
		file << "			 << f_EpsilonMin + f_EpsilonRange\n";
		file << "			 << endl;\n";
		file << "	}\n";
		file << "	if ((et_softmax == e_ExplorationType) ||\n";
		file << "		(et_epsilon_softmax == e_ExplorationType))\n";
		file << "	{\n";
		file << "		cout << \"   \" << _zPrefix << \" beta        : \"\n";
		file << "			 << f_BetaMin << \" < \"\n";
		file << "			 << f_BetaMin + f_BetaRange\n";
		file << "			 << endl;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "SubgoalPolicy::SubgoalPolicy (void)\n";
		file << "{\n";
		file << "	Random::Init ();\n";
		file << "\n";
		file << "	b_UseSimpleConnectionFeatures = false;\n";
		file << "	b_UseTextConnectionFeatures = false;\n";
		file << "	b_UseComplexNonConnectionFeatures = false;\n";
		file << "}\n";
		file << "\n";
		file << "SubgoalPolicy::~SubgoalPolicy (void)\n";
		file << "{\n";
		file << "	Random::Destroy ();\n";
		file << "\n";
		file << "	ITERATE (PddlPredicate_vec_t, vec_CandidatePredicates, ite)\n";
		file << "		delete *ite;\n";
		file << "	vec_CandidatePredicates.clear ();\n";
		file << "\n";
		file << "	ITERATE (SentenceConnection_vec_t, vec_SentenceConnections, iteConn)\n";
		file << "	{\n";
		file << "		SentenceConnection* pConnection = *iteConn;\n";
		file << "		delete pConnection->p_PositiveFeatures;\n";
		file << "		delete pConnection->p_NegativeFeatures;\n";
		file << "		delete pConnection;\n";
		file << "	}\n";
		file << "	vec_SentenceConnections.clear ();\n";
		file << "\n";
		file << "	if (true == mtx_SentencesPositiveFromTo.IsInitialized ())\n";
		file << "	{\n";
		file << "		for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "		{\n";
		file << "			for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "			{\n";
		file << "				if (NULL != mtx_SentencesPositiveFromTo (f, t))\n";
		file << "					delete mtx_SentencesPositiveFromTo (f, t);\n";
		file << "				if (NULL != mtx_SentencesNegativeFromTo (f, t))\n";
		file << "					delete mtx_SentencesNegativeFromTo (f, t);\n";
		file << "			}\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "ExplorationType_e ExplorationParameters::ToEnum (String _sType)\n";
		file << "{\n";
		file << "	if (\"epsilon-greedy\" == _sType)\n";
		file << "		return et_epsilon_greedy;\n";
		file << "	else if (\"softmax\" == _sType)\n";
		file << "		return et_softmax;\n";
		file << "	else if (\"epsilon-softmax\" == _sType)\n";
		file << "		return et_epsilon_softmax;\n";
		file << "	return et_unknown;\n";
		file << "}\n";
		file << "\n";
		file << "const char* ExplorationParameters::ToString (ExplorationType_e _eType)\n";
		file << "{\n";
		file << "	if (et_epsilon_greedy == _eType)\n";
		file << "		return \"epsilon-greedy\";\n";
		file << "	else if (et_softmax == _eType)\n";
		file << "		return \"softmax\";\n";
		file << "	else if (et_epsilon_softmax == _eType)\n";
		file << "		return \"epsilon-softmax\";\n";
		file << "	return \"unknown\";\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::Init (void)\n";
		file << "{\n";
		file << "	o_SequenceEndModel.Init (\"end\");\n";
		file << "	o_SubgoalSelectionModel.Init (\"subgoal\");\n";
		file << "	o_TextConnectionModel.Init (\"connection\");\n";
		file << "\n";
		file << "	o_SequenceEndExploration.SetParamsFromConfig (\"end\");\n";
		file << "	o_SubgoalExploration.SetParamsFromConfig (\"subgoal\");\n";
		file << "	o_ConnectionExploration.SetParamsFromConfig (\"connection\");\n";
		file << "\n";
		file << "	i_MaxSequenceLength = (config)\"max_subgoal_sequence_length\";\n";
		file << "	b_DisallowNeighboringDuplicateSubgoals = (1 == (int)(config)\"disallow_neighboring_duplicate_subgoals\");\n";
		file << "	b_DisallowAnyDuplicateSubgoals = (1 == (int)(config)\"disallow_any_duplicate_subgoals\");\n";
		file << "	b_UseLogarithmicDistanceScore = (1 == (int)(config)\"use_logarithmic_distance_score\");\n";
		file << "\n";
		file << "	b_ForceConnectionWeights = (1 == (int)(config)\"force_connection_weights\");\n";
		file << "	d_ForcedConnectionWeightToInit = (config)\"forced_connection_weight_to_init\";\n";
		file << "	d_ForcedConnectionWeightToTarget = (config)\"forced_connection_weight_to_target\";\n";
		file << "	b_UsePredicateValueFeature = (1 == (int)(config)\"use_predicate_value_feature\");\n";
		file << "	b_UseReachableSubgoalFeature = (1 == (int)(config)\"use_reachable_subgoal_feature\");\n";
		file << "	b_UseReachabilityEquivalents = (1 == (int)(config)\"use_reachability_equivalents\");\n";
		file << "\n";
		file << "	b_UseOnlyPreviousSubgoal = (1 == (int)(config)\"features:use_only_previous_subgoal\");\n";
		file << "	b_IncludeInit = (0 != (int)(config)\"features:include_init\");\n";
		file << "	f_PredicateIdentityPairFeatureWeight = (config)\"predicate_identity_pair_feature_weight\";\n";
		file << "	String sConnectionRewardType ((config)\"connection:reward_type\");\n";
		file << "	if (\"linear\" == sConnectionRewardType)\n";
		file << "		e_ConnectionRewardType = crt_linear;\n";
		file << "	else if (\"single_success\" == sConnectionRewardType)\n";
		file << "		e_ConnectionRewardType = crt_single_success;\n";
		file << "	else\n";
		file << "	{\n";
		file << "		cout << \"[ERROR] Unknown connection reward type '\"\n";
		file << "			 << sConnectionRewardType << \"'.\" << endl;\n";
		file << "		e_ConnectionRewardType = crt_unknown;\n";
		file << "	}\n";
		file << "	f_ConnectionSuccessReward = (config)\"connection:success_reward\";\n";
		file << "	f_ConnectionFailurePenalty = (config)\"connection:failure_penalty\";\n";
		file << "	b_TaskCompletionTextReward = (1 == (int)(config)\"use_task_completion_text_reward\");\n";
		file << "	f_SubgoalNotInPrefixReward = (config)\"subgoal_not_in_prefix_reward\";\n";
		file << "\n";
		file << "	cout << \"Initializing subgoal policy\" << endl;\n";
		file << "	cout << \"   Max sequence length : \" << i_MaxSequenceLength << endl;\n";
		file << "	if (true == b_DisallowAnyDuplicateSubgoals)\n";
		file << "		cout << \"   Disallowing any duplicate subgoals.\" << endl;\n";
		file << "	else if (true == b_DisallowNeighboringDuplicateSubgoals)\n";
		file << "		cout << \"   Disallowing neighboring duplicate subgoals.\" << endl;\n";
		file << "	else\n";
		file << "		cout << \"   Allowing duplicate subgoals.\" << endl;\n";
		file << "	if (true == b_UseLogarithmicDistanceScore)\n";
		file << "		cout << \"   Using logarithmic distance score.\" << endl;\n";
		file << "	else\n";
		file << "		cout << \"   Using normal distance score.\" << endl;\n";
		file << "	if (true == b_UsePredicateValueFeature)\n";
		file << "		cout << \"   Using predicate value feature.\" << endl;\n";
		file << "	if (true == b_UseReachableSubgoalFeature)\n";
		file << "		cout << \"   Using reachable-subgoal feature.\" << endl;\n";
		file << "	if (true == b_UseReachabilityEquivalents)\n";
		file << "		cout << \"   Using reachability equivalents.\" << endl;\n";
		file << "	cout << \"   predicate identity pair feature weight : \"\n";
		file << "		 << f_PredicateIdentityPairFeatureWeight << endl;\n";
		file << "\n";
		file << "	o_SequenceEndExploration.PrintConfiguration (\"Seq end\");\n";
		file << "	o_SubgoalExploration.PrintConfiguration (\"Subgoal\");\n";
		file << "	o_ConnectionExploration.PrintConfiguration (\"Connect\");\n";
		file << "\n";
		file << "\n";
		file << "	f_NonConnectionFeatureImportance = (double)(config)\"non_connection_feature_importance\";\n";
		file << "\n";
		file << "	if (false == LoadPredDictFile ())\n";
		file << "		return false;\n";
		file << "	AssignIndicesToTargetProblemPredicates ();\n";
		file << "\n";
		file << "	i_PredicateNames = hmp_PredicateNameToIndex.size ();\n";
		file << "	i_ParameterValues = hmp_ParameterValueToIndex.size ();\n";
		file << "	i_PredicateIdentities = hmp_PredicateIdToIndex.size ();\n";
		file << "\n";
		file << "\n";
		file << "	o_SequenceEndFeatureSpace.SetBagOfWordsOffset (2 * pow (i_PredicateIdentities, 2));\n";
		file << "\n";
		file << "	size_t iFeatureSet = i_MaxPredicateValue + 1 + 6\n";
		file << "						 + 2 * pow (i_PredicateNames, 2)\n";
		file << "						 + 2 * pow (i_ParameterValues, 2)\n";
		file << "						 + 2 * pow (i_PredicateIdentities, 2);\n";
		file << "	o_SubgoalFeatureSpace.SetBagOfWordsOffset (iFeatureSet);\n";
		file << "\n";
		file << "	i_OffsetToConnectionFeatures = i_MaxPredicateValue + 1;\n";
		file << "	i_OffsetToPredicateNameFeatures = 14 + i_OffsetToConnectionFeatures;\n";
		file << "	i_OffsetToParameterValueFeatures = i_OffsetToPredicateNameFeatures\n";
		file << "										+ 2 * pow (i_PredicateNames, 2);\n";
		file << "	i_OffsetToPredicateIdentityFeatures = i_OffsetToParameterValueFeatures\n";
		file << "										+ 2 * pow (i_ParameterValues, 2);\n";
		file << "\n";
		file << "	b_PrintTextConnectionFeatures\n";
		file << "		= (1 == (int)(config)\"features:print_text_connection_features\");\n";
		file << "	if (true == b_PrintTextConnectionFeatures)\n";
		file << "	{\n";
		file << "		//first three features\n";
		file << "		for (int i = 0; i < i_MaxPredicateValue; ++ i)\n";
		file << "		{\n";
		file << "			String sFeature;\n";
		file << "			sFeature << \"PredVal:\" << i;\n";
		file << "			map_FeatureIndexToFeatureString[i] = sFeature;\n";
		file << "		}\n";
		file << "\n";
		file << "		map_FeatureIndexToFeatureString [i_MaxPredicateValue] = \"<unused>\";\n";
		file << "		map_FeatureIndexToFeatureString [i_OffsetToConnectionFeatures] = \"<unused>\";\n";
		file << "		map_FeatureIndexToFeatureString [1 + i_OffsetToConnectionFeatures] = \"ReachableSubgoal\";\n";
		file << "		map_FeatureIndexToFeatureString [2 + i_OffsetToConnectionFeatures] = \"ConnInit\";\n";
		file << "		map_FeatureIndexToFeatureString [3 + i_OffsetToConnectionFeatures] = \"ConnInit+Reachable\";\n";
		file << "		map_FeatureIndexToFeatureString [4 + i_OffsetToConnectionFeatures] = \"NoConnInit\";\n";
		file << "\n";
		file << "		for (int d = 1; d < 5; ++ d)\n";
		file << "		{\n";
		file << "			map_FeatureIndexToFeatureString [5 + 2*(d-1) + i_OffsetToConnectionFeatures]\n";
		file << "									= \"ConnFuture\";\n";
		file << "			map_FeatureIndexToFeatureString [6 + 2*(d-1) + i_OffsetToConnectionFeatures]\n";
		file << "									= \"ConnFuture+Reachable\";\n";
		file << "		}\n";
		file << "		map_FeatureIndexToFeatureString [13 + i_OffsetToConnectionFeatures] = \"NoConnFuture\";\n";
		file << "\n";
		file << "\n";
		file << "		// populate Feature Strings -- names\n";
		file << "		ITERATE(FeatureToIndex_hmp_t, hmp_PredicateNameToIndex, itrFrom)\n";
		file << "		{\n";
		file << "			ITERATE(FeatureToIndex_hmp_t, hmp_PredicateNameToIndex, itrTo)\n";
		file << "			{\n";
		file << "				int iIndexInit = i_OffsetToPredicateNameFeatures\n";
		file << "								 + (2 * i_PredicateNames * itrFrom->second\n";
		file << "										+ itrTo->second);\n";
		file << "				int iIndexFuture = i_OffsetToPredicateNameFeatures\n";
		file << "								   + (2 * i_PredicateNames * itrFrom->second\n";
		file << "										  + itrTo->second\n";
		file << "										  + i_PredicateNames);\n";
		file << "				map_FeatureIndexToFeatureString [iIndexInit]\n";
		file << "					= \"NameInit::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "				map_FeatureIndexToFeatureString [iIndexFuture]\n";
		file << "					= \"NameFuture::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		// populate Feature Strings -- values\n";
		file << "		ITERATE(FeatureToIndex_hmp_t, hmp_ParameterValueToIndex, itrFrom)\n";
		file << "		{\n";
		file << "			ITERATE(FeatureToIndex_hmp_t, hmp_ParameterValueToIndex, itrTo)\n";
		file << "			{\n";
		file << "				int iIndexInit = i_OffsetToParameterValueFeatures\n";
		file << "								 + (2 * i_ParameterValues * itrFrom->second\n";
		file << "										+ itrTo->second);\n";
		file << "				int iIndexFuture = i_OffsetToParameterValueFeatures\n";
		file << "								   + (2 * i_ParameterValues * itrFrom->second\n";
		file << "										  + itrTo->second\n";
		file << "										  + i_ParameterValues);\n";
		file << "				map_FeatureIndexToFeatureString [iIndexInit]\n";
		file << "					= \"ValueInit::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "				map_FeatureIndexToFeatureString [iIndexFuture]\n";
		file << "					= \"ValueFuture::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		// populate Feature Strings -- identity\n";
		file << "		ITERATE(FeatureToIndex_hmp_t, hmp_PredicateIdToIndex, itrFrom)\n";
		file << "		{\n";
		file << "			ITERATE(FeatureToIndex_hmp_t, hmp_PredicateIdToIndex, itrTo)\n";
		file << "			{\n";
		file << "				int iIndexInit = i_OffsetToPredicateIdentityFeatures\n";
		file << "								 + (2 * i_PredicateIdentities*itrFrom->second\n";
		file << "										+ itrTo->second);\n";
		file << "				int iIndexFuture = i_OffsetToPredicateIdentityFeatures\n";
		file << "								   + (2 * i_PredicateIdentities * itrFrom->second\n";
		file << "										  + itrTo->second\n";
		file << "										  + i_PredicateIdentities);\n";
		file << "				map_FeatureIndexToFeatureString [iIndexInit]\n";
		file << "					= \"PredIdInit::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "				map_FeatureIndexToFeatureString [iIndexFuture]\n";
		file << "					= \"PredIdFuture::\" + itrFrom->first + \"::\" + itrTo->first;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		#ifndef NDEBUG\n";
		file << "		// make sure all the values are there\n";
		file << "		for(unsigned int i = 0; i < map_FeatureIndexToFeatureString.size(); i++)\n";
		file << "		{\n";
		file << "			assert (map_FeatureIndexToFeatureString.find(i)\n";
		file << "					!= map_FeatureIndexToFeatureString.end());\n";
		file << "		}\n";
		file << "		#endif\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	f_UseSimpleConnectionFeatures = (config)\"use_pddl_connection_features\";\n";
		file << "	f_UseTextConnectionFeatures = (config)\"use_text_connection_features\";\n";
		file << "	f_UseComplexNonConnectionFeatures = (config)\"use_complex_non_connection_features\";\n";
		file << "\n";
		file << "	b_LogConnectionPredictions = false;\n";
		file << "	b_LogConnectionFeedback = false;\n";
		file << "	if (f_UseTextConnectionFeatures > 0)\n";
		file << "	{\n";
		file << "		b_LogConnectionPredictions = (1 == (int)(config)\"log_connection_predictions\");\n";
		file << "		b_LogConnectionFeedback = (1 == (int)(config)\"log_connection_feedback\");\n";
		file << "	}\n";
		file << "\n";
		file << "	if ((f_UseSimpleConnectionFeatures > 0) &&\n";
		file << "		(f_UseTextConnectionFeatures > 0))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Conflicting configuration options set:\\n\"\n";
		file << "				\"Both 'use_pddl_connection_features' and 'use_text_connection_features'\\n\"\n";
		file << "				\"options have been set to true. Only one can be active at one time.\"\n";
		file << "			 << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	if (f_UseSimpleConnectionFeatures > 0)\n";
		file << "	{\n";
		file << "		if (false == LoadSimpleConnectionFile ())\n";
		file << "			return false;\n";
		file << "	}\n";
		file << "	else if (f_UseTextConnectionFeatures > 0)\n";
		file << "	{\n";
		file << "		if (false == LoadFeatureConnectionFile ())\n";
		file << "			return false;\n";
		file << "		if (true == b_PrintTextConnectionFeatures)\n";
		file << "			LoadFeaturesToDebugPrintFile();\n";
		file << "	}\n";
		file << "\n";
		file << "	if (true == b_LogConnectionPredictions)\n";
		file << "		WriteConnectionPredictionHeader ();\n";
		file << "\n";
		file << "	//NK: my debug stuff\n";
		file << "	b_UseGoldLength = (1 == (int)(config)\"use_gold_length\");\n";
		file << "	if (true == b_UseGoldLength)\n";
		file << "		LoadGoldLengthFile();\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::LoadFeaturesToDebugPrintFile(void)\n";
		file << "{\n";
		file << "	String sGoldLengthFile = (config)\"features:debug_features_to_print_file\";\n";
		file << "	// read in the dict file\n";
		file << "	String_dq_t dqLines;\n";
		file << "	File::ReadLines (sGoldLengthFile, dqLines);\n";
		file << "\n";
		file << "	ITERATE (String_dq_t, dqLines, iterLine)\n";
		file << "	{\n";
		file << "		String sFeature = *iterLine;\n";
		file << "		int iIndex = o_SubgoalFeatureSpace.GetFeatureIndex (sFeature, true);\n";
		file << "		if(iIndex == 0)\n";
		file << "		{\n";
		file << "			cout << \"Couldn't find feature:\" << sFeature << endl;\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		dq_FeaturesToDebugPrint.push_back(iIndex);\n";
		file << "	}\n";
		file << "\n";
		file << "	cout << \"   loaded \" << this->dq_FeaturesToDebugPrint.size()\n";
		file << "		 << \" features to debug print \" << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::LogDebugFeatureWeights (File* _pFile)\n";
		file << "{\n";
		file << "	if (false == b_PrintTextConnectionFeatures)\n";
		file << "		return;\n";
		file << "\n";
		file << "	*_pFile << \"Text Features:\" << endl;\n";
		file << "	ITERATE(int_dq_t, dq_FeaturesToDebugPrint, iter)\n";
		file << "	{\n";
		file << "		int iFeature = *iter;\n";
		file << "		*_pFile << \"Feature: \"\n";
		file << "				<< o_SubgoalSelectionModel.GetWeight(iFeature)\n";
		file << "				<< \":\" << GetFeatureString(iFeature)\n";
		file << "				<< \":\" <<  iFeature << endl;\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String SubgoalPolicy::GetFeatureString(int _iIndex) const\n";
		file << "{\n";
		file << "	if (_iIndex >= o_SubgoalFeatureSpace.BagOfWordsOffset())\n";
		file << "	{\n";
		file << "		return o_SubgoalFeatureSpace.GetFeatureString(_iIndex);\n";
		file << "	}\n";
		file << "\n";
		file << "	int_String_map_t::const_iterator iter =  map_FeatureIndexToFeatureString.find(_iIndex);\n";
		file << "	assert(iter != map_FeatureIndexToFeatureString.end());\n";
		file << "	return iter->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::GetPredicateIdentityFeatureIndex (const String& _rPredicate)\n";
		file << "{\n";
		file << "	FeatureToIndex_hmp_t::iterator	ite;\n";
		file << "	ite = hmp_PredicateIdToIndex.find (_rPredicate);\n";
		file << "	if (hmp_PredicateIdToIndex.end () == ite)\n";
		file << "	{\n";
		file << "		int iIndex = hmp_PredicateIdToIndex.size ();\n";
		file << "		hmp_PredicateIdToIndex.insert (make_pair (_rPredicate, iIndex));\n";
		file << "		return iIndex;\n";
		file << "	}\n";
		file << "	return ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::GetPredicateNameFeatureIndex (const String& _rName)\n";
		file << "{\n";
		file << "	FeatureToIndex_hmp_t::iterator	ite;\n";
		file << "	ite = hmp_PredicateNameToIndex.find (_rName);\n";
		file << "	if (hmp_PredicateNameToIndex.end () == ite)\n";
		file << "	{\n";
		file << "		int iIndex = hmp_PredicateNameToIndex.size ();\n";
		file << "		hmp_PredicateNameToIndex.insert (make_pair (_rName, iIndex));\n";
		file << "		return iIndex;\n";
		file << "	}\n";
		file << "	return ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::GetParameterValueFeatureIndex (const String& _rValue)\n";
		file << "{\n";
		file << "	FeatureToIndex_hmp_t::iterator	ite;\n";
		file << "	ite = hmp_ParameterValueToIndex.find (_rValue);\n";
		file << "	if (hmp_ParameterValueToIndex.end () == ite)\n";
		file << "	{\n";
		file << "		int iIndex = hmp_ParameterValueToIndex.size ();\n";
		file << "		hmp_ParameterValueToIndex.insert (make_pair (_rValue, iIndex));\n";
		file << "		return iIndex;\n";
		file << "	}\n";
		file << "	return ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::AssignIndicesToTargetProblemPredicates (void)\n";
		file << "{\n";
		file << "	cout << \"Assigning indices to problem predicates.\" << endl;\n";
		file << "	String_set_t setMissingInitPredicates;\n";
		file << "	String_set_t setMissingTargetPredicates;\n";
		file << "	for (long i = 0; i < Problem::GetProblemCount (); ++ i)\n";
		file << "	{\n";
		file << "		Problem* pProblem = Problem::GetProblem (i);\n";
		file << "		PddlProblem& rPddlProblem = pProblem->GetPddlProblem ();\n";
		file << "\n";
		file << "		int_set_t	setPredicateIdentityFI;\n";
		file << "		int_set_t	setPredicateNameFI;\n";
		file << "		int_set_t	setParameterValueFI;\n";
		file << "\n";
		file << "		// init state ...\n";
		file << "		ITERATE (PddlPredicate_dq_t, rPddlProblem.o_StartState.dq_Predicates, ite)\n";
		file << "		{\n";
		file << "			PddlPredicate* pPredicate = *ite;\n";
		file << "\n";
		file << "			// assign predicate candidate index ...\n";
		file << "			pPredicate->i_PredicateCandidateIndex = FindInitPredicateCandidateIndex (*pPredicate);\n";
		file << "			if (-1 == pPredicate->i_PredicateCandidateIndex)\n";
		file << "				setMissingInitPredicates.insert (pPredicate->GetPddlString ());\n";
		file << "\n";
		file << "			// assign feature indices to predicate\n";
		file << "			pPredicate->i_PredicateIdentityFeatureIndex\n";
		file << "				= GetPredicateIdentityFeatureIndex (pPredicate->GetPddlString ());\n";
		file << "			pPredicate->i_PredicateNameFeatureIndex\n";
		file << "				= GetPredicateNameFeatureIndex (pPredicate->s_Name);\n";
		file << "\n";
		file << "			int_set_t setValueFI;\n";
		file << "			CONST_ITERATE (PddlParameter_dq_t, pPredicate->dq_Parameters, iteParam)\n";
		file << "				setValueFI.insert (GetParameterValueFeatureIndex (*iteParam->p_ResolvedValue));\n";
		file << "\n";
		file << "			pPredicate->vec_ParameterValueFeatureIndex.Create (setValueFI.size ());\n";
		file << "			int x = 0;\n";
		file << "			ITERATE (int_set_t, setValueFI, iteFI)\n";
		file << "				pPredicate->vec_ParameterValueFeatureIndex [x++] = *iteFI;\n";
		file << "\n";
		file << "			// collect feature indicies for problem\n";
		file << "			setPredicateIdentityFI.insert (pPredicate->i_PredicateIdentityFeatureIndex);\n";
		file << "			setPredicateNameFI.insert (pPredicate->i_PredicateNameFeatureIndex);\n";
		file << "			setParameterValueFI.insert (setValueFI.begin (), setValueFI.end ());\n";
		file << "		}\n";
		file << "\n";
		file << "		// assign init feature indices to problem\n";
		file << "		pProblem->vec_InitPredicateIdentityFI.Create (setPredicateIdentityFI.size ());\n";
		file << "		int x = 0;\n";
		file << "		ITERATE (int_set_t, setPredicateIdentityFI, ite)\n";
		file << "			pProblem->vec_InitPredicateIdentityFI [x++] = *ite;\n";
		file << "\n";
		file << "		pProblem->vec_InitPredicateNameFI.Create (setPredicateNameFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setPredicateNameFI, ite)\n";
		file << "			pProblem->vec_InitPredicateNameFI [x++] = *ite;\n";
		file << "\n";
		file << "		pProblem->vec_InitParameterValueFI.Create (setParameterValueFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setParameterValueFI, ite)\n";
		file << "			pProblem->vec_InitParameterValueFI [x++] = *ite;\n";
		file << "\n";
		file << "\n";
		file << "		// goal state ...\n";
		file << "		setPredicateIdentityFI.clear ();\n";
		file << "		setPredicateNameFI.clear ();\n";
		file << "		setParameterValueFI.clear ();\n";
		file << "\n";
		file << "		ITERATE (PddlPredicate_dq_t, rPddlProblem.o_PartialGoalState.dq_Predicates, ite)\n";
		file << "		{\n";
		file << "			PddlPredicate* pPredicate = *ite;\n";
		file << "\n";
		file << "			// assign predicate candidate index ...\n";
		file << "			pPredicate->i_PredicateCandidateIndex = FindPredicateCandidateIndex (*pPredicate);\n";
		file << "			if (-1 == pPredicate->i_PredicateCandidateIndex)\n";
		file << "				setMissingTargetPredicates.insert (pPredicate->GetPddlString ());\n";
		file << "\n";
		file << "			// assign feature indices to predicate\n";
		file << "			pPredicate->i_PredicateIdentityFeatureIndex\n";
		file << "				= GetPredicateIdentityFeatureIndex (pPredicate->GetPddlString ());\n";
		file << "			pPredicate->i_PredicateNameFeatureIndex\n";
		file << "				= GetPredicateNameFeatureIndex (pPredicate->s_Name);\n";
		file << "\n";
		file << "			int_set_t setValueFI;\n";
		file << "			CONST_ITERATE (PddlParameter_dq_t, pPredicate->dq_Parameters, iteParam)\n";
		file << "				setValueFI.insert (GetParameterValueFeatureIndex (*iteParam->p_ResolvedValue));\n";
		file << "\n";
		file << "			pPredicate->vec_ParameterValueFeatureIndex.Create (setValueFI.size ());\n";
		file << "			int x = 0;\n";
		file << "			ITERATE (int_set_t, setValueFI, iteFI)\n";
		file << "				pPredicate->vec_ParameterValueFeatureIndex [x++] = *iteFI;\n";
		file << "\n";
		file << "			// collect feature indicies for problem\n";
		file << "			setPredicateIdentityFI.insert (pPredicate->i_PredicateIdentityFeatureIndex);\n";
		file << "			setPredicateNameFI.insert (pPredicate->i_PredicateNameFeatureIndex);\n";
		file << "			setParameterValueFI.insert (setValueFI.begin (), setValueFI.end ());\n";
		file << "		}\n";
		file << "\n";
		file << "		// assign target feature indices to problem\n";
		file << "		pProblem->vec_TargetPredicateIdentityFI.Create (setPredicateIdentityFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setPredicateIdentityFI, ite)\n";
		file << "			pProblem->vec_TargetPredicateIdentityFI [x++] = *ite;\n";
		file << "\n";
		file << "		pProblem->vec_TargetPredicateNameFI.Create (setPredicateNameFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setPredicateNameFI, ite)\n";
		file << "			pProblem->vec_TargetPredicateNameFI [x++] = *ite;\n";
		file << "\n";
		file << "		pProblem->vec_TargetParameterValueFI.Create (setParameterValueFI.size ());\n";
		file << "		x = 0;\n";
		file << "		ITERATE (int_set_t, setParameterValueFI, ite)\n";
		file << "			pProblem->vec_TargetParameterValueFI [x++] = *ite;\n";
		file << "	}\n";
		file << "\n";
		file << "	cout << \"   \" << setMissingInitPredicates.size ()\n";
		file << "		 << \" init predicates not present in candidate list.\" << endl;\n";
		file << "	cout << \"   \" << setMissingTargetPredicates.size ()\n";
		file << "		 << \" target predicates not present in candidate list.\" << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::LoadGoldLengthFile(void)\n";
		file << "{\n";
		file << "	String sGoldLengthFile = (config)\"gold_length_file\";\n";
		file << "	// read in the dict file\n";
		file << "	String_dq_t dqLines;\n";
		file << "	File::ReadLines (sGoldLengthFile, dqLines);\n";
		file << "\n";
		file << "	ITERATE (String_dq_t, dqLines, iterLine)\n";
		file << "	{\n";
		file << "		// Problem | length\n";
		file << "		String_dq_t dqSplit;\n";
		file << "		iterLine->Split (dqSplit, '|');\n";
		file << "		assert (dqSplit.size () == 2);\n";
		file << "		String sProblem = dqSplit[0];\n";
		file << "		int iLength = dqSplit[1];\n";
		file << "		this->map_ProblemToGoldLength[sProblem] = iLength;\n";
		file << "	}\n";
		file << "\n";
		file << "	cout << \"   loaded \" << this->map_ProblemToGoldLength.size()\n";
		file << "		 << \" gold lengths \" << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::LoadPredDictFile (void)\n";
		file << "{\n";
		file << "	String sPddlDictFile = (config)\"pddl_dict_file\";\n";
		file << "	cout << \"   loading dict: \" << sPddlDictFile << endl;\n";
		file << "	// read in the dict file\n";
		file << "	String_dq_t dqLines;\n";
		file << "	if (false == File::ReadLines (sPddlDictFile, dqLines))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed to read predicate dictionary file.\" << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	i_MaxPredicateValue = 0;\n";
		file << "	vec_CandidatePredicates.reserve (dqLines.size ());\n";
		file << "	ITERATE (String_dq_t, dqLines, iterLine)\n";
		file << "	{\n";
		file << "		// id | 0/1 predicate/function | name\n";
		file << "		String_dq_t dqSplit;\n";
		file << "		iterLine->Split (dqSplit, '|');\n";
		file << "		assert (dqSplit.size () == 3);\n";
		file << "\n";
		file << "		int iIndex = dqSplit [0];\n";
		file << "		int iValue = (int)dqSplit [1];\n";
		file << "		bool bIsFunction = (iValue > 0);\n";
		file << "		String sPredicate = dqSplit[2];\n";
		file << "		sPredicate.Strip ();\n";
		file << "\n";
		file << "		String_dq_t dqPred;\n";
		file << "		sPredicate.Split (dqPred, ' ');\n";
		file << "\n";
		file << "		PddlPredicate* pPred;\n";
		file << "		if (true == bIsFunction)\n";
		file << "			pPred = new PddlFunctionValuePredicate;\n";
		file << "		else\n";
		file << "			pPred = new PddlPredicate;\n";
		file << "\n";
		file << "		pPred->i_PredicateCandidateIndex = iIndex;\n";
		file << "		pPred->s_Name = dqPred[0];\n";
		file << "		pPred->b_IsFunction = bIsFunction;\n";
		file << "		pPred->l_Value = iValue;\n";
		file << "\n";
		file << "		if (true == bIsFunction)\n";
		file << "		{\n";
		file << "			pPred->l_Value --;\n";
		file << "			((PddlFunctionValuePredicate*)pPred)->c_Operator = '>';\n";
		file << "			if (i_MaxPredicateValue < pPred->l_Value)\n";
		file << "				i_MaxPredicateValue = pPred->l_Value;\n";
		file << "		}\n";
		file << "\n";
		file << "		int_set_t setValueFI;\n";
		file << "		for (unsigned int i = 1; i < dqPred.size (); i++)\n";
		file << "		{\n";
		file << "			pPred->dq_Parameters.push_back (PddlParameter());\n";
		file << "			pPred->dq_Parameters [i-1].SetValue (dqPred [i]);\n";
		file << "			setValueFI.insert (GetParameterValueFeatureIndex (dqPred [i]));\n";
		file << "		}\n";
		file << "		pPred->vec_ParameterValueFeatureIndex.Create (setValueFI.size ());\n";
		file << "		int x = 0;\n";
		file << "		ITERATE (int_set_t, setValueFI, iteFI)\n";
		file << "			pPred->vec_ParameterValueFeatureIndex [x++] = *iteFI;\n";
		file << "\n";
		file << "		assert ((long) vec_CandidatePredicates.size () == iIndex);\n";
		file << "		vec_CandidatePredicates.push_back (pPred);\n";
		file << "\n";
		file << "		String sPddlString (pPred->GetPddlString ());\n";
		file << "		pair <PddlStringToPredicate_map_t::iterator, bool> pairInsert;\n";
		file << "		pairInsert = map_PddlStringToCandidatePredicate.insert (make_pair (sPddlString, pPred));\n";
		file << "		if (false == pairInsert.second)\n";
		file << "		{\n";
		file << "			cerr << \"[ERROR] Duplicate predicate in candidate dictionary?\\n\"\n";
		file << "				 << sPddlString << endl;\n";
		file << "		}\n";
		file << "\n";
		file << "		pPred->i_PredicateIdentityFeatureIndex\n";
		file << "			= GetPredicateIdentityFeatureIndex (pPred->GetPddlString ());\n";
		file << "		pPred->i_PredicateNameFeatureIndex\n";
		file << "			= GetPredicateNameFeatureIndex (pPred->s_Name);\n";
		file << "\n";
		file << "\n";
		file << "		if (true == pPred->b_IsFunction)\n";
		file << "		{\n";
		file << "			PddlFunctionValuePredicate* pClone = (PddlFunctionValuePredicate*)pPred->Clone ();\n";
		file << "			pClone->c_Operator = '=';\n";
		file << "			++ pClone->l_Value;\n";
		file << "\n";
		file << "			map_PddlStringToCandidatePredicate [pClone->GetPddlString ()] = pPred;\n";
		file << "			delete pClone;\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	// '0' is a valid predicate value, so we need to add 1 here...\n";
		file << "	++ i_MaxPredicateValue;\n";
		file << "\n";
		file << "	i_CandidatePredicates = vec_CandidatePredicates.size ();\n";
		file << "	vec_CanReachCandidatePredicate.resize (i_CandidatePredicates, 0);\n";
		file << "\n";
		file << "\n";
		file << "	// compute reachability predicate equivalents...\n";
		file << "	vector <int_set_t>	vecReachabilityEquivalents;\n";
		file << "	vecReachabilityEquivalents.resize (i_CandidatePredicates);\n";
		file << "	for (int i = 0; i < i_CandidatePredicates; ++ i)\n";
		file << "	{\n";
		file << "		PddlPredicate* pPred = vec_CandidatePredicates [i];\n";
		file << "		if (false == pPred->b_IsFunction)\n";
		file << "			continue;\n";
		file << "\n";
		file << "		PddlFunctionValuePredicate* pClone = (PddlFunctionValuePredicate*)pPred->Clone ();\n";
		file << "		pClone->l_Value = 0;\n";
		file << "\n";
		file << "		PddlPredicate* pEquivalent = FindEquivalentPredicateCandidate (*pClone);\n";
		file << "		delete pClone;\n";
		file << "		if (NULL == pEquivalent)\n";
		file << "		{\n";
		file << "			cerr << \"[ERROR] Predicate candidate with numeric value 0 not found: \"\n";
		file << "				 << pClone->GetPddlString () << endl;\n";
		file << "			abort ();\n";
		file << "		}\n";
		file << "\n";
		file << "		vecReachabilityEquivalents [pEquivalent->i_PredicateCandidateIndex].insert (pPred->i_PredicateCandidateIndex);\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	for (int i = 0; i < i_CandidatePredicates; ++ i)\n";
		file << "	{\n";
		file << "		ITERATE (int_set_t, vecReachabilityEquivalents [i], ite)\n";
		file << "		{\n";
		file << "			vecReachabilityEquivalents [*ite].insert (i);\n";
		file << "			ITERATE (int_set_t, vecReachabilityEquivalents [i], iteOther)\n";
		file << "				vecReachabilityEquivalents [*ite].insert (*iteOther);\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	vec_ReachabilityPredicateEqulivalents.resize (i_CandidatePredicates);\n";
		file << "	for (int i = 0; i < i_CandidatePredicates; ++ i)\n";
		file << "	{\n";
		file << "		ITERATE (int_set_t, vecReachabilityEquivalents [i], ite)\n";
		file << "			vec_ReachabilityPredicateEqulivalents [i].push_back (*ite);\n";
		file << "	}\n";
		file << "\n";
		file << "	mtx_PredicateConnectionsFromTo.Create (i_CandidatePredicates,\n";
		file << "										   i_CandidatePredicates);\n";
		file << "	mtx_PredicateConnectionsFromTo.Memset (0);\n";
		file << "	mtx_PredicateConnectionsToFrom.Create (i_CandidatePredicates,\n";
		file << "										   i_CandidatePredicates);\n";
		file << "	mtx_PredicateConnectionsToFrom.Memset (0);\n";
		file << "\n";
		file << "\n";
		file << "	cout << \"   loaded \" << i_CandidatePredicates\n";
		file << "		 << \" candidate predicates.  Max value of \"\n";
		file << "		 << i_MaxPredicateValue << endl;\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::LoadSimpleConnectionFile (void)\n";
		file << "{\n";
		file << "	i_MaxConnectionDepth = 0;\n";
		file << "	cout << \"   loading simple connection file: \"\n";
		file << "		 << (config)\"pddl_connection_file\" << endl;\n";
		file << "\n";
		file << "	String_dq_t dqLines;\n";
		file << "	if (false == File::ReadLines ((config)\"pddl_connection_file\", dqLines))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed to open connection file.\" << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "	ITERATE(String_dq_t, dqLines, ite)\n";
		file << "	{\n";
		file << "		String_dq_t dqSplit;\n";
		file << "		ite->Split(dqSplit, '|');\n";
		file << "\n";
		file << "		assert(dqSplit.size() >= 3);\n";
		file << "		int iDepth = dqSplit[0];\n";
		file << "		int iFrom = dqSplit[1];\n";
		file << "		int iTo = dqSplit[2];\n";
		file << "		mtx_PredicateConnectionsFromTo (iFrom, iTo) = iDepth;\n";
		file << "		mtx_PredicateConnectionsToFrom (iTo, iFrom) = iDepth;\n";
		file << "\n";
		file << "		if (i_MaxConnectionDepth < iDepth)\n";
		file << "			i_MaxConnectionDepth = iDepth;\n";
		file << "	}\n";
		file << "	cout << \"   loaded \" << dqLines.size ()\n";
		file << "		 << \" pddl relationships, with max depth \"\n";
		file << "		 << i_MaxConnectionDepth << endl;\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::LoadFeatureConnectionFile (void)\n";
		file << "{\n";
		file << "	i_MaxConnectionDepth = 0;\n";
		file << "	cout << \"   loading feature connection file : \"\n";
		file << "		 << (config)\"text_connection_file\" << endl;\n";
		file << "\n";
		file << "	ConnectionHashToFeatures_map_t	mapConnectionHashToFeatures;\n";
		file << "\n";
		file << "	//\n";
		file << "	File file;\n";
		file << "	if (false == file.Open ((config)\"text_connection_file\"))\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed open connection file.\" << endl;\n";
		file << "		return false;\n";
		file << "	}\n";
		file << "\n";
		file << "	size_t iLines = 0;\n";
		file << "	String sLine;\n";
		file << "	while (true == file.ReadLine (sLine))\n";
		file << "	{\n";
		file << "		++ iLines;\n";
		file << "		String_dq_t dqSplit;\n";
		file << "		sLine.Split(dqSplit, '|');\n";
		file << "\n";
		file << "		assert(dqSplit.size() >= 5);\n";
		file << "		String sFeature = dqSplit [0];\n";
		file << "		float fFeatureValue = (double) dqSplit [1];\n";
		file << "		int iFrom = dqSplit [2];\n";
		file << "		int iTo = dqSplit [3];\n";
		file << "		int iSentenceId = dqSplit [4];\n";
		file << "\n";
		file << "		String sHash;\n";
		file << "		sHash << iFrom << '|' << iTo << '|' << iSentenceId;\n";
		file << "		FeatureToValue_map_t* pmapFeatureToValuePos;\n";
		file << "		FeatureToValue_map_t* pmapFeatureToValueNeg;\n";
		file << "		ConnectionHashToFeatures_map_t::iterator	iteFeatures;\n";
		file << "		iteFeatures = mapConnectionHashToFeatures.find (sHash);\n";
		file << "		if (mapConnectionHashToFeatures.end () == iteFeatures)\n";
		file << "		{\n";
		file << "			SentenceConnection* pConnection = new SentenceConnection;\n";
		file << "			vec_SentenceConnections.push_back (pConnection);\n";
		file << "			pConnection->i_Sentence = iSentenceId;\n";
		file << "			pConnection->i_From = iFrom;\n";
		file << "			pConnection->i_To = iTo;\n";
		file << "\n";
		file << "			pmapFeatureToValuePos = new FeatureToValue_map_t;\n";
		file << "			pmapFeatureToValueNeg = new FeatureToValue_map_t;\n";
		file << "			mapConnectionHashToFeatures.insert (make_pair (sHash, make_pair (pmapFeatureToValuePos, pmapFeatureToValueNeg)));\n";
		file << "		}\n";
		file << "		else\n";
		file << "		{\n";
		file << "			pmapFeatureToValuePos = iteFeatures->second.first;\n";
		file << "			pmapFeatureToValueNeg = iteFeatures->second.second;\n";
		file << "		}\n";
		file << "\n";
		file << "		String sPositiveFeature;\n";
		file << "		sPositiveFeature << \"pos\\x01\" << sFeature;\n";
		file << "		int iPositiveFeature = o_TextConnectionFeatureSpace.GetFeatureIndex (sPositiveFeature);\n";
		file << "		pmapFeatureToValuePos->insert (make_pair (iPositiveFeature, fFeatureValue));\n";
		file << "\n";
		file << "		String sNegativeFeature;\n";
		file << "		sNegativeFeature << \"neg\\x01\" << sFeature;\n";
		file << "		int iNegativeFeature = o_TextConnectionFeatureSpace.GetFeatureIndex (sNegativeFeature);\n";
		file << "		pmapFeatureToValueNeg->insert (make_pair (iNegativeFeature, fFeatureValue));\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	//\n";
		file << "	mtx_SentencesPositiveFromTo.Create (i_CandidatePredicates, i_CandidatePredicates);\n";
		file << "	mtx_SentencesPositiveFromTo.Memset (0);\n";
		file << "	mtx_SentencesNegativeFromTo.Create (i_CandidatePredicates, i_CandidatePredicates);\n";
		file << "	mtx_SentencesNegativeFromTo.Memset (0);\n";
		file << "\n";
		file << "	ITERATE (SentenceConnection_vec_t, vec_SentenceConnections, iteConn)\n";
		file << "	{\n";
		file << "		SentenceConnection* pConnection = *iteConn;\n";
		file << "		pConnection->p_PositiveFeatures = new Features;\n";
		file << "		pConnection->p_NegativeFeatures = new Features;\n";
		file << "\n";
		file << "		String sHash;\n";
		file << "		sHash << pConnection->i_From << '|'\n";
		file << "			  << pConnection->i_To << '|'\n";
		file << "			  << pConnection->i_Sentence;\n";
		file << "\n";
		file << "		ConnectionHashToFeatures_map_t::iterator	iteFeatures;\n";
		file << "		iteFeatures = mapConnectionHashToFeatures.find (sHash);\n";
		file << "		assert (mapConnectionHashToFeatures.end () != iteFeatures);\n";
		file << "\n";
		file << "		FeatureToValue_map_t* pmapFeatureToValuePos = iteFeatures->second.first;\n";
		file << "		pConnection->p_PositiveFeatures->SetSize (pmapFeatureToValuePos->size ());\n";
		file << "		ITERATE (FeatureToValue_map_t, (*pmapFeatureToValuePos), ite)\n";
		file << "			pConnection->p_PositiveFeatures->Set (ite->first, ite->second);\n";
		file << "\n";
		file << "		FeatureToValue_map_t* pmapFeatureToValueNeg = iteFeatures->second.second;\n";
		file << "		pConnection->p_NegativeFeatures->SetSize (pmapFeatureToValueNeg->size ());\n";
		file << "		ITERATE (FeatureToValue_map_t, (*pmapFeatureToValueNeg), ite)\n";
		file << "			pConnection->p_NegativeFeatures->Set (ite->first, ite->second);\n";
		file << "\n";
		file << "		delete pmapFeatureToValuePos;\n";
		file << "		delete pmapFeatureToValueNeg;\n";
		file << "\n";
		file << "		if (NULL == mtx_SentencesPositiveFromTo (pConnection->i_From, pConnection->i_To))\n";
		file << "		{\n";
		file << "			mtx_SentencesPositiveFromTo (pConnection->i_From, pConnection->i_To)\n";
		file << "				= new int_dq_t;\n";
		file << "		}\n";
		file << "		if (NULL == mtx_SentencesNegativeFromTo (pConnection->i_From, pConnection->i_To))\n";
		file << "		{\n";
		file << "			mtx_SentencesNegativeFromTo (pConnection->i_From, pConnection->i_To)\n";
		file << "				= new int_dq_t;\n";
		file << "		}\n";
		file << "	}\n";
		file << "	mapConnectionHashToFeatures.clear ();\n";
		file << "\n";
		file << "	lprb_SentenceConnection.Create (2);\n";
		file << "	mtx_FeedbackOnSentenceConnections.Create (i_CandidatePredicates,\n";
		file << "											  i_CandidatePredicates,\n";
		file << "											  2);\n";
		file << "	mtx_FeedbackOnSentenceConnections.Memset (0);\n";
		file << "\n";
		file << "\n";
		file << "	cout << \"   loaded \" << vec_SentenceConnections.size ()\n";
		file << "		 << \" text relationships, and \" << iLines\n";
		file << "		 << \" features for an average feature size of \"\n";
		file << "		 << iLines / (float)vec_SentenceConnections.size () << endl;\n";
		file << "\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::ComputeSequenceEndFeatures (int _iIndex,\n";
		file << "												const Problem& _rProblem,\n";
		file << "												SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	// features look at last subgoal & init state.\n";
		file << "	// [predicate identity]^2\n";
		file << "	// [connections]\n";
		file << "	Subgoal* pSubgoal = _pSequence->GetSubgoal (_iIndex);\n";
		file << "	pSubgoal->vec_SequenceEndFeatureVectors.resize (2);\n";
		file << "\n";
		file << "	// all features are computed by comparing the\n";
		file << "	// next subgoal in the sequence with the init\n";
		file << "	// state...\n";
		file << "	Subgoal* pNextSubgoal = _pSequence->GetSubgoal (_iIndex + 1);\n";
		file << "	assert (NULL != pNextSubgoal);\n";
		file << "\n";
		file << "\n";
		file << "	for (int e = 0; e < 2; ++ e)\n";
		file << "	{\n";
		file << "		Features* pFeatures = new Features;\n";
		file << "		pSubgoal->vec_SequenceEndFeatureVectors [e] = pFeatures;\n";
		file << "\n";
		file << "		size_t iFeatureCount = _rProblem.vec_InitPredicateIdentityFI.Size ();\n";
		file << "		pFeatures->SetSize (iFeatureCount);\n";
		file << "		// pFeatures->SetSize (1);\n";
		file << "\n";
		file << "		// predicate identity...\n";
		file << "		size_t iOffset = pNextSubgoal->p_PddlSubgoalPredicate->i_PredicateIdentityFeatureIndex\n";
		file << "						 * 2 * i_PredicateIdentities\n";
		file << "						 + e * i_PredicateIdentities;\n";
		file << "		SetFeatures (_rProblem.vec_InitPredicateIdentityFI,\n";
		file << "					 iOffset,\n";
		file << "					 pFeatures);\n";
		file << "		/*\n";
		file << "		size_t iOffset = pNextSubgoal->p_PddlSubgoalPredicate->i_PredicateIdentityFeatureIndex\n";
		file << "						 + e * i_PredicateIdentities;\n";
		file << "		pFeatures->Set (iOffset, 1);\n";
		file << "		*/\n";
		file << "\n";
		file << "		// connections ...\n";
		file << "		// [SB] I'm not sure connection features\n";
		file << "		// are good to have here.  We're assuming\n";
		file << "		// that connection features will encode\n";
		file << "		// long distance relationships, whereas\n";
		file << "		// predicting sequence-end requires short\n";
		file << "		// distance relationships...\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::ComputeSubgoalFeatures (int _iIndex,\n";
		file << "											const Problem& _rProblem,\n";
		file << "											SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	PddlProblem& rPddlProblem = ((Problem&)_rProblem).GetPddlProblem ();\n";
		file << "	Subgoal* pSubgoal = _pSequence->GetSubgoal (_iIndex);\n";
		file << "	pSubgoal->vec_SubgoalFeatureVectors.resize (i_CandidatePredicates);\n";
		file << "\n";
		file << "	int iSubgoals = (int)_pSequence->dq_Subgoals.size ();\n";
		file << "	// include the target\n";
		file << "	bool bIncludeTarget = (!b_UseOnlyPreviousSubgoal || (_iIndex == iSubgoals-1));\n";
		file << "	size_t iEndSubgoal = b_UseOnlyPreviousSubgoal ? min(iSubgoals,_iIndex+2) : iSubgoals;\n";
		file << "\n";
		file << "\n";
		file << "	float fDistanceFactorToTarget = DistanceScore (_pSequence->Length () - _iIndex);\n";
		file << "	for (int c = 0; c < i_CandidatePredicates; ++ c)\n";
		file << "	{\n";
		file << "		const PddlPredicate* pCandidatePredicate = vec_CandidatePredicates [c];\n";
		file << "		int iReachableSubgoal = 0;\n";
		file << "		if ((true == b_UseReachableSubgoalFeature) &&\n";
		file << "			(true == b_UseComplexNonConnectionFeatures))\n";
		file << "			iReachableSubgoal = (int) vec_CanReachCandidatePredicate [c];\n";
		file << "		Features* pFeatures = new Features;\n";
		file << "		pSubgoal->vec_SubgoalFeatureVectors [c] = pFeatures;\n";
		file << "\n";
		file << "		int iCandidatePredicateParameters\n";
		file << "			= pCandidatePredicate->vec_ParameterValueFeatureIndex.Size ();\n";
		file << "\n";
		file << "\n";
		file << "		// set feature vector size ...\n";
		file << "		size_t iFeatureCount = 2;\n";
		file << "		if (0 != f_NonConnectionFeatureImportance)\n";
		file << "		{\n";
		file << "			iFeatureCount += _rProblem.vec_InitPredicateNameFI.Size ()\n";
		file << "							 + _rProblem.vec_TargetPredicateNameFI.Size ()\n";
		file << "							 + _rProblem.vec_InitPredicateIdentityFI.Size ()\n";
		file << "							 + _rProblem.vec_TargetPredicateIdentityFI.Size ()\n";
		file << "							 + iCandidatePredicateParameters\n";
		file << "								* (_rProblem.vec_InitParameterValueFI.Size ()\n";
		file << "									+ _rProblem.vec_TargetParameterValueFI.Size ());\n";
		file << "\n";
		file << "			for (size_t i = _iIndex + 1; i < _pSequence->dq_Subgoals.size (); ++ i)\n";
		file << "			{\n";
		file << "				Subgoal& rSubgoal = _pSequence->dq_Subgoals [i];\n";
		file << "				PddlPredicate* pSubgoalPredicate = rSubgoal.p_PddlSubgoalPredicate;\n";
		file << "				iFeatureCount += 2 + pSubgoalPredicate->vec_ParameterValueFeatureIndex.Size ();\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		//\n";
		file << "		iFeatureCount += 4;\n";
		file << "		pFeatures->SetSize (iFeatureCount);\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "		// predicate numerics feature...\n";
		file << "		if ((true == b_UsePredicateValueFeature) &&\n";
		file << "			(true == b_UseComplexNonConnectionFeatures))\n";
		file << "		{\n";
		file << "			assert (pCandidatePredicate->l_Value >= 0);\n";
		file << "			// pFeatures->Set (0, 0.1 * pCandidatePredicate->l_Value);\n";
		file << "			// pFeatures->Set (pCandidatePredicate->l_Value, 0.01);\n";
		file << "		}\n";
		file << "		// pFeatures->Set (1 + i_OffsetToConnectionFeatures, iReachableSubgoal);\n";
		file << "\n";
		file << "\n";
		file << "		// features to init & target ...\n";
		file << "		if (0 != f_NonConnectionFeatureImportance)\n";
		file << "		{\n";
		file << "			// predicate name...\n";
		file << "			size_t iOffset = i_OffsetToPredicateNameFeatures\n";
		file << "							 + pCandidatePredicate->i_PredicateNameFeatureIndex\n";
		file << "							 * 2 * i_PredicateNames;\n";
		file << "			if(true == b_IncludeInit)\n";
		file << "			{\n";
		file << "				SetFeatures (_rProblem.vec_InitPredicateNameFI,\n";
		file << "							 iOffset,\n";
		file << "							 pFeatures,\n";
		file << "							 f_NonConnectionFeatureImportance);\n";
		file << "			}\n";
		file << "			if (true == bIncludeTarget)\n";
		file << "			{\n";
		file << "				SetFeatures (_rProblem.vec_TargetPredicateNameFI,\n";
		file << "							 iOffset + i_PredicateNames,\n";
		file << "							 pFeatures,\n";
		file << "							 fDistanceFactorToTarget * f_NonConnectionFeatureImportance);\n";
		file << "			}\n";
		file << "\n";
		file << "			// predicate identity...\n";
		file << "			iOffset = i_OffsetToPredicateIdentityFeatures\n";
		file << "					  + pCandidatePredicate->i_PredicateIdentityFeatureIndex\n";
		file << "					  * 2 * i_PredicateIdentities;\n";
		file << "			if(true == b_IncludeInit)\n";
		file << "			{\n";
		file << "				SetFeatures (_rProblem.vec_InitPredicateIdentityFI,\n";
		file << "							 iOffset,\n";
		file << "							 pFeatures,\n";
		file << "							 f_PredicateIdentityPairFeatureWeight\n";
		file << "							 * f_NonConnectionFeatureImportance);\n";
		file << "			}\n";
		file << "			if (true == bIncludeTarget)\n";
		file << "			{\n";
		file << "				SetFeatures (_rProblem.vec_TargetPredicateIdentityFI,\n";
		file << "							 iOffset + i_PredicateIdentities,\n";
		file << "							 pFeatures,\n";
		file << "							 f_PredicateIdentityPairFeatureWeight\n";
		file << "							 	 * fDistanceFactorToTarget\n";
		file << "							 	 * f_NonConnectionFeatureImportance);\n";
		file << "			}\n";
		file << "\n";
		file << "			// parameter values...\n";
		file << "			for (int v = 0; v < iCandidatePredicateParameters; ++ v)\n";
		file << "			{\n";
		file << "				iOffset = i_OffsetToParameterValueFeatures\n";
		file << "						  + pCandidatePredicate->vec_ParameterValueFeatureIndex [v]\n";
		file << "						  * 2 * i_ParameterValues;\n";
		file << "				if(true == b_IncludeInit)\n";
		file << "				{\n";
		file << "					SetFeatures (_rProblem.vec_InitParameterValueFI,\n";
		file << "								 iOffset,\n";
		file << "								 pFeatures,\n";
		file << "								 f_NonConnectionFeatureImportance);\n";
		file << "				}\n";
		file << "\n";
		file << "				if (true == bIncludeTarget)\n";
		file << "				{\n";
		file << "					SetFeatures (_rProblem.vec_TargetParameterValueFI,\n";
		file << "								 iOffset + i_ParameterValues,\n";
		file << "								 pFeatures,\n";
		file << "								 fDistanceFactorToTarget * f_NonConnectionFeatureImportance);\n";
		file << "				}\n";
		file << "			}\n";
		file << "\n";
		file << "\n";
		file << "			// features to other subgoals ...\n";
		file << "			for (size_t i = _iIndex + 1; i < iEndSubgoal; ++ i)\n";
		file << "			{\n";
		file << "				Subgoal& rSubgoal = _pSequence->dq_Subgoals [i];\n";
		file << "				PddlPredicate* pSubgoalPredicate = rSubgoal.p_PddlSubgoalPredicate;\n";
		file << "				float fDistanceFactor = f_NonConnectionFeatureImportance * DistanceScore (i - _iIndex);\n";
		file << "\n";
		file << "				// predicate name...\n";
		file << "				iOffset = i_OffsetToPredicateNameFeatures\n";
		file << "						  + pCandidatePredicate->i_PredicateNameFeatureIndex\n";
		file << "						  * 2 * i_PredicateNames + i_PredicateNames;\n";
		file << "				pFeatures->Set (iOffset + pSubgoalPredicate->i_PredicateNameFeatureIndex,\n";
		file << "								fDistanceFactor,\n";
		file << "								false);\n";
		file << "\n";
		file << "				// predicate identity...\n";
		file << "				iOffset = i_OffsetToPredicateIdentityFeatures\n";
		file << "						  + pCandidatePredicate->i_PredicateIdentityFeatureIndex\n";
		file << "						  * 2 * i_PredicateIdentities + i_PredicateIdentities;\n";
		file << "				pFeatures->Set (iOffset + pSubgoalPredicate->i_PredicateIdentityFeatureIndex,\n";
		file << "								f_PredicateIdentityPairFeatureWeight * fDistanceFactor,\n";
		file << "								false);\n";
		file << "\n";
		file << "				// parameter values...\n";
		file << "				for (int v = 0; v < iCandidatePredicateParameters; ++ v)\n";
		file << "				{\n";
		file << "					iOffset = i_OffsetToParameterValueFeatures\n";
		file << "							  + pCandidatePredicate->vec_ParameterValueFeatureIndex [v]\n";
		file << "							  * 2 * i_ParameterValues + i_ParameterValues;\n";
		file << "\n";
		file << "					SetFeatures (pSubgoalPredicate->vec_ParameterValueFeatureIndex,\n";
		file << "								 iOffset,\n";
		file << "								 pFeatures,\n";
		file << "								 fDistanceFactor,\n";
		file << "								 false);\n";
		file << "				}\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		// connection features ...\n";
		file << "		if ((true == b_UseSimpleConnectionFeatures) ||\n";
		file << "			(true == b_UseTextConnectionFeatures))\n";
		file << "		{\n";
		file << "			if(true == b_IncludeInit)\n";
		file << "			{\n";
		file << "				bool bHaveConnToInit = false;\n";
		file << "				// connection distance to init state.\n";
		file << "				Matrix <char,1> mtxSliceFrom;\n";
		file << "				mtxSliceFrom.GetSlice (mtx_PredicateConnectionsToFrom,\n";
		file << "									   pCandidatePredicate->i_PredicateCandidateIndex);\n";
		file << "\n";
		file << "				CONST_ITERATE (PddlPredicate_dq_t, rPddlProblem.o_StartState.dq_Predicates, ite)\n";
		file << "				{\n";
		file << "					PddlPredicate* pInitPredicate = *ite;\n";
		file << "					if (-1 == pInitPredicate->i_PredicateCandidateIndex)\n";
		file << "						continue;\n";
		file << "					if (0 == mtxSliceFrom (pInitPredicate->i_PredicateCandidateIndex))\n";
		file << "						continue;\n";
		file << "\n";
		file << "					pFeatures->Set (2 + i_OffsetToConnectionFeatures, 1);\n";
		file << "					pFeatures->Set (3 + i_OffsetToConnectionFeatures, iReachableSubgoal);\n";
		file << "					bHaveConnToInit = true;\n";
		file << "					break;\n";
		file << "				}\n";
		file << "\n";
		file << "				if (false == bHaveConnToInit)\n";
		file << "					pFeatures->Set (4 + i_OffsetToConnectionFeatures, 1);\n";
		file << "			}\n";
		file << "\n";
		file << "\n";
		file << "			// connection distance to target state.\n";
		file << "			Matrix <char,1> mtxSliceTo;\n";
		file << "			mtxSliceTo.GetSlice (mtx_PredicateConnectionsFromTo,\n";
		file << "								 pCandidatePredicate->i_PredicateCandidateIndex);\n";
		file << "\n";
		file << "			if (true == bIncludeTarget)\n";
		file << "			{\n";
		file << "				CONST_ITERATE (PddlPredicate_dq_t, rPddlProblem.o_PartialGoalState.dq_Predicates, ite)\n";
		file << "				{\n";
		file << "					PddlPredicate* pGoalPredicate = *ite;\n";
		file << "					if (-1 == pGoalPredicate->i_PredicateCandidateIndex)\n";
		file << "						continue;\n";
		file << "					if (0 == mtxSliceTo (pGoalPredicate->i_PredicateCandidateIndex))\n";
		file << "						continue;\n";
		file << "					// The -1 below is to account for the fact that\n";
		file << "					// iSubgoals is the length of the list, and _iIndex\n";
		file << "					// is zero indexed...\n";
		file << "					int iDistance = iSubgoals - _iIndex - 1;\n";
		file << "					if (iDistance < 3)\n";
		file << "					{\n";
		file << "						size_t iOffset = 2 * (iDistance - 1) + i_OffsetToConnectionFeatures;\n";
		file << "						pFeatures->Set (5 + iOffset, 1);\n";
		file << "						pFeatures->Set (6 + iOffset, iReachableSubgoal);\n";
		file << "					}\n";
		file << "					break;\n";
		file << "				}\n";
		file << "			}\n";
		file << "\n";
		file << "\n";
		file << "			// connection distance to future subgoals.\n";
		file << "			bool bHaveConnToFuture = false;\n";
		file << "			for (size_t s = _iIndex + 1; s < iEndSubgoal; ++ s)\n";
		file << "			{\n";
		file << "				Subgoal* pNextSubgoal = _pSequence->GetSubgoal (s);\n";
		file << "				int iNextPredicate = pNextSubgoal->p_PddlSubgoalPredicate->i_PredicateCandidateIndex;\n";
		file << "				if (0 == mtxSliceTo (iNextPredicate))\n";
		file << "					continue;\n";
		file << "				int iDistance = s - _iIndex;\n";
		file << "				if (iDistance > 2)\n";
		file << "					break;\n";
		file << "\n";
		file << "				size_t iOffset = 2 * (iDistance - 1) + i_OffsetToConnectionFeatures;\n";
		file << "				pFeatures->Set (5 + iOffset, 1, false);\n";
		file << "				pFeatures->Set (6 + iOffset, iReachableSubgoal, false);\n";
		file << "				bHaveConnToFuture = true;\n";
		file << "			}\n";
		file << "\n";
		file << "			if (false == bHaveConnToFuture)\n";
		file << "				pFeatures->Set (13 + i_OffsetToConnectionFeatures, 1);\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleExplorationParameters (void)\n";
		file << "{\n";
		file << "	cout << \"   se [\"\n";
		file << "		 << o_SequenceEndExploration.SampleParameters (o_Sample)\n";
		file << "		 << \"]  \";\n";
		file << "	cout << \"sg [\"\n";
		file << "		 << o_SubgoalExploration.SampleParameters (o_Sample)\n";
		file << "		 << \"]  \";\n";
		file << "	cout << \"cn [\"\n";
		file << "		 << o_ConnectionExploration.SampleParameters (o_Sample)\n";
		file << "		 << \"]\";\n";
		file << "	cout << endl;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::ForceConnectionUseFlags (void)\n";
		file << "{\n";
		file << "	if (f_UseSimpleConnectionFeatures > 0)\n";
		file << "		b_UseSimpleConnectionFeatures = true;\n";
		file << "	if (f_UseTextConnectionFeatures > 0)\n";
		file << "		b_UseTextConnectionFeatures = true;\n";
		file << "	if (f_UseComplexNonConnectionFeatures > 0)\n";
		file << "		b_UseComplexNonConnectionFeatures = true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleConnectionUseFlags (void)\n";
		file << "{\n";
		file << "	b_UseSimpleConnectionFeatures = false;\n";
		file << "	if (f_UseSimpleConnectionFeatures > 0)\n";
		file << "		b_UseSimpleConnectionFeatures\n";
		file << "			= (o_Sample.SampleUniform () < f_UseSimpleConnectionFeatures);\n";
		file << "\n";
		file << "	b_UseTextConnectionFeatures = false;\n";
		file << "	if (f_UseTextConnectionFeatures > 0)\n";
		file << "		b_UseTextConnectionFeatures\n";
		file << "			= (o_Sample.SampleUniform () < f_UseTextConnectionFeatures);\n";
		file << "\n";
		file << "	b_UseComplexNonConnectionFeatures = false;\n";
		file << "	if (f_UseComplexNonConnectionFeatures > 0)\n";
		file << "		b_UseComplexNonConnectionFeatures\n";
		file << "			= (o_Sample.SampleUniform () < f_UseComplexNonConnectionFeatures);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "size_t SubgoalPolicy::SampleDecision (LogProbability& _rLogProb,\n";
		file << "									  ExplorationParameters& _rExploration,\n";
		file << "									  bool _bTestMode)\n";
		file << "{\n";
		file << "	if (true == _bTestMode)\n";
		file << "		return o_Sample.Argmax (_rLogProb.GetData (), _rLogProb.Size ());\n";
		file << "\n";
		file << "\n";
		file << "	// epsilon-softmax\n";
		file << "	if (et_epsilon_softmax == _rExploration.e_ExplorationType)\n";
		file << "	{\n";
		file << "		if (o_Sample.SampleUniform () < _rExploration.f_Epsilon)\n";
		file << "			return o_Sample.SampleFromLogPDF (_rLogProb.GetData (),\n";
		file << "											  _rLogProb.Size (),\n";
		file << "											  _rExploration.f_Beta);\n";
		file << "		return o_Sample.Argmax (_rLogProb.GetData (), _rLogProb.Size ());\n";
		file << "	}\n";
		file << "	// epsilon-greedy\n";
		file << "	if (et_epsilon_greedy == _rExploration.e_ExplorationType)\n";
		file << "	{\n";
		file << "		if (o_Sample.SampleUniform () < _rExploration.f_Epsilon)\n";
		file << "			return o_Sample.SampleUniformCategorical (_rLogProb.Size ());\n";
		file << "		return o_Sample.Argmax (_rLogProb.GetData (), _rLogProb.Size ());\n";
		file << "	}\n";
		file << "	// softmax\n";
		file << "	return o_Sample.SampleFromLogPDF (_rLogProb.GetData (),\n";
		file << "									  _rLogProb.Size (),\n";
		file << "									  _rExploration.f_Beta);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "size_t SubgoalPolicy::SampleSequenceEnd (int _iSubgoalIndex,\n";
		file << "										 const Problem& _rProblem,\n";
		file << "										 LogProbability& _rLogProb,\n";
		file << "										 bool _bTestMode)\n";
		file << "{\n";
		file << "	if (true == b_UseGoldLength)\n";
		file << "	{\n";
		file << "		String_int_map_t::iterator	iteLen;\n";
		file << "		iteLen = map_ProblemToGoldLength.find (_rProblem.s_FileName);\n";
		file << "		if (map_ProblemToGoldLength.end () == iteLen)\n";
		file << "		{\n";
		file << "			cerr << \"[ERROR] Was told to use gold solution lengths, \"\n";
		file << "					\"but length not known for problem '\"\n";
		file << "				 << _rProblem.s_FileName << \"'.\" << endl;\n";
		file << "		}\n";
		file << "\n";
		file << "		return (_iSubgoalIndex >= iteLen->second)? SEQUENCE_END : 0;\n";
		file << "	}\n";
		file << "\n";
		file << "	return SampleDecision (_rLogProb, o_SequenceEndExploration, _bTestMode);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleZeroSubgoalSequence (const Problem& _rProblem,\n";
		file << "											   SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	// this vector is an intermediate structure used for feature\n";
		file << "	// computation, and needs to be cleared for each sequence...\n";
		file << "	_pSequence->vec_PredicatesInSequence.resize (i_CandidatePredicates, 0);\n";
		file << "	AddLastSubgoal (_rProblem, _pSequence);\n";
		file << "	AddForcedSequenceEnd (_rProblem, _pSequence);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleConnections (bool _bTestMode)\n";
		file << "{\n";
		file << "	if (f_UseTextConnectionFeatures <= 0)\n";
		file << "		return;\n";
		file << "\n";
		file << "	for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "		{\n";
		file << "			int_dq_t* pdqConnectionHit = mtx_SentencesPositiveFromTo (f, t);\n";
		file << "			if (NULL != pdqConnectionHit)\n";
		file << "				pdqConnectionHit->clear ();\n";
		file << "			pdqConnectionHit = mtx_SentencesNegativeFromTo (f, t);\n";
		file << "			if (NULL != pdqConnectionHit)\n";
		file << "				pdqConnectionHit->clear ();\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	mtx_PredicateConnectionsFromTo.Memset (0);\n";
		file << "	mtx_PredicateConnectionsToFrom.Memset (0);\n";
		file << "\n";
		file << "	int iPositives = 0;\n";
		file << "	int iNegatives = 0;\n";
		file << "	for (size_t i = 0; i < vec_SentenceConnections.size (); ++ i)\n";
		file << "	{\n";
		file << "		SentenceConnection* pConnection = vec_SentenceConnections [i];\n";
		file << "		lprb_SentenceConnection [0]\n";
		file << "			= o_TextConnectionModel.ComputeLogProb (*pConnection->p_NegativeFeatures);\n";
		file << "		lprb_SentenceConnection [1]\n";
		file << "			= o_TextConnectionModel.ComputeLogProb (*pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "		// cout << \"  \" << lprb_SentenceConnection << endl;\n";
		file << "		if (0 == SampleDecision (lprb_SentenceConnection,\n";
		file << "								 o_ConnectionExploration,\n";
		file << "								 _bTestMode))\n";
		file << "		{\n";
		file << "			++ iNegatives;\n";
		file << "			int_dq_t* pdqConnectionHit\n";
		file << "				= mtx_SentencesNegativeFromTo (pConnection->i_From, pConnection->i_To);\n";
		file << "			if (NULL != pdqConnectionHit)\n";
		file << "				pdqConnectionHit->push_back (i);\n";
		file << "			continue;\n";
		file << "		}\n";
		file << "		++ iPositives;\n";
		file << "\n";
		file << "		// remember which connections are sampled,\n";
		file << "		// and also from which sentences...\n";
		file << "\n";
		file << "		mtx_PredicateConnectionsFromTo (pConnection->i_From, pConnection->i_To) = 1;\n";
		file << "		mtx_PredicateConnectionsToFrom (pConnection->i_To, pConnection->i_From) = 1;\n";
		file << "\n";
		file << "		int_dq_t* pdqConnectionHit\n";
		file << "			= mtx_SentencesPositiveFromTo (pConnection->i_From, pConnection->i_To);\n";
		file << "		if (NULL != pdqConnectionHit)\n";
		file << "			pdqConnectionHit->push_back (i);\n";
		file << "	}\n";
		file << "\n";
		file << "	cout << \"   +\" << iPositives << \"  -\" << iNegatives << endl;\n";
		file << "	if (true == b_LogConnectionPredictions)\n";
		file << "		WriteConnectionPredictions ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::SampleSubgoalSequence (const Problem& _rProblem,\n";
		file << "										   bool _bTestMode,\n";
		file << "										   SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	// Sample sequence length...\n";
		file << "	assert (0 != i_CandidatePredicates);\n";
		file << "	_pSequence->vec_PredicatesInSequence.resize (i_CandidatePredicates, 0);\n";
		file << "\n";
		file << "	// we first need the last subgoal to reach the actual target goal...\n";
		file << "	AddLastSubgoal (_rProblem, _pSequence);\n";
		file << "\n";
		file << "	// Sample subgoals...\n";
		file << "	bool bAlreadyAddedSequenceEnd = false;\n";
		file << "	Subgoal* pNextSubgoal = _pSequence->GetSubgoal (0);\n";
		file << "	for (int i = 0; i < i_MaxSequenceLength; ++ i)\n";
		file << "	{\n";
		file << "		Subgoal* pSubgoal = _pSequence->AddSubgoalToFront ();\n";
		file << "\n";
		file << "		// sample END-SEQUENCE symbol...\n";
		file << "		assert (true == pSubgoal->vec_SequenceEndFeatureVectors.empty ());\n";
		file << "		ComputeSequenceEndFeatures (0, _rProblem, _pSequence);\n";
		file << "		pSubgoal->lprb_SequenceEnd.Create (2);\n";
		file << "		for (int e = 0; e < 2; ++ e)\n";
		file << "		{\n";
		file << "			Features* pFV = pSubgoal->vec_SequenceEndFeatureVectors [e];\n";
		file << "			pSubgoal->lprb_SequenceEnd [e] = o_SequenceEndModel.ComputeLogProb (*pFV);\n";
		file << "			delete pFV;\n";
		file << "		}\n";
		file << "		pSubgoal->vec_SequenceEndFeatureVectors.clear ();\n";
		file << "		pSubgoal->i_SequenceEnd = SampleSequenceEnd (i,\n";
		file << "													 _rProblem,\n";
		file << "													 pSubgoal->lprb_SequenceEnd,\n";
		file << "													 _bTestMode);\n";
		file << "		if (SEQUENCE_END == pSubgoal->i_SequenceEnd)\n";
		file << "		{\n";
		file << "			bAlreadyAddedSequenceEnd = true;\n";
		file << "			break;\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		assert (true == pSubgoal->vec_SubgoalFeatureVectors.empty ());\n";
		file << "		ComputeSubgoalFeatures (0, _rProblem, _pSequence);\n";
		file << "\n";
		file << "		// compute log probs\n";
		file << "		pSubgoal->lprb_Subgoal.Create (i_CandidatePredicates);\n";
		file << "		for (long g = 0; g < i_CandidatePredicates; ++ g)\n";
		file << "		{\n";
		file << "			Features* pFV = pSubgoal->vec_SubgoalFeatureVectors [g];\n";
		file << "\n";
		file << "			// check if this is identical to the next subgoal...\n";
		file << "			if ((NULL != pNextSubgoal) &&\n";
		file << "				(g == pNextSubgoal->i_SubgoalSelection))\n";
		file << "				pSubgoal->lprb_Subgoal [g] = -1000;\n";
		file << "\n";
		file << "			// check if this is identical to any future subgoal\n";
		file << "			else if ((true == b_DisallowAnyDuplicateSubgoals) &&\n";
		file << "					 (1 == _pSequence->vec_PredicatesInSequence [g]))\n";
		file << "				pSubgoal->lprb_Subgoal [g] = -1000;\n";
		file << "\n";
		file << "			else\n";
		file << "				pSubgoal->lprb_Subgoal [g] = o_SubgoalSelectionModel.ComputeLogProb (*pFV);\n";
		file << "\n";
		file << "			if (false == b_PrintTextConnectionFeatures)\n";
		file << "				delete pFV;\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		// sample\n";
		file << "		pSubgoal->i_SubgoalSelection\n";
		file << "			= SampleDecision (pSubgoal->lprb_Subgoal, o_SubgoalExploration, _bTestMode);\n";
		file << "		pSubgoal->p_PddlSubgoalPredicate\n";
		file << "			= vec_CandidatePredicates [pSubgoal->i_SubgoalSelection];\n";
		file << "\n";
		file << "		_pSequence->vec_PredicatesInSequence [pSubgoal->i_SubgoalSelection] = 1;\n";
		file << "\n";
		file << "		// delete the old one\n";
		file << "		if (true == b_PrintTextConnectionFeatures)\n";
		file << "		{\n";
		file << "			if (pSubgoal->p_SelectedPredicateFeatures != NULL)\n";
		file << "				delete pSubgoal->p_SelectedPredicateFeatures;\n";
		file << "\n";
		file << "			for (long g = 0; g < i_CandidatePredicates; ++ g)\n";
		file << "			{\n";
		file << "				Features* pFV = pSubgoal->vec_SubgoalFeatureVectors [g];\n";
		file << "				if(g == pSubgoal->i_SubgoalSelection)\n";
		file << "					pSubgoal->p_SelectedPredicateFeatures = pFV;\n";
		file << "				else\n";
		file << "					delete pFV;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "		pSubgoal->vec_SubgoalFeatureVectors.clear ();\n";
		file << "\n";
		file << "		if (true == b_DisallowNeighboringDuplicateSubgoals)\n";
		file << "			pNextSubgoal = pSubgoal;\n";
		file << "	}\n";
		file << "\n";
		file << "	if (false == bAlreadyAddedSequenceEnd)\n";
		file << "		AddForcedSequenceEnd (_rProblem, _pSequence);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::AddLastSubgoal (const Problem& _rProblem,\n";
		file << "									SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	assert (0 == _pSequence->Length ());\n";
		file << "	Subgoal* pSubgoal = _pSequence->AddSubgoalToFront ();\n";
		file << "\n";
		file << "	assert (true == pSubgoal->vec_SubgoalFeatureVectors.empty ());\n";
		file << "	ComputeSubgoalFeatures (0, _rProblem, _pSequence);\n";
		file << "	assert (false == pSubgoal->vec_SubgoalFeatureVectors.empty ());\n";
		file << "\n";
		file << "	pSubgoal->lprb_Subgoal.Create (i_CandidatePredicates);\n";
		file << "	for (long g = 0; g < i_CandidatePredicates; ++ g)\n";
		file << "	{\n";
		file << "		Features* pFV = pSubgoal->vec_SubgoalFeatureVectors [g];\n";
		file << "		pSubgoal->lprb_Subgoal [g] = o_SubgoalSelectionModel.ComputeLogProb (*pFV);\n";
		file << "		delete pFV;\n";
		file << "	}\n";
		file << "	pSubgoal->vec_SubgoalFeatureVectors.clear ();\n";
		file << "\n";
		file << "\n";
		file << "	// Identify target goal's predicate indices...\n";
		file << "	PddlProblem& rPddlProblem = ((Problem&)_rProblem).GetPddlProblem ();\n";
		file << "	if (1 != rPddlProblem.o_PartialGoalState.dq_Predicates.size ())\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Target goal has multiple predicates set.\\n\"\n";
		file << "			 << \"        This code cannot handle this scenario :-/\"\n";
		file << "			 << endl;\n";
		file << "		assert (false);\n";
		file << "	}\n";
		file << "\n";
		file << "	PddlPredicate* pTargetGoalPredicate\n";
		file << "		= rPddlProblem.o_PartialGoalState.dq_Predicates [0];\n";
		file << "	pSubgoal->i_SubgoalSelection = pTargetGoalPredicate->i_PredicateCandidateIndex;\n";
		file << "	pSubgoal->p_PddlSubgoalPredicate = vec_CandidatePredicates [pSubgoal->i_SubgoalSelection];\n";
		file << "	if (-1 == pSubgoal->i_SubgoalSelection)\n";
		file << "	{\n";
		file << "		cerr << \"[ERROR] Failed to find target goal predicate in candidate predicate list:\"\n";
		file << "			 << *pTargetGoalPredicate << endl;\n";
		file << "		abort ();\n";
		file << "	}\n";
		file << "\n";
		file << "	_pSequence->vec_PredicatesInSequence [pSubgoal->i_SubgoalSelection] = 1;\n";
		file << "\n";
		file << "	// set other variables in subgoal...\n";
		file << "	pSubgoal->b_IsLastSubgoalToTarget = true;\n";
		file << "	pSubgoal->i_SequenceEnd = 0;\n";
		file << "	pSubgoal->p_PddlTargetProblem = &rPddlProblem;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::AddForcedSequenceEnd (const Problem& _rProblem,\n";
		file << "										  SubgoalSequence* _pSequence)\n";
		file << "{\n";
		file << "	Subgoal* pSubgoal = _pSequence->AddSubgoalToFront ();\n";
		file << "\n";
		file << "	assert (true == pSubgoal->vec_SequenceEndFeatureVectors.empty ());\n";
		file << "	ComputeSequenceEndFeatures (0, _rProblem, _pSequence);\n";
		file << "\n";
		file << "	pSubgoal->lprb_SequenceEnd.Create (2);\n";
		file << "	for (int e = 0; e < 2; ++ e)\n";
		file << "	{\n";
		file << "		Features* pFV = pSubgoal->vec_SequenceEndFeatureVectors [e];\n";
		file << "		pSubgoal->lprb_SequenceEnd [e] = o_SequenceEndModel.ComputeLogProb (*pFV);\n";
		file << "		delete pFV;\n";
		file << "	}\n";
		file << "	pSubgoal->vec_SequenceEndFeatureVectors.clear ();\n";
		file << "	pSubgoal->i_SequenceEnd = SEQUENCE_END;\n";
		file << "	pSubgoal->b_ForcedSequenceEnd = true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::InitUpdate (void)\n";
		file << "{\n";
		file << "	o_SequenceEndModel.InitializeFeatureExpectationVector (vec_SequenceEndFE,\n";
		file << "										o_SequenceEndFeatureSpace.MaxIndex () + 1);\n";
		file << "\n";
		file << "	o_SubgoalSelectionModel.InitializeFeatureExpectationVector (vec_SubgoalFE,\n";
		file << "										o_SubgoalFeatureSpace.MaxIndex () + 1);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::UpdateParameters (SubgoalSequence& _rSequence,\n";
		file << "									  double _dReward,\n";
		file << "									  bool _bTaskComplete,\n";
		file << "									  bool _bWithConnections)\n";
		file << "{\n";
		file << "	if (true == _bWithConnections)\n";
		file << "	{\n";
		file << "		b_UseSimpleConnectionFeatures = (f_UseSimpleConnectionFeatures > 0);\n";
		file << "		b_UseTextConnectionFeatures = (f_UseTextConnectionFeatures > 0);\n";
		file << "		b_UseComplexNonConnectionFeatures = (f_UseComplexNonConnectionFeatures > 0);\n";
		file << "	}\n";
		file << "	else\n";
		file << "	{\n";
		file << "		b_UseSimpleConnectionFeatures = false;\n";
		file << "		b_UseTextConnectionFeatures = false;\n";
		file << "	}\n";
		file << "\n";
		file << "	// connection prediction model...\n";
		file << "	if (f_UseTextConnectionFeatures > 0)\n";
		file << "	{\n";
		file << "		int_set_t setPreviousSubgoals;\n";
		file << "		size_t iSequenceLength = _rSequence.dq_Subgoals.size ();\n";
		file << "		for (size_t f = 0; f < iSequenceLength; ++ f)\n";
		file << "		{\n";
		file << "			Subgoal* pFrom = _rSequence.GetSubgoal (f);\n";
		file << "			if (true == pFrom->b_ForcedSequenceEnd)\n";
		file << "				continue;\n";
		file << "			if (SEQUENCE_END == pFrom->i_SequenceEnd)\n";
		file << "				continue;\n";
		file << "			if (po_plan_found != pFrom->e_PlanningOutcome)\n";
		file << "				break;\n";
		file << "			int iFrom = pFrom->p_PddlSubgoalPredicate->i_PredicateCandidateIndex;\n";
		file << "			setPreviousSubgoals.insert (iFrom);\n";
		file << "\n";
		file << "			size_t t = f + 1;\n";
		file << "			if (t >= iSequenceLength)\n";
		file << "				break;\n";
		file << "			Subgoal* pTo = _rSequence.GetSubgoal (t);\n";
		file << "			if (true == pTo->b_ForcedSequenceEnd)\n";
		file << "				continue;\n";
		file << "			if (SEQUENCE_END == pTo->i_SequenceEnd)\n";
		file << "				continue;\n";
		file << "			if (po_outside_known_world == pTo->e_PlanningOutcome)\n";
		file << "				continue;\n";
		file << "\n";
		file << "			// find sentences that contributed to this connection.\n";
		file << "			int iTo = pTo->p_PddlSubgoalPredicate->i_PredicateCandidateIndex;\n";
		file << "			int iRewardType = -1;\n";
		file << "			if (true == b_TaskCompletionTextReward)\n";
		file << "				iRewardType = (true == _bTaskComplete)? 1 : 0;\n";
		file << "			else\n";
		file << "				iRewardType = (po_plan_found == pTo->e_PlanningOutcome)? 1 : 0;\n";
		file << "			mtx_FeedbackOnSentenceConnections (iFrom, iTo, iRewardType) += 1;\n";
		file << "\n";
		file << "\n";
		file << "			// negative reward for any subgoal that didn't occur before iTo...\n";
		file << "			if ((f_SubgoalNotInPrefixReward > 0) &&\n";
		file << "				(po_plan_found == pTo->e_PlanningOutcome))\n";
		file << "			{\n";
		file << "				for (int n = 0; n < i_CandidatePredicates; ++ n)\n";
		file << "				{\n";
		file << "					if (setPreviousSubgoals.end () != setPreviousSubgoals.find (n))\n";
		file << "						continue;\n";
		file << "					mtx_FeedbackOnSentenceConnections (n, iTo, 0)\n";
		file << "						+= f_SubgoalNotInPrefixReward;\n";
		file << "				}\n";
		file << "			}\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "\n";
		file << "	// sequence prediction models ...\n";
		file << "	for (int i = _rSequence.dq_Subgoals.size () - 1; i >= 0; -- i)\n";
		file << "	{\n";
		file << "		Subgoal* pSubgoal = _rSequence.GetSubgoal (i);\n";
		file << "		if (true == pSubgoal->b_ForcedSequenceEnd)\n";
		file << "			continue;\n";
		file << "\n";
		file << "		if (false == pSubgoal->b_IsLastSubgoalToTarget)\n";
		file << "		{\n";
		file << "			assert (-1 != pSubgoal->i_SequenceEnd);\n";
		file << "			// sequence end model ...\n";
		file << "			{\n";
		file << "				// recompute features ...\n";
		file << "				assert (true == pSubgoal->vec_SequenceEndFeatureVectors.empty ());\n";
		file << "				ComputeSequenceEndFeatures (i, *_rSequence.p_TargetProblem, &_rSequence);\n";
		file << "\n";
		file << "				// It's possible to have subgoals that don't\n";
		file << "				// the policy distribution already computed.\n";
		file << "				// I.e. in the case where we propose additional\n";
		file << "				// sequences based on the predicted sequence.\n";
		file << "				if (0 == pSubgoal->lprb_SequenceEnd.Size ())\n";
		file << "				{\n";
		file << "					pSubgoal->lprb_SequenceEnd.Create (2);\n";
		file << "					for (int e = 0; e < 2; ++ e)\n";
		file << "					{\n";
		file << "						Features* pFV = pSubgoal->vec_SequenceEndFeatureVectors [e];\n";
		file << "						pSubgoal->lprb_SequenceEnd [e]\n";
		file << "							= o_SequenceEndModel.ComputeLogProb (*pFV);\n";
		file << "					}\n";
		file << "				}\n";
		file << "\n";
		file << "				// compute negative expectation\n";
		file << "				o_SequenceEndModel.ComputeNegativeFeatureExpectation (pSubgoal->lprb_SequenceEnd,\n";
		file << "												pSubgoal->vec_SequenceEndFeatureVectors,\n";
		file << "												_dReward,\n";
		file << "												vec_SequenceEndFE);\n";
		file << "\n";
		file << "				// add selected action features\n";
		file << "				Features* pSelectedFeatures\n";
		file << "					= pSubgoal->vec_SequenceEndFeatureVectors [pSubgoal->i_SequenceEnd];\n";
		file << "				for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "					vec_SequenceEndFE [pSelectedFeatures->Index (f)]\n";
		file << "						+= _dReward * pSelectedFeatures->Feature (f);\n";
		file << "\n";
		file << "				// clear up memory ...\n";
		file << "				ITERATE (Features_vec_t, pSubgoal->vec_SequenceEndFeatureVectors, ite)\n";
		file << "					delete *ite;\n";
		file << "				pSubgoal->vec_SequenceEndFeatureVectors.clear ();\n";
		file << "\n";
		file << "				if (SEQUENCE_END == pSubgoal->i_SequenceEnd)\n";
		file << "					continue;\n";
		file << "			}\n";
		file << "		}\n";
		file << "\n";
		file << "\n";
		file << "		// subgoal model ...\n";
		file << "		{\n";
		file << "			assert (-1 != pSubgoal->i_SubgoalSelection);\n";
		file << "\n";
		file << "			// recompute features ...\n";
		file << "			assert (true == pSubgoal->vec_SubgoalFeatureVectors.empty ());\n";
		file << "			ComputeSubgoalFeatures (i, *_rSequence.p_TargetProblem, &_rSequence);\n";
		file << "\n";
		file << "			// It's possible to have subgoals that don't\n";
		file << "			// the policy distribution already computed.\n";
		file << "			// I.e. in the case where we propose additional\n";
		file << "			// sequences based on the predicted sequence.\n";
		file << "			if (0 == pSubgoal->lprb_Subgoal.Size ())\n";
		file << "			{\n";
		file << "				pSubgoal->lprb_Subgoal.Create (i_CandidatePredicates);\n";
		file << "				for (long g = 0; g < i_CandidatePredicates; ++ g)\n";
		file << "				{\n";
		file << "					Features* pFV = pSubgoal->vec_SubgoalFeatureVectors [g];\n";
		file << "					pSubgoal->lprb_Subgoal [g]\n";
		file << "						= o_SubgoalSelectionModel.ComputeLogProb (*pFV);\n";
		file << "				}\n";
		file << "			}\n";
		file << "\n";
		file << "			// compute negative expectation\n";
		file << "			o_SubgoalSelectionModel.ComputeNegativeFeatureExpectation (pSubgoal->lprb_Subgoal,\n";
		file << "											pSubgoal->vec_SubgoalFeatureVectors,\n";
		file << "											_dReward,\n";
		file << "											vec_SubgoalFE);\n";
		file << "\n";
		file << "			// add selected action features\n";
		file << "			Features* pSelectedFeatures\n";
		file << "				= pSubgoal->vec_SubgoalFeatureVectors [pSubgoal->i_SubgoalSelection];\n";
		file << "			for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "				vec_SubgoalFE [pSelectedFeatures->Index (f)]\n";
		file << "					+= _dReward * pSelectedFeatures->Feature (f);\n";
		file << "\n";
		file << "			// clear up memory ...\n";
		file << "			ITERATE (Features_vec_t, pSubgoal->vec_SubgoalFeatureVectors, ite)\n";
		file << "				delete *ite;\n";
		file << "			pSubgoal->vec_SubgoalFeatureVectors.clear ();\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::UpdateConnectionParameters (void)\n";
		file << "{\n";
		file << "	if (f_UseTextConnectionFeatures <= 0)\n";
		file << "		return;\n";
		file << "\n";
		file << "	for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "		{\n";
		file << "			int iSuccesses = mtx_FeedbackOnSentenceConnections (f, t, 1);\n";
		file << "			int iFailures = mtx_FeedbackOnSentenceConnections (f, t, 0);\n";
		file << "			double dReward = 0;\n";
		file << "			switch (e_ConnectionRewardType)\n";
		file << "			{\n";
		file << "				case crt_linear:\n";
		file << "					dReward = iSuccesses * f_ConnectionSuccessReward\n";
		file << "							  - iFailures * f_ConnectionFailurePenalty;\n";
		file << "					break;\n";
		file << "\n";
		file << "				case crt_single_success:\n";
		file << "					dReward = (iSuccesses > 0)?\n";
		file << "								f_ConnectionSuccessReward :\n";
		file << "								- f_ConnectionFailurePenalty;\n";
		file << "					break;\n";
		file << "				default:\n";
		file << "					cerr << \"[ERROR] Unknown reward type: \"\n";
		file << "						 << e_ConnectionRewardType\n";
		file << "						 << endl;\n";
		file << "			}\n";
		file << "\n";
		file << "\n";
		file << "			if ((0 == iSuccesses) && (0 == iFailures))\n";
		file << "				dReward = -0.01;\n";
		file << "\n";
		file << "			if (0 == dReward)\n";
		file << "				continue;\n";
		file << "\n";
		file << "			// positive predictions ...\n";
		file << "			{\n";
		file << "				int_dq_t* pdqSentence = mtx_SentencesPositiveFromTo (f, t);\n";
		file << "				if (NULL != pdqSentence)\n";
		file << "				{\n";
		file << "					ITERATE (int_dq_t, (*pdqSentence), ite)\n";
		file << "					{\n";
		file << "						SentenceConnection* pConnection = vec_SentenceConnections [*ite];\n";
		file << "						lprb_SentenceConnection [0]\n";
		file << "							= o_TextConnectionModel.ComputeLogProb (*pConnection->p_NegativeFeatures);\n";
		file << "						lprb_SentenceConnection [1]\n";
		file << "							= o_TextConnectionModel.ComputeLogProb (*pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "						Features_vec_t vecFeatures;\n";
		file << "						vecFeatures.reserve (2);\n";
		file << "						vecFeatures.push_back (pConnection->p_NegativeFeatures);\n";
		file << "						vecFeatures.push_back (pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "						o_TextConnectionModel.ComputeNegativeFeatureExpectation (lprb_SentenceConnection,\n";
		file << "																				 vecFeatures,\n";
		file << "																				dReward,\n";
		file << "																				vec_ConnectionFE);\n";
		file << "\n";
		file << "						// add selected action features\n";
		file << "						Features* pSelectedFeatures = pConnection->p_PositiveFeatures;\n";
		file << "						for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "							vec_ConnectionFE [pSelectedFeatures->Index (f)]\n";
		file << "								+= dReward * pSelectedFeatures->Feature (f);\n";
		file << "					}\n";
		file << "				}\n";
		file << "			}\n";
		file << "\n";
		file << "\n";
		file << "			// negative predictions ...\n";
		file << "			{\n";
		file << "				//dReward *= -0.1;\n";
		file << "				dReward *= -1.0;\n";
		file << "\n";
		file << "				int_dq_t* pdqSentence = mtx_SentencesNegativeFromTo (f, t);\n";
		file << "				if (NULL != pdqSentence)\n";
		file << "				{\n";
		file << "					ITERATE (int_dq_t, (*pdqSentence), ite)\n";
		file << "					{\n";
		file << "						SentenceConnection* pConnection = vec_SentenceConnections [*ite];\n";
		file << "						lprb_SentenceConnection [0]\n";
		file << "							= o_TextConnectionModel.ComputeLogProb (*pConnection->p_NegativeFeatures);\n";
		file << "						lprb_SentenceConnection [1]\n";
		file << "							= o_TextConnectionModel.ComputeLogProb (*pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "						Features_vec_t vecFeatures;\n";
		file << "						vecFeatures.reserve (2);\n";
		file << "						vecFeatures.push_back (pConnection->p_NegativeFeatures);\n";
		file << "						vecFeatures.push_back (pConnection->p_PositiveFeatures);\n";
		file << "\n";
		file << "						o_TextConnectionModel.ComputeNegativeFeatureExpectation (lprb_SentenceConnection,\n";
		file << "																				 vecFeatures,\n";
		file << "																				dReward,\n";
		file << "																				vec_ConnectionFE);\n";
		file << "\n";
		file << "						// add selected action features\n";
		file << "						Features* pSelectedFeatures = pConnection->p_NegativeFeatures;\n";
		file << "						for (int f = 0; f < pSelectedFeatures->Size (); ++ f)\n";
		file << "							vec_ConnectionFE [pSelectedFeatures->Index (f)]\n";
		file << "								+= dReward * pSelectedFeatures->Feature (f);\n";
		file << "					}\n";
		file << "				}\n";
		file << "			}\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	if (true == b_LogConnectionFeedback)\n";
		file << "		WriteConnectionFeedback ();\n";
		file << "	mtx_FeedbackOnSentenceConnections.Memset (0);\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::CompleteUpdate (void)\n";
		file << "{\n";
		file << "	o_SequenceEndModel.UpdateWeights (1, vec_SequenceEndFE);\n";
		file << "	o_SubgoalSelectionModel.UpdateWeights (1, vec_SubgoalFE);\n";
		file << "\n";
		file << "	o_TextConnectionModel.InitializeFeatureExpectationVector (vec_ConnectionFE,\n";
		file << "										o_TextConnectionFeatureSpace.MaxIndex () + 1);\n";
		file << "	UpdateConnectionParameters ();\n";
		file << "	o_TextConnectionModel.UpdateWeights (1, vec_ConnectionFE);\n";
		file << "\n";
		file << "	if (true == b_ForceConnectionWeights)\n";
		file << "	{\n";
		file << "		size_t f = 2 + i_OffsetToConnectionFeatures;\n";
		file << "		if (o_SubgoalSelectionModel.GetWeight (f) < d_ForcedConnectionWeightToInit)\n";
		file << "			o_SubgoalSelectionModel.SetWeight (f, d_ForcedConnectionWeightToInit);\n";
		file << "		f = 3 + i_OffsetToConnectionFeatures;\n";
		file << "		if (o_SubgoalSelectionModel.GetWeight (f) < d_ForcedConnectionWeightToInit)\n";
		file << "			o_SubgoalSelectionModel.SetWeight (f, d_ForcedConnectionWeightToInit);\n";
		file << "\n";
		file << "		for (int d = 1; d < 5; ++ d)\n";
		file << "		{\n";
		file << "			f = 5 + 2*(d-1) + i_OffsetToConnectionFeatures;\n";
		file << "			if (o_SubgoalSelectionModel.GetWeight (f) < d_ForcedConnectionWeightToTarget)\n";
		file << "				o_SubgoalSelectionModel.SetWeight (f, d_ForcedConnectionWeightToTarget);\n";
		file << "			f = 6 + 2*(d-1) + i_OffsetToConnectionFeatures;\n";
		file << "			if (o_SubgoalSelectionModel.GetWeight (f) < d_ForcedConnectionWeightToTarget)\n";
		file << "				o_SubgoalSelectionModel.SetWeight (f, d_ForcedConnectionWeightToTarget);\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::AddReachableSubgoals (const int_set_t& _rsetReachableSubgoals)\n";
		file << "{\n";
		file << "	ITERATE (int_set_t, _rsetReachableSubgoals, ite)\n";
		file << "	{\n";
		file << "		assert (*ite < i_CandidatePredicates);\n";
		file << "		assert (*ite < (long)vec_CanReachCandidatePredicate.size ());\n";
		file << "		assert (i_CandidatePredicates == (long)vec_CanReachCandidatePredicate.size ());\n";
		file << "\n";
		file << "		vec_CanReachCandidatePredicate [*ite] = 1;\n";
		file << "\n";
		file << "		if (true == b_UseReachabilityEquivalents)\n";
		file << "		{\n";
		file << "			ITERATE (int_vec_t, vec_ReachabilityPredicateEqulivalents [*ite], iteEquiv)\n";
		file << "				vec_CanReachCandidatePredicate [*iteEquiv] = 1;\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::FindInitPredicateCandidateIndex (PddlPredicate& _rPredicate)\n";
		file << "{\n";
		file << "	int i = -1;\n";
		file << "	CONST_ITERATE (PddlPredicate_vec_t, vec_CandidatePredicates, ite)\n";
		file << "	{\n";
		file << "		++ i;\n";
		file << "		PddlPredicate* pCandidate = *ite;\n";
		file << "		if (*(PddlPredicate*)pCandidate != (PddlPredicate&)_rPredicate)\n";
		file << "			continue;\n";
		file << "		return i;\n";
		file << "	}\n";
		file << "	return -1;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "int SubgoalPolicy::FindPredicateCandidateIndex (PddlPredicate& _rPredicate)\n";
		file << "{\n";
		file << "	int i = -1;\n";
		file << "	CONST_ITERATE (PddlPredicate_vec_t, vec_CandidatePredicates, ite)\n";
		file << "	{\n";
		file << "		++ i;\n";
		file << "		PddlPredicate* pCandidate = *ite;\n";
		file << "		if (*pCandidate != _rPredicate)\n";
		file << "			continue;\n";
		file << "		return i;\n";
		file << "	}\n";
		file << "	return -1;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "PddlPredicate* SubgoalPolicy::FindEquivalentPredicateCandidate (PddlPredicate& _rPredicate)\n";
		file << "{\n";
		file << "	PddlStringToPredicate_map_t::iterator	ite;\n";
		file << "	ite = map_PddlStringToCandidatePredicate.find (_rPredicate.GetPddlString ());\n";
		file << "	if (map_PddlStringToCandidatePredicate.end () == ite)\n";
		file << "		return NULL;\n";
		file << "	return ite->second;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "bool SubgoalPolicy::SaveWeights (void)\n";
		file << "{\n";
		file << "	if (1 == (int)(config)\"save_global_feature_map\")\n";
		file << "	{\n";
		file << "		File file ((config)\"global_feature_mapping_file\", ios_base::out);\n";
		file << "		ITERATE (int_String_map_t, map_FeatureIndexToFeatureString, ite)\n";
		file << "			file << ite->first << '\\x01' << ite->second << endl;\n";
		file << "		file.Close ();\n";
		file << "	}\n";
		file << "\n";
		file << "	if (false == o_SequenceEndFeatureSpace.SaveFeatureMapping (\"end\"))\n";
		file << "		return false;\n";
		file << "	if (false == o_SequenceEndModel.SaveWeights (\"end\"))\n";
		file << "		return false;\n";
		file << "\n";
		file << "	if (false == o_SubgoalFeatureSpace.SaveFeatureMapping (\"subgoal\"))\n";
		file << "		return false;\n";
		file << "	if (false == o_SubgoalSelectionModel.SaveWeights (\"subgoal\"))\n";
		file << "		return false;\n";
		file << "	return true;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "double SubgoalPolicy::WeightVectorNorm (void)\n";
		file << "{\n";
		file << "	return o_SequenceEndModel.WeightVectorNorm ()\n";
		file << "			+ o_SubgoalSelectionModel.WeightVectorNorm ()\n";
		file << "			+ o_TextConnectionModel.WeightVectorNorm ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::DebugPrintFeatureVectors (const Subgoal& subgoal,\n";
		file << "											  ostream* osOut,\n";
		file << "											  const String& sPrefix) const\n";
		file << "{\n";
		file << "	// iterate over possible\n";
		file << "	for(unsigned int iPred = 0; iPred < subgoal.vec_SubgoalFeatureVectors.size(); iPred++){\n";
		file << "		const Features& featuresCur = *subgoal.vec_SubgoalFeatureVectors[iPred];\n";
		file << "		const PddlPredicate& predCur = *vec_CandidatePredicates [iPred];\n";
		file << "		*osOut << sPrefix << \":\" << iPred << \":\" << predCur.GetPddlString() << \"\\n\";\n";
		file << "		for (int iFeatureListIndex = 0; iFeatureListIndex < featuresCur.Size(); iFeatureListIndex++){\n";
		file << "			int iFeature = featuresCur.Index(iFeatureListIndex);\n";
		file << "			const String& sFeature = o_SubgoalFeatureSpace.GetFeatureString(iFeature);\n";
		file << "			*osOut << \"\\t\" << iFeature << \"-->\" << sFeature << \"\\n\";\n";
		file << "		}\n";
		file << "	}\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::WriteConnectionPredictionHeader (void)\n";
		file << "{\n";
		file << "	File file;\n";
		file << "	if (false == file.Open ((config)\"connection_prediction_log_file\",\n";
		file << "						    ios_base::out))\n";
		file << "		return;\n";
		file << "\n";
		file << "	for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "		{\n";
		file << "			if (NULL == mtx_SentencesPositiveFromTo (f, t))\n";
		file << "				continue;\n";
		file << "			file << f << ':' << t << ' ';\n";
		file << "		}\n";
		file << "	}\n";
		file << "	file << endl;\n";
		file << "	file.flush ();\n";
		file << "	file.Close ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::WriteConnectionPredictions (void)\n";
		file << "{\n";
		file << "	File file;\n";
		file << "	if (false == file.Open ((config)\"connection_prediction_log_file\",\n";
		file << "						    ios_base::out|ios_base::app))\n";
		file << "		return;\n";
		file << "\n";
		file << "	for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "		{\n";
		file << "			if (NULL == mtx_SentencesPositiveFromTo (f, t))\n";
		file << "				continue;\n";
		file << "			file << ((0 == mtx_PredicateConnectionsFromTo (f, t))? '0' : '1') << ' ';\n";
		file << "		}\n";
		file << "	}\n";
		file << "	file << endl;\n";
		file << "	file.flush ();\n";
		file << "	file.Close ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "String SubgoalPolicy::ConnectionPredictionRatio (void)\n";
		file << "{\n";
		file << "	if (f_UseTextConnectionFeatures <= 0)\n";
		file << "		return String (\"0/0\");\n";
		file << "\n";
		file << "	long lTotal = 0;\n";
		file << "	long lPredictedConnections = 0;\n";
		file << "	for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "		{\n";
		file << "			if (NULL == mtx_SentencesPositiveFromTo (f, t))\n";
		file << "				continue;\n";
		file << "			++ lTotal;\n";
		file << "			lPredictedConnections +=  mtx_PredicateConnectionsFromTo (f, t);\n";
		file << "		}\n";
		file << "	}\n";
		file << "\n";
		file << "	String sRet;\n";
		file << "	sRet << lPredictedConnections << '/' << lTotal;\n";
		file << "	return sRet;\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "//\n";
		file << "void SubgoalPolicy::WriteConnectionFeedback (void)\n";
		file << "{\n";
		file << "	File file;\n";
		file << "	if (false == file.Open ((config)\"connection_feedback_log_file\",\n";
		file << "						    ios_base::out|ios_base::app))\n";
		file << "		return;\n";
		file << "\n";
		file << "	for (int f = 0; f < i_CandidatePredicates; ++ f)\n";
		file << "	{\n";
		file << "		for (int t = 0; t < i_CandidatePredicates; ++ t)\n";
		file << "		{\n";
		file << "			int iSuccesses = mtx_FeedbackOnSentenceConnections (f, t, 1);\n";
		file << "			int iFailures = mtx_FeedbackOnSentenceConnections (f, t, 0);\n";
		file << "			if ((0 == iSuccesses) && (0 == iFailures))\n";
		file << "				continue;\n";
		file << "\n";
		file << "			file << f << ':' << t << ':' << iSuccesses << ':' << iFailures << ' ';\n";
		file << "		}\n";
		file << "	}\n";
		file << "	file << endl;\n";
		file << "	file.flush ();\n";
		file << "	file.Close ();\n";
		file << "}\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file << "\n";
		file.close ();
	}



}

